<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陈凡的博客</title>
  
  <subtitle>chenfanlinux.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.chenfanlinux.org/"/>
  <updated>2018-01-10T07:43:38.000Z</updated>
  <id>http://www.chenfanlinux.org/</id>
  
  <author>
    <name>陈凡</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker入门之镜像基础概念与管理(二)</title>
    <link href="http://www.chenfanlinux.org/2018/01/10/Docker%E5%85%A5%E9%97%A8%E4%B9%8B%E9%95%9C%E5%83%8F%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%AE%A1%E7%90%86-%E4%BA%8C/"/>
    <id>http://www.chenfanlinux.org/2018/01/10/Docker入门之镜像基础概念与管理-二/</id>
    <published>2018-01-10T07:35:23.000Z</published>
    <updated>2018-01-10T07:43:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="认识最小的镜像（hello-world-）"><a href="#认识最小的镜像（hello-world-）" class="headerlink" title="认识最小的镜像（hello-world ）"></a>认识最小的镜像（hello-world ）</h2><blockquote><p>镜像是 Docker 容器的基石，容器是镜像的运行实例，有了镜像才能启动容器。理解清楚镜像的内部结构,我们才能够按照需求构建符合要求的镜像。hello-world 是 Docker 官方提供的一个镜像，通常用来验证 Docker 是否安装成功。</p></blockquote><p>我们先通过 docker pull 从 Docker Hub 下载它</p><pre><code>[root@docker ~]# docker pull hello-worldUsing default tag: latestlatest: Pulling from library/hello-worldca4f61b1923c: Pull completeDigest: sha256:ca0eeb6fb05351dfc8759c20733c91def84cb8007aa89a5bf606bc8b315b9fc7Status: Downloaded newer image for hello-world:latest</code></pre><p>可以使用 docker images 命令查看镜像的信息，可以看到镜像非常的小,只有1.85k</p><pre><code>[root@docker ~]# docker images |grep hello-worldhello-world  latest       f2a91732366c     6 weeks ago         1.85kB</code></pre><p>最后通过 docker run 运行镜像</p><pre><code>[root@docker ~]# docker run hello-worldHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.    (amd64) 3. The Docker daemon created a new container from that image which runs the    executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it    to your terminal.</code></pre><p>那么该镜像运行怎么就输出上面这一串信息的呢？如果对 Docker 了解一点的话自然会去找该镜像的 Dockerfile，Dockerfile 详细描述了该镜像是如何建立的以及运行时执行的命令。从 Docker Hub 上 <a href="https://hub.docker.com/r/library/hello-world/" target="_blank" rel="noopener">hello-world</a> 的库简介 找到其 <a href="https://github.com/docker-library/hello-world/blob/b7a78b7ccca62cc478919b101f3ab1334899df2b/Dockerfile" target="_blank" rel="noopener">Dockerfile</a> 在 github 上，简简单单的三条语句。</p><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/4q6B6C" alt="hello-world Dockerfile"><br><strong>hello-world的Dockerfile如下:</strong></p><pre><code>FROM scratchADD hello /CMD [&quot;/hello&quot;]</code></pre><ul><li><p>第一条FROM指令是 Docker 用来指定该镜像是基于哪个基础镜像构建的，这里指定为 scratch，实际上 scratch 镜像是一个空镜像，用来构建基础镜像或者极小的镜像。</p></li><li><p>第二条ADD指令表示从 Dockerfile 所在目录拷贝文件到指定路径下，这里拷贝 hello 文件到根目录下，这里的hello文件是一个二进制可执行文件。</p></li><li><p>第三条CMD指令用来指示当运行 docker run 命令运行该镜像时要执行的命令，这里执行 /hello，就是执行第二步拷贝到根目录下的 hello 文件。</p><a id="more"></a></li></ul><h2 id="认识base镜像-centos"><a href="#认识base镜像-centos" class="headerlink" title="认识base镜像(centos)"></a>认识base镜像(centos)</h2><blockquote><p>hello-world 虽然是一个完整的镜像，但它并没有什么实际用途。通常来说，我们希望镜像能提供一个基本的操作系统环境，用户可以根据需要安装和配置软件。这样的镜像我们称作 base 镜像。base镜像具有两层含义,首先base镜像不依赖其他镜像，从 scratch 构建;另外其他镜像可以之为基础进行扩展。</p></blockquote><h3 id="拉取centos镜像"><a href="#拉取centos镜像" class="headerlink" title="拉取centos镜像"></a>拉取centos镜像</h3><p>能称作 base 镜像的通常都是各种 Linux 发行版的 Docker 镜像，比如 Ubuntu, Debian, CentOS 等。下面我们以centos为例,来分析一下Centos镜像是如何构建的。</p><pre><code>[root@docker ~]# docker pull centosUsing default tag: latestlatest: Pulling from library/centosDigest: sha256:3b1a65e9a05f0a77b5e8a698d3359459904c2a354dc3b25ae2e2f5c95f0b3667Status: Image is up to date for centos:latest[root@docker ~]# docker images centosREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEcentos              latest              3fa822599e10        5 weeks ago         204MB</code></pre><p>我们上面拉取到的centos大小就204M左右,而我们平时装的系统有几个GB大小,这是为啥呢？下面解释一下。对于 base 镜像来说，底层直接用 Host 的 kernel，自己只需要提供 rootfs 就行了。<br>而对于一个精简的 OS，rootfs 可以很小，只需要包括最基本的命令、工具和程序库就可以了。相比其他 Linux 发行版，CentOS 的 rootfs 已经算臃肿的了,alpine 还不到 10MB。</p><h3 id="认识Docker文件系统"><a href="#认识Docker文件系统" class="headerlink" title="认识Docker文件系统"></a>认识Docker文件系统</h3><p>典型的Linux文件系统由bootfs和rootfs两部分组成，bootfs(boot file system)主要包含 bootloader和kernel，bootloader主要是引导加载kernel，当kernel被加载到内存中后 bootfs就被umount了。 用户空间的文件系统rootfs (root file system) 包含的就是典型 Linux 系统中的/dev，/proc，/bin，/etc等标准目录和文件。Docker在启动容器的时候，需要创建文件系统，为rootfs提供挂载点。<br><img src="https://cdn-std.dprcdn.net/files/acc_582513/7MiXuC" alt="典型的文件系统"></p><p>Docker容器是建立在Aufs基础上的，Aufs是一种Union FS， 简单来说就是支持将不同的目录挂载到同一个虚拟文件系统下，并实现一种layer的概念。Aufs将挂载到同一虚拟文件系统下的多个目录分别设置成read-only，read-write以及whiteout-able权限，对read-only目录只能读，而写操作只能实施在read-write目录中。重点在于，写操作是在read-only上的一种增量操作，不影响read-only目录。当挂载目录的时候要严格按照各目录之间的这种增量关系，将被增量操作的目录优先于在它基础上增量操作的目录挂载，待所有目录挂载结束了，继续挂载一个read-write目录，如此便形成了一种层次结构。</p><p>Docker镜像的典型结构如下图。传统的Linux加载bootfs时会先将rootfs设为read-only，然后在系统自检之后将rootfs从read-only改为read-write，然后我们就可以在rootfs上进行写和读的操作了。但Docker的镜像却不是这样，它在bootfs自检完毕之后并不会把rootfs的read-only改为read-write。而是利用union mount（UnionFS的一种挂载机制）将一个或多个read-only的rootfs加载到之前的read-only的rootfs层之上。在加载了这么多层的rootfs之后，仍然让它看起来只像是一个文件系统，在Docker的体系里把union mount的这些read-only的rootfs叫做Docker的镜像。但是，此时的每一层rootfs都是read-only的，我们此时还不能对其进行操作。当我们创建一个容器，也就是将Docker镜像进行实例化，系统会在一层或是多层read-only的rootfs之上分配一层空的read-write的rootfs。</p><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/Lyk5KF" alt="Docker文件系统"></p><h2 id="认识centos镜像的Dockerfile"><a href="#认识centos镜像的Dockerfile" class="headerlink" title="认识centos镜像的Dockerfile"></a>认识centos镜像的Dockerfile</h2><blockquote><p>这些基础镜像的Dockerfile,我们可以在Docker hub上搜索到,cenots的<a href="https://github.com/CentOS/sig-cloud-instance-images/blob/37e0a7f3d98ae875dac7ae1026e99c1c04524c62/docker/Dockerfile" target="_blank" rel="noopener">dockerfile</a>如下,我们可以来分析dockerfile文件,知道整个镜像的构建过程。</p></blockquote><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/WFgiMJ" alt="ceonts_dockerfile"></p><pre><code>FROM scratchADD centos-7-docker.tar.xz /LABEL name=&quot;CentOS Base Image&quot; \    vendor=&quot;CentOS&quot; \    license=&quot;GPLv2&quot; \    build-date=&quot;20171128&quot;CMD [&quot;/bin/bash&quot;]</code></pre><p>第一行是上面我们讲到scratch最小的镜像源,第二行 ADD 指令添加到镜像的 tar 包就是 CentOS 7 的 rootfs。在制作镜像时,这个 tar 包会自动解压到 / 目录下,生成 /dev、 /porc、/bin 等目录,最后就是运行一个伪终端。</p><p><strong>支持运行多种 Linux OS</strong></p><p>不同 Linux 发行版的区别主要就是 rootfs。<br><img src="https://cdn-std.dprcdn.net/files/acc_582513/EBn4fs" alt="rootfs"><br>比如 Ubuntu 14.04 使用 upstart 管理服务，apt 管理软件包；而 CentOS 7 使用 systemd 和 yum。这些都是用户空间上的区别，Linux kernel 差别不大。所以 Docker 可以同时支持多种 Linux 镜像，模拟出多种操作系统环境,但都共用宿主机的内核，只是用户空间进行了隔离。</p><h2 id="认识镜像的分层结构"><a href="#认识镜像的分层结构" class="headerlink" title="认识镜像的分层结构"></a>认识镜像的分层结构</h2><blockquote><p>实际工作中,我们的镜像大部分都是通过在base镜像中安装与配置需要的软件构建而成。</p></blockquote><p>比如我现在构建一个新的镜像，Dockerfile如下：</p><pre><code>FROM debainRUN apt-get   install emacsRUN apt-get  install apacheCMD [&quot;/bin/bash&quot;]</code></pre><p>分层架构如下：</p><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/GwQiZh" alt=""><br>可以看到，新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层。</p><p><strong>问什么 Docker 镜像要采用这种分层结构呢？</strong><br>有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。当多个镜像共享一份基础镜像，某个容器修改基础镜像中的内容，比如/dev下面的内容，其他容器不会被修改。这是因为在容器启动后，一个新的可写层被加载到镜像顶部，这一层通常被称为”容器层”，容器层是可写的，镜像层是可读的。在容器层中，用户看到的是一个叠加之后的文件系统。</p><p><strong>容器层的细节如何？</strong><br>镜像层数量可能会很多，所有镜像层会联合在一起组成一个统一的文件系统。比如/etc/abc,上层的/etc/abc会覆盖下层的/etc/abc，用户看到的就是最上层的/etc/abc内容。只有当需要修改时才复制一份数据，这种特性被称作 <a href="https://zh.wikipedia.org/wiki/%E5%AF%AB%E5%85%A5%E6%99%82%E8%A4%87%E8%A3%BD" target="_blank" rel="noopener">Copy-on-Write</a>。可见，容器层保存的是镜像变化的部分，不会对镜像本身进行任何修改。这样就解释了我们前面提出的问题：容器层记录对镜像的修改，所有镜像层都是只读的，不会被容器修改，所以镜像可以被多个容器共享。</p><ul><li><p>添加文件<br>在容器中创建文件时，新文件被添加到容器层中。</p></li><li><p>读取文件<br>在容器中读取某个文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，打开并读入内存。</p></li><li><p>修改文件<br>在容器中修改已存在的文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，立即将其复制到容器层，然后修改之。</p></li><li><p>删除文件<br>在容器中删除文件时，Docker 也是从上往下依次在镜像层中查找此文件。找到后，会在容器层中记录下此删除操作。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;认识最小的镜像（hello-world-）&quot;&gt;&lt;a href=&quot;#认识最小的镜像（hello-world-）&quot; class=&quot;headerlink&quot; title=&quot;认识最小的镜像（hello-world ）&quot;&gt;&lt;/a&gt;认识最小的镜像（hello-world ）&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;镜像是 Docker 容器的基石，容器是镜像的运行实例，有了镜像才能启动容器。理解清楚镜像的内部结构,我们才能够按照需求构建符合要求的镜像。hello-world 是 Docker 官方提供的一个镜像，通常用来验证 Docker 是否安装成功。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们先通过 docker pull 从 Docker Hub 下载它&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@docker ~]# docker pull hello-world
Using default tag: latest
latest: Pulling from library/hello-world
ca4f61b1923c: Pull complete
Digest: sha256:ca0eeb6fb05351dfc8759c20733c91def84cb8007aa89a5bf606bc8b315b9fc7
Status: Downloaded newer image for hello-world:latest
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以使用 docker images 命令查看镜像的信息，可以看到镜像非常的小,只有1.85k&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@docker ~]# docker images |grep hello-world
hello-world  latest       f2a91732366c     6 weeks ago         1.85kB
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后通过 docker run 运行镜像&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@docker ~]# docker run hello-world

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the &amp;quot;hello-world&amp;quot; image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那么该镜像运行怎么就输出上面这一串信息的呢？如果对 Docker 了解一点的话自然会去找该镜像的 Dockerfile，Dockerfile 详细描述了该镜像是如何建立的以及运行时执行的命令。从 Docker Hub 上 &lt;a href=&quot;https://hub.docker.com/r/library/hello-world/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hello-world&lt;/a&gt; 的库简介 找到其 &lt;a href=&quot;https://github.com/docker-library/hello-world/blob/b7a78b7ccca62cc478919b101f3ab1334899df2b/Dockerfile&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dockerfile&lt;/a&gt; 在 github 上，简简单单的三条语句。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-std.dprcdn.net/files/acc_582513/4q6B6C&quot; alt=&quot;hello-world Dockerfile&quot;&gt;&lt;br&gt;&lt;strong&gt;hello-world的Dockerfile如下:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM scratch
ADD hello /
CMD [&amp;quot;/hello&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一条FROM指令是 Docker 用来指定该镜像是基于哪个基础镜像构建的，这里指定为 scratch，实际上 scratch 镜像是一个空镜像，用来构建基础镜像或者极小的镜像。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二条ADD指令表示从 Dockerfile 所在目录拷贝文件到指定路径下，这里拷贝 hello 文件到根目录下，这里的hello文件是一个二进制可执行文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第三条CMD指令用来指示当运行 docker run 命令运行该镜像时要执行的命令，这里执行 /hello，就是执行第二步拷贝到根目录下的 hello 文件。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker系列" scheme="http://www.chenfanlinux.org/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Docker" scheme="http://www.chenfanlinux.org/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Bash特性汇总</title>
    <link href="http://www.chenfanlinux.org/2018/01/05/Bash%E7%89%B9%E6%80%A7%E6%B1%87%E6%80%BB/"/>
    <id>http://www.chenfanlinux.org/2018/01/05/Bash特性汇总/</id>
    <published>2018-01-05T04:35:53.000Z</published>
    <updated>2018-01-05T05:33:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是shell"><a href="#什么是shell" class="headerlink" title="什么是shell?"></a>什么是shell?</h2><blockquote><p>通常,替我们工作的是”硬件”,而控制硬件的是”内核”。用户利用”shell”控制着一些内核提供的”工具”,来控制硬件替我们工作。由于内核听不懂人类语言,所以shell从本质来说就是一个UI(用户界面)应用程序,让内核控制着硬件正确无误的工作，如图1-1 硬件-内核-shell 所示，可以清晰的看到他们的关系。</p></blockquote><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/DDfPGJ" alt="硬件-内核"></p><h2 id="Bash-shell功能特性"><a href="#Bash-shell功能特性" class="headerlink" title="Bash shell功能特性"></a>Bash shell功能特性</h2><h3 id="history命令记忆功能"><a href="#history命令记忆功能" class="headerlink" title="history命令记忆功能"></a>history命令记忆功能</h3><blockquote><p>在Bash里面,我们只要在命令行按”上、下键”或者更强大的”Ctrl+r”,就可以找到之前输入的历史命令,这依赖于Bash的命令记录功能,记录的文件位于家目录下的.bash_history。登录shell后新执行的命令只会记录在缓存中,这些命令会在用户退出时追加到命令历史文件中,我们通过history命令可以查看历史命令.</p></blockquote><p><strong>命令历史相关的环境变量:</strong></p><ul><li>HISTSIZE: 命令历史记录的条数</li><li>HISTFILE: ~/.bash_history</li></ul><p><strong>命令历史调用相关的命令:</strong></p><ul><li><p>调用历史中的命令:</p><ul><li>!#: 重复执行第#条指令</li><li>!!: 重复上一条命令</li><li>!string: 匹配以string开头的命令</li></ul></li><li><p>调用上一条命令的最后一个参数:</p><ul><li>!$</li><li>ESC . （先按esc,释放然后按.）</li></ul></li></ul><a id="more"></a><h3 id="命令与文件补全功能"><a href="#命令与文件补全功能" class="headerlink" title="命令与文件补全功能"></a>命令与文件补全功能</h3><blockquote><p>常在bash中使用热键[Tab]是一个好习惯,因为它可以减少键盘的输入和保证命令的输出的正确性。</p></blockquote><ul><li>接在一串命令的第一个字后面,则为命令的补全</li><li>接在一床命令的第二个字以后时,则为文件的补全</li></ul><h3 id="命令别名的功能"><a href="#命令别名的功能" class="headerlink" title="命令别名的功能"></a>命令别名的功能</h3><blockquote><p>通过给常用命令设置别名的方式,减少命令的输出长度,提升工作效率。命令行键入alias命令,可以查看系统配置的alias命令,将命令别名记录在全局配置环境配置文件/etc/profile或~/.bashrc都是一种持久生效的方式.</p></blockquote><pre><code>[root@chenfanlinux ~]# aliasalias cp=&apos;cp -i&apos;alias egrep=&apos;egrep --color=auto&apos;alias fgrep=&apos;fgrep --color=auto&apos;alias grep=&apos;grep --color=auto&apos;alias l.=&apos;ls -d .* --color=auto&apos;alias ll=&apos;ls -l --color=auto&apos;alias ls=&apos;ls --color=auto&apos;alias mv=&apos;mv -i&apos;alias rm=&apos;rm -i&apos;alias which=&apos;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde&apos;</code></pre><p>   <strong>注意:由于shell脚本中的别名不生效，\cp的含义是脱去别名的设置。</strong></p><h3 id="命令行展开功能"><a href="#命令行展开功能" class="headerlink" title="命令行展开功能"></a>命令行展开功能</h3><blockquote><p>{}:可以承载一个以逗号分隔的列表,并将其展开为多个路径.</p></blockquote><pre><code>$ mkdir /tmp/{a,b} &lt;==&gt;  $ mkdir /tmp/a;mkdir /tmp/b$ mkdir /tmp/{tom,jerry}/hi &lt;==&gt;  $ mkidr /tmp/tom/hi;mkdir /tmp/jerry/hi</code></pre><h3 id="作业-jobs-、前台-fg-、后台-bg-控制"><a href="#作业-jobs-、前台-fg-、后台-bg-控制" class="headerlink" title="作业(jobs)、前台(fg)、后台(bg)控制"></a>作业(jobs)、前台(fg)、后台(bg)控制</h3><blockquote><p>使用前台、后台控制,可以让工作进行得更加的顺利.我们可以随时将作业放置到后台执行,不用担心使用了[Ctrl]+c键来停掉该程序。在单用户登录环境中，达到了多任务的目标。</p></blockquote><ul><li>前台作业: 通过终端启动,且启动后一直占据终端</li><li><p>后台作业: 通过终端启动,但启动后即转入后台运行(释放终端)</p></li><li><p><strong>如何让作业运行于后台?</strong></p><ul><li><p>运行中的作业<br><code>Ctrl+Z</code></p></li><li><p>尚未启动的作业<br><code>COMMAND &amp;</code><br><strong><em>此类作业虽然被送往后台运行,但其依然与终端相关,<br>因为退出登录后作业将停止运行;如果希望送往后台,剥离与终端的关系。</em></strong></p></li><li><p>剥离作业与终端的关系<br><code>nohup COMMAND &amp;</code></p></li></ul></li></ul><ul><li><p><strong>作业控制相关命令:</strong></p><ul><li>查看所有作业情况<br><code>jobs</code></li><li>指定的后台作业调回前台<br><code>fg [[%]JOB_NUM]</code></li><li>让送往后台的作业在后台继续运行<br><code>bg [[%]JOB_NUM]</code></li><li>终止指定的作业<br><code>kill [%JOB_NUM]</code></li></ul></li></ul><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><blockquote><p>除了完整的字符串之外,bash还支持许多通配符来帮助用户查询和执行命令。下表列出常见的通配符,仅供参考。</p></blockquote><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">内容</th></tr></thead><tbody><tr><td style="text-align:center">*</td><td style="text-align:center">通配符,代表0个或多个字符(或数字)</td></tr><tr><td style="text-align:center">?</td><td style="text-align:center">通配符,代表一个有一个字符</td></tr><tr><td style="text-align:center">#</td><td style="text-align:center">注释,常在脚本中,被视为说明</td></tr><tr><td style="text-align:center">\</td><td style="text-align:center">转义字符,将特殊字符或通配符还原成一般字符</td></tr><tr><td style="text-align:center">~</td><td style="text-align:center">用户的家目录</td></tr><tr><td style="text-align:center">$</td><td style="text-align:center">变量之前需要加的变量替换值</td></tr><tr><td style="text-align:center">&amp;</td><td style="text-align:center">将命令转为后台执行</td></tr><tr><td style="text-align:center">!</td><td style="text-align:center">逻辑运算符(not)意思</td></tr><tr><td style="text-align:center">/</td><td style="text-align:center">路径分隔符</td></tr><tr><td style="text-align:center">&gt; &gt;&gt;</td><td style="text-align:center">重定向与追加重定向</td></tr><tr><td style="text-align:center">‘</td><td style="text-align:center">单引号,不具有变量置换功能</td></tr><tr><td style="text-align:center">“</td><td style="text-align:center">具有变量置换功能</td></tr><tr><td style="text-align:center">``</td><td style="text-align:center">中间为可以执行的命令</td></tr><tr><td style="text-align:center">()</td><td style="text-align:center">中间为子shell的起始于结束</td></tr><tr><td style="text-align:center">[] [^]</td><td style="text-align:center">中间为字符的组合</td></tr><tr><td style="text-align:center">{}</td><td style="text-align:center">中间为命令区块的组合</td></tr></tbody></table><table><thead><tr><th style="text-align:center">组合按键</th><th style="text-align:center">执行结果</th></tr></thead><tbody><tr><td style="text-align:center">Ctrl+c</td><td style="text-align:center">终止当前的命令</td></tr><tr><td style="text-align:center">Ctrl+a</td><td style="text-align:center">跳转至命令开始处</td></tr><tr><td style="text-align:center">Ctrl+e</td><td style="text-align:center">跳转至命令结尾处</td></tr><tr><td style="text-align:center">Ctrl+u</td><td style="text-align:center">删除命令行首至光标所在处的所有内容</td></tr><tr><td style="text-align:center">Ctrl+k</td><td style="text-align:center">删除光标所在行至命令行尾部的内容</td></tr><tr><td style="text-align:center">Ctrl+z</td><td style="text-align:center">暂停当前命令的执行</td></tr><tr><td style="text-align:center">Ctrl+l</td><td style="text-align:center">清屏,相当于clear命令</td></tr></tbody></table><p><strong>匹配字符举例</strong></p><ul><li>* 任意长度的任意字符</li><li>? 任意单个字符</li><li><p>[] 只能匹配指定范围内的任意单个字符</p><ul><li>[0-9] 所有数字中挑一个</li><li>[a-z] 不分区字符大小写</li><li>[A-Z] 大写字母</li><li>[[:lower:]] 小写字母</li><li>[^0-9a-z] 特殊字符</li></ul></li><li><p>[^] 匹配指定范围外的任意单个字符</p></li><li><p>专用字符集合:</p><ul><li>[:digit:]:任意数字,相当于0-9</li><li>[:lower:]:任意小写字母</li><li>[:upper:]:任意大写字母</li><li>[:alpha:]:任意大小写字母</li><li>[:alnum:]:任意数字或字母</li><li>[:space:]:空格</li><li>[:punct:]:标点符号</li></ul></li></ul><h3 id="命令执行的判断依据-amp-amp"><a href="#命令执行的判断依据-amp-amp" class="headerlink" title="命令执行的判断依据(; &amp;&amp; ||)"></a>命令执行的判断依据(; &amp;&amp; ||)</h3><blockquote><p>通常来说命令的运行状态会返回两种结果,执行成功则返回0，执行错误则返回非0。而多个命令的执行通常,从前至后,而且命令的执行还具有一定的逻辑关系,上一个命令的执行成功与否,某种程序可用决定下一个命令的执行。</p></blockquote><p><strong>一次执行多个命令,命令之间没有关联。</strong></p><pre><code>[root@chenfanlinux ~]# toch test.txt ; echo &quot;I  touch test.txt&quot;-bash: toch: 未找到命令I touch test.txt</code></pre><p><strong>命令相互关联,上一个命令执行成功,才会执行下一个命令。</strong></p><pre><code>[root@chenfanlinux ~]# toch test.txt &amp;&amp; echo &quot;I touch test.txt&quot;-bash: toch: 未找到命令</code></pre><p><strong>命令相关关联,上一个命令执行失败,才会执行下一个命令。</strong></p><pre><code>[root@chenfanlinux ~]# toch test.txt || echo &quot;I touch test.txt&quot;-bash: toch: 未找到命令I touch test.txt[root@chenfanlinux ~]# touch test.txt || echo &quot;I touch test.txt&quot;注意:这里不会执行echo &quot;I touch test.txt&quot;</code></pre><p><strong>如果第一个命令执行成功,则执行第二个命令,否则执行第三个命令。</strong></p><pre><code>[root@chenfanlinux ~]# touch test.txt &amp;&amp;  echo &quot;我是第二个命令&quot; || echo &quot;我是第三个命令&quot;我是第二个命令[root@chenfanlinux ~]# tuch test.txt &amp;&amp;  echo &quot;我是第二个命令&quot; || echo &quot;我是第三个命令&quot;-bash: tuch: 未找到命令我是第三个命令</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是shell&quot;&gt;&lt;a href=&quot;#什么是shell&quot; class=&quot;headerlink&quot; title=&quot;什么是shell?&quot;&gt;&lt;/a&gt;什么是shell?&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;通常,替我们工作的是”硬件”,而控制硬件的是”内核”。用户利用”shell”控制着一些内核提供的”工具”,来控制硬件替我们工作。由于内核听不懂人类语言,所以shell从本质来说就是一个UI(用户界面)应用程序,让内核控制着硬件正确无误的工作，如图1-1 硬件-内核-shell 所示，可以清晰的看到他们的关系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-std.dprcdn.net/files/acc_582513/DDfPGJ&quot; alt=&quot;硬件-内核&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Bash-shell功能特性&quot;&gt;&lt;a href=&quot;#Bash-shell功能特性&quot; class=&quot;headerlink&quot; title=&quot;Bash shell功能特性&quot;&gt;&lt;/a&gt;Bash shell功能特性&lt;/h2&gt;&lt;h3 id=&quot;history命令记忆功能&quot;&gt;&lt;a href=&quot;#history命令记忆功能&quot; class=&quot;headerlink&quot; title=&quot;history命令记忆功能&quot;&gt;&lt;/a&gt;history命令记忆功能&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在Bash里面,我们只要在命令行按”上、下键”或者更强大的”Ctrl+r”,就可以找到之前输入的历史命令,这依赖于Bash的命令记录功能,记录的文件位于家目录下的.bash_history。登录shell后新执行的命令只会记录在缓存中,这些命令会在用户退出时追加到命令历史文件中,我们通过history命令可以查看历史命令.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;命令历史相关的环境变量:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HISTSIZE: 命令历史记录的条数&lt;/li&gt;
&lt;li&gt;HISTFILE: ~/.bash_history&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;命令历史调用相关的命令:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;调用历史中的命令:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;!#: 重复执行第#条指令&lt;/li&gt;
&lt;li&gt;!!: 重复上一条命令&lt;/li&gt;
&lt;li&gt;!string: 匹配以string开头的命令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;调用上一条命令的最后一个参数:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;!$&lt;/li&gt;
&lt;li&gt;ESC . （先按esc,释放然后按.）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Bash基础" scheme="http://www.chenfanlinux.org/categories/Bash%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Bash" scheme="http://www.chenfanlinux.org/tags/Bash/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门之基础概念与架构(一)</title>
    <link href="http://www.chenfanlinux.org/2017/12/28/Docker%E5%85%A5%E9%97%A8%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%9E%B6%E6%9E%84-%E4%B8%80/"/>
    <id>http://www.chenfanlinux.org/2017/12/28/Docker入门之基础概念与架构-一/</id>
    <published>2017-12-28T01:11:33.000Z</published>
    <updated>2018-01-08T05:21:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="what-什么是docker"><a href="#what-什么是docker" class="headerlink" title="what 什么是docker?"></a>what 什么是docker?</h2><p><a href="https://www.docker.com" target="_blank" rel="noopener">Docker</a> 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 <a href="https://zh.wikipedia.org/wiki/Cgroups" target="_blank" rel="noopener">cgroup</a>，<a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">namespace</a>，以及 <a href="https://en.wikipedia.org/wiki/Aufs" target="_blank" rel="noopener">AUFS</a> 类的 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">Union FS</a> 等技术，对进程进行封装隔离，属于 <a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization" target="_blank" rel="noopener">操作系统层面的虚拟化技术</a>。由于隔离的进程独立于宿主和其它的隔离的进程，在容器中运行的程序只能看到容器的内容和分配给该容器的设备,因此也称其为容器。最初实现是基于 <a href="https://linuxcontainers.org/lxc/introduction/" target="_blank" rel="noopener">LXC</a>，现在基于<a href="http://www.infoq.com/cn/articles/docker-standard-container-execution-engine-runc?utm_source=articles_about_RunC&amp;utm_medium=link&amp;utm_campaign=RunC" target="_blank" rel="noopener">runc</a>等机制。Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。</p><ul><li>Docker容器本质上是宿主机上的一个进程，Docker通过namespace实现了资源隔离。</li><li>Docker有五个命名空间：进程、网络、挂载、宿主和共享内存，为了隔离有问题的应用，运用Namespace将进程隔离，为进程或进程组创建已隔离的运行空间，为进程提供不同的命名空间视图；这样，每一个隔离出来的进程组，对外就表现为一个container。</li><li>Namespaces充当隔离的第一级，确保一个容器中运行一个进程而且不能看到或影响容器外的其它进程。</li><li>cgroups是LXC的重要组成部分，实现了资源的限制，通过写时复制机制copy-on-write实现了高效的文件操作。</li><li>UnionFS（文件系统）作为容器的构建块。为了支持Docker的轻量级以及速度快的特性，它创建了用户层</li></ul><h2 id="why-为什么使用docker？"><a href="#why-为什么使用docker？" class="headerlink" title="why 为什么使用docker？"></a>why 为什么使用docker？</h2><p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便,而且容器使软件具备了超强的可移植能力。</p><ul><li>容器技术与传统虚拟机虚拟化方式对比：</li></ul><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/vyEvvG" alt="传统虚拟机"></p><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/hEWM0Z" alt="Docker"></p><ul><li>容器技术与传统虚拟机性能对比：</li></ul><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/6RGWHJ" alt="性能对比"></p><a id="more"></a><p><strong>Docker给DevOps带来的好处</strong></p><ul><li><p>更快速的交付和部署<br>开发人员可以使用镜像快速的构建标准开发环境；开发完成后，测试和运维人员可以使用开发人员提供的docker镜像快速部署应用，可以避免开发和测试运维人员之间的环境差异导致的部署问题。</p></li><li><p>更高效的资源利用<br>Docker容器的运行不需要额外的虚拟化管理程序支持，它是内核级的虚拟化，在占用更少资源的情况实现更高的性能。</p></li><li><p>更方便的迁移和扩展<br>Docker容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、服务器等。这种兼容使得用户可以在不同的平台之间很方便的完成应用迁移。</p></li><li><p>更简单的更新管理<br>使用Dockerfile，只需要小小的配置修改，就可以替代以往大量的更新工作，并且所有修改都以增量方式进行分发和更新。</p></li></ul><h2 id="How-容器是如何工作的"><a href="#How-容器是如何工作的" class="headerlink" title="How 容器是如何工作的?"></a>How 容器是如何工作的?</h2><p>Docker有五大核心组件,可以快速浏览下面的Docker架构图来了解核心组件,了解他们如何协作。</p><p><strong>Docker 的核心组件包括：</strong></p><ul><li>Docker 客户端 - Client</li><li>Docker 服务器 - Docker daemon</li><li>Docker 镜像 - Image</li><li>Docker 仓库 - Registry</li><li>Docker 容器 - Container</li></ul><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/uLaYib" alt="Docker架构图"><br>Docker 采用的是 Client/Server 架构。客户端向服务器发送请求，服务器负责构建、运行和分发容器。客户端和服务器可以运行在同一个 Host 上，客户端也可以通过 socket 或 REST API 与远程的服务器通信。</p><h4 id="Docker-客户端"><a href="#Docker-客户端" class="headerlink" title="Docker 客户端"></a>Docker 客户端</h4><p>最常用的 Docker 客户端是 docker 命令。通过 docker 我们可以方便地在 Host 上构建和运行容器。docker 支持很多操作（子命令），后面会逐步用到。</p><pre><code>[root@my-k8s-master01 ~]# docker -vDocker version 1.12.6, build 85d7426/1.12.6</code></pre><p>除了 docker 命令行工具，用户也可以通过 REST API 与服务器通信</p><h4 id="Docker-服务器"><a href="#Docker-服务器" class="headerlink" title="Docker 服务器"></a>Docker 服务器</h4><p>Docker daemon 是服务器组件，以 Linux 后台服务的方式运行。</p><pre><code>[root@my-k8s-master01 ~]# systemctl status docker● docker.service - Docker Application Container Engine   Loaded: loaded (/usr/lib/systemd/system/docker.service; enabled; vendor preset: disabled)   Active: active (running) since 二 2017-12-05 15:57:51 CST; 1 months 3 days ago     Docs: http://docs.docker.com Main PID: 1527 (dockerd-current)</code></pre><p>Docker daemon 运行在 Docker host 上，负责创建、运行、监控容器，构建、存储镜像。<br>默认配置下，Docker daemon 只能响应来自本地 Host 的客户端请求。如果要允许远程客户端请求，需要在配置文件中打开 TCP 监听。</p><h4 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h4><p>可将 Docker 镜像看着只读模板，通过它可以创建 Docker 容器。<br>镜像有多种生成方法：</p><ul><li>可以从无到有开始创建镜像</li><li>也可以下载并使用别人创建好的现成的镜像</li><li>还可以在现有镜像上创建新的镜像</li></ul><p>我们可以将镜像的内容和创建步骤描述在一个文本文件中，这个文件被称作 Dockerfile，通过执行 docker build <docker-file> 命令可以构建出 Docker 镜像，后面我们会讨论。</docker-file></p><h4 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h4><p>Docker 容器就是 Docker 镜像的运行实例。</p><p>用户可以通过 CLI（docker）或是 API 启动、停止、移动或删除容器。可以这么认为，对于应用软件，镜像是软件生命周期的构建和打包阶段，而容器则是启动和运行阶段</p><h4 id="Docker-仓库"><a href="#Docker-仓库" class="headerlink" title="Docker 仓库"></a>Docker 仓库</h4><p>Registry 是存放 Docker 镜像的仓库，Registry 分私有和公有两种。</p><p>Docker Hub（<a href="https://hub.docker.com/）" target="_blank" rel="noopener">https://hub.docker.com/）</a> 是默认的 Registry，由 Docker 公司维护，上面有数以万计的镜像，用户可以自由下载和使用。</p><p>出于对速度或安全的考虑，用户也可以创建自己的私有 Registry。后面我们会学习如何搭建私有 Registry。</p><p>docker pull 命令可以从 Registry 下载镜像。<br>docker run 命令则是先下载镜像（如果本地没有），然后再启动容器。</p><h2 id="Centos7开始安装Docker"><a href="#Centos7开始安装Docker" class="headerlink" title="Centos7开始安装Docker"></a>Centos7开始安装Docker</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在Linux上安装Docker并配置加速器，Docker目前被分为两个版本：</p><ul><li>Community-Edition：社区版</li><li>Enterprise-Edition：企业版</li></ul><h4 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h4><p><strong>卸载旧版本的Docker服务</strong></p><pre><code>$ yum -y remove docker \docker-common \container-selinux \docker-selinux \docker-engine</code></pre><p><strong>安装yum-utils，它提供yum-config-manager实用程序</strong></p><pre><code>$ yum install -y yum-utils</code></pre><p><strong>添加Docker的CE存储库(官网)</strong></p><pre><code>$ yum-config-manager \    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo</code></pre><p><strong>添加Docker的CE存储库(国内)</strong></p><pre><code>$ yum-config-manager \    --add-repo \    http://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo</code></pre><p><strong>更新软件包的索引列表</strong></p><pre><code>$ yum makecache fast</code></pre><p><strong>安装最新版的Docker服务</strong></p><pre><code>yum install -y docker-ce</code></pre><p><strong>启动Docker服务</strong></p><pre><code>systemctl start docker</code></pre><p><strong>Docker服务随机自启</strong></p><pre><code>systemctl enable docker</code></pre><p><strong>卸载Docker服务</strong></p><p>   # 卸载软件包</p><pre><code>$ yum remove -y docker-ce</code></pre><p>卸载Docker后,/var/lib/docker/目录下会保留原Docker的镜像,网络,存储卷等文件. 如果需要全新安装Docker,需要删除/var/lib/docker/目录.</p><pre><code>$ rm -rf /var/lib/docker</code></pre><p><strong>查看docker版本信息</strong></p><p>   # 获取版本信息的简介</p><pre><code>$ docker -v</code></pre><p>   # 获取详细的版本信息</p><pre><code>$ docker version</code></pre><h4 id="配置Docker加速器"><a href="#配置Docker加速器" class="headerlink" title="配置Docker加速器"></a>配置Docker加速器</h4><ol><li><p>由于众所周知的原因(墙)，从Docker Hub难以高效地下载镜像，除了使用VPN或代理之外，<br>最为有效的方式就是使用Docker国内镜像；</p></li><li><p>DaoCloud为首个提供国内免费Docker Hub镜像的团体，可以使用DaoCloud团队提供的<br>Docker Hub Mirror服务代替Docker官网的Docker Hub；</p></li><li><p>官网：传送门，注册用户并登录；</p></li><li><p>登录以后，在自己管理界面点击加速器标签，根据弹出页面配置加速器；</p></li></ol><blockquote><p>Copy<br>该脚本可以将 –registry-mirror 加入到你的 Docker 配置文件 /etc/docker/daemon.json 中。适用于 Ubuntu14.04、Debian、CentOS6 、CentOS7、Fedora、Arch Linux、openSUSE Leap 42.1，其他版本可能有细微不同</p></blockquote><pre><code>curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://9fa458c0.m.daocloud.io</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;what-什么是docker&quot;&gt;&lt;a href=&quot;#what-什么是docker&quot; class=&quot;headerlink&quot; title=&quot;what 什么是docker?&quot;&gt;&lt;/a&gt;what 什么是docker?&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.docker.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Docker&lt;/a&gt; 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 &lt;a href=&quot;https://zh.wikipedia.org/wiki/Cgroups&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;cgroup&lt;/a&gt;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Linux_namespaces&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;namespace&lt;/a&gt;，以及 &lt;a href=&quot;https://en.wikipedia.org/wiki/Aufs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AUFS&lt;/a&gt; 类的 &lt;a href=&quot;https://en.wikipedia.org/wiki/Union_mount&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Union FS&lt;/a&gt; 等技术，对进程进行封装隔离，属于 &lt;a href=&quot;https://en.wikipedia.org/wiki/Operating-system-level_virtualization&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;操作系统层面的虚拟化技术&lt;/a&gt;。由于隔离的进程独立于宿主和其它的隔离的进程，在容器中运行的程序只能看到容器的内容和分配给该容器的设备,因此也称其为容器。最初实现是基于 &lt;a href=&quot;https://linuxcontainers.org/lxc/introduction/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LXC&lt;/a&gt;，现在基于&lt;a href=&quot;http://www.infoq.com/cn/articles/docker-standard-container-execution-engine-runc?utm_source=articles_about_RunC&amp;amp;utm_medium=link&amp;amp;utm_campaign=RunC&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;runc&lt;/a&gt;等机制。Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Docker容器本质上是宿主机上的一个进程，Docker通过namespace实现了资源隔离。&lt;/li&gt;
&lt;li&gt;Docker有五个命名空间：进程、网络、挂载、宿主和共享内存，为了隔离有问题的应用，运用Namespace将进程隔离，为进程或进程组创建已隔离的运行空间，为进程提供不同的命名空间视图；这样，每一个隔离出来的进程组，对外就表现为一个container。&lt;/li&gt;
&lt;li&gt;Namespaces充当隔离的第一级，确保一个容器中运行一个进程而且不能看到或影响容器外的其它进程。&lt;/li&gt;
&lt;li&gt;cgroups是LXC的重要组成部分，实现了资源的限制，通过写时复制机制copy-on-write实现了高效的文件操作。&lt;/li&gt;
&lt;li&gt;UnionFS（文件系统）作为容器的构建块。为了支持Docker的轻量级以及速度快的特性，它创建了用户层&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;why-为什么使用docker？&quot;&gt;&lt;a href=&quot;#why-为什么使用docker？&quot; class=&quot;headerlink&quot; title=&quot;why 为什么使用docker？&quot;&gt;&lt;/a&gt;why 为什么使用docker？&lt;/h2&gt;&lt;p&gt;传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便,而且容器使软件具备了超强的可移植能力。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容器技术与传统虚拟机虚拟化方式对比：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-std.dprcdn.net/files/acc_582513/vyEvvG&quot; alt=&quot;传统虚拟机&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-std.dprcdn.net/files/acc_582513/hEWM0Z&quot; alt=&quot;Docker&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容器技术与传统虚拟机性能对比：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-std.dprcdn.net/files/acc_582513/6RGWHJ&quot; alt=&quot;性能对比&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Docker系列" scheme="http://www.chenfanlinux.org/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Docker" scheme="http://www.chenfanlinux.org/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>编辑器之神-vim</title>
    <link href="http://www.chenfanlinux.org/2017/12/24/%E7%BC%96%E8%BE%91%E5%99%A8%E4%B9%8B%E7%A5%9E-vim/"/>
    <id>http://www.chenfanlinux.org/2017/12/24/编辑器之神-vim/</id>
    <published>2017-12-24T02:24:27.000Z</published>
    <updated>2018-01-10T07:40:13.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vim简介"><a href="#vim简介" class="headerlink" title="vim简介"></a>vim简介</h3><p>vi是“Visual interface”的简称，它不像Word或WPS那样可以对字体、格式、段落等其他属性进行编排，它只是一个文本编辑程序。 vi没有菜单，只有命令，且命令繁多。vim(VIM - Vi IMproved)是vi的加强版本，在vi的基础上增加了如下功能。</p><blockquote><ul><li>增加了多级撤销</li><li>多窗口操作</li><li>提高了稳定性，减少了崩溃以及崩溃后也可以恢复</li><li>关键字自动补全以及上下文相关的补全</li></ul></blockquote><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/bEfzpN" alt="vim键盘图"></p><h3 id="vim的工作模式"><a href="#vim的工作模式" class="headerlink" title="vim的工作模式"></a>vim的工作模式</h3><p>Vi有三种基本工作模式：</p><ul><li>命令模式（普通模式）</li><li>文本输入模式</li><li>末行模式(底线命令模式)</li></ul><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/SDuEA" alt="vim工作模式"></p><h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><ul><li><strong>单个字符移动</strong></li></ul><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">移动方向</th></tr></thead><tbody><tr><td style="text-align:center">h</td><td style="text-align:center">向左移动</td></tr><tr><td style="text-align:center">l</td><td style="text-align:center">向右移动</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center">向下移动</td></tr><tr><td style="text-align:center">k</td><td style="text-align:center">向上移动</td></tr></tbody></table><ul><li><strong>单词移动</strong></li></ul><table><thead><tr><th style="text-align:center">单词</th><th style="text-align:center">移动方向</th></tr></thead><tbody><tr><td style="text-align:center">w</td><td style="text-align:center">将光标移动到下一个单词开头</td></tr><tr><td style="text-align:center">b</td><td style="text-align:center">将光标移动到前一个单词的开头</td></tr><tr><td style="text-align:center">e</td><td style="text-align:center">将光标移动到下一个单词的词末</td></tr><tr><td style="text-align:center">E</td><td style="text-align:center">移动到单词的结尾(忽略标点符号)</td></tr><tr><td style="text-align:center">ge</td><td style="text-align:center">将光标移动到前一个单词的词末</td></tr></tbody></table><ul><li><strong>行移动</strong></li></ul><table><thead><tr><th style="text-align:center">单词</th><th style="text-align:center">移动方向</th></tr></thead><tbody><tr><td style="text-align:center">$</td><td style="text-align:center">将光标移动到当前行的行尾</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">将光标移动到当前行的行首</td></tr><tr><td style="text-align:center">fx</td><td style="text-align:center">将光标移动到当前行的第一个字符x上</td></tr><tr><td style="text-align:center">3fx</td><td style="text-align:center">将光标移动到航前行的第3个字符x上</td></tr><tr><td style="text-align:center">%</td><td style="text-align:center">用于符号间的移动，它会在一对()、[]、{}之间跳跃</td></tr></tbody></table><a id="more"></a><ul><li><strong>文本块移动</strong></li></ul><table><thead><tr><th style="text-align:center">单词</th><th style="text-align:center">移动方向</th></tr></thead><tbody><tr><td style="text-align:center">(</td><td style="text-align:center">移到当前句子的开头</td></tr><tr><td style="text-align:center">)</td><td style="text-align:center">移到下一个句子的开头</td></tr><tr><td style="text-align:center">{</td><td style="text-align:center">移到当前一段的开头</td></tr><tr><td style="text-align:center">}</td><td style="text-align:center">移到下一段的开头</td></tr><tr><td style="text-align:center">ge</td><td style="text-align:center">将光标移动到前一个单词的词末</td></tr></tbody></table><ul><li><strong>在屏幕中移动</strong></li></ul><table><thead><tr><th style="text-align:center">单词</th><th style="text-align:center">移动方向</th></tr></thead><tbody><tr><td style="text-align:center">H</td><td style="text-align:center">移动到当前屏幕的开头</td></tr><tr><td style="text-align:center">M</td><td style="text-align:center">移动到当前屏幕中间</td></tr><tr><td style="text-align:center">L</td><td style="text-align:center">移动当前屏幕的末尾</td></tr><tr><td style="text-align:center">gg</td><td style="text-align:center">移动到文件开头</td></tr><tr><td style="text-align:center">xG</td><td style="text-align:center">跳转到指定的第x行，G移动到文件按末尾</td></tr></tbody></table><h3 id="滚屏与跳转"><a href="#滚屏与跳转" class="headerlink" title="滚屏与跳转"></a>滚屏与跳转</h3><ul><li><strong>半屏滚动</strong></li></ul><table><thead><tr><th style="text-align:center">快捷键</th><th style="text-align:center">方向</th></tr></thead><tbody><tr><td style="text-align:center">ctrl+u</td><td style="text-align:center">向上滚动</td></tr><tr><td style="text-align:center">ctrl+d</td><td style="text-align:center">向下滚动</td></tr></tbody></table><ul><li><strong>全屏滚动</strong></li></ul><table><thead><tr><th style="text-align:center">快捷键</th><th style="text-align:center">方向</th></tr></thead><tbody><tr><td style="text-align:center">ctrl+b</td><td style="text-align:center">向上滚动</td></tr><tr><td style="text-align:center">ctrl+f</td><td style="text-align:center">向下滚动</td></tr></tbody></table><ul><li><strong>定位光标的位置</strong></li></ul><table><thead><tr><th style="text-align:center">快捷键</th><th style="text-align:center">方向</th></tr></thead><tbody><tr><td style="text-align:center">zz</td><td style="text-align:center">将光标置于屏幕的中间</td></tr><tr><td style="text-align:center">zt</td><td style="text-align:center">将光标移动到屏幕的顶部</td></tr><tr><td style="text-align:center">zb</td><td style="text-align:center">将光标移动到屏幕的底部</td></tr></tbody></table><h3 id="文本插入操作"><a href="#文本插入操作" class="headerlink" title="文本插入操作"></a>文本插入操作</h3><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">i</td><td style="text-align:center">在当前光标的前面插入字符</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">在当前光标的后面追加字符</td></tr><tr><td style="text-align:center">o</td><td style="text-align:center">在当前光标的下一行行首插入字符</td></tr><tr><td style="text-align:center">O</td><td style="text-align:center">在当前光标的上一行行首插入字符</td></tr><tr><td style="text-align:center">I</td><td style="text-align:center">在一行的开头添加文本</td></tr><tr><td style="text-align:center">A</td><td style="text-align:center">在一行的结尾处添加文本</td></tr><tr><td style="text-align:center">u</td><td style="text-align:center">撤销修改</td></tr><tr><td style="text-align:center">ctrl+r</td><td style="text-align:center">反撤销修改</td></tr></tbody></table><h3 id="文本删除"><a href="#文本删除" class="headerlink" title="文本删除"></a>文本删除</h3><ul><li><strong>字符删除</strong></li></ul><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">x</td><td style="text-align:center">删除当前光标所在处的字符</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">删除当前光标左边的字符</td></tr></tbody></table><ul><li><strong>单词删除</strong></li></ul><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">dw</td><td style="text-align:center">删除一个单词(从光标处到空格)</td></tr><tr><td style="text-align:center">d$</td><td style="text-align:center">删除从光标到一行末尾的整个文本</td></tr><tr><td style="text-align:center">d0</td><td style="text-align:center">删除从光标到一行开头的所有单词</td></tr></tbody></table><ul><li><strong>行删除</strong></li></ul><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">dd</td><td style="text-align:center">删除当前光标处的一整行=D</td></tr><tr><td style="text-align:center">5dd</td><td style="text-align:center">删除从光标到文本开头</td></tr><tr><td style="text-align:center">dG</td><td style="text-align:center">删除从光标到文本结尾</td></tr></tbody></table><h3 id="文本复制、剪切与粘贴"><a href="#文本复制、剪切与粘贴" class="headerlink" title="文本复制、剪切与粘贴"></a>文本复制、剪切与粘贴</h3><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">y</td><td style="text-align:center">复制,p:粘贴</td></tr><tr><td style="text-align:center">yw</td><td style="text-align:center">复制一个单词</td></tr><tr><td style="text-align:center">y2w</td><td style="text-align:center">复制2个单词</td></tr><tr><td style="text-align:center">y$</td><td style="text-align:center">复制从当前光标到行结尾的所有单词</td></tr><tr><td style="text-align:center">y0</td><td style="text-align:center">复制从当前光标到行首的所有单词</td></tr><tr><td style="text-align:center">&gt;&gt;</td><td style="text-align:center">文本行右移</td></tr><tr><td style="text-align:center">&lt;&lt;</td><td style="text-align:center">文本行左移</td></tr><tr><td style="text-align:center">.</td><td style="text-align:center">重复命令</td></tr></tbody></table><p><strong>可视模式</strong></p><ul><li>v: 按字符移动,选中文本    </li><li>V: 按行移动,选中文本可视模式可以配合 d, y, &gt;&gt;, &lt;&lt; 实现对文本块的删除,复制,左右移动 </li><li>Ctrl+v: 列操作模式  <ul><li>删除某一列内容：先ctrl+v,然后通过上下左右键,选择需要操作的文本，键入d,则可以删除选中的列内容。</li><li>插入操作: 先ctrl+v,然后上下左右键，选择需要操作的列,键入shift+i(在列前面插入)或shift+a(在列后面插入)指定的内容；接下来按Esc才能看到插入生效,再键入Esc,回到命令行模式,保存退出。</li></ul></li></ul><h3 id="查找命令与替换"><a href="#查找命令与替换" class="headerlink" title="查找命令与替换"></a>查找命令与替换</h3><ul><li><strong>字符串查找</strong></li></ul><table><thead><tr><th style="text-align:center">表达式</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">/string</td><td style="text-align:center">正向查找</td></tr><tr><td style="text-align:center">?string</td><td style="text-align:center">反向查找</td></tr></tbody></table><ul><li><strong>字符串替换</strong></li></ul><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">:s/old/new</td><td style="text-align:center">将当前行的第一个字符串old替换为new</td></tr><tr><td style="text-align:center">:s/old/new/g</td><td style="text-align:center">将当前行的所有字符串old替换为new</td></tr><tr><td style="text-align:center">:90s/old/new/g</td><td style="text-align:center">将指定行的所有字符串old替换为new</td></tr><tr><td style="text-align:center">:90,93s/old/new/g</td><td style="text-align:center">将90到93行的所有字符串old替换为new</td></tr><tr><td style="text-align:center">:%s/old/new/g</td><td style="text-align:center">将文本中所有的字符串old替换为new</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;vim简介&quot;&gt;&lt;a href=&quot;#vim简介&quot; class=&quot;headerlink&quot; title=&quot;vim简介&quot;&gt;&lt;/a&gt;vim简介&lt;/h3&gt;&lt;p&gt;vi是“Visual interface”的简称，它不像Word或WPS那样可以对字体、格式、段落等其他属性进行编排，它只是一个文本编辑程序。 vi没有菜单，只有命令，且命令繁多。vim(VIM - Vi IMproved)是vi的加强版本，在vi的基础上增加了如下功能。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;增加了多级撤销&lt;/li&gt;
&lt;li&gt;多窗口操作&lt;/li&gt;
&lt;li&gt;提高了稳定性，减少了崩溃以及崩溃后也可以恢复&lt;/li&gt;
&lt;li&gt;关键字自动补全以及上下文相关的补全&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-std.dprcdn.net/files/acc_582513/bEfzpN&quot; alt=&quot;vim键盘图&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;vim的工作模式&quot;&gt;&lt;a href=&quot;#vim的工作模式&quot; class=&quot;headerlink&quot; title=&quot;vim的工作模式&quot;&gt;&lt;/a&gt;vim的工作模式&lt;/h3&gt;&lt;p&gt;Vi有三种基本工作模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命令模式（普通模式）&lt;/li&gt;
&lt;li&gt;文本输入模式&lt;/li&gt;
&lt;li&gt;末行模式(底线命令模式)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-std.dprcdn.net/files/acc_582513/SDuEA&quot; alt=&quot;vim工作模式&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;光标移动&quot;&gt;&lt;a href=&quot;#光标移动&quot; class=&quot;headerlink&quot; title=&quot;光标移动&quot;&gt;&lt;/a&gt;光标移动&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;单个字符移动&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;字符&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;移动方向&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;h&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;向左移动&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;l&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;向右移动&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;j&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;向下移动&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;k&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;向上移动&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;单词移动&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;单词&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;移动方向&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;w&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将光标移动到下一个单词开头&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;b&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将光标移动到前一个单词的开头&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;e&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将光标移动到下一个单词的词末&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;E&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;移动到单词的结尾(忽略标点符号)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;ge&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将光标移动到前一个单词的词末&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;行移动&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;单词&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;移动方向&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将光标移动到当前行的行尾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将光标移动到当前行的行首&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;fx&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将光标移动到当前行的第一个字符x上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;3fx&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将光标移动到航前行的第3个字符x上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;%&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;用于符号间的移动，它会在一对()、[]、{}之间跳跃&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="Tools利器" scheme="http://www.chenfanlinux.org/categories/Tools%E5%88%A9%E5%99%A8/"/>
    
    
      <category term="Vim" scheme="http://www.chenfanlinux.org/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>python基础之流程控制</title>
    <link href="http://www.chenfanlinux.org/2017/12/19/python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>http://www.chenfanlinux.org/2017/12/19/python基础之流程控制/</id>
    <published>2017-12-19T14:31:23.000Z</published>
    <updated>2018-01-10T07:36:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><blockquote><p>if语句是用来检查一个条件：如果条件为真(true)，我们运行一个语句块（你为if块），否则(else)，我们执行另一个语句块（称为else块），else子语句是可选的。</p></blockquote><h3 id="单条件"><a href="#单条件" class="headerlink" title="单条件"></a>单条件</h3><p>示例：如果num变量大于1，那么就输出num大，否则就输出num小，num值为5</p><p><strong>代码：</strong></p><pre><code>#!/usr/bin/env python# -*- coding:utf-8 -*-num = 5if num &gt; 1:print(&quot;num大&quot;)else:print(&quot;num小&quot;)</code></pre><p><strong>结果：</strong></p><pre><code>python num.pynum大</code></pre><h3 id="多条件"><a href="#多条件" class="headerlink" title="多条件"></a>多条件</h3><p>示例：请输入一个整数，如果输入的为负数，负数转变为0,输出print(‘Negative changed to zero’);如果输入的为0，则输出Zero;如果输入的为1，则输出Single；输入其他则，输出More。</p><p><strong>代码：</strong></p><pre><code>#__author: Administrator#date: 2017/12/19x = int(input(&apos;Please enter an integer: &apos;))if x &lt; 0:    x = 0    print(&apos;Negative changed to zero&apos;)elif x == 0:    print(&apos;Zero&apos;)elif x == 1:    print(&apos;Single&apos;)else:    print(&apos;More&apos;)</code></pre><p><strong>结果：</strong></p><pre><code>Please enter an integer: -1Negative changed to zero</code></pre><a id="more"></a><h3 id="三元运算"><a href="#三元运算" class="headerlink" title="三元运算"></a>三元运算</h3><blockquote><p>如果条件成立，那么就把值1赋值给var，如果条件不成立，就把值2赋值给var</p></blockquote><p><strong>语法：</strong></p><p><code>var = 值1 if 条件 else 值2</code></p><p><strong>示例：</strong></p><pre><code>&gt;&gt;&gt; var = &quot;True&quot; if 1 == 1 else &quot;False&quot;&gt;&gt;&gt; var&apos;True&apos;</code></pre><h2 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h2><h3 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h3><blockquote><p>while 是Python中的循环语句. 事实它上是一个条件循环语句. 与 if 声明相比, 如果 if 后的条件为真, 就会执行一次相应的代码块. 而 while 中的代码块会一直循环执行, 直到循环条件不再为真.</p></blockquote><p><strong>语法：</strong></p><pre><code>while expression:       suite_to_repeat</code></pre><p>while 循环的suit_to_repeat子句会一直循环执行, 直到 expression 值为布尔假. 这种 类型的循环机制常常用在计数循环中。</p><p><strong>代码：</strong></p><pre><code>#__author: Administrator#date: 2017/12/19count = 0while (count &lt; 5):    print(&apos;The index is: &apos;,count)    count += 1</code></pre><p><strong>结果：</strong></p><pre><code>The index is:  0The index is:  1The index is:  2The index is:  3The index is:  4</code></pre><h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><p>你必须小心地使用 while 循环, 因为有可能它的条件永远不会为布尔假. 这样一来循环就永远不会结束. 这些”无限”的循环不一定是坏事, 许多通讯服务器的客户端/服务器系统就是通过它来工作的. 这取决于循环是否需要一直执行下去, 如果不是, 那么这个循环是否会结束; 也就是说, 条件表达式会不会计算后得到布尔假?</p><pre><code>while True:    handle, indata = wait_for_client_connect()    outdata = process_request(indata)    ack_result_to_client(handle, outdata)</code></pre><p>例如上边的代码就是故意被设置为无限循环的，因为 True 无论如何都不会变成 False. 这是因为服务器代码是用来等待客户端(可能通过网络)来连接的. 这些客户端向服务器发送请求, 服务器处理请求.<br>请求被处理后, 服务器将向客户端返回数据, 而此时客户端可能断开连接或是发送另一个请求. 对于服务器而言它已经完成了对这个客户端的任务, 它会返回最外层循环等待下一个连接.</p><h3 id="while使用-else-语句"><a href="#while使用-else-语句" class="headerlink" title="while使用 else 语句"></a>while使用 else 语句</h3><p>在 python 中，for … else 表示这样的意思，for 中的语句和普通的没有区别，else 中的语句会在循环正常执行完（即 for 不是通过 break 跳出而中断的）的情况下执行.while … else 也是一样,其在循环条件不满足的时候,会开始执行else语句,通过break中断的情况下,不会执行else.</p><p><strong>代码：</strong></p><pre><code>#__author: Administrator#date: 2017/12/19count = 0while (count &lt; 5):    print(count,&apos;is less than 5&apos;)    count += 1else:    print(count,&apos;is not less than 5&apos;)</code></pre><p><strong>结果：</strong></p><pre><code>0 is less than 51 is less than 52 is less than 53 is less than 54 is less than 55 is not less than 5</code></pre><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><h3 id="基础用法-1"><a href="#基础用法-1" class="headerlink" title="基础用法"></a>基础用法</h3><blockquote><p>Python 提供给我们的另一个循环机制就是 for 语句, 它提供了 Python 中最强大的循环结构. 它可以遍历序列成员(链表或字符串). for循环会访问一个可迭代对象(例如序列或是迭代器)中的所有元素, 并在所有条目都处理过后结束循环.</p></blockquote><p><strong>语法：</strong></p><pre><code>for iter_var in iterable:        suite_to_repeat</code></pre><p>每次循环, iter_var 迭代变量被设置为可迭代对象(序列, 迭代器, 或者是其他支持迭代的对象)的当前元素, 提供给 suite_to_repeat 语句块使用.</p><p><strong>代码：</strong></p><pre><code>#__author: Administrator#date: 2017/12/19words = [&apos;cat&apos;, &apos;window&apos;, &apos;defenestrate&apos;]for w in words:    print(w,len(w))</code></pre><p><strong>结果：</strong></p><pre><code>cat 3window 6defenestrate 12</code></pre><h3 id="for使用-else-语句"><a href="#for使用-else-语句" class="headerlink" title="for使用 else 语句"></a>for使用 else 语句</h3><blockquote><p>for 循环也可以有 else 用于循环后处理(post-processing). 它和 while 循环中的 else 处理方式相同. 只要 for 循环是正常结束的(不是通过 break ), else 子句就会执行.</p></blockquote><p>代码：</p><pre><code>#__author: Administrator#date: 2017/12/19s = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;]found = Falsefor c in s:    if c.find(&apos;c&apos;) != -1:        found = True        print(&quot;发现c&quot;)        breakif not found:    print(&quot;未发现c&quot;)</code></pre><p>等价于下面的代码:</p><pre><code>#__author: Administrator#date: 2017/12/19s = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;]for c in s:    if c.find(&apos;c&apos;) != -1:        print(&quot;发现c&quot;)        breakelse:    print(&quot;未发现c&quot;)</code></pre><h2 id="break和continue语句"><a href="#break和continue语句" class="headerlink" title="break和continue语句"></a>break和continue语句</h2><h3 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h3><blockquote><p>Python 中的 break 语句可以结束当前循环然后跳转到下条语句, 类似 C 中的传统 break . 常用在当某个外部条件被触发(一般通过 if 语句检查), 需要立即从循环中退出时. break 语句可以用在 while 和 for 循环中.</p></blockquote><p><strong>代码：</strong></p><pre><code>&gt;&gt;&gt; for i in &quot;hello&quot;:...     if i ==&apos;l&apos;:...         break...     print(i)...</code></pre><p><strong>结果：</strong></p><pre><code>he</code></pre><h3 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h3><blockquote><p>不管是 Python、 C、Java 还是其它任何支持 continue 语句的结构化语言中, 一些初学者有这样的一个误解: continue 语句”立即启动循环的下一次迭代”. 实际上, 当遇到 continue 语句时, 程序会终止当前循环, 并忽略剩余的语句, 然后回到循环的顶端. 在开始下一次迭代前, 如果是条件循环, 我们将验证条件表达式. 如果是迭代循环, 我们将验证是否还有元素可以迭代. 只有在验证成功的情况下, 我们才会开始下一次迭代.</p></blockquote><p>Python 里的 continue 语句和其他高级语言中的传统 continue 并没有什么不同. 它可以被用在 while 和 for 循环里. while 循环是条件性的, 而 for 循环是迭代的, 所以 continue 在开始下一次循环前要满足一些先决条件, 否则循环会正常结束.</p><p><strong>代码：</strong></p><pre><code>&gt;&gt;&gt; for i in &quot;hello&quot;:...     if i ==&apos;l&apos;:...         continue...     print(i)...</code></pre><p><strong>结果：</strong></p><pre><code>heo</code></pre><h2 id="总结循环中的else语句"><a href="#总结循环中的else语句" class="headerlink" title="总结循环中的else语句"></a>总结循环中的else语句</h2><blockquote><p>循环一般可以分为两种，for循环或while循环，上文都有明确的介绍。循环可以有一个 else 子句；它在循环迭代完整个列表（对于 for ）或执行条件为 false （对于 while ）不被break中止的情况下执行，循环被 break 中止的情况下不会执行else语句。</p></blockquote><p><strong>示例：</strong> 在数字2-9中搜索素数</p><p><strong>代码：</strong></p><pre><code>#__author: Administrator#date: 2017/12/19&apos;&apos;&apos;在数字2-9之间搜索素数素数的定义:除了1和它自身外，不能被其他自然数整除的数叫做质数.n 被除数x 除数&apos;&apos;&apos;for n in range(2,10):    for x in range(2,n):        if n % x == 0:            print(n,&apos;equals&apos;,x,&apos;*&apos;,n//x)            break    else:        print(n,&apos;is a prime number&apos;)</code></pre><p><strong>结果：</strong></p><pre><code>2 is a prime number3 is a prime number4 equals 2 * 25 is a prime number6 equals 2 * 37 is a prime number8 equals 2 * 49 equals 3 * 3</code></pre><h2 id="range-函数"><a href="#range-函数" class="headerlink" title="range() 函数"></a>range() 函数</h2><blockquote><p>如果你需要一个数值序列，内置函数 range() 会很方便，它生成一个等差级数链表（不包含结束的end值）</p></blockquote><p><strong>语法：</strong></p><p><code>range(start, end, step=1)</code></p><pre><code>&gt;&gt;&gt; for i in range(5):...     print(i)...01234&gt;&gt;&gt; list(range(2,2))[]range(0, 10, 3)   0, 3, 6, 9range(-10, -100, -30)  -10, -40, -70</code></pre><p>range(10) 生成了一个包含 10 个值的链表，它用链表的索引值填充了这个长度为 10 的列表，所生成的链表中不包括范围中的结束值。也可以让 range() 操作从另一个数值开始，不指定时为0,或者可以指定一个不同的步进值（甚至是负数，有时这也被称为 “步长”）</p><p><strong>如果你只是打印一个序列的话会发生奇怪的事情</strong></p><pre><code>&gt;&gt;&gt; print(range(10))range(0, 10)</code></pre><p>在不同方面 range() 函数返回的对象表现为它是一个列表，但事实上它并不是。当你迭代它时，它是一个能够像期望的序列返回连续项的对象；但为了节省空间，它并不真正构造列表。</p><p>我们称此类对象是 可迭代的，即适合作为那些期望从某些东西中获得连续项直到结束的函数或结构的一个目标（参数）。我们已经见过的 for 语句就是这样一个迭代器。list() 函数是另外一个（ 迭代器 ），它从可迭代（对象）中创建列表:</p><pre><code>&gt;&gt;&gt; list(range(5))[0, 1, 2, 3, 4]</code></pre><p>稍后我们会看到更多返回可迭代（对象）和以可迭代（对象）作为参数的函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;if语句&quot;&gt;&lt;a href=&quot;#if语句&quot; class=&quot;headerlink&quot; title=&quot;if语句&quot;&gt;&lt;/a&gt;if语句&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;if语句是用来检查一个条件：如果条件为真(true)，我们运行一个语句块（你为if块），否则(else)，我们执行另一个语句块（称为else块），else子语句是可选的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;单条件&quot;&gt;&lt;a href=&quot;#单条件&quot; class=&quot;headerlink&quot; title=&quot;单条件&quot;&gt;&lt;/a&gt;单条件&lt;/h3&gt;&lt;p&gt;示例：如果num变量大于1，那么就输出num大，否则就输出num小，num值为5&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding:utf-8 -*-
num = 5
if num &amp;gt; 1:
print(&amp;quot;num大&amp;quot;)
else:
print(&amp;quot;num小&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python num.py
num大
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;多条件&quot;&gt;&lt;a href=&quot;#多条件&quot; class=&quot;headerlink&quot; title=&quot;多条件&quot;&gt;&lt;/a&gt;多条件&lt;/h3&gt;&lt;p&gt;示例：请输入一个整数，如果输入的为负数，负数转变为0,输出print(‘Negative changed to zero’);如果输入的为0，则输出Zero;如果输入的为1，则输出Single；输入其他则，输出More。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#__author: Administrator
#date: 2017/12/19
x = int(input(&amp;apos;Please enter an integer: &amp;apos;))
if x &amp;lt; 0:
    x = 0
    print(&amp;apos;Negative changed to zero&amp;apos;)
elif x == 0:
    print(&amp;apos;Zero&amp;apos;)
elif x == 1:
    print(&amp;apos;Single&amp;apos;)
else:
    print(&amp;apos;More&amp;apos;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Please enter an integer: -1
Negative changed to zero
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="python基础知识" scheme="http://www.chenfanlinux.org/categories/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="流程控制" scheme="http://www.chenfanlinux.org/tags/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>zabbx基础安装</title>
    <link href="http://www.chenfanlinux.org/2017/12/11/zabbx%E5%9F%BA%E7%A1%80%E5%AE%89%E8%A3%85/"/>
    <id>http://www.chenfanlinux.org/2017/12/11/zabbx基础安装/</id>
    <published>2017-12-11T10:07:48.000Z</published>
    <updated>2018-01-10T07:39:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、安装部署zabbix-3-4"><a href="#一、安装部署zabbix-3-4" class="headerlink" title="一、安装部署zabbix 3.4"></a>一、安装部署zabbix 3.4</h1><p><a href="https://baike.baidu.com/item/zabbix/6780368?fr=aladdin" target="_blank" rel="noopener">Zabbix</a> 是由 Alexei Vladishev 开发的一种网络监视、管理系统，基于 Server-Client 架构。可用于监视各种网络服务、服务器和网络机器等状态。</p><h2 id="1-zabbix基础说明"><a href="#1-zabbix基础说明" class="headerlink" title="1.zabbix基础说明"></a>1.zabbix基础说明</h2><h3 id="1-1-zabbix使用说明"><a href="#1-1-zabbix使用说明" class="headerlink" title="1.1  zabbix使用说明"></a>1.1  zabbix使用说明</h3><ul><li><p><a href="https://www.zabbix.com/documentation/3.4/zh/manual" target="_blank" rel="noopener">zabbix3.4软件中文使用手册</a></p></li><li><p><a href="http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/" target="_blank" rel="noopener">zabbix3.4版本安装包路径</a></p></li></ul><h3 id="1-2-zabbix-3-4版本说明"><a href="#1-2-zabbix-3-4版本说明" class="headerlink" title="1.2 zabbix 3.4版本说明"></a>1.2 zabbix 3.4版本说明</h3><p>Zabbix Server端安装的软件：</p><ul><li>zabbix-server-mysql</li><li>zabbix-get</li><li>mysql</li><li>zabbix-web</li><li>zabbix-web-mysql</li></ul><p>Zabbix Clinet 端安装的软件</p><ul><li>zabbix-agent</li><li>zabbix-sender</li></ul><h2 id="2-zabbix系统环境配置"><a href="#2-zabbix系统环境配置" class="headerlink" title="2.zabbix系统环境配置"></a>2.zabbix系统环境配置</h2><h3 id="2-1-系统环境"><a href="#2-1-系统环境" class="headerlink" title="2.1 系统环境"></a>2.1 系统环境</h3><pre><code># cat /etc/redhat-releaseCentOS Linux release 7.4.1708 (Core)</code></pre><h3 id="2-2-永久修改主机名"><a href="#2-2-永久修改主机名" class="headerlink" title="2.2 永久修改主机名"></a>2.2 永久修改主机名</h3><pre><code># hostnamectl --static set-hostname zabbix-server</code></pre><h3 id="2-3-关闭防火墙及selinux"><a href="#2-3-关闭防火墙及selinux" class="headerlink" title="2.3 关闭防火墙及selinux"></a>2.3 关闭防火墙及selinux</h3><pre><code># systemctl stop firewalld.service# systemctl daemon-reload# systemctl disable firewalld.service# sed -i &apos;s/SELINUX=enforcing/SELINUX=disabled/g&apos; /etc/selinux/config# grep SELINUX=disabled /etc/selinux/config# setenforce 0# getenforce  Disabled</code></pre><a id="more"></a><h2 id="3-数据库的安装与配置"><a href="#3-数据库的安装与配置" class="headerlink" title="3.数据库的安装与配置"></a>3.数据库的安装与配置</h2><h3 id="3-1-MariaDB概述"><a href="#3-1-MariaDB概述" class="headerlink" title="3.1 MariaDB概述"></a>3.1 MariaDB概述</h3><p>MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可。<br>开发这个分支的原因是：甲骨文公司收购了MySQL后，有将MySQL闭源的潜在风险，因此社区采用分支的方式来避开这个风险。MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。</p><h3 id="3-2-安装mariadb"><a href="#3-2-安装mariadb" class="headerlink" title="3.2 安装mariadb"></a>3.2 安装mariadb</h3><pre><code># yum install mariadb-server mariadb -y# rpm -qa |grep mariamariadb-5.5.56-2.el7.x86_64mariadb-server-5.5.56-2.el7.x86_64mariadb-libs-5.5.56-2.el7.x86_64</code></pre><h3 id="3-3-配置数据库服务"><a href="#3-3-配置数据库服务" class="headerlink" title="3.3 配置数据库服务"></a>3.3 配置数据库服务</h3><pre><code># vim /etc/my.cnf添加如下两行：innodb_file_per_table=onskip_name_resolve=on</code></pre><h3 id="3-4-启动mariadb数据库并设置开机自启动"><a href="#3-4-启动mariadb数据库并设置开机自启动" class="headerlink" title="3.4 启动mariadb数据库并设置开机自启动"></a>3.4 启动mariadb数据库并设置开机自启动</h3><pre><code># systemctl start mariadb# systemctl enable mariadb</code></pre><h3 id="3-5-设置mariadb数据库的安全配置"><a href="#3-5-设置mariadb数据库的安全配置" class="headerlink" title="3.5 设置mariadb数据库的安全配置"></a>3.5 设置mariadb数据库的安全配置</h3><pre><code># mysql_secure_installation  //根据需求设置密码password:test# mysql -uroot -ptest //登录mysql</code></pre><h3 id="3-6-创建数据库zabbix数据库并授权用户"><a href="#3-6-创建数据库zabbix数据库并授权用户" class="headerlink" title="3.6 创建数据库zabbix数据库并授权用户"></a>3.6 创建数据库zabbix数据库并授权用户</h3><p>创建zabbix数据库，并创建zbuser用户具有库的访问权限。</p><pre><code>&gt; CREATE DATABASE  zabbix  DEFAULT CHARACTER SET utf8 COLLATE utf8_bin;&gt; GRANT ALL PRIVILEGES ON zabbix.* TO zbuser@localhost IDENTIFIED BY &apos;test&apos;;&gt; FLUSH PRIVILEGES ;# mysql -uzbuser -ptest zabbix //登录测试</code></pre><h2 id="4-安装配置zabbix-3-4"><a href="#4-安装配置zabbix-3-4" class="headerlink" title="4.安装配置zabbix.3.4"></a>4.安装配置zabbix.3.4</h2><h3 id="4-1-zabbix相关软件包的安装"><a href="#4-1-zabbix相关软件包的安装" class="headerlink" title="4.1 zabbix相关软件包的安装"></a>4.1 zabbix相关软件包的安装</h3><h4 id="4-1-1-安装zabbix相关的yum源"><a href="#4-1-1-安装zabbix相关的yum源" class="headerlink" title="4.1.1 安装zabbix相关的yum源"></a>4.1.1 安装zabbix相关的yum源</h4><pre><code># rpm -ivh http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/zabbix-release-3.4-1.el7.centos.noarch.rpm</code></pre><h4 id="4-1-2-安装zabbix相关包"><a href="#4-1-2-安装zabbix相关包" class="headerlink" title="4.1.2 安装zabbix相关包"></a>4.1.2 安装zabbix相关包</h4><p>zabbix服务端需要安装：zabbix-server-mysql zabbix-web-mysql  zabbix-get<br>zabbix被监控主机端安装的软件：：zabbix-agent, zabbix-sender</p><pre><code># yum install zabbix-server-mysql zabbix-web-mysql zabbix-get zabbix-agent zabbix-sender -y# rpm -qa |grep zabbix zabbix-web-mysql-3.4.4-2.el7.noarch zabbix-get-3.4.4-2.el7.x86_64 zabbix-web-3.4.4-2.el7.noarch zabbix-agent-3.4.4-2.el7.x86_64 zabbix-release-3.4-1.el7.centos.noarch zabbix-server-mysql-3.4.4-2.el7.x86_64 zabbix-sender-3.4.4-2.el7.x86_64</code></pre><h3 id="4-2-zabbix相关数据导入数据库"><a href="#4-2-zabbix相关数据导入数据库" class="headerlink" title="4.2 zabbix相关数据导入数据库"></a>4.2 zabbix相关数据导入数据库</h3><pre><code># cd /usr/share/doc/zabbix-server-mysql-3.4.4/# zcat create.sql.gz |mysql -uzbuser -ptest zabbix</code></pre><h3 id="4-3-修改数据库相关配置"><a href="#4-3-修改数据库相关配置" class="headerlink" title="4.3 修改数据库相关配置"></a>4.3 修改数据库相关配置</h3><pre><code># vim /etc/zabbix/zabbix_server.conf# grep -n &apos;^&apos;[a-Z] /etc/zabbix/zabbix_server.conf38:LogFile=/var/log/zabbix/zabbix_server.log49:LogFileSize=072:PidFile=/var/run/zabbix/zabbix_server.pid82:SocketDir=/var/run/zabbix91:DBHost=localhost101:DBName=zabbix117:DBUser=zbuser125:DBPassword=test132:DBSocket=/var/lib/mysql/mysql.sock316:SNMPTrapperFile=/var/log/snmptrap/snmptrap.log434:Timeout=4476:AlertScriptsPath=/usr/lib/zabbix/alertscripts486:ExternalScripts=/usr/lib/zabbix/externalscripts522:LogSlowQueries=3000</code></pre><h3 id="4-4-启动zabbix-server并设置开机启动"><a href="#4-4-启动zabbix-server并设置开机启动" class="headerlink" title="4.4 启动zabbix server并设置开机启动"></a>4.4 启动zabbix server并设置开机启动</h3><pre><code># systemctl enable zabbix-server# systemctl start zabbix-server</code></pre><h3 id="4-5-编辑Zabbix前端PHP配置-更改时区"><a href="#4-5-编辑Zabbix前端PHP配置-更改时区" class="headerlink" title="4.5 编辑Zabbix前端PHP配置,更改时区"></a>4.5 编辑Zabbix前端PHP配置,更改时区</h3><pre><code># vim /etc/httpd/conf.d/zabbix.confphp_value date.timezone Asia/Shanghaiphp_value date.timezone Asia/Shanghai</code></pre><h3 id="4-6-启动httpd并设置开机启动"><a href="#4-6-启动httpd并设置开机启动" class="headerlink" title="4.6 启动httpd并设置开机启动"></a>4.6 启动httpd并设置开机启动</h3><pre><code># systemctl start httpd# systemctl enable httpd</code></pre><h3 id="4-7-图形界面安装配置zabbix"><a href="#4-7-图形界面安装配置zabbix" class="headerlink" title="4.7 图形界面安装配置zabbix"></a>4.7 图形界面安装配置zabbix</h3><p>浏览器输入<a href="http://server_ip/zabbix,根据图形引导信息,配置zabbix信息。" target="_blank" rel="noopener">http://server_ip/zabbix,根据图形引导信息,配置zabbix信息。</a></p><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/nggAUz" alt="1"></p><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/TUgNnW" alt="2"></p><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/0742rj" alt="3"></p><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/Iv6t7z" alt="4"></p><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/VNlpQC" alt="5"></p><p><strong>zabbix初始登录账户和密码为： Admin  zabbix</strong></p><h2 id="5-zabbxi-agent安装及配置"><a href="#5-zabbxi-agent安装及配置" class="headerlink" title="5.zabbxi-agent安装及配置"></a>5.zabbxi-agent安装及配置</h2><h3 id="5-1-安装zabbxi-agent"><a href="#5-1-安装zabbxi-agent" class="headerlink" title="5.1 安装zabbxi-agent"></a>5.1 安装zabbxi-agent</h3><pre><code># yum install zabbix-agent  zabbix-sender -y# grep -n &apos;^&apos;[a-Z] /etc/zabbix/zabbix_agentd.conf 13:PidFile=/var/run/zabbix/zabbix_agentd.pid 32:LogFile=/var/log/zabbix/zabbix_agentd.log 43:LogFileSize=0 95:Server=127.0.0.1 136:ServerActive=127.0.0.1 147:Hostname=zabbix-server 265:Include=/etc/zabbix/zabbix_agentd.d/*.conf</code></pre><p>Server：被动模式，允许哪台服务器连接Agent。<br>ServerActive：主动模式，向哪台服务器传送数据。</p><h3 id="5-2-启动zabbix-agent"><a href="#5-2-启动zabbix-agent" class="headerlink" title="5.2 启动zabbix-agent"></a>5.2 启动zabbix-agent</h3><pre><code># systemctl start zabbix-agent# systemctl enable zabbix-agent</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、安装部署zabbix-3-4&quot;&gt;&lt;a href=&quot;#一、安装部署zabbix-3-4&quot; class=&quot;headerlink&quot; title=&quot;一、安装部署zabbix 3.4&quot;&gt;&lt;/a&gt;一、安装部署zabbix 3.4&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/zabbix/6780368?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Zabbix&lt;/a&gt; 是由 Alexei Vladishev 开发的一种网络监视、管理系统，基于 Server-Client 架构。可用于监视各种网络服务、服务器和网络机器等状态。&lt;/p&gt;
&lt;h2 id=&quot;1-zabbix基础说明&quot;&gt;&lt;a href=&quot;#1-zabbix基础说明&quot; class=&quot;headerlink&quot; title=&quot;1.zabbix基础说明&quot;&gt;&lt;/a&gt;1.zabbix基础说明&lt;/h2&gt;&lt;h3 id=&quot;1-1-zabbix使用说明&quot;&gt;&lt;a href=&quot;#1-1-zabbix使用说明&quot; class=&quot;headerlink&quot; title=&quot;1.1  zabbix使用说明&quot;&gt;&lt;/a&gt;1.1  zabbix使用说明&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.zabbix.com/documentation/3.4/zh/manual&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;zabbix3.4软件中文使用手册&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;zabbix3.4版本安装包路径&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-2-zabbix-3-4版本说明&quot;&gt;&lt;a href=&quot;#1-2-zabbix-3-4版本说明&quot; class=&quot;headerlink&quot; title=&quot;1.2 zabbix 3.4版本说明&quot;&gt;&lt;/a&gt;1.2 zabbix 3.4版本说明&lt;/h3&gt;&lt;p&gt;Zabbix Server端安装的软件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;zabbix-server-mysql&lt;/li&gt;
&lt;li&gt;zabbix-get&lt;/li&gt;
&lt;li&gt;mysql&lt;/li&gt;
&lt;li&gt;zabbix-web&lt;/li&gt;
&lt;li&gt;zabbix-web-mysql&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Zabbix Clinet 端安装的软件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;zabbix-agent&lt;/li&gt;
&lt;li&gt;zabbix-sender&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-zabbix系统环境配置&quot;&gt;&lt;a href=&quot;#2-zabbix系统环境配置&quot; class=&quot;headerlink&quot; title=&quot;2.zabbix系统环境配置&quot;&gt;&lt;/a&gt;2.zabbix系统环境配置&lt;/h2&gt;&lt;h3 id=&quot;2-1-系统环境&quot;&gt;&lt;a href=&quot;#2-1-系统环境&quot; class=&quot;headerlink&quot; title=&quot;2.1 系统环境&quot;&gt;&lt;/a&gt;2.1 系统环境&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;# cat /etc/redhat-release
CentOS Linux release 7.4.1708 (Core)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;2-2-永久修改主机名&quot;&gt;&lt;a href=&quot;#2-2-永久修改主机名&quot; class=&quot;headerlink&quot; title=&quot;2.2 永久修改主机名&quot;&gt;&lt;/a&gt;2.2 永久修改主机名&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;# hostnamectl --static set-hostname zabbix-server
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;2-3-关闭防火墙及selinux&quot;&gt;&lt;a href=&quot;#2-3-关闭防火墙及selinux&quot; class=&quot;headerlink&quot; title=&quot;2.3 关闭防火墙及selinux&quot;&gt;&lt;/a&gt;2.3 关闭防火墙及selinux&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;# systemctl stop firewalld.service
# systemctl daemon-reload
# systemctl disable firewalld.service

# sed -i &amp;apos;s/SELINUX=enforcing/SELINUX=disabled/g&amp;apos; /etc/selinux/config
# grep SELINUX=disabled /etc/selinux/config
# setenforce 0
# getenforce
  Disabled
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Linux服务" scheme="http://www.chenfanlinux.org/categories/Linux%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="Zabbix" scheme="http://www.chenfanlinux.org/tags/Zabbix/"/>
    
  </entry>
  
  <entry>
    <title>hexo安装与介绍</title>
    <link href="http://www.chenfanlinux.org/2017/12/04/my-first-article/"/>
    <id>http://www.chenfanlinux.org/2017/12/04/my-first-article/</id>
    <published>2017-12-04T03:05:54.000Z</published>
    <updated>2018-01-10T07:39:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo 是高效的静态站点生成框架，她基于 Node.js。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 <a href="https://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a> 本身的语法之外，还可以使用 Hexo 提供的 标签插件 来快速的插入特定形式的内容。在这篇文章中，假定你已经成功安装了 Hexo，并使用 Hexo 提供的命令创建了一个站点。</p><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><h3 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h3><p>安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序：</p><ul><li><p><a href="https://nodejs.org/dist/v8.9.1/node-v8.9.1-x64.msi" target="_blank" rel="noopener">Node.js</a></p></li><li><p><a href="https://git-for-windows.github.io" target="_blank" rel="noopener">Git</a></p></li></ul><blockquote><p>安装git时候，由于众所周知的原因，从上面的链接下载git for windows最好挂上一个代理，否则下载速度十分缓慢。也可以参考<a href="https://github.com/waylau/git-for-win" target="_blank" rel="noopener">这个页面</a>，收录了存储于百度云的下载地址。</p></blockquote><h3 id="开始安装hexo"><a href="#开始安装hexo" class="headerlink" title="开始安装hexo"></a>开始安装hexo</h3><p>windows上安装所有必备的应用程序安装完成后，打开Git Bash命令行模式，即可使用 npm 安装 Hexo。</p><pre><code>$ cd F:\$ mkdir blog //windows下创建博客目录$ npm install -g hexo-cli    //安装hexo基础包</code></pre><h3 id="建立静态站点"><a href="#建立静态站点" class="headerlink" title="建立静态站点"></a>建立静态站点</h3><p>使用hexo建站非常的方便快捷，迅速就能在本地建立一个静态站点。安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><pre><code>$ hexo init blog  //初始化博客目录$ cd blog$ npm install    //开始安装</code></pre><p>新建完成后，指定文件夹的目录如下：</p><pre><code>.├── _config.yml  //站点配置文件├── package.json //应用程序信息├── scaffolds   //模版文件夹├── source      //资源文件夹 |   ├── _drafts|   └── _posts└── themes     //主题文件夹</code></pre><h3 id="hexo基础命令介绍"><a href="#hexo基础命令介绍" class="headerlink" title="hexo基础命令介绍"></a>hexo基础命令介绍</h3><p>hexo有一些常用的指令，明确这些指令的用途和方法，方便我们更高效的管理和构建炫酷的静态网站。</p><ul><li>init </li><li>new</li><li>generate</li><li>publish</li><li>server</li><li>deploy</li><li>clean</li><li>list</li></ul><h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><pre><code>$ hexo init [folder]</code></pre><p>新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。</p><h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><pre><code>$ hexo new [layout] &lt;title&gt;$ hexo new &quot;postName&quot; //新建文章$ hexo new page &quot;pageName&quot; //新建页面</code></pre><p>新建一篇文章。如果没有设置 layout 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">_config.yml</a> 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</p><h4 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h4><pre><code>$ hexo clean</code></pre><p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。<br>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h4 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h4><pre><code>$ hexo generate   //或者使用 hexo g </code></pre><a id="more"></a><p>生成静态文件,每次我们修改完一些配置后,可以使用hexo clean清理一下历史数据,然后再hexo g生成静态文件。</p><h4 id="server"><a href="#server" class="headerlink" title="server"></a>server</h4><p>启动服务器。默认情况下，访问网址为  <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 。</p><pre><code>$ hexo server</code></pre><blockquote><p>选项<br>描述<br>-p      重设端口<br>-s      只使用静态文件<br>-l  启动日记记录，使用覆盖记录格式 </p></blockquote><h4 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h4><p>部署网站,将本地网站推送到远程仓库。</p><pre><code>$ hexo deploy</code></pre><blockquote><p>参数<br>描述<br>-g, –generate    部署之前预先生成静态文件</p></blockquote><p>该命令可以简写为：</p><pre><code>$ hexo d</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hexo 是高效的静态站点生成框架，她基于 Node.js。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 &lt;a href=&quot;https://daringfireball.net/projects/markdown/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Markdown&lt;/a&gt; 本身的语法之外，还可以使用 Hexo 提供的 标签插件 来快速的插入特定形式的内容。在这篇文章中，假定你已经成功安装了 Hexo，并使用 Hexo 提供的命令创建了一个站点。&lt;/p&gt;
&lt;h2 id=&quot;安装hexo&quot;&gt;&lt;a href=&quot;#安装hexo&quot; class=&quot;headerlink&quot; title=&quot;安装hexo&quot;&gt;&lt;/a&gt;安装hexo&lt;/h2&gt;&lt;h3 id=&quot;安装前提&quot;&gt;&lt;a href=&quot;#安装前提&quot; class=&quot;headerlink&quot; title=&quot;安装前提&quot;&gt;&lt;/a&gt;安装前提&lt;/h3&gt;&lt;p&gt;安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://nodejs.org/dist/v8.9.1/node-v8.9.1-x64.msi&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Node.js&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://git-for-windows.github.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Git&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;安装git时候，由于众所周知的原因，从上面的链接下载git for windows最好挂上一个代理，否则下载速度十分缓慢。也可以参考&lt;a href=&quot;https://github.com/waylau/git-for-win&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这个页面&lt;/a&gt;，收录了存储于百度云的下载地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;开始安装hexo&quot;&gt;&lt;a href=&quot;#开始安装hexo&quot; class=&quot;headerlink&quot; title=&quot;开始安装hexo&quot;&gt;&lt;/a&gt;开始安装hexo&lt;/h3&gt;&lt;p&gt;windows上安装所有必备的应用程序安装完成后，打开Git Bash命令行模式，即可使用 npm 安装 Hexo。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd F:\
$ mkdir blog //windows下创建博客目录
$ npm install -g hexo-cli    //安装hexo基础包
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;建立静态站点&quot;&gt;&lt;a href=&quot;#建立静态站点&quot; class=&quot;headerlink&quot; title=&quot;建立静态站点&quot;&gt;&lt;/a&gt;建立静态站点&lt;/h3&gt;&lt;p&gt;使用hexo建站非常的方便快捷，迅速就能在本地建立一个静态站点。安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ hexo init blog  //初始化博客目录
$ cd blog
$ npm install    //开始安装
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;新建完成后，指定文件夹的目录如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.
├── _config.yml  //站点配置文件
├── package.json //应用程序信息
├── scaffolds   //模版文件夹
├── source      //资源文件夹 
|   ├── _drafts
|   └── _posts
└── themes     //主题文件夹
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;hexo基础命令介绍&quot;&gt;&lt;a href=&quot;#hexo基础命令介绍&quot; class=&quot;headerlink&quot; title=&quot;hexo基础命令介绍&quot;&gt;&lt;/a&gt;hexo基础命令介绍&lt;/h3&gt;&lt;p&gt;hexo有一些常用的指令，明确这些指令的用途和方法，方便我们更高效的管理和构建炫酷的静态网站。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;init &lt;/li&gt;
&lt;li&gt;new&lt;/li&gt;
&lt;li&gt;generate&lt;/li&gt;
&lt;li&gt;publish&lt;/li&gt;
&lt;li&gt;server&lt;/li&gt;
&lt;li&gt;deploy&lt;/li&gt;
&lt;li&gt;clean&lt;/li&gt;
&lt;li&gt;list&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;init&quot;&gt;&lt;a href=&quot;#init&quot; class=&quot;headerlink&quot; title=&quot;init&quot;&gt;&lt;/a&gt;init&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;$ hexo init [folder]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。&lt;/p&gt;
&lt;h4 id=&quot;new&quot;&gt;&lt;a href=&quot;#new&quot; class=&quot;headerlink&quot; title=&quot;new&quot;&gt;&lt;/a&gt;new&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;$ hexo new [layout] &amp;lt;title&amp;gt;
$ hexo new &amp;quot;postName&amp;quot; //新建文章
$ hexo new page &amp;quot;pageName&amp;quot; //新建页面
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;新建一篇文章。如果没有设置 layout 的话，默认使用 &lt;a href=&quot;https://hexo.io/zh-cn/docs/configuration.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;_config.yml&lt;/a&gt; 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。&lt;/p&gt;
&lt;h4 id=&quot;clean&quot;&gt;&lt;a href=&quot;#clean&quot; class=&quot;headerlink&quot; title=&quot;clean&quot;&gt;&lt;/a&gt;clean&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;$ hexo clean
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;清除缓存文件 (db.json) 和已生成的静态文件 (public)。&lt;br&gt;在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。&lt;/p&gt;
&lt;h4 id=&quot;generate&quot;&gt;&lt;a href=&quot;#generate&quot; class=&quot;headerlink&quot; title=&quot;generate&quot;&gt;&lt;/a&gt;generate&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;$ hexo generate   //或者使用 hexo g 
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://www.chenfanlinux.org/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://www.chenfanlinux.org/tags/Hexo/"/>
    
  </entry>
  
</feed>
