<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陈凡的个人站点</title>
  
  <subtitle>chenfanlinux.org</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.chenfanlinux.org/"/>
  <updated>2018-02-23T08:51:54.000Z</updated>
  <id>http://www.chenfanlinux.org/</id>
  
  <author>
    <name>陈凡</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python基础之迭代器和生成器</title>
    <link href="http://www.chenfanlinux.org/2018/02/23/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://www.chenfanlinux.org/2018/02/23/Python基础之迭代器和生成器/</id>
    <published>2018-02-23T08:49:36.000Z</published>
    <updated>2018-02-23T08:51:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><blockquote><p>迭代器是一个可以记住遍历的位置的对象。迭代器对象要求支持迭代器协议的对象，在Python中，支持迭代器协议就是实现对象的iter()和next()方法。其中iter()方法返回迭代器对象本身；next()方法返回容器的下一个元素，在结尾时引发StopIteration异常。</p></blockquote><h3 id="可迭代对象-Iterable"><a href="#可迭代对象-Iterable" class="headerlink" title="可迭代对象: Iterable"></a>可迭代对象: Iterable</h3><p>在Python中，很多对象都是可以通过for语句来直接遍历的数据类型有以下几种:</p><ul><li>一类是集合数据类型，如list、tuple、dict、set、str等；</li><li>一类是generator，包括生成器和带yield的generator function 。</li></ul><p>这些可以直接作用于for循环的对象统称为可迭代对象：Iterable，可以使用isinstance()判断一个对象是否是Iterable对象:</p><pre><code>&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance([], Iterable)True&gt;&gt;&gt; isinstance({}, Iterable)True&gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterable)True&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable)True&gt;&gt;&gt; isinstance(100, Iterable)False</code></pre><a id="more"></a><h3 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器: Iterator"></a>迭代器: Iterator</h3><blockquote><p>可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。迭代器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。</p></blockquote><p>迭代器有两个基本的方法：</p><pre><code>__iter__()和next()方法</code></pre><p>可以使用isinstance()判断一个对象是否是Iterator对象：</p><pre><code>&gt;&gt;&gt; from collections import Iterator&gt;&gt;&gt;&gt;&gt;&gt; isinstance((x for x in range(10)), Iterator)True&gt;&gt;&gt; isinstance([], Iterator)False&gt;&gt;&gt; isinstance({}, Iterator)False&gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterator)False&gt;&gt;&gt;</code></pre><p><strong><em>生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。</em></strong></p><p>把list、dict、str等Iterable变成Iterator可以使用iter()函数：</p><pre><code>&gt;&gt;&gt; isinstance(iter([]), Iterator)True&gt;&gt;&gt; isinstance(iter(&apos;abc&apos;), Iterator)True</code></pre><p>你可能会问，为什么list、dict、str等数据类型不是Iterator？</p><p>这是因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。</p><p>Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。</p><h3 id="迭代器小结"><a href="#迭代器小结" class="headerlink" title="迭代器小结"></a>迭代器小结</h3><ul><li>凡是可作用于for循环的对象都是Iterable类型；</li><li>凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；</li><li>集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。</li><li>Python的for语句就会自动的通过iter()方法来获得迭代器对象，并且通过next()方法来获取下一个元素。</li></ul><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><blockquote><p>生成器是用来创建 Python 序列的一个对象。使用它可以迭代庞大的序列，且不需要再内存中创建和存储整个序列，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。</p></blockquote><h3 id="创建生成器"><a href="#创建生成器" class="headerlink" title="创建生成器"></a>创建生成器</h3><p>要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：</p><pre><code>&gt;&gt;&gt; L = [ x * x for x in range(10)]&gt;&gt;&gt; L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x0000000003541BA0&gt;</code></pre><p>如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值：</p><pre><code>&gt;&gt;&gt; next(g)0&gt;&gt;&gt; next(g)1&gt;&gt;&gt; next(g)4&gt;&gt;&gt; next(g)9&gt;&gt;&gt; next(g)16&gt;&gt;&gt; next(g)25&gt;&gt;&gt; next(g)36&gt;&gt;&gt; next(g)49&gt;&gt;&gt; next(g)64&gt;&gt;&gt; next(g)81&gt;&gt;&gt; next(g)Traceback (most recent call last):  File &quot;&lt;pyshell#27&gt;&quot;, line 1, in &lt;module&gt;    next(g)StopIteration</code></pre><p>generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。</p><p>当然，上面这种不断调用next(g)实在是太变态了，正确的方法是使用for循环，因为generator也是可迭代对象：</p><pre><code>&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; for n in g:    print(n)0149162536496481</code></pre><p>所以，我们创建了一个generator后，基本上永远不会调用next()，而是通过for循环来迭代它，并且不需要关心StopIteration的错误。</p><h3 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h3><blockquote><p>每次迭代生成器，它会记录上一次调用的位置，并且返回下一个值。这一点和普通的函数是不一样的，一般函数都不记录之前一次调用，而且都会在函数的第一行开始执行。</p></blockquote><p>如果你想创建一个比较大的序列，使用生成器推导的代码会很长，这是可以尝试写一个生成器函数。生成器函数和普通函数类似，但是它的返回值使用 yield 语句声明, 不是 return。下面编写我们自己的 range() 函数版本：</p><pre><code>&gt;&gt;&gt; def my_range(first=0, last=10, step=1):    number = first    while number &lt; last:        yield number        number += step</code></pre><p>这是一个普通的函数：</p><pre><code>&gt;&gt;&gt; my_range&lt;function my_range at 0x00000000035FC158&gt;</code></pre><p>并且它返回的是一个生成器对象:</p><pre><code>&gt;&gt;&gt; ranger = my_range(1, 5)&gt;&gt;&gt; ranger&lt;generator object my_range at 0x00000000035F1C50&gt;</code></pre><p>可以对这个生成器对象进行迭代：</p><pre><code>&gt;&gt;&gt; for x in ranger:    print(x)1234</code></pre><p><strong><em>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回yield的值。并在下一次执行 next()方法时从当前位置继续运行。</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;迭代器&quot;&gt;&lt;a href=&quot;#迭代器&quot; class=&quot;headerlink&quot; title=&quot;迭代器&quot;&gt;&lt;/a&gt;迭代器&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;迭代器是一个可以记住遍历的位置的对象。迭代器对象要求支持迭代器协议的对象，在Python中，支持迭代器协议就是实现对象的iter()和next()方法。其中iter()方法返回迭代器对象本身；next()方法返回容器的下一个元素，在结尾时引发StopIteration异常。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;可迭代对象-Iterable&quot;&gt;&lt;a href=&quot;#可迭代对象-Iterable&quot; class=&quot;headerlink&quot; title=&quot;可迭代对象: Iterable&quot;&gt;&lt;/a&gt;可迭代对象: Iterable&lt;/h3&gt;&lt;p&gt;在Python中，很多对象都是可以通过for语句来直接遍历的数据类型有以下几种:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一类是集合数据类型，如list、tuple、dict、set、str等；&lt;/li&gt;
&lt;li&gt;一类是generator，包括生成器和带yield的generator function 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些可以直接作用于for循环的对象统称为可迭代对象：Iterable，可以使用isinstance()判断一个对象是否是Iterable对象:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from collections import Iterable
&amp;gt;&amp;gt;&amp;gt; isinstance([], Iterable)
True
&amp;gt;&amp;gt;&amp;gt; isinstance({}, Iterable)
True
&amp;gt;&amp;gt;&amp;gt; isinstance(&amp;apos;abc&amp;apos;, Iterable)
True

&amp;gt;&amp;gt;&amp;gt; isinstance((x for x in range(10)), Iterable)
True
&amp;gt;&amp;gt;&amp;gt; isinstance(100, Iterable)
False
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="python基础知识" scheme="http://www.chenfanlinux.org/categories/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Python" scheme="http://www.chenfanlinux.org/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python基础之函数与模块</title>
    <link href="http://www.chenfanlinux.org/2018/02/23/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0%E4%B8%8E%E6%A8%A1%E5%9D%97/"/>
    <id>http://www.chenfanlinux.org/2018/02/23/Python基础之函数与模块/</id>
    <published>2018-02-23T04:15:11.000Z</published>
    <updated>2018-02-23T04:20:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><blockquote><p>代码复用的第一步是使用函数，它是命名的用于区分的代码段。函数可以接受任何数字或者其他类型的输入作为参数，并且返回数字或者其他类型的结果。函数是Python为了代码最大程度的重用和最小化代码冗余而提供的最基本的程序结构。</p></blockquote><h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><p>在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:；然后在缩进块中编写函数体，函数的返回值用return语句返回。</p><pre><code>def 函数名(参数):    ...    函数体    ...    返回值</code></pre><h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><p>函数的返回值需要使用到return这个关键字，返回值主要是用来接受函数的执行结果。</p><pre><code>&gt;&gt;&gt; def re():    if 1 == 1:        return True    else:        return False&gt;&gt;&gt; re()True</code></pre><p>函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕；如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。</p><a id="more"></a><h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><blockquote><p>定义函数的时候，我们把参数的名字和位置确定下来，函数的接口定义就完成了。对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值就够了，函数内部的复杂逻辑被封装起来，调用者无需了解。</p></blockquote><h4 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h4><p>Python 处理参数的方式要比其他语言更加灵活。其中，最熟悉的参数类型是位置参数，传入参数的值必须按照顺序依次复制过去的。</p><pre><code>// n1, n2, n3是形参&gt;&gt;&gt; def name (n1, n2, n3):    print(&apos;1&apos;, n1)    print(&apos;2&apos;, n2)    print(&apos;3&apos;, n3)// 老大, 老二, 老三是实参&gt;&gt;&gt; name(&apos;老大&apos;, &apos;老二&apos;, &apos;老三&apos;)1 老大2 老二3 老三</code></pre><p>尽管这种方式很常见，但是位置参数的一个弊端是必须熟记没个位置的参数的含义。在调用函数name() 时误把最后一个参数当做第一个参数，会得到完全不同的结果：</p><pre><code>&gt;&gt;&gt; name(&apos;老三&apos;,&apos;老大&apos;,&apos;老二&apos;)1 老三2 老大3 老二</code></pre><h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>为了避免位置参数带来的混乱，调用参数时可以指定对应的名字，甚至可以采用与函数定义不同的顺序调用，<strong><em>关键字参数需要在位置参数之后。</em></strong></p><pre><code>&gt;&gt;&gt; name(n2=&apos;老二&apos;, n1=&apos;老大&apos;, n3=&apos;老三&apos;)1 老大2 老二3 老三</code></pre><p>你也可以把位置参数和关键字参数混合起来:</p><pre><code>&gt;&gt;&gt; name(&apos;老大&apos;, n2=&apos;老二&apos;, n3=&apos;老三&apos;)1 老大2 老二3 老三</code></pre><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p><strong>当调用方没有提供对应的参数值时，你可以指定默认参数值。</strong></p><pre><code>&gt;&gt;&gt; def name(n2, n3, n1=&apos;老大&apos;):    print(&apos;1&apos;, n1)    print(&apos;2&apos;, n2)    print(&apos;3&apos;, n3)&gt;&gt;&gt; name(&apos;老二&apos;, &apos;老三&apos;)1 老大2 老二3 老三</code></pre><p><strong><em>默认参数可以简化函数的调用,设置默认参数时,有几点要注意:</em></strong></p><ul><li>一是必选参数在前，默认参数在后，否则Python的解释器会报错。</li><li>当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。</li><li>定义默认参数要牢记一点：默认参数必须指向不变对象！</li></ul><p>默认参数值在函数被定义时已经计算出来，而不是在程序运行时。Python程序员经常犯的一个错误是把可变的数据类型（例如列表或者字典）当做默认参数值。Python函数在定义的时候，默认参数result的值就被计算出来了，即[]，因为默认参数result也是一个变量，它指向对象[]，每次调用该函数，如果改变了result的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。</p><pre><code>&gt;&gt;&gt; def box(arg, result=[]):    result.append(arg)    print(result)&gt;&gt;&gt; box(&apos;a&apos;)[&apos;a&apos;]&gt;&gt;&gt; box(&apos;b&apos;)[&apos;a&apos;, &apos;b&apos;]</code></pre><p>如果写成下面的样子就会解决刚才的问题：</p><pre><code>&gt;&gt;&gt; def box(arg):    result = []    result.append(arg)    return result&gt;&gt;&gt; box(&apos;a&apos;)[&apos;a&apos;]&gt;&gt;&gt; box(&apos;b&apos;)[&apos;b&apos;]</code></pre><p>这样的修改也是为了表明第一次调用跳过一些操作：</p><pre><code>&gt;&gt;&gt; def box(arg, result=None):    if result is None:        result = []    result.append(arg)    print(result)&gt;&gt;&gt; box(&apos;a&apos;)[&apos;a&apos;]&gt;&gt;&gt; box(&apos;b&apos;)[&apos;b&apos;]</code></pre><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p><strong>若你的函数在定义时不确定用户想传入多少个参数，就可以使用可变参数。</strong></p><pre><code>&gt;&gt;&gt; def stu_register(name, age, *args): # *args 会把多传入的参数变成一个元组形式    print(name, age , args)&gt;&gt;&gt; stu_register(&quot;chenfanlinux&quot;, 23)chenfanlinux 23 () # 后面这个()就是args,只是因为没传值,所以为空&gt;&gt;&gt; stu_register(&quot;chenfanlinux&quot;, 30, &quot;CN&quot;, &quot;Python&quot;)chenfanlinux 30 (&apos;CN&apos;, &apos;Python&apos;)  # 后面传入的参数会被当做一个元组</code></pre><p>还可以有一个 **kwargs</p><pre><code>&gt;&gt;&gt; def stu_register(name, age, *args, **kwargs):    print(name, age, args, kwargs)&gt;&gt;&gt; stu_register(&quot;chenfan&quot;, 22)chenfan 22 () {}    # 后面这个{}就是kwargs,只是因为没传值,所以为空&gt;&gt;&gt; stu_register(&quot;chenfan&quot;, 22, &quot;CN&quot;, &quot;Python&quot;, sex=&quot;Male&quot;, province=&quot;guangzhou&quot;)chenfan 22 (&apos;CN&apos;, &apos;Python&apos;) {&apos;province&apos;: &apos;guangzhou&apos;, &apos;sex&apos;: &apos;Male&apos;}</code></pre><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a><a href="http://www.cnblogs.com/wupeiqi/articles/4963027.html" target="_blank" rel="noopener">模块</a></h2><p>在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。<br>为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。<strong><em>在Python中，一个.py文件就称之为一个模块（Module）。</em></strong></p><h3 id="使用模块的好处"><a href="#使用模块的好处" class="headerlink" title="使用模块的好处"></a>使用模块的好处</h3><ul><li>最大的好处是大大提高了代码的可维护性。</li><li>编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。</li><li>相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。</li><li>如果不同的人编写的模块名相同怎么办？为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package）。</li></ul><h3 id="模块与包"><a href="#模块与包" class="headerlink" title="模块与包"></a>模块与包</h3><p>举个例子，一个 <strong><em>abc.py</em></strong> 的文件就是一个名字叫 <strong><em>abc</em></strong> 的模块，一个 <strong><em>xyz.py</em></strong> 的文件就一个名字叫 <strong><em>xyz</em></strong> 的模块。</p><p>现在，假设我们的 <strong><em>abc</em></strong> 和 <strong><em>xyz</em></strong> 这两个模块名字与其他模块冲突了，于是我们可以通过包来组织模块，避免冲突。方法是选择一个顶层包名，比如<strong><em>mycompany</em></strong>，按照如下目录存放：</p><pre><code>mycompany # 包名├─ __init__.py├─ abc.py # 模块名└─ xyz.py</code></pre><p>引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。现在，<strong><em>abc.py</em></strong> 模块的名字就变成了 <strong><em>mycompany.abc</em></strong>，<strong><em>xyz.py</em></strong> 的模块名变成了 <strong><em>mycompany.xyz</em></strong>。</p><p>请注意，每一个包目录下面都会有一个 __init__.py 的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。__init__.py可以是空文件，也可以有Python代码，因为__init__.py本身就是一个模块，而它的模块名就是文件夹名mycompany。</p><p>类似的，可以有多级目录，组成多级层次的包结构。比如如下的目录结构：</p><pre><code>mycompany ├─ web │  ├─ __init__.py │  ├─ utils.py │  └─ www.py ├─ __init__.py ├─ abc.py └─ xyz.py</code></pre><p>文件www.py的模块名就是mycompany.web.www 。</p><blockquote><p>自己创建模块时要注意命名，不能和Python自带的模块名称冲突。例如，系统自带了sys模块，自己的模块就不可命名为sys.py，否则将无法导入系统自带的sys模块。</p></blockquote><h3 id="模块的导入"><a href="#模块的导入" class="headerlink" title="模块的导入"></a>模块的导入</h3><p>导入模块有一下几种方法：</p><ul><li>import module</li><li>from module.xx.xx import xx</li><li>from module.xx.xx import xx as rename</li><li>from module.xx.xx import *</li></ul><p>导入模块其实就是告诉Python解释器去解释那个py文件</p><ul><li>导入一个py文件，解释器解释该py文件</li><li>导入一个包，解释器解释该包下的 __init__.py 文件</li></ul><p>那么问题来了，导入模块时是根据那个路径作为基准来进行的呢？即：sys.path</p><pre><code>&gt;&gt;&gt; import sys&gt;&gt;&gt; print(sys.path)[&apos;&apos;, &apos;F:\\Python35\\Lib\\idlelib&apos;, &apos;F:\\Python35\\python35.zip&apos;, &apos;F:\\Python35\\DLLs&apos;, &apos;F:\\Python35\\lib&apos;, &apos;F:\\Python35&apos;, &apos;F:\\Python35\\lib\\site-packages&apos;]</code></pre><p>如果sys.path路径列表没有你想要的路径，可以通过 sys.path.append(‘路径’) 添加。</p><pre><code>import sysimport ospre_path = os.path.abspath(&apos;../&apos;)sys.path.append(pre_path)</code></pre><h3 id="模块总结"><a href="#模块总结" class="headerlink" title="模块总结"></a>模块总结</h3><p>模块是一组Python代码的集合，可以使用其他模块，也可以被其他模块使用。</p><p>创建自己的模块时，要注意：</p><ul><li>模块名要遵循Python变量命名规范，不要使用中文、特殊字符；</li><li>模块名不要和系统模块名冲突，最好先查看系统是否已存在该模块，检查方法是在Python交互环境执行import abc，若成功则说明系统存在此模块。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;代码复用的第一步是使用函数，它是命名的用于区分的代码段。函数可以接受任何数字或者其他类型的输入作为参数，并且返回数字或者其他类型的结果。函数是Python为了代码最大程度的重用和最小化代码冗余而提供的最基本的程序结构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;函数的定义&quot;&gt;&lt;a href=&quot;#函数的定义&quot; class=&quot;headerlink&quot; title=&quot;函数的定义&quot;&gt;&lt;/a&gt;函数的定义&lt;/h3&gt;&lt;p&gt;在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:；然后在缩进块中编写函数体，函数的返回值用return语句返回。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def 函数名(参数):
    ...
    函数体
    ...
    返回值
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;函数的返回值&quot;&gt;&lt;a href=&quot;#函数的返回值&quot; class=&quot;headerlink&quot; title=&quot;函数的返回值&quot;&gt;&lt;/a&gt;函数的返回值&lt;/h3&gt;&lt;p&gt;函数的返回值需要使用到return这个关键字，返回值主要是用来接受函数的执行结果。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def re():
    if 1 == 1:
        return True
    else:
        return False


&amp;gt;&amp;gt;&amp;gt; re()
True
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕；如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。&lt;/p&gt;
    
    </summary>
    
      <category term="python基础知识" scheme="http://www.chenfanlinux.org/categories/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Python" scheme="http://www.chenfanlinux.org/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python基础之文件与异常</title>
    <link href="http://www.chenfanlinux.org/2018/02/22/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BC%82%E5%B8%B8/"/>
    <id>http://www.chenfanlinux.org/2018/02/22/Python基础之文件与异常/</id>
    <published>2018-02-22T08:41:24.000Z</published>
    <updated>2018-02-22T08:42:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><blockquote><p>数据持久化最简单的类型是普通文件,它仅仅是在一个文件名下的字节流，把数据从一个文件读入内存，然后从内存写入文件。</p></blockquote><h3 id="文件操作模型"><a href="#文件操作模型" class="headerlink" title="文件操作模型"></a>文件操作模型</h3><pre><code>data = open(filename, mode)</code></pre><p>下面是对该 open() 调用的简单解释：</p><ul><li>data 是 open() 返回的文件对象</li><li>filename 是该文件的字符串名</li><li>mode 是指明文件类型和操作的字符串</li></ul><p>mode 的第一个字母表明对其的操作：</p><ul><li>r 以只读方式打开文件。文件的指针将会放在文件的开头，这是默认模式。</li><li>r+ 可读可写，不会创建不存在的文件。如果直接写文件，则从顶部开始写，覆盖之前此位置的内容，如果先读后写，则会在文件最后追加内容。</li><li>w 表示写模式。若果文件不存在则新创建，如果该文件已存在则将其覆盖。</li><li>w+ 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</li><li>x 表示在文件不存在的情况下新创建并写文件，如果文件存在就会报错。</li><li>a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</li><li>a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</li></ul><p>mode 的第二个字母是文件类型：</p><ul><li>t（或者省略） 代表文本类型</li><li>b 代表二进制文件</li></ul><p><strong><em>注意: 打开文件之后就可以调用函数来读写数据，最后需要关闭文件。</em></strong></p><a id="more"></a><h3 id="使用-write-写文本文件"><a href="#使用-write-写文本文件" class="headerlink" title="使用 write() 写文本文件"></a>使用 write() 写文本文件</h3><pre><code>&gt;&gt;&gt; poem = &quot;日照香炉生紫烟，遥看瀑布挂前川。飞流直下三千尺，疑是银河落九天。&quot;&gt;&gt;&gt;&gt;&gt;&gt; len(poem)32</code></pre><p>将整首诗写到libai.txt中：</p><pre><code>&gt;&gt;&gt; fout = open(&apos;libai.txt&apos;,&apos;wt&apos;)&gt;&gt;&gt; fout.write(poem)32&gt;&gt;&gt; fout.close&lt;built-in method close of _io.TextIOWrapper object at 0x00000000034E1120&gt;</code></pre><p>函数 write() 返回写入文件的字节数。和 print() 一样， 他没有增加空格或者换行符。同样，你也可以在一个文本文件中使用 print()。</p><pre><code>&gt;&gt;&gt; fout = open(&apos;libai.txt&apos;,&apos;wt&apos;)&gt;&gt;&gt; print(poem, file=fout)&gt;&gt;&gt; fout.close()</code></pre><p>这就产生了一个问题：到底是用是 write() 还是 print()？ print() 默认会在每个参数后面添加空格，在每行结束处添加换行。在之前的例子中， libai.txt 中默认添加了一个换行。为了使 print() 与 write() 有同样的输出，传入下面两个参数：</p><ul><li>sep 分隔符：默认是一个空格‘’</li><li>end 结束字符：默认是一个换行符 ‘\n’</li></ul><p>除非自定义参数，否则 print() 会使用默认参数。在这里，我们通过空字符串替换 print() 添加的所有多余输出：</p><pre><code>&gt;&gt;&gt; print(poem, file=fout, sep=&apos;&apos;, end=&apos;&apos;)&gt;&gt;&gt; fout.close()</code></pre><p>如果字符串非常大，可以将数据分块，直到所有字符被写入：</p><pre><code>&gt;&gt;&gt; size = len(poem)&gt;&gt;&gt;&gt;&gt;&gt; fout = open(&apos;libai.txt&apos;, &apos;w&apos;)&gt;&gt;&gt; offset = 0&gt;&gt;&gt; chunk = 10&gt;&gt;&gt; while True:    if offset &gt; size:        break    fout.write(poem[offset:offset+chunk])    offset += chunk1010102&gt;&gt;&gt;&gt;&gt;&gt; fout.close()</code></pre><p>如果 libai.txt 文件已经存在，使用模式 x 可以避免重写文件：</p><pre><code>&gt;&gt;&gt; fount = open(&apos;libai.txt&apos;,&apos;xt&apos;)Traceback (most recent call last):  File &quot;&lt;pyshell#0&gt;&quot;, line 1, in &lt;module&gt;    fount = open(&apos;libai.txt&apos;,&apos;xt&apos;)FileExistsError: [Errno 17] File exists: &apos;libai.txt&apos;</code></pre><h3 id="使用-read-、readline-或者-readlines-读取文本文件"><a href="#使用-read-、readline-或者-readlines-读取文本文件" class="headerlink" title="使用 read()、readline() 或者 readlines() 读取文本文件"></a>使用 read()、readline() 或者 readlines() 读取文本文件</h3><p>使用不带参数的 read() 函数一次读入文件的所有内容。但在读入文件时要格外注意，1GB的文件会用到相同大小的内存，如果文件大小太大的话，需要防止内存爆掉。</p><pre><code>&gt;&gt;&gt; fin = open(&apos;libai.txt&apos;, &apos;rt&apos;)&gt;&gt;&gt; poem = fin.read()&gt;&gt;&gt; poem&apos;日照香炉生紫烟，遥看瀑布挂前川。飞流直下三千尺，疑是银河落九天。&apos;&gt;&gt;&gt; fin.close()&gt;&gt;&gt; len(poem)32</code></pre><p>同样也可以设置最大的读入字符数限制 read() 函数一次返回的大小。下面一次读入10个字符，然后把每一快拼接成原来的字符串 poem。</p><pre><code>&gt;&gt;&gt; poem = &apos;&apos;&gt;&gt;&gt; fin = open(&apos;libai.txt&apos;, &apos;rt&apos;)&gt;&gt;&gt; chunk = 10&gt;&gt;&gt; while True:    fragment = fin.read(chunk)    if not fragment:        break    poem += fragment&gt;&gt;&gt; fin.close()&gt;&gt;&gt; len(poem)32&gt;&gt;&gt; poem&apos;日照香炉生紫烟，遥看瀑布挂前川。飞流直下三千尺，疑是银河落九天。&apos;</code></pre><p>读到结尾之后，再次调用 read() 会返回空字符串(‘’)， if not fragment 条件被判断为 False。此时会跳出 while True 的循环。 当然， 你也能使用 readline() 每次读入文件的一行。 在下面的例子中，通过追加每一行拼接成原来的字符串 poem。</p><pre><code>&gt;&gt;&gt; poem = &apos;&apos;&gt;&gt;&gt; fin = open(&apos;libai.txt&apos;, &apos;rt&apos;)&gt;&gt;&gt; while True:    line = fin.readline()    if not line:        break    poem += line&gt;&gt;&gt; fin.close()&gt;&gt;&gt; len(poem)32&gt;&gt;&gt; poem&apos;日照香炉生紫烟，遥看瀑布挂前川。飞流直下三千尺，疑是银河落九天。&apos;</code></pre><p>读取文本文件最简单的方式是使用一个迭代器（iterator），它会每次返回一行。这和之前的例子类似，但代码会更短：</p><pre><code>&gt;&gt;&gt; poem = &apos;&apos;&gt;&gt;&gt; fin = open(&apos;libai.txt&apos;, &apos;rt&apos;)&gt;&gt;&gt; for line in fin:    poem += line&gt;&gt;&gt; fin.close()&gt;&gt;&gt; len(poem)32&gt;&gt;&gt; poem&apos;日照香炉生紫烟，遥看瀑布挂前川。飞流直下三千尺，疑是银河落九天。&apos;</code></pre><p>前面所有的示例最终都返回单个字符串 poem。 函数 readlines() 调用时每次读取一行，并返回单行字符串的列表：</p><pre><code>&gt;&gt;&gt; poem = &apos;&apos;&apos;日照香炉生紫烟，遥看瀑布挂前川。飞流直下三千尺,疑是银河落九天。&apos;&apos;&apos;&gt;&gt;&gt; fin = open(&apos;libai.txt&apos;,&apos;wt&apos;)&gt;&gt;&gt; fin.write(poem)36&gt;&gt;&gt; fin.close()&gt;&gt;&gt; fin = open(&apos;libai.txt&apos;, &apos;rt&apos;)&gt;&gt;&gt; lines = fin.readlines()&gt;&gt;&gt; fin.close()&gt;&gt;&gt; lines[&apos;日照香炉生紫烟，\n&apos;, &apos;遥看瀑布挂前川。\n&apos;, &apos;飞流直下三千尺,\n&apos;, &apos;疑是银河落九天。\n&apos;]&gt;&gt;&gt; for line in lines:print(line,end=&apos;&apos;)日照香炉生紫烟，遥看瀑布挂前川。飞流直下三千尺,疑是银河落九天。</code></pre><h3 id="使用-with-自动关闭文件"><a href="#使用-with-自动关闭文件" class="headerlink" title="使用 with 自动关闭文件"></a>使用 with 自动关闭文件</h3><p>Python的上下文管理器（context manager）会清理一些资源，例如打开的文件。<br>它的形式<br><code>with expression as variable：</code></p><pre><code>&gt;&gt;&gt; opem = &apos;&apos;&apos;welcome to chenfanlinux.org&apos;&apos;&apos;// 利用这种方式就可以不必用close()函数关闭文件&gt;&gt;&gt; with open(&apos;libai.txt&apos;, &apos;wt&apos;) as fout:    print(opem,file=fout,end=&apos;&apos;)&gt;&gt;&gt; with open(&apos;libai.txt&apos;, &apos;rt&apos;) as fin:    for line in fin:        print(line,end=&apos;&apos;)welcome to chenfanlinux.org</code></pre><p>完成上下文管理器的代码后，文件会自动关闭。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><blockquote><p>Python使用被称为异常的特殊对象来管理程序执行期间发生的错误。每当发生让Python不知 所措的错误时，它都会创建一个异常对象。如果你编写了处理该异常的代码，程序将继续运行; 如果你未对异常进行处理，程序将停止，并显示一个traceback，其中包含有关异常的报告。<br>异常是使用try-except代码块处理的。try-except代码块让Python执行指定的操作，同时告 诉Python发生异常时怎么办。使用了try-except代码块时，即便出现异常，程序也将继续运行: 显示你编写的友好的错误消息，而不是令用户迷惑的traceback。</p></blockquote><h3 id="使用-try-except-代码块"><a href="#使用-try-except-代码块" class="headerlink" title="使用 try-except 代码块"></a>使用 try-except 代码块</h3><blockquote><p>try 语句有两种主要形式: try-except 和 try-finally . 这两个语句是互斥的, 也就是说你 只能使用其中的一种. 一个 try 语句可以对应一个或多个 except 子句, 但只能对应一个 finally 子句, 或是一个 try-except-finally 复合语句。</p></blockquote><p>处理ZeroDivisionError异常的try-except代码 类似于下面这样：</p><pre><code>&gt;&gt;&gt; try:    print(5/0)except ZeroDivisionError:    print(&quot;You can&apos;t divide by zero!&quot;)You can&apos;t divide by zero!</code></pre><p>我们将导致错误的代码行print(5/0)放在了一个try代码中。如果try代码中的代码运行起来没有问题，Python将跳过except代码; 如果try代码中的代码导致了错误，Python将查找这样的except代码块，并运行其中的代码，即其中指定的错误与引发的错误相同。<br>在这个示例中，try代码中的代码引发了ZeroDivisionError异常，因此Python指出了该如何解决问题的except代码块，并运行其中的代码。这样，用户看到的是一条 好的错误消息，而不是traceback:</p><pre><code>You can&apos;t divide by zero!</code></pre><p>如果try-except代码后面还有其他代码，程序将接着运行，因为已经告诉了Python如何处理这种错误。</p><h3 id="使用异常避免崩溃"><a href="#使用异常避免崩溃" class="headerlink" title="使用异常避免崩溃"></a>使用异常避免崩溃</h3><p>发生错误时，如果程序还有工作没有完成，妥善地处理错误就尤其重要。这种情况经常会出现在要求用户提供输入的程序中;如果程序能够妥善地处理无效输入，就能再提示用户提供有效输入，而不至于崩溃。</p><pre><code>#__author: Administrator#date: 2018/2/11print(&quot;Give me two numbers, and I&apos;ll divide them.&quot;)print(&quot;Enter &apos;q&apos; to quit.&quot;)while True:    first_number = input(&quot;\n First number: &quot;)    if first_number == &apos;q&apos;:        break    second_number = input(&quot;\n Second number: &quot;)    if second_number == &apos;q&apos;:        break    answer = int(first_number) / int(second_number)    print(answer)</code></pre><p>这个程序没有采取任何处理错误的措施，因此让它执行除数为0的除法运算时，它将崩溃:</p><pre><code>Give me two numbers, and I&apos;ll divide them.Enter &apos;q&apos; to quit.First number: 5Second number: 0Traceback (most recent call last):  File &quot;&lt;ipython-input-208-1e61f850d337&gt;&quot;, line 11, in &lt;module&gt;    answer = int(first_number) / int(second_number)ZeroDivisionError: division by zero&gt;&gt;&gt;</code></pre><p>程序崩溃可不好，但让用户看到 traceback 也不是好主意。不懂技术的用户会被它们搞糊涂， 而且如果用户 怀有恶意，他会通过traceback获悉你不希望他知道的信息。例如，他将知道你的程序文件的名称，还将看到部分不能正确运行的代码。有时候，训练有素的攻击者可根据这些信息判断出可对你的代码发起什么样的攻击。</p><h3 id="else-代码块"><a href="#else-代码块" class="headerlink" title="else 代码块"></a>else 代码块</h3><p>通过将可能引发错误的代码放在try-except代码中，可提高这个程序抵御错误的能力。错误是执行除法运算的代码行导致的，因此我们需要将它放到try-except代码块中。这个示例还包含一个else代码块; 依赖于try代码块成功执行的代码都应放到else代码中:</p><pre><code>#__author: Administrator#date: 2018/2/11print(&quot;Give me two numbers, and I&apos;ll divide them.&quot;)print(&quot;Enter &apos;q&apos; to quit.&quot;)while True:    first_number = input(&quot;\n First number: &quot;)    if first_number == &apos;q&apos;:        break    second_number = input(&quot;\n Second number: &quot;)    if second_number == &apos;q&apos;:        break    try:        answer = int(first_number) / int(second_number)    except ZeroDivisionError:        print(&quot;You can&apos;t divide by 0!&quot;)    else:        print(answer)</code></pre><p>我们让Python尝试执行try代码块中的除法运算，这个代码块只包含可能导致错误的代码。依赖于try代码块成功执行的代码都放在else代码中; 在这个示例中，如果除法运算成功，我们就使用else代码块来打印结果。<br>except代码块告诉Python，出现ZeroDivisionError异常时该怎么办。如果try代码因除零错误而失败，我们就打印一条友好的消息，告诉用户如何避免这种错误。程序将继续运行，用户根本看不到traceback。</p><pre><code>Give me two numbers, and I&apos;ll divide them.Enter &apos;q&apos; to quit.First number: 5Second number: 0You can&apos;t divide by 0!First number: 5Second number: 22.5First number: q&gt;&gt;&gt;</code></pre><p>try-except-else代码块的工作原理大致如下: Python尝试执行try代码块中的代码; 只有可能引发异常的代码才需要放在try语句中。有时候，有一些仅在try代码块成功执行时才需要运行的的代码; 这些代码应放在else代码中。except代码块告诉Python，如果它尝试运行try代码块中的代码时引发了指定的异常，该怎么办。通过预测可能发生错误的代码，可编写健壮的程序，它们即便面临无效数据或缺少资源，也能继续运行，从而能够抵御无意的用户错误和恶意的攻击。</p><h3 id="finally子句"><a href="#finally子句" class="headerlink" title="finally子句"></a>finally子句</h3><p>finally 子句是无论异常是否发生,是否捕捉都会执行的一段代码. 你可以将 finally 仅仅配合 try 一起使用,也可以和 try-except(else 也是可选的)一起使用。你可以用 finally 子句 与 try-except 或 try-except-else 一起使用。</p><p>下面是 try-except-else-finally 语法的示例:</p><pre><code>try:    Aexcept MyException1:    B1except MyException2:    B2else:    Cfinally:    D</code></pre><p>当然,无论如何,你都可以有不止一个的 except 子句,但最少有一个 except 语句,而 else 和 finally 都是可选的. A,B,C 和 D 是程序(代码块). 程序会按预期的顺序执行.(注意:可能的顺序是 A-C-D[正常]或 A-B-D[异常])，无论异常发生都将执行 finally 块。</p><h3 id="常见的异常"><a href="#常见的异常" class="headerlink" title="常见的异常"></a>常见的异常</h3><p><img src="https://s1.ax1x.com/2018/02/22/9UQn74.png" alt="常见的异常"></p><h3 id="决定报告那些错误"><a href="#决定报告那些错误" class="headerlink" title="决定报告那些错误"></a>决定报告那些错误</h3><ul><li>编写得很好且经过详尽测试的代码不容易出现内部错误，如语法或逻辑错误。</li><li>但只要程序依赖于外部因素，如用户输入、存在指定的文件、有网络连接，就有可能出现异常。凭借经验可判断该在程序的什么地方包含异常处理 ，以及出现错误时该向用户提供多少相关的信息。</li><li>向用户显示他不想看到的信息可能会降低程序的可用性。Python的错误处理结构让你能够细致地控制与用户分享错误信息的程度，要分享多少信息由你决定。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文件&quot;&gt;&lt;a href=&quot;#文件&quot; class=&quot;headerlink&quot; title=&quot;文件&quot;&gt;&lt;/a&gt;文件&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;数据持久化最简单的类型是普通文件,它仅仅是在一个文件名下的字节流，把数据从一个文件读入内存，然后从内存写入文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;文件操作模型&quot;&gt;&lt;a href=&quot;#文件操作模型&quot; class=&quot;headerlink&quot; title=&quot;文件操作模型&quot;&gt;&lt;/a&gt;文件操作模型&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;data = open(filename, mode)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面是对该 open() 调用的简单解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;data 是 open() 返回的文件对象&lt;/li&gt;
&lt;li&gt;filename 是该文件的字符串名&lt;/li&gt;
&lt;li&gt;mode 是指明文件类型和操作的字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;mode 的第一个字母表明对其的操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;r 以只读方式打开文件。文件的指针将会放在文件的开头，这是默认模式。&lt;/li&gt;
&lt;li&gt;r+ 可读可写，不会创建不存在的文件。如果直接写文件，则从顶部开始写，覆盖之前此位置的内容，如果先读后写，则会在文件最后追加内容。&lt;/li&gt;
&lt;li&gt;w 表示写模式。若果文件不存在则新创建，如果该文件已存在则将其覆盖。&lt;/li&gt;
&lt;li&gt;w+ 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。&lt;/li&gt;
&lt;li&gt;x 表示在文件不存在的情况下新创建并写文件，如果文件存在就会报错。&lt;/li&gt;
&lt;li&gt;a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。&lt;/li&gt;
&lt;li&gt;a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;mode 的第二个字母是文件类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;t（或者省略） 代表文本类型&lt;/li&gt;
&lt;li&gt;b 代表二进制文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意: 打开文件之后就可以调用函数来读写数据，最后需要关闭文件。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python基础知识" scheme="http://www.chenfanlinux.org/categories/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Python" scheme="http://www.chenfanlinux.org/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python基础之变量与运算符</title>
    <link href="http://www.chenfanlinux.org/2018/02/17/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://www.chenfanlinux.org/2018/02/17/Python基础之变量与运算符/</id>
    <published>2018-02-16T22:44:59.000Z</published>
    <updated>2018-02-16T22:48:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><blockquote><p>在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。所谓变量就是在程序中为了方便地引用内存中的值而为它取的名称。在 Python 中，我们用 = 来给一个变量赋值。</p></blockquote><h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><p>Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</p><pre><code>&gt;&gt;&gt; a = 123  # a是整数&gt;&gt;&gt; id(a)1647579408&gt;&gt;&gt; a = &apos;ABC&apos; # a变为字符串&gt;&gt;&gt; id(a)10190496</code></pre><p><strong><em>Python 中的变量有一个非常重要的性质:它仅仅是一个名字。赋值操作并不会实际 复制值，它只是为数据对象取个相关的名字。名字是对对象的引用而不是对象本身。你可以把名字想象成贴在盒子上的标签</em></strong></p><a id="more"></a><h3 id="变量在内存中表示"><a href="#变量在内存中表示" class="headerlink" title="变量在内存中表示"></a>变量在内存中表示</h3><p>理解变量在计算机内存中的表示也非常重要。当我们写:</p><pre><code>a =  &apos;ABC&apos;</code></pre><p>Python解释器干了两件事情：</p><ul><li>在内存中创建了一个’ABC’的字符串；</li><li>在内存中创建了一个名为a的变量，并把它指向’ABC’。</li></ul><p>也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据，例如下面的代码：</p><pre><code>&gt;&gt;&gt; a =  &apos;ABC&apos;&gt;&gt;&gt; a = &apos;ABC&apos;&gt;&gt;&gt; b = a&gt;&gt;&gt; a = &apos;XYZ&apos;&gt;&gt;&gt; print(b)ABC</code></pre><p>上面的代码执行步骤如下:</p><ul><li>执行a = ‘ABC’，解释器创建了字符串’ABC’和变量a，并把a指向’ABC’</li><li>执行b = a，解释器创建了变量b，并把b指向a指向的字符串’ABC’</li><li>执行a = ‘XYZ’，解释器创建了字符串’XYZ’，并把a的指向改为’XYZ’，但b并没有更改,所以，最后打印变量b的结果自然是’ABC’了</li></ul><h3 id="变量的命名"><a href="#变量的命名" class="headerlink" title="变量的命名"></a>变量的命名</h3><p>在Python中使用变量时，需要遵守一些规则和指南。违反这些规则将引发错误，而指南旨在 让你编写的代码更容易阅读和理解， 请务必牢记下述有关变量的规则。</p><ul><li>变量名只能包含字母、数字和下划线。变量名可以字母或下划线打头，但不能以数字打 头，例如，可将变量命名为message_1，不能命名为1_message</li><li>变量名不能包含空格，但可使用下划线来分隔其中的单词。例如，变量名greeting_message 可行，但变量名greeting message会引发错误。</li><li>不要将Python关键字和函数名用作变量名，即不要使用Python保留用于特殊用途的单词。</li></ul><h4 id="Python-关键字"><a href="#Python-关键字" class="headerlink" title="Python 关键字"></a>Python 关键字</h4><p>下面的关键字都有特殊含义，如果你将它们用作变量名，将引发错误:<br><img src="https://s1.ax1x.com/2018/02/18/9tDAZn.md.png" alt="Python关键字"></p><h4 id="Python-内置函数"><a href="#Python-内置函数" class="headerlink" title="Python 内置函数"></a>Python 内置函数</h4><p>将内置函数名用作变量名时，不会导致错误，但将覆盖这些函数的行为:<br><img src="https://s1.ax1x.com/2018/02/18/9tDEaq.md.png" alt="Python内置函数"></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><blockquote><p>你所编写的大多数语句(逻辑行)都包含了表达式(Expressions)。一个表达式的简单例子<br>便是 2+3 。表达式可以拆分成运算符（ Operators） 与操作数（ Operands),运算符（ Operators） 是进行某些操作，并且可以用诸如 + 等符号或特殊关键词加以表达的<br>功能。运算符需要一些数据来进行操作，这些数据就被称作操作数（ Operands)。</p></blockquote><p>Python语言支持以下类型的运算符:</p><ul><li>算术运算符</li><li>比较（关系）运算符</li><li>赋值运算符</li><li>逻辑运算符</li><li>位运算符</li><li>成员运算符</li><li>身份运算符</li><li>运算符优先级</li></ul><h3 id="Python算术运算符"><a href="#Python算术运算符" class="headerlink" title="Python算术运算符"></a>Python算术运算符</h3><p><img src="https://s1.ax1x.com/2018/02/18/9tDtJK.png" alt="Python算术运算符"></p><h3 id="Python比较运算符"><a href="#Python比较运算符" class="headerlink" title="Python比较运算符"></a>Python比较运算符</h3><p><img src="https://s1.ax1x.com/2018/02/18/9tDsot.png" alt="Python比较运算符"></p><h3 id="Python赋值运算符"><a href="#Python赋值运算符" class="headerlink" title="Python赋值运算符"></a>Python赋值运算符</h3><p><img src="https://s1.ax1x.com/2018/02/18/9tDRSS.png" alt="Python赋值运算符"></p><h3 id="Python位运算符"><a href="#Python位运算符" class="headerlink" title="Python位运算符"></a>Python位运算符</h3><blockquote><p>按位运算符是把数字看作二进制来进行计算的。</p></blockquote><p><img src="https://s1.ax1x.com/2018/02/18/9tDIwn.png" alt="Python位运算符"></p><h3 id="Python逻辑运算符"><a href="#Python逻辑运算符" class="headerlink" title="Python逻辑运算符"></a>Python逻辑运算符</h3><p><img src="https://s1.ax1x.com/2018/02/18/9tDHYV.png" alt="Python逻辑运算符"></p><h3 id="Python成员运算符"><a href="#Python成员运算符" class="headerlink" title="Python成员运算符"></a>Python成员运算符</h3><blockquote><p>除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。</p></blockquote><p><img src="https://s1.ax1x.com/2018/02/18/9tDLSU.png" alt="Python成员运算符"></p><h3 id="Python身份运算符"><a href="#Python身份运算符" class="headerlink" title="Python身份运算符"></a>Python身份运算符</h3><blockquote><p>身份运算符用于比较两个对象的存储单元。</p></blockquote><p><img src="https://s1.ax1x.com/2018/02/18/9tDXy4.md.png" alt="Python身份运算符"></p><p><strong>is 与 == 区别：</strong></p><p>is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。</p><pre><code>&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; b = a&gt;&gt;&gt; b is aTrue&gt;&gt;&gt; b == aTrue&gt;&gt;&gt; b = a[:]&gt;&gt;&gt; b is aFalse&gt;&gt;&gt; b == aTrue</code></pre><h3 id="Python运算符优先级"><a href="#Python运算符优先级" class="headerlink" title="Python运算符优先级"></a>Python运算符优先级</h3><p>以下表格列出了从最高到最低优先级的所有运算符:</p><p><img src="https://s1.ax1x.com/2018/02/18/9trklD.png" alt="运算符优先级"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。所谓变量就是在程序中为了方便地引用内存中的值而为它取的名称。在 Python 中，我们用 = 来给一个变量赋值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;变量赋值&quot;&gt;&lt;a href=&quot;#变量赋值&quot; class=&quot;headerlink&quot; title=&quot;变量赋值&quot;&gt;&lt;/a&gt;变量赋值&lt;/h3&gt;&lt;p&gt;Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = 123  # a是整数
&amp;gt;&amp;gt;&amp;gt; id(a)
1647579408
&amp;gt;&amp;gt;&amp;gt; a = &amp;apos;ABC&amp;apos; # a变为字符串
&amp;gt;&amp;gt;&amp;gt; id(a)
10190496
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Python 中的变量有一个非常重要的性质:它仅仅是一个名字。赋值操作并不会实际 复制值，它只是为数据对象取个相关的名字。名字是对对象的引用而不是对象本身。你可以把名字想象成贴在盒子上的标签&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python基础知识" scheme="http://www.chenfanlinux.org/categories/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Python" scheme="http://www.chenfanlinux.org/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Pytho基础之内置数据类型(二)</title>
    <link href="http://www.chenfanlinux.org/2018/02/14/Pytho%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%BA%8C/"/>
    <id>http://www.chenfanlinux.org/2018/02/14/Pytho基础之内置数据类型-二/</id>
    <published>2018-02-14T04:17:34.000Z</published>
    <updated>2018-02-14T04:25:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><blockquote><p>列表由一系列按特定顺序排列的元素组成，可以将任何东西加入列表中，其中的元素之间可以没有任何关系。列表非常适合利用顺序和位置定位某一元素，尤其是当元素的顺序或内容经常发生改变时。与字符串不同，列表是可变的。你可以直接对原始列表进行修改:添加新元素、删除 或覆盖已有元素。在列表中，具有相同值的元素允许出现多次。</p></blockquote><h3 id="常用列表方法"><a href="#常用列表方法" class="headerlink" title="常用列表方法"></a>常用列表方法</h3><pre><code>&gt;&gt;&gt; dir(list)[&apos;__add__&apos;, &apos;__class__&apos;, &apos;__contains__&apos;,&apos;__delattr__&apos;, &apos;__delitem__&apos;, &apos;__dir__&apos;,&apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;,&apos;__getattribute__&apos;, &apos;__getitem__&apos;, &apos;__gt__&apos;,&apos;__hash__&apos;, &apos;__iadd__&apos;, &apos;__imul__&apos;,&apos;__init__&apos;, &apos;__iter__&apos;, &apos;__le__&apos;, &apos;__len__&apos;, &apos;__lt__&apos;, &apos;__mul__&apos;,&apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__reversed__&apos;, &apos;__rmul__&apos;, &apos;__setattr__&apos;, &apos;__setitem__&apos;,&apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;append&apos;, &apos;clear&apos;, &apos;copy&apos;, &apos;count&apos;, &apos;extend&apos;, &apos;index&apos;, &apos;insert&apos;, &apos;pop&apos;, &apos;remove&apos;, &apos;reverse&apos;, &apos;sort&apos;]</code></pre><h3 id="列表切片"><a href="#列表切片" class="headerlink" title="列表切片"></a>列表切片</h3><p><strong>定义列表后，可从其中获取任何部分作为新列表。该技术称为对列表进行切片，对于有序序列，包括字符串，元组都可以切片。</strong></p><pre><code>&gt;&gt;&gt; lists = [&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;, &apos;Bob&apos;, &apos;Jack&apos;]&gt;&gt;&gt; lists[0]&apos;Michael&apos;&gt;&gt;&gt; lists[1:3] # 切片实际是索引尾部取开区间 [1:3)[&apos;Sarah&apos;, &apos;Tracy&apos;]&gt;&gt;&gt; lists[:3]  # 相当于索引lists[0:3][&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;]&gt;&gt;&gt; lists[0:3][&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;]&gt;&gt;&gt; lists[-2:] # 取列表最后两个元素[&apos;Bob&apos;, &apos;Jack&apos;]</code></pre><h3 id="append-向列表尾部追加一个元素"><a href="#append-向列表尾部追加一个元素" class="headerlink" title="append 向列表尾部追加一个元素"></a>append 向列表尾部追加一个元素</h3><pre><code>&gt;&gt;&gt; lists[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;, &apos;Bob&apos;, &apos;Jack&apos;]&gt;&gt;&gt; lists.append(&apos;chenfan&apos;)&gt;&gt;&gt; lists[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;, &apos;Bob&apos;, &apos;Jack&apos;, &apos;chenfan&apos;]</code></pre><h3 id="clear-清除列表中的所有元素"><a href="#clear-清除列表中的所有元素" class="headerlink" title="clear 清除列表中的所有元素"></a>clear 清除列表中的所有元素</h3><pre><code>&gt;&gt;&gt; num = [1,2,3,4,5]&gt;&gt;&gt; num.clear()&gt;&gt;&gt; num[]</code></pre><a id="more"></a><h3 id="copy-复制一个列表"><a href="#copy-复制一个列表" class="headerlink" title="copy 复制一个列表"></a>copy 复制一个列表</h3><pre><code>&gt;&gt;&gt; lists[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;, &apos;Bob&apos;, &apos;Jack&apos;, &apos;chenfan&apos;]&gt;&gt;&gt; the_list = lists.copy()&gt;&gt;&gt; the_list[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;, &apos;Bob&apos;, &apos;Jack&apos;, &apos;chenfan&apos;]</code></pre><h3 id="count-计算某个元素在列表中出现的次数"><a href="#count-计算某个元素在列表中出现的次数" class="headerlink" title="count 计算某个元素在列表中出现的次数"></a>count 计算某个元素在列表中出现的次数</h3><pre><code>&gt;&gt;&gt; numbers = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]&gt;&gt;&gt; numbers.count(4)4&gt;&gt;&gt; numbers.count(2)2</code></pre><h3 id="extend-向列表末尾一次性追加另一个列表"><a href="#extend-向列表末尾一次性追加另一个列表" class="headerlink" title="extend 向列表末尾一次性追加另一个列表"></a>extend 向列表末尾一次性追加另一个列表</h3><pre><code>&gt;&gt;&gt; numbers[1, 2, 2, 3, 3, 3, 4, 4, 4, 4]&gt;&gt;&gt; a = [5, 5, 5, 5, 5]&gt;&gt;&gt; numbers.extend(a)&gt;&gt;&gt; numbers[1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]</code></pre><h3 id="index-从列表中找出某个值第一个匹配的索引位置"><a href="#index-从列表中找出某个值第一个匹配的索引位置" class="headerlink" title="index 从列表中找出某个值第一个匹配的索引位置"></a>index 从列表中找出某个值第一个匹配的索引位置</h3><pre><code>&gt;&gt;&gt; numbers[1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]&gt;&gt;&gt; numbers.index(5)10&gt;&gt;&gt; numbers.index(2)1</code></pre><h3 id="insert-将对象插入列表某个索引位置"><a href="#insert-将对象插入列表某个索引位置" class="headerlink" title="insert 将对象插入列表某个索引位置"></a>insert 将对象插入列表某个索引位置</h3><pre><code>&gt;&gt;&gt; numbers.insert(0,0)&gt;&gt;&gt; numbers[0, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5</code></pre><h3 id="pop-移除列表中的最后一个元素"><a href="#pop-移除列表中的最后一个元素" class="headerlink" title="pop 移除列表中的最后一个元素"></a>pop 移除列表中的最后一个元素</h3><pre><code>&gt;&gt;&gt; numbers[0, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]&gt;&gt;&gt; numbers.pop()5&gt;&gt;&gt; numbers[0, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5]</code></pre><h3 id="remove-移除列表中第一个匹配的元素"><a href="#remove-移除列表中第一个匹配的元素" class="headerlink" title="remove 移除列表中第一个匹配的元素"></a>remove 移除列表中第一个匹配的元素</h3><pre><code>&gt;&gt;&gt; num = [1, 2, 1, 3, 2]&gt;&gt;&gt; num.remove(1)&gt;&gt;&gt; num[2, 1, 3, 2]&gt;&gt;&gt; num.remove(2)&gt;&gt;&gt; num[1, 3, 2]</code></pre><h3 id="reverse-将列表中的元素反向存放"><a href="#reverse-将列表中的元素反向存放" class="headerlink" title="reverse 将列表中的元素反向存放"></a>reverse 将列表中的元素反向存放</h3><pre><code>&gt;&gt;&gt; numbers[0, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5]&gt;&gt;&gt; numbers.reverse()&gt;&gt;&gt; numbers[5, 5, 5, 5, 4, 4, 4, 4, 3, 3, 3, 2, 2, 1, 0]</code></pre><h3 id="sort-对列表排序"><a href="#sort-对列表排序" class="headerlink" title="sort 对列表排序"></a>sort 对列表排序</h3><h4 id="默认排序（升序）"><a href="#默认排序（升序）" class="headerlink" title="默认排序（升序）"></a>默认排序（升序）</h4><pre><code>&gt;&gt;&gt; L = [1,4,3,2]&gt;&gt;&gt; L.sort()&gt;&gt;&gt; L[1, 2, 3, 4]</code></pre><h4 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h4><p><strong>看sort的使用方法</strong></p><pre><code>&gt;&gt;&gt; L.sort.__doc__&apos;L.sort(key=None, reverse=False) -&gt; None -- stable sort *IN PLACE*&apos;</code></pre><p><strong>根据提供的key函数为元素产生一个键，列表的元素按照这个键值来排序</strong></p><pre><code>&gt;&gt;&gt; x = [&apos;abc&apos;,&apos;a&apos;,&apos;bc&apos;,&apos;abcd&apos;]&gt;&gt;&gt; x.sort(key=len)&gt;&gt;&gt; x[&apos;a&apos;, &apos;bc&apos;, &apos;abc&apos;, &apos;abcd&apos;]</code></pre><p><strong>反向排序</strong></p><pre><code>&gt;&gt;&gt; n = [3, 1, 2, 5]&gt;&gt;&gt; n.sort(reverse=True)&gt;&gt;&gt; n[5, 3, 2, 1]</code></pre><h3 id="使用-in-判断值是否存在"><a href="#使用-in-判断值是否存在" class="headerlink" title="使用 in 判断值是否存在"></a>使用 in 判断值是否存在</h3><pre><code>&gt;&gt;&gt; num = [1, 2, 3]&gt;&gt;&gt; 1 in numTrue&gt;&gt;&gt; 4 in numFalse</code></pre><h3 id="使用-len-获取长度"><a href="#使用-len-获取长度" class="headerlink" title="使用 len() 获取长度"></a>使用 len() 获取长度</h3><pre><code>&gt;&gt;&gt; num[1, 2, 3]&gt;&gt;&gt; len(num)3</code></pre><h3 id="使用-赋值，使用copy-复制"><a href="#使用-赋值，使用copy-复制" class="headerlink" title="使用=赋值，使用copy()复制"></a>使用=赋值，使用copy()复制</h3><p><strong>如果将一个列表赋值给了多个变量，改变其中的任何一处造成其他变量对应的值也被修改</strong></p><pre><code>&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; a[1, 2, 3]&gt;&gt;&gt; b = a&gt;&gt;&gt; a[0] = &apos;surpise&apos;&gt;&gt;&gt; a[&apos;surpise&apos;, 2, 3]&gt;&gt;&gt; b[&apos;surpise&apos;, 2, 3]</code></pre><p>b与a实际上指向的是同一个对象，因此，无论我们是通过a还是b来修改列表的内容，其结果都会作用于双方。</p><pre><code>&gt;&gt;&gt; b[&apos;surpise&apos;, 2, 3]&gt;&gt;&gt; b[0] = &apos;I love surprises&apos;&gt;&gt;&gt; b[&apos;I love surprises&apos;, 2, 3]&gt;&gt;&gt; a[&apos;I love surprises&apos;, 2, 3]&gt;&gt;&gt;</code></pre><p><strong>通过下面任意一种方法，都可以将一个列表的值复制到另一个新的列表中</strong></p><pre><code>&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; b = a.copy()&gt;&gt;&gt; c = list(a)&gt;&gt;&gt; d = a[:]&gt;&gt;&gt; a[0] = &apos;one&apos;&gt;&gt;&gt; b[1, 2, 3]&gt;&gt;&gt; c[1, 2, 3]&gt;&gt;&gt; d[1, 2, 3]</code></pre><ul><li>列表 copy() 函数</li><li>list() 转换函数</li><li>列表分片 [:]</li></ul><p>b、c、d 都是a的复制：它们是自身带有值的新对象，与原始的a所指向的列表对象[1, 2, 3]没有任何关联。所以改变a不影响b、c、d的复制。</p><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><blockquote><p>与列表类似，元组也是由任意类型元素组成的有序序列。与列表不同的是，元组是不可改变的，这意味着一但元组被定义，将无法再进行增加、删除或者修改元素等操作。因此元组就像一个常量列表。元组的只读性使其拥有更好的内存效率和性能。除无法修改外，其普通特征和列表类似。 在需要传递 “不可变” 参数时，应鼓励用元组替代列表。</p></blockquote><h3 id="使用-创建元组"><a href="#使用-创建元组" class="headerlink" title="使用()创建元组"></a>使用()创建元组</h3><p>可以用()创建一个空元组：</p><pre><code>&gt;&gt;&gt; empty_tuple = () # 创建空元组&gt;&gt;&gt; empty_tuple()&gt;&gt;&gt; type(empty_tuple)&lt;class &apos;tuple&apos;&gt;</code></pre><p>创建包含一个或多个元素的元组时，每一个元素后面需要跟着一个逗号：</p><pre><code>&gt;&gt;&gt; num = (1)&gt;&gt;&gt; type(num)&lt;class &apos;int&apos;&gt;&gt;&gt;&gt; num = (1,)&gt;&gt;&gt; type(num)&lt;class &apos;tuple&apos;&gt;</code></pre><p>创建多个元素的元组，可以用括号将所有元素包裹起来，这会使得程序更加清晰：</p><pre><code>&gt;&gt;&gt; num = 1,2,3&gt;&gt;&gt; num1 = (1,2,3)&gt;&gt;&gt; num(1, 2, 3)&gt;&gt;&gt; num1(1, 2, 3)</code></pre><h3 id="元组解包"><a href="#元组解包" class="headerlink" title="元组解包"></a>元组解包</h3><p><strong>可以一口气将元组赋值给多个变量</strong></p><pre><code>&gt;&gt;&gt; num(1, 2, 3)&gt;&gt;&gt; a, b, c = num&gt;&gt;&gt; a1&gt;&gt;&gt; b2&gt;&gt;&gt; c3</code></pre><p><strong>可以利用元组在一条语句中对多个变量的值进行交换，而不需借助临时变量</strong></p><pre><code>&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = 2&gt;&gt;&gt; a, b = b, a&gt;&gt;&gt; a2&gt;&gt;&gt; b1</code></pre><h3 id="元组与列表对比"><a href="#元组与列表对比" class="headerlink" title="元组与列表对比"></a>元组与列表对比</h3><p>在许多地方都可以用元组代替列表，但元组的方法函数与类表相比要少一些，元组没有append()、insert()等等。因为一但创建元组变无法修改，既然列表更加灵活那为什么不在所有地方都是用列表呢？原因如下：</p><ul><li>元组占用的空间小</li><li>你不会意外修改元组的值</li><li>可以将元组用作字典的键（详细的后面会介绍）</li><li>命名元组可以作为对象的代替</li><li>函数的参数是以元组形式是传递的</li></ul><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><blockquote><p>字典 是键值对的无序集合。向字典添加一个键的同时，必须为该键增添一个值。（之后可随时修改该值。） Python 的字典为通过键获取值进行了优化，而不是反过来。比如字典的键必须为不可变对象，因此列表、字典和集合都不能作为字典的键，但元组可以作为字典的键。</p></blockquote><h3 id="使用-创建字典"><a href="#使用-创建字典" class="headerlink" title="使用 {} 创建字典"></a>使用 {} 创建字典</h3><pre><code>&gt;&gt;&gt; empty_dict = {}&gt;&gt;&gt; empty_dict{}&gt;&gt;&gt; type(empty_dict)&lt;class &apos;dict&apos;&gt;</code></pre><h3 id="字典的键也不允许重复"><a href="#字典的键也不允许重复" class="headerlink" title="字典的键也不允许重复"></a>字典的键也不允许重复</h3><pre><code>&gt;&gt;&gt; c = {&quot;1&quot;:2, &quot;1&quot;:3, &quot;1&quot;:4}&gt;&gt;&gt; c{&apos;1&apos;: 4}</code></pre><h3 id="使用-dict-转换为字典"><a href="#使用-dict-转换为字典" class="headerlink" title="使用 dict() 转换为字典"></a>使用 dict() 转换为字典</h3><p><strong>记住，字典是无序的，字典中元素的顺序是无关紧要的，实际存储顺序可能取决于你添加元素的顺序。</strong></p><p>双值子序列的序列转换成字典：</p><pre><code>&gt;&gt;&gt; type(empty_dict)&lt;class &apos;dict&apos;&gt;&gt;&gt;&gt; lol = [ [&apos;a&apos;, &apos;b&apos;], [&apos;c&apos;, &apos;d&apos;], [&apos;e&apos;, &apos;f&apos;] ]&gt;&gt;&gt; dict(lol){&apos;c&apos;: &apos;d&apos;, &apos;a&apos;: &apos;b&apos;, &apos;e&apos;: &apos;f&apos;}</code></pre><p>双值元组列表：</p><pre><code>&gt;&gt;&gt; lot = [ (&apos;a&apos;, &apos;b&apos;), (&apos;c&apos;, &apos;d&apos;), (&apos;e&apos;, &apos;f&apos;) ]&gt;&gt;&gt; dict(lot){&apos;c&apos;: &apos;d&apos;, &apos;a&apos;: &apos;b&apos;, &apos;e&apos;: &apos;f&apos;}</code></pre><p>双字符串的字符串组成的列表：</p><pre><code>&gt;&gt;&gt; los = [ &apos;ab&apos;, &apos;cd&apos;, &apos;ef&apos; ]&gt;&gt;&gt; dict(los){&apos;c&apos;: &apos;d&apos;, &apos;a&apos;: &apos;b&apos;, &apos;e&apos;: &apos;f&apos;}</code></pre><p>双字符的字符串组成的元组：</p><pre><code>&gt;&gt;&gt; tos = ( &apos;ab&apos;, &apos;cd&apos;, &apos;ef&apos;)&gt;&gt;&gt; dict(tos){&apos;c&apos;: &apos;d&apos;, &apos;a&apos;: &apos;b&apos;, &apos;e&apos;: &apos;f&apos;}</code></pre><h3 id="使用-key-添加或修改元素"><a href="#使用-key-添加或修改元素" class="headerlink" title="使用 [key] 添加或修改元素"></a>使用 [key] 添加或修改元素</h3><pre><code>&gt;&gt;&gt; d = {&quot;11&quot;:1, &quot;12&quot;:2, &quot;13&quot;:3}&gt;&gt;&gt; d[&quot;14&quot;] = 4&gt;&gt;&gt; d{&apos;13&apos;: 3, &apos;14&apos;: 4, &apos;11&apos;: 1, &apos;12&apos;: 2}</code></pre><h3 id="使用-update-合并字典"><a href="#使用-update-合并字典" class="headerlink" title="使用 update() 合并字典"></a>使用 update() 合并字典</h3><pre><code>&gt;&gt;&gt; d = {&quot;l1&quot;:1, &quot;l2&quot;:2, &quot;l3&quot;:3}&gt;&gt;&gt; e = {&quot;14&quot;:4, &quot;15&quot;:5}&gt;&gt;&gt; d.update(e)&gt;&gt;&gt; d{&apos;14&apos;: 4, &apos;l1&apos;: 1, &apos;l2&apos;: 2, &apos;l3&apos;: 3, &apos;15&apos;: 5}</code></pre><h3 id="使用-del-删除具有指定键的元素"><a href="#使用-del-删除具有指定键的元素" class="headerlink" title="使用 del 删除具有指定键的元素"></a>使用 del 删除具有指定键的元素</h3><pre><code>&gt;&gt;&gt; d{&apos;14&apos;: 4, &apos;l1&apos;: 1, &apos;l2&apos;: 2, &apos;l3&apos;: 3, &apos;15&apos;: 5}&gt;&gt;&gt; del d[&quot;14&quot;]&gt;&gt;&gt; d{&apos;l1&apos;: 1, &apos;l2&apos;: 2, &apos;l3&apos;: 3, &apos;15&apos;: 5}</code></pre><h3 id="使用-clear-删除所有元素"><a href="#使用-clear-删除所有元素" class="headerlink" title="使用 clear() 删除所有元素"></a>使用 clear() 删除所有元素</h3><pre><code>&gt;&gt;&gt; d{&apos;l1&apos;: 1, &apos;l2&apos;: 2, &apos;l3&apos;: 3, &apos;15&apos;: 5}&gt;&gt;&gt; d{&apos;l1&apos;: 1, &apos;l2&apos;: 2, &apos;l3&apos;: 3, &apos;15&apos;: 5}&gt;&gt;&gt; d.clear()&gt;&gt;&gt; d{}</code></pre><h3 id="使用-in-判断是否存在"><a href="#使用-in-判断是否存在" class="headerlink" title="使用 in 判断是否存在"></a>使用 in 判断是否存在</h3><p>如果你希望判断某一个键是否存在于一个字典中，可以使用 in。</p><pre><code>&gt;&gt;&gt; d = {&quot;l1&quot;:1, &quot;l2&quot;:2, &quot;l3&quot;:3}&gt;&gt;&gt; d{&apos;l1&apos;: 1, &apos;l3&apos;: 3, &apos;l2&apos;: 2}&gt;&gt;&gt; 1 in dFalse&gt;&gt;&gt; &quot;l1&quot; in dTrue&gt;&gt;&gt; &quot;l4&quot; in dFalse</code></pre><h3 id="使用-keys-获取元素"><a href="#使用-keys-获取元素" class="headerlink" title="使用 keys() 获取元素"></a>使用 keys() 获取元素</h3><pre><code>&gt;&gt;&gt; d = {&quot;l1&quot;:1, &quot;l2&quot;:2, &quot;l3&quot;:3}&gt;&gt;&gt; d.keys()dict_keys([&apos;l1&apos;, &apos;l3&apos;, &apos;l2&apos;])</code></pre><h3 id="使用-values-获取所有值"><a href="#使用-values-获取所有值" class="headerlink" title="使用 values() 获取所有值"></a>使用 values() 获取所有值</h3><pre><code>&gt;&gt;&gt; d.values()dict_values([1, 3, 2])</code></pre><h3 id="使用-赋值，使用copy-复制-1"><a href="#使用-赋值，使用copy-复制-1" class="headerlink" title="使用=赋值，使用copy()复制"></a>使用=赋值，使用copy()复制</h3><p>与列表一样，对字典内容进行修改会反应到所有与之相关联的变量名上：</p><pre><code>&gt;&gt;&gt; d = {&quot;l1&quot;:1, &quot;l2&quot;:2, &quot;l3&quot;:3}&gt;&gt;&gt; d2 = d&gt;&gt;&gt; d.update({&quot;14&quot;:4})&gt;&gt;&gt; d{&apos;l1&apos;: 1, &apos;l3&apos;: 3, &apos;14&apos;: 4, &apos;l2&apos;: 2}&gt;&gt;&gt; d2{&apos;l1&apos;: 1, &apos;l3&apos;: 3, &apos;14&apos;: 4, &apos;l2&apos;: 2}</code></pre><p>若想避免这种情况，可以使用 copy() 将字典复制到一个新的字典中：</p><pre><code>&gt;&gt;&gt; d = {&quot;l1&quot;:1, &quot;l2&quot;:2, &quot;l3&quot;:3}&gt;&gt;&gt; d2 = d.copy()&gt;&gt;&gt; d2.update({&quot;14&quot;:5})&gt;&gt;&gt; d{&apos;l3&apos;: 3, &apos;l2&apos;: 2, &apos;l1&apos;: 1}&gt;&gt;&gt; d2{&apos;14&apos;: 5, &apos;l3&apos;: 3, &apos;l1&apos;: 1, &apos;l2&apos;: 2}</code></pre><h3 id="两个列表转换为字典"><a href="#两个列表转换为字典" class="headerlink" title="两个列表转换为字典"></a>两个列表转换为字典</h3><pre><code>&gt;&gt;&gt; l1 = [1,2,3]&gt;&gt;&gt; l2 = [&quot;one&quot;, &quot;two&quot;, &quot;there&quot;]&gt;&gt;&gt; zip(l1,l2)&lt;zip object at 0x0000000003569E08&gt;&gt;&gt;&gt; dict(zip(l1,l2)){1: &apos;one&apos;, 2: &apos;two&apos;, 3: &apos;there&apos;}</code></pre><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><blockquote><p>集合就像舍弃了值，仅剩下键的字典一样。键与键之间也不允许重复。如果你仅仅想知道某一个元素是否存在而不关心其他的，使用集合是个非常好的选择。如果需要为键附加其他信息的话建议使用字典。</p></blockquote><h3 id="使用-set-创建集合"><a href="#使用-set-创建集合" class="headerlink" title="使用 set() 创建集合"></a>使用 set() 创建集合</h3><pre><code>&gt;&gt;&gt; empty_set = set()&gt;&gt;&gt; empty_setset()&gt;&gt;&gt; type(empty_set)&lt;class &apos;set&apos;&gt;</code></pre><blockquote><p>与字典一样，集合是无序的。{} 创建的是一个空字典，这仅仅是因为字典出现的比较早抢占了花括号；因此创建空的集合，使用set()。</p></blockquote><h3 id="使用set-将其他类型转换为集合"><a href="#使用set-将其他类型转换为集合" class="headerlink" title="使用set()将其他类型转换为集合"></a>使用set()将其他类型转换为集合</h3><p><strong>你可以利用已有的列表、字符串、元组或字典的内容来创建集合，其中重复的值会被丢弃。</strong></p><pre><code>&gt;&gt;&gt; set(&apos;letters&apos;){&apos;t&apos;, &apos;s&apos;, &apos;l&apos;, &apos;e&apos;, &apos;r&apos;}</code></pre><p>再试试用列表建立集合：</p><pre><code>&gt;&gt;&gt; set([&apos;one&apos;, &apos;two&apos;, &apos;three&apos;]){&apos;one&apos;, &apos;three&apos;, &apos;two&apos;}</code></pre><p>再看下元组：</p><pre><code>&gt;&gt;&gt; set((&apos;one&apos;, &apos;two&apos;, &apos;three&apos;)){&apos;one&apos;, &apos;three&apos;, &apos;two&apos;}</code></pre><p>当字典作为参数传入set()函数时，只有键会被使用：</p><pre><code>&gt;&gt;&gt; set( {&apos;apple&apos;: &apos;red&apos;, &apos;orange&apos;: &apos;orange&apos;, &apos;cherry&apos;: &apos;red&apos;} ){&apos;apple&apos;, &apos;orange&apos;, &apos;cherry&apos;}</code></pre><h3 id="使用in测试值是否存在"><a href="#使用in测试值是否存在" class="headerlink" title="使用in测试值是否存在"></a>使用in测试值是否存在</h3><pre><code>&gt;&gt;&gt; num_set = {&apos;one&apos;, &apos;two&apos;, &apos;three&apos;}&gt;&gt;&gt; &quot;one&quot; in num_setTrue&gt;&gt;&gt; &quot;four&quot; in num_setFalse</code></pre><h3 id="添加删除数据"><a href="#添加删除数据" class="headerlink" title="添加删除数据"></a>添加删除数据</h3><pre><code>&gt;&gt;&gt; num_set = {&apos;one&apos;, &apos;two&apos;, &apos;three&apos;}&gt;&gt;&gt; num_set.add(&quot;four&quot;) # 增加数据&gt;&gt;&gt; num_set{&apos;four&apos;, &apos;one&apos;, &apos;three&apos;, &apos;two&apos;}&gt;&gt;&gt; num_set{&apos;four&apos;, &apos;one&apos;, &apos;three&apos;, &apos;two&apos;}&gt;&gt;&gt; num_set.remove(&quot;three&quot;) # 删除数据&gt;&gt;&gt; num_set{&apos;four&apos;, &apos;one&apos;, &apos;two&apos;}</code></pre><h3 id="交集和并集"><a href="#交集和并集" class="headerlink" title="交集和并集"></a>交集和并集</h3><pre><code>&gt;&gt;&gt; s1 = set([1, 2, 3])&gt;&gt;&gt; s2 = set([2, 3, 4])&gt;&gt;&gt; s1 &amp; s2{2, 3}&gt;&gt;&gt; s1 | s2{1, 2, 3, 4}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;列表&quot;&gt;&lt;a href=&quot;#列表&quot; class=&quot;headerlink&quot; title=&quot;列表&quot;&gt;&lt;/a&gt;列表&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;列表由一系列按特定顺序排列的元素组成，可以将任何东西加入列表中，其中的元素之间可以没有任何关系。列表非常适合利用顺序和位置定位某一元素，尤其是当元素的顺序或内容经常发生改变时。与字符串不同，列表是可变的。你可以直接对原始列表进行修改:添加新元素、删除 或覆盖已有元素。在列表中，具有相同值的元素允许出现多次。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;常用列表方法&quot;&gt;&lt;a href=&quot;#常用列表方法&quot; class=&quot;headerlink&quot; title=&quot;常用列表方法&quot;&gt;&lt;/a&gt;常用列表方法&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; dir(list)
[&amp;apos;__add__&amp;apos;, &amp;apos;__class__&amp;apos;, &amp;apos;__contains__&amp;apos;,
&amp;apos;__delattr__&amp;apos;, &amp;apos;__delitem__&amp;apos;, &amp;apos;__dir__&amp;apos;,
&amp;apos;__doc__&amp;apos;, &amp;apos;__eq__&amp;apos;, &amp;apos;__format__&amp;apos;, &amp;apos;__ge__&amp;apos;,
&amp;apos;__getattribute__&amp;apos;, &amp;apos;__getitem__&amp;apos;, &amp;apos;__gt__&amp;apos;,
&amp;apos;__hash__&amp;apos;, &amp;apos;__iadd__&amp;apos;, &amp;apos;__imul__&amp;apos;,
&amp;apos;__init__&amp;apos;, &amp;apos;__iter__&amp;apos;, &amp;apos;__le__&amp;apos;,
 &amp;apos;__len__&amp;apos;, &amp;apos;__lt__&amp;apos;, &amp;apos;__mul__&amp;apos;,
&amp;apos;__ne__&amp;apos;, &amp;apos;__new__&amp;apos;, &amp;apos;__reduce__&amp;apos;,
 &amp;apos;__reduce_ex__&amp;apos;, &amp;apos;__repr__&amp;apos;, &amp;apos;__reversed__&amp;apos;
, &amp;apos;__rmul__&amp;apos;, &amp;apos;__setattr__&amp;apos;, &amp;apos;__setitem__&amp;apos;,
&amp;apos;__sizeof__&amp;apos;, &amp;apos;__str__&amp;apos;, &amp;apos;__subclasshook__&amp;apos;,
 &amp;apos;append&amp;apos;, &amp;apos;clear&amp;apos;, &amp;apos;copy&amp;apos;, &amp;apos;count&amp;apos;, &amp;apos;extend&amp;apos;, &amp;apos;index&amp;apos;, &amp;apos;insert&amp;apos;, &amp;apos;pop&amp;apos;, &amp;apos;remove&amp;apos;, &amp;apos;reverse&amp;apos;, &amp;apos;sort&amp;apos;]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;列表切片&quot;&gt;&lt;a href=&quot;#列表切片&quot; class=&quot;headerlink&quot; title=&quot;列表切片&quot;&gt;&lt;/a&gt;列表切片&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;定义列表后，可从其中获取任何部分作为新列表。该技术称为对列表进行切片，对于有序序列，包括字符串，元组都可以切片。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; lists = [&amp;apos;Michael&amp;apos;, &amp;apos;Sarah&amp;apos;, &amp;apos;Tracy&amp;apos;, &amp;apos;Bob&amp;apos;, &amp;apos;Jack&amp;apos;]
&amp;gt;&amp;gt;&amp;gt; lists[0]
&amp;apos;Michael&amp;apos;
&amp;gt;&amp;gt;&amp;gt; lists[1:3] # 切片实际是索引尾部取开区间 [1:3)
[&amp;apos;Sarah&amp;apos;, &amp;apos;Tracy&amp;apos;]
&amp;gt;&amp;gt;&amp;gt; lists[:3]  # 相当于索引lists[0:3]
[&amp;apos;Michael&amp;apos;, &amp;apos;Sarah&amp;apos;, &amp;apos;Tracy&amp;apos;]
&amp;gt;&amp;gt;&amp;gt; lists[0:3]
[&amp;apos;Michael&amp;apos;, &amp;apos;Sarah&amp;apos;, &amp;apos;Tracy&amp;apos;]
&amp;gt;&amp;gt;&amp;gt; lists[-2:] # 取列表最后两个元素
[&amp;apos;Bob&amp;apos;, &amp;apos;Jack&amp;apos;]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;append-向列表尾部追加一个元素&quot;&gt;&lt;a href=&quot;#append-向列表尾部追加一个元素&quot; class=&quot;headerlink&quot; title=&quot;append 向列表尾部追加一个元素&quot;&gt;&lt;/a&gt;append 向列表尾部追加一个元素&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; lists
[&amp;apos;Michael&amp;apos;, &amp;apos;Sarah&amp;apos;, &amp;apos;Tracy&amp;apos;, &amp;apos;Bob&amp;apos;, &amp;apos;Jack&amp;apos;]
&amp;gt;&amp;gt;&amp;gt; lists.append(&amp;apos;chenfan&amp;apos;)
&amp;gt;&amp;gt;&amp;gt; lists
[&amp;apos;Michael&amp;apos;, &amp;apos;Sarah&amp;apos;, &amp;apos;Tracy&amp;apos;, &amp;apos;Bob&amp;apos;, &amp;apos;Jack&amp;apos;, &amp;apos;chenfan&amp;apos;]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;clear-清除列表中的所有元素&quot;&gt;&lt;a href=&quot;#clear-清除列表中的所有元素&quot; class=&quot;headerlink&quot; title=&quot;clear 清除列表中的所有元素&quot;&gt;&lt;/a&gt;clear 清除列表中的所有元素&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; num = [1,2,3,4,5]
&amp;gt;&amp;gt;&amp;gt; num.clear()
&amp;gt;&amp;gt;&amp;gt; num
[]
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="python基础知识" scheme="http://www.chenfanlinux.org/categories/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Python" scheme="http://www.chenfanlinux.org/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python基础之内置数据类型(一)</title>
    <link href="http://www.chenfanlinux.org/2018/02/13/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%80/"/>
    <id>http://www.chenfanlinux.org/2018/02/13/Python基础之内置数据类型-一/</id>
    <published>2018-02-13T14:14:07.000Z</published>
    <updated>2018-02-14T04:20:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在 Python 中， 每个值都有一种数据类型，但您并不需要声明变量的数据类型。那该方式是如何运作的呢？Python 根据每个变量的初始赋值情况分析其类型，并在内部对其进行跟踪。</p></blockquote><h3 id="内置数据类型分类"><a href="#内置数据类型分类" class="headerlink" title="内置数据类型分类"></a>内置数据类型分类</h3><ul><li>Booleans［布尔型］ 或为 True［真］ 或为 False［假］</li><li>Numbers［数值型］ 可以是 Integers［整数］（1 和 2）、Floats［浮点数］（1.1 和 1.2）、Fractions［分数］（1/2 和 2/3）；甚至是 Complex Number［复数］</li><li>Strings［字符串型］ 是 Unicode 字符序列，例如： 一份 html 文档</li><li>Bytes［字节］ 和 Byte Arrays［字节数组］， 例如: 一份 jpeg 图像文件</li><li>Lists［列表］ 是值的有序序列</li><li>Tuples［元组］ 是有序而不可变的值序列</li><li>Sets［集合］ 是装满无序值的包裹</li><li>Dictionaries［字典］ 是键值对的无序包裹</li></ul><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><p><strong>布尔类型或为真或为假。Python 有两个被巧妙地命名为 True 和 False 的常量，可用于对布尔类型的直接赋值。表达式也可以计算为布尔类型的值。数字 0、None、以及元素为空的容器类对象都可视作 bool False，反之为 True。</strong></p><pre><code>&gt;&gt;&gt; bool(0)False&gt;&gt;&gt; bool(None)False&gt;&gt;&gt; bool([])False&gt;&gt;&gt; bool({})False&gt;&gt;&gt; bool(1)True&gt;&gt;&gt; bool([1,2])True</code></pre><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><p>python本身支持整数以及浮点数。你可以对这些数字进行下表中的计算。</p><p><img src="https://s1.ax1x.com/2018/02/13/9YZkc9.png" alt="数字类型"></p><a id="more"></a><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>任何仅含数字的序列在 Python 中都被认为是整数</p><pre><code>&gt;&gt;&gt; 55</code></pre><p>Python还支持运算次序，因此你可在同一个表达式中使用多种运算。你还可以使用括号来修 改运算次序，让Python按你指定的次序执行运算，如下所示:</p><pre><code>&gt;&gt;&gt; 2 + 3 * 414&gt;&gt;&gt; (2 + 3) * 420</code></pre><p>在这些示例中，空格不影响Python计算表达式的方式，它们的存在旨在让你阅读代码时，能迅速确定先执行哪些运算。</p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p><strong>Python将带小数点的数字都称为浮点数。大多数编程语言都使用了这个术语，它指出了这样一个事实:小数点可出现在数字的任何位置。</strong></p><pre><code>&gt;&gt;&gt; 0.1 + 0.10.2&gt;&gt;&gt; 2 * 0.10.2</code></pre><p>但需要注意的是，结果包含的小数位数可能是不确定的:</p><pre><code>&gt;&gt;&gt; 3 * 0.10.30000000000000004&gt;&gt;&gt; 0.2 + 0.10.30000000000000004&gt;&gt;&gt; 4 * 0.10.4</code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是由多个字符组成的序列。在Python中，用引号括起的都是字符串，字符串定义简单自由，可以是单引号、双引号或者三引号。字符串是不可变序列（immutable, sequence）类型，默认存储 Unicode 文本。</p><h3 id="字符串使用"><a href="#字符串使用" class="headerlink" title="字符串使用"></a>字符串使用</h3><pre><code>&gt;&gt;&gt; s = &quot;chenfanlinux博客&quot;&gt;&gt;&gt; len(s)14&gt;&gt;&gt; print(ascii(s))&apos;chenfanlinux\u535a\u5ba2&apos;</code></pre><p>内置函数 ascii 将目标转换为可打印 ASCII 字符组成的字符串。</p><p><strong>构建字符串很容易，单引号、双引号，以及跨行的三个引号。</strong></p><pre><code>&gt;&gt;&gt; &quot;ab&apos;c&quot;  #双引号&quot;ab&apos;c&quot;&gt;&gt;&gt; &apos;ab&quot;c&quot;&apos; #单引号&apos;ab&quot;c&quot;&gt;&gt;&gt; &quot;&quot;&quot; abc #多行efdhij&quot;&quot;&quot;&apos; abc\nefd\nhij\n&apos;&gt;&gt;&gt; &apos;ab\&apos;c&apos; #引号转义&quot;ab&apos;c&quot;</code></pre><p><strong>可在字面量前添加特殊指示符。</strong></p><pre><code>&gt;&gt;&gt; print(r&quot;abc\nd&quot;)  # raw string，禁用转义。abc\nd&gt;&gt;&gt; type(b&quot;ab&quot;)&lt;class &apos;bytes&apos;&gt;&gt;&gt;&gt; type(u&quot;ab&quot;)&lt;class &apos;str&apos;&gt;</code></pre><h3 id="str-类型转换"><a href="#str-类型转换" class="headerlink" title="str() 类型转换"></a>str() 类型转换</h3><pre><code>&gt;&gt;&gt; &quot;abc&quot; + str(2.2)&apos;abc2.2&apos;</code></pre><h3 id="合并字符串"><a href="#合并字符串" class="headerlink" title="合并字符串"></a>合并字符串</h3><h4 id="format格式化输出-推荐使用"><a href="#format格式化输出-推荐使用" class="headerlink" title="format格式化输出(推荐使用)"></a>format格式化输出(推荐使用)</h4><pre><code>&gt;&gt;&gt; &quot;谁的博客很酷: {}&quot;.format(&quot;陈凡&quot;)&apos;谁的博客很酷: 陈凡&apos;&gt;&gt;&gt; s =&quot;&quot;&quot;你的名字是: {};你的工资是多少: {};你是做什么工作的: {}&quot;&quot;&quot;.format(&quot;陈凡&quot;,&quot;不告诉你&quot;,&quot;运维&quot;)&gt;&gt;&gt; print(s)你的名字是: 陈凡;你的工资是多少: 不告诉你;你是做什么工作的: 运维&gt;&gt;&gt; &quot;你喜欢什么音乐:{0} 你的偶像是谁:{1}&quot;.format(&quot;戒指&quot;,&quot;你猜&quot;)&apos;你喜欢什么音乐:戒指 你的偶像是谁:你猜&apos;</code></pre><h4 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="% 字符串格式化"></a>% 字符串格式化</h4><pre><code>&gt;&gt;&gt; msg = &quot;my name is %s and weight is %d kg!&quot; %(&quot;chenfan&quot;,120)&gt;&gt;&gt; print(msg)my name is chenfan and weight is 120 kg!</code></pre><h4 id=""><a href="#" class="headerlink" title="+"></a>+</h4><pre><code>&gt;&gt;&gt; &quot;欢迎来到:&quot; + &quot;www.chenfanlinux.org&quot;&apos;欢迎来到:www.chenfanlinux.org&apos;</code></pre><h3 id="split-分割"><a href="#split-分割" class="headerlink" title="split() 分割"></a>split() 分割</h3><pre><code>&gt;&gt;&gt; (man,said) = &quot;chenfan : welcome to my bolg:www.chenfanlinu.org&quot;.split(&apos;:&apos;,1)&gt;&gt;&gt; print(man)chenfan&gt;&gt;&gt; print(said) welcome to my bolg:www.chenfanlinu.org</code></pre><h3 id="strip-移除头尾的字符串"><a href="#strip-移除头尾的字符串" class="headerlink" title="strip() 移除头尾的字符串"></a>strip() 移除头尾的字符串</h3><pre><code>&gt;&gt;&gt; &quot; www.chenfanlinux.org &quot;.strip()  # 注意只能移除头部和尾部字符串&apos;www.chenfanlinux.org&apos;&gt;&gt; &quot;www.chenfanlinux. org&quot;.strip() # 这种空格无法移除www.chenfanlinux. org&apos;&gt;&gt;&gt; &quot;www.chenfanlinux.org&quot;.strip(&quot;www.&quot;)&apos;chenfanlinux.org&apos;</code></pre><h3 id="join-合并列表"><a href="#join-合并列表" class="headerlink" title="join() 合并列表"></a>join() 合并列表</h3><pre><code>&gt;&gt;&gt; path = [&quot;/etc&quot;, &quot;nginx&quot;, &quot;nginx.conf&quot; ]&gt;&gt;&gt; &apos;/&apos;.join(path)&apos;/etc/nginx/nginx.conf&apos;</code></pre><h3 id="find-查找子串"><a href="#find-查找子串" class="headerlink" title="find 查找子串"></a>find 查找子串</h3><p><strong>查找到返回该子串在原字符串中的索引位置，如果无法找到，find方法会返回值-1</strong></p><pre><code>&gt;&gt;&gt; s = &quot;www.chenfanlinux.org&quot;&gt;&gt;&gt; s.find(&quot;chenfan&quot;)  #访问索引位置4&gt;&gt;&gt; s.find(&quot;chenfanfan&quot;) # 未找到返回-1-1</code></pre><h3 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h3><p><strong>存在索引的数据类型，包括字符串,列表和元组都可以做切片操作</strong></p><pre><code>&gt;&gt;&gt; s = &quot;www.chenfanlinux.org&quot;&gt;&gt;&gt; s[0]&apos;w&apos;&gt;&gt;&gt; s[0:5]&apos;www.c&apos;&gt;&gt;&gt; s[-1]&apos;g&apos;</code></pre><h3 id="字符串运算符总结"><a href="#字符串运算符总结" class="headerlink" title="字符串运算符总结"></a>字符串运算符总结</h3><p>下表实例变量 a 值为字符串 “Hello”，b 变量值为 “Python”<br><img src="https://s1.ax1x.com/2018/02/13/9YVUSJ.png" alt="字符串运算符"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在 Python 中， 每个值都有一种数据类型，但您并不需要声明变量的数据类型。那该方式是如何运作的呢？Python 根据每个变量的初始赋值情况分析其类型，并在内部对其进行跟踪。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;内置数据类型分类&quot;&gt;&lt;a href=&quot;#内置数据类型分类&quot; class=&quot;headerlink&quot; title=&quot;内置数据类型分类&quot;&gt;&lt;/a&gt;内置数据类型分类&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Booleans［布尔型］ 或为 True［真］ 或为 False［假］&lt;/li&gt;
&lt;li&gt;Numbers［数值型］ 可以是 Integers［整数］（1 和 2）、Floats［浮点数］（1.1 和 1.2）、Fractions［分数］（1/2 和 2/3）；甚至是 Complex Number［复数］&lt;/li&gt;
&lt;li&gt;Strings［字符串型］ 是 Unicode 字符序列，例如： 一份 html 文档&lt;/li&gt;
&lt;li&gt;Bytes［字节］ 和 Byte Arrays［字节数组］， 例如: 一份 jpeg 图像文件&lt;/li&gt;
&lt;li&gt;Lists［列表］ 是值的有序序列&lt;/li&gt;
&lt;li&gt;Tuples［元组］ 是有序而不可变的值序列&lt;/li&gt;
&lt;li&gt;Sets［集合］ 是装满无序值的包裹&lt;/li&gt;
&lt;li&gt;Dictionaries［字典］ 是键值对的无序包裹&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;布尔类型&quot;&gt;&lt;a href=&quot;#布尔类型&quot; class=&quot;headerlink&quot; title=&quot;布尔类型&quot;&gt;&lt;/a&gt;布尔类型&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;布尔类型或为真或为假。Python 有两个被巧妙地命名为 True 和 False 的常量，可用于对布尔类型的直接赋值。表达式也可以计算为布尔类型的值。数字 0、None、以及元素为空的容器类对象都可视作 bool False，反之为 True。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; bool(0)
False
&amp;gt;&amp;gt;&amp;gt; bool(None)
False
&amp;gt;&amp;gt;&amp;gt; bool([])
False
&amp;gt;&amp;gt;&amp;gt; bool({})
False
&amp;gt;&amp;gt;&amp;gt; bool(1)
True
&amp;gt;&amp;gt;&amp;gt; bool([1,2])
True
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;数字类型&quot;&gt;&lt;a href=&quot;#数字类型&quot; class=&quot;headerlink&quot; title=&quot;数字类型&quot;&gt;&lt;/a&gt;数字类型&lt;/h2&gt;&lt;p&gt;python本身支持整数以及浮点数。你可以对这些数字进行下表中的计算。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/02/13/9YZkc9.png&quot; alt=&quot;数字类型&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python基础知识" scheme="http://www.chenfanlinux.org/categories/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Python" scheme="http://www.chenfanlinux.org/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>SQL查询语句及视图(三)</title>
    <link href="http://www.chenfanlinux.org/2018/02/05/SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E5%8F%8A%E8%A7%86%E5%9B%BE-%E4%B8%89/"/>
    <id>http://www.chenfanlinux.org/2018/02/05/SQL查询语句及视图-三/</id>
    <published>2018-02-05T06:57:20.000Z</published>
    <updated>2018-02-05T06:59:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a><a href="http://dev.mysql.com/doc/refman/5.7/en/subqueries.html" target="_blank" rel="noopener">SELECT</a></h2><h3 id="SELECT语法格式"><a href="#SELECT语法格式" class="headerlink" title="SELECT语法格式"></a>SELECT语法格式</h3><pre><code>SELECT values_to_display    FROM table_name    WHERE expression    GROUP BY how_to_group    HAVING expression    ORDER BY how_to_sort    LIMIT row_count;</code></pre><ul><li>SELECT子句：指定要显示的属性列</li><li>FROM子句：指定查询的对象(基本表或视图)</li><li>WHERE子句：指定查询的条件</li><li>GROUP BY子句：对查询的结果按指定列的值分组,该属性列值相等的记录为一组。通常会在每组中作用聚集函数</li><li>HAVING短语：只有满足指定条件的组才予以输出，对聚集计算的结果做过滤</li><li>ORDER BY子句：对查询结果按指定的列升序（ASC）或者降序（DESC）排序</li><li>LIMIT num ： 限制操作的行</li><li>执行过程： FROM –&gt; WHERE –&gt; GROUP BY –&gt; HAVING –&gt; ORDER BY –&gt; SELECT –&gt; LIMIT</li></ul><p><strong>WHERE expression: 比较表达式，内置函数；</strong></p><p><img src="https://s1.ax1x.com/2018/02/02/9EvdV1.png" alt=""></p><ul><li><p>特殊的比较操作符：</p><ul><li>BETWEEN… AND …:</li><li>IN：指定范围内值的存在性测试</li><li>IN(list): 指定的字段取的取值在此list中，则表示符合条件；</li><li>IS NULL</li><li>IS NOT NULL</li><li>LIKE：可使用通配符，%, _</li><li>RLIKE或REGEXP：可使用正则表达式的模式</li></ul></li><li><p>逻辑操作符：</p><ul><li>AND</li><li>OR</li><li>NOT</li></ul></li></ul><a id="more"></a><h3 id="创建用于查询的表"><a href="#创建用于查询的表" class="headerlink" title="创建用于查询的表"></a>创建用于查询的表</h3><h4 id="学生表"><a href="#学生表" class="headerlink" title="学生表"></a>学生表</h4><p><strong>Student(Sno,Sname,Ssex,Sage,Sdept)</strong></p><pre><code>mysql&gt; CREATE TABLE Student    -&gt; (Sno CHAR(9) PRIMARY KEY,    -&gt; Sname CHAR(20)   UNIQUE,    -&gt; Ssex CHAR(2),    -&gt; Sage SMALLINT,    -&gt; Sdept CHAR(20)    -&gt; );Query OK, 0 rows affected (0.07 sec)mysql&gt; DESC student;+-------+-------------+------+-----+---------+-------+| Field | Type        | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| Sno   | char(9)     | NO   | PRI | NULL    |       || Sname | char(20)    | YES  | UNI | NULL    |       || Ssex  | char(2)     | YES  |     | NULL    |       || Sage  | smallint(6) | YES  |     | NULL    |       || Sdept | char(20)    | YES  |     | NULL    |       |+-------+-------------+------+-----+---------+-------+mysql&gt; INSERT INTO Student VALUES  (&apos;201215121&apos;,&apos;李勇&apos;,&apos;男&apos;,19,&apos;CS&apos;), (&apos;201215122&apos;,&apos;刘晨&apos;,&apos;女&apos;,19,&apos;CS&apos;),(&apos;201215123&apos;,&apos;王敏&apos;,&apos;女&apos;,18,&apos;MA&apos;),(&apos;201215125&apos;,&apos;张立&apos;,&apos;男&apos;,19,&apos;IS&apos;);mysql&gt; SELECT * FROM Student;+-----------+-------+------+------+-------+| Sno       | Sname | Ssex | Sage | Sdept |+-----------+-------+------+------+-------+| 201215121 | 李勇  | 男   |   20 | CS    || 201215122 | 刘晨  | 女   |   19 | CS    || 201215123 | 王敏  | 女   |   18 | MA    || 201215125 | 张立  | 男   |   19 | IS    |+-----------+-------+------+------+-------+4 rows in set (0.00 sec)</code></pre><h4 id="课程表"><a href="#课程表" class="headerlink" title="课程表"></a>课程表</h4><p><strong>Course(Cno,Cname,Cpno,Ccredit)</strong></p><pre><code>mysql&gt; CREATE TABLE Course    -&gt; (Cno CHAR(4) PRIMARY KEY,    -&gt; Cname CHAR(40),    -&gt; Cpno CHAR(4),    -&gt; Ccredit SMALLINT,    -&gt; FOREIGN KEY(Cpno) REFERENCES Course(Cno)    -&gt; ); // Cpno是外码,被参照表的Course,被参照列是Cnomysql&gt; INSERT INTO Course (Cno,Cname,Ccredit) VALUES (&apos;1&apos;,&apos;数据库&apos;,4),    -&gt; (&apos;2&apos;,&apos;数学&apos;,2),(&apos;3&apos;,&apos;信息系统&apos;,4),(&apos;4&apos;,&apos;操作系统&apos;,3),(&apos;5&apos;,&apos;数据结构&apos;,4),    -&gt; (&apos;6&apos;,&apos;数据处理&apos;,2),(&apos;7&apos;,&apos;PASCAL语言&apos;,4);Query OK, 7 rows affected (0.18 sec)Records: 7  Duplicates: 0  Warnings: 0mysql&gt; UPDATE course SET cpno=&apos;5&apos; WHERE Cno=&apos;1&apos;;mysql&gt; UPDATE course SET cpno=&apos;1&apos; WHERE Cno=&apos;3&apos;;mysql&gt; UPDATE course SET cpno=&apos;6&apos; WHERE Cno=&apos;4&apos;;mysql&gt; UPDATE course SET cpno=&apos;7&apos; WHERE Cno=&apos;5&apos;;mysql&gt; UPDATE course SET cpno=&apos;6&apos; WHERE Cno=&apos;7&apos;;mysql&gt; SELECT * FROM Course;+-----+------------+------+---------+| Cno | Cname      | Cpno | Ccredit |+-----+------------+------+---------+| 1   | 数据库     | 5    |       4 || 2   | 数学       | NULL |       2 || 3   | 信息系统   | 1    |       4 || 4   | 操作系统   | 6    |       3 || 5   | 数据结构   | 7    |       4 || 6   | 数据处理   | NULL |       2 || 7   | PASCAL语言 | 6    |       4 |+-----+------------+------+---------+7 rows in set (0.00 sec)</code></pre><h4 id="选课表"><a href="#选课表" class="headerlink" title="选课表"></a>选课表</h4><p><strong>SC(Sno,Cno,Grade)</strong></p><pre><code>mysql&gt; CREATE TABLE SC    -&gt; (Sno CHAR(9),    -&gt; Cno CHAR(4),    -&gt; Grade SMALLINT,    -&gt; PRIMARY KEY(Sno,Cno),     /* 主码由两个属性构成，必须作为表级完整性进行定义*/    -&gt; FOREIGN KEY(Sno) REFERENCES Student(Sno),     /* 表级完整性约束条件， Sno是外码，被参照表是Student */    -&gt; FOREIGN KEY(Cno) REFERENCES Course(Cno)     /* 表级完整性约束条件， Cno是外码，被参照表是Course*/    -&gt; );mysql&gt; INSERT INTO sc VALUES (&apos;201215121&apos;,&apos;1&apos;,92),(&apos;201215121&apos;,&apos;2&apos;,85),(&apos;201215121&apos;,&apos;3&apos;,88),(&apos;201215122&apos;,&apos;2&apos;,90),(&apos;201215122&apos;,&apos;3&apos;,80);mysql&gt; SELECT * FROM sc;+-----------+-----+-------+| Sno       | Cno | Grade |+-----------+-----+-------+| 201215121 | 1   |    92 || 201215121 | 2   |    85 || 201215121 | 3   |    88 || 201215122 | 2   |    90 || 201215122 | 3   |    80 |+-----------+-----+-------+</code></pre><h2 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h2><h3 id="查询表中的若干列"><a href="#查询表中的若干列" class="headerlink" title="查询表中的若干列"></a>查询表中的若干列</h3><p><strong>查询指定的列</strong><br>查询全体学生的学号与姓名：</p><pre><code>mysql&gt; SELECT Sno,Sname FROM Student;+-----------+-------+| Sno       | Sname |+-----------+-------+| 201215122 | 刘晨  || 201215125 | 张立  || 201215121 | 李勇  || 201215123 | 王敏  |+-----------+-------+4 rows in set (0.00 sec)</code></pre><p><strong>查询全部的列</strong><br>查询全体学生的详细记录：</p><pre><code>mysql&gt; SELECT * FROM Student;+-----------+-------+------+------+-------+| Sno       | Sname | Ssex | Sage | Sdept |+-----------+-------+------+------+-------+| 201215121 | 李勇  | 男   |   20 | CS    || 201215122 | 刘晨  | 女   |   19 | CS    || 201215123 | 王敏  | 女   |   18 | MA    || 201215125 | 张立  | 男   |   19 | IS    |+-----------+-------+------+------+-------+4 rows in set (0.00 sec)</code></pre><p><strong>查询经过计算的值</strong></p><blockquote><p>SELECT子句的&lt;目标列表达式&gt;不仅可以为表中的属性列， 也可以是表达式</p></blockquote><p>查全体学生的姓名及其出生年份：</p><pre><code>mysql&gt; SELECT Sname,2017-Sage FROM Student;+-------+-----------+| Sname | 2017-Sage |+-------+-----------+| 李勇  |      1997 || 刘晨  |      1998 || 王敏  |      1999 || 张立  |      1998 |+-------+-----------+</code></pre><p>查询全体学生的姓名、 出生年份和所在的院系， 要<br>求用小写字母表示系名：</p><pre><code>mysql&gt; SELECT Sname,&apos;出生年份:&apos;,2017-Sage,LOWER(Sdept) FROM Student;+-------+-----------+-----------+--------------+| Sname | 出生年份: | 2017-Sage | LOWER(Sdept) |+-------+-----------+-----------+--------------+| 李勇  | 出生年份: |      1997 | cs           || 刘晨  | 出生年份: |      1998 | cs           || 王敏  | 出生年份: |      1999 | ma           || 张立  | 出生年份: |      1998 | is           |+-------+-----------+-----------+--------------+</code></pre><p>使用列别名改变查询结果的列标题:</p><pre><code>mysql&gt; SELECT Sname NAME,&apos;出生年份:&apos; BIRTH,2017-Sage BIRTHDAY,LOWER(Sdept) DEPARTMENTFROM Student;+------+-----------+----------+------------+| NAME | BIRTH     | BIRTHDAY | DEPARTMENT |+------+-----------+----------+------------+| 李勇 | 出生年份: |     1997 | cs         || 刘晨 | 出生年份: |     1998 | cs         || 王敏 | 出生年份: |     1999 | ma         || 张立 | 出生年份: |     1998 | is         |+------+-----------+----------+------------+</code></pre><h3 id="选择表中的若干元组"><a href="#选择表中的若干元组" class="headerlink" title="选择表中的若干元组"></a>选择表中的若干元组</h3><p><strong>消除取值重复的行</strong></p><blockquote><p>指定DISTINCT关键词，去掉表中重复的行,如果没有指定DISTINCT关键词，则缺省为ALL</p></blockquote><pre><code>mysql&gt; SELECT  Sno FROM Sc;+-----------+| Sno       |+-----------+| 201215121 || 201215121 || 201215122 || 201215121 || 201215122 |+-----------+5 rows in set (0.00 sec)mysql&gt; SELECT  DISTINCT Sno FROM Sc;+-----------+| Sno       |+-----------+| 201215121 || 201215122 |+-----------+2 rows in set (0.18 sec)</code></pre><p><strong>查询符合条件的行</strong></p><p>（1）比较大小</p><pre><code>// 查询计算机科学系全体学生的名单：mysql&gt; SELECT Sname FROM student WHERE Sdept=&apos;CS&apos;;+-------+| Sname |+-------+| 李勇  || 刘晨  |+-------+// 查询所有年龄在20岁以下的学生姓名及其年龄:mysql&gt; SELECT Sname,Sage FROM student WHERE Sage&lt;20;+-------+------+| Sname | Sage |+-------+------+| 刘晨  |   19 || 王敏  |   18 || 张立  |   19 |+-------+------+// 查询考试成绩及格的学生的学号:mysql&gt; SELECT DISTINCT Sno FROM sc WHERE Grade&gt;60;+-----------+| Sno       |+-----------+| 201215121 || 201215122 |+-----------+</code></pre><p>  (2) 确定范围  BETWEEN … AND …  NOT BETWEEN … AND …</p><pre><code>// 查询年龄在20~23岁（包括20岁和23岁）之间的学生的姓名、系别和年龄:mysql&gt; SELECT Sname,Sdept,Sage FROM student WHERE Sage BETWEEN 20 AND 23;+-------+-------+------+| Sname | Sdept | Sage |+-------+-------+------+| 李勇  | CS    |   20 |+-------+-------+------+// 查询年龄不在20~23岁之间的学生姓名、 系别和年龄:mysql&gt; SELECT Sname,Sdept,Sage FROM student WHERE Sage NOT  BETWEEN 20 AND 23;+-------+-------+------+| Sname | Sdept | Sage |+-------+-------+------+| 刘晨  | CS    |   19 || 王敏  | MA    |   18 || 张立  | IS    |   19 |+-------+-------+------+</code></pre><p>  (3) 确定集合  IN &lt;值表&gt;, NOT IN &lt;值表&gt;</p><pre><code>// 查询计算机科学系（ CS）、数学系（ MA）和信息系（ IS）学生的姓名和性别:mysql&gt; SELECT Sname Ssex FROM student WHERE Sdept in (&apos;CS&apos;,&apos;MA&apos;,&apos;IS&apos;);+------+| Ssex |+------+| 李勇 || 刘晨 || 王敏 || 张立 |+------+// 查询既不是计算机科学系、 也不是数学系的学生的姓名和性别:mysql&gt; SELECT Sname Ssex FROM student WHERE Sdept not in (&apos;CS&apos;,&apos;MA&apos;);+------+| Ssex |+------+| 张立 |+------+</code></pre><p> （4）字符匹配 [NOT] LIKE ‘&lt;匹配串&gt;’ [ESCAPE ‘ &lt;换码字符&gt;’]</p><pre><code>// &lt;匹配串&gt;可以是一个完整的字符串， 也可以含有通配符%和 _// 查询所有姓刘学生的姓名、学号和性别mysql&gt; SELECT Sname,Sno,Ssex FROM student WHERE Sname LIKE &apos;刘%&apos;;+-------+-----------+------+| Sname | Sno       | Ssex |+-------+-----------+------+| 刘晨  | 201215122 | 女   |+-------+-----------+------+// 查询所有不姓刘的学生姓名、学号和性别:mysql&gt; SELECT Sname,Sno,Ssex FROM student WHERE Sname NOT LIKE &apos;刘_&apos;;+-------+-----------+------+| Sname | Sno       | Ssex |+-------+-----------+------+| 李勇  | 201215121 | 男   || 王敏  | 201215123 | 女   || 张立  | 201215125 | 男   |+-------+-----------+------+</code></pre><p>   (5) 涉及空值的查询 IS NULL 或 IS NOT NULL ,“IS” 不能用 “ =” 代替</p><pre><code>// 查询缺少成绩的学生的学号和相应的课程号:mysql&gt; INSERT INTO sc (Sno,Cno) VALUES(&apos;201215125&apos;,&apos;2&apos;);mysql&gt; SELECT Sno,Cno FROM sc WHERE Grade IS NULL;    +-----------+-----+| Sno       | Cno |+-----------+-----+| 201215125 | 2   |+-----------+-----+</code></pre><p>  (6) 逻辑运算符： AND和 OR来连接多个查询条件</p><pre><code> // 查询计算机系年龄在20岁以下的学生姓名: mysql&gt; SELECT Sname FROM student WHERE Sdept=&apos;CS&apos; AND Sage &lt;20;+-------+| Sname |+-------+| 刘晨  |+-------+// 查询计算机科学系（ CS）和数学系（ MA））学生的姓名和性别:mysql&gt; SELECT Sname,Ssex FROM student WHERE Sdept=&apos;CS&apos; or Sdept=&apos;MA&apos; ;+-------+------+| Sname | Ssex |+-------+------+| 李勇  | 男   || 刘晨  | 女   || 王敏  | 女   |+-------+------+mysql&gt; SELECT Sname,Ssex FROM student WHERE Sdept IN (&apos;CS&apos;,&apos;MA&apos;);+-------+------+| Sname | Ssex |+-------+------+| 李勇  | 男   || 刘晨  | 女   || 王敏  | 女   |+-------+------+</code></pre><h3 id="ORDER-BY子句"><a href="#ORDER-BY子句" class="headerlink" title="ORDER BY子句"></a>ORDER BY子句</h3><blockquote><p>可以按一个或多个属性列排序,升序： ASC;降序： DESC;缺省值为升序</p></blockquote><pre><code>// 查询选修了3号课程的学生的学号及其成绩， 查询结果按分数降序排列:mysql&gt; SELECT Sno,Grade FROM SC WHERE Cno=&apos;3&apos; ORDER BY Grade DESC;+-----------+-------+| Sno       | Grade |+-----------+-------+| 201215121 |    88 || 201215122 |    80 |+-----------+-------+// 查询全体学生情况，查询结果按所在系的系号升序排列，同一系中的学生按年龄降序排列。mysql&gt; SELECT * FROM student ORDER BY Sdept,Sage DESC;+-----------+-------+------+------+-------+| Sno       | Sname | Ssex | Sage | Sdept |+-----------+-------+------+------+-------+| 201215121 | 李勇  | 男   |   20 | CS    || 201215122 | 刘晨  | 女   |   19 | CS    || 201215125 | 张立  | 男   |   19 | IS    || 201215123 | 王敏  | 女   |   18 | MA    |+-----------+-------+------+------+-------+</code></pre><h3 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h3><ul><li>统计记录个数<ul><li>COUNT(*)</li></ul></li><li>统计一列中值的个数<ul><li>COUNT([DISTINCT|ALL] &lt;列名&gt;)</li></ul></li><li>计算一列值的总和（ 此列必须为数值型）<ul><li>SUM([DISTINCT|ALL] &lt;列名&gt;)</li></ul></li><li>计算一列值的平均值（ 此列必须为数值型）<ul><li>AVG([DISTINCT|ALL] &lt;列名&gt;)</li></ul></li><li>求一列中的最大值和最小值<ul><li>MAX([DISTINCT|ALL] &lt;列名&gt;)</li><li>MIN([DISTINCT|ALL] &lt;列名&gt;)</li></ul></li></ul><p><strong>范例：</strong></p><pre><code>// 查询学生总人数mysql&gt; SELECT COUNT(*) FROM Student;+----------+| COUNT(*) |+----------+|        4 |+----------+// 查询选修了课程的学生人数mysql&gt; SELECT COUNT(DISTINCT Sno) FROM SC;+---------------------+| COUNT(DISTINCT Sno) |+---------------------+|                   3 |+---------------------+// 计算1号课程的学生平均成绩mysql&gt; SELECT AVG(Grade) FROM SC WHERE Cno=&apos;1&apos;;+------------+| AVG(Grade) |+------------+|    92.0000 |+------------+// 查询选修2号课程的学生最高分数mysql&gt; SELECT MAX(Grade) FROM SC WHERE Cno=&apos;2&apos;;+------------+| MAX(Grade) |+------------+|         90 |+------------+</code></pre><h3 id="GROUP-BY子句"><a href="#GROUP-BY子句" class="headerlink" title="GROUP BY子句"></a>GROUP BY子句</h3><blockquote><p>细化聚集函数的作用对象</p></blockquote><ul><li>如果未对查询结果分组， 聚集函数将作用于整个查询结果</li><li>对查询结果分组后，聚集函数将分别作用于每个组</li><li>按指定的一列或多列值分组，值相等的为一组</li></ul><p><strong>范例：</strong></p><pre><code>// 求各个课程号及相应的选课人数mysql&gt; SELECT Cno,COUNT(Sno) FROM SC GROUP BY Cno;+-----+------------+| Cno | COUNT(Sno) |+-----+------------+| 1   |          1 || 2   |          3 || 3   |          2 |+-----+------------+// 查询选修了2门以上课程的学生学号mysql&gt; SELECT Sno FROM SC GROUP BY Sno HAVING COUNT(*)&gt;2;+-----------+| Sno       |+-----------+| 201215121 |+-----------+// 查询平均成绩大于等于80分的学生学号和平均成绩mysql&gt; SELECT Sno,AVG(Grade) FROM SC GROUP BY Sno HAVING AVG(Grade)&gt;=80;+-----------+------------+| Sno       | AVG(Grade) |+-----------+------------+| 201215121 |    88.3333 || 201215122 |    85.0000 |+-----------+------------+</code></pre><p><strong><em>注意：WHERE子句中是不能用聚集函数作为条件表达式，使用HAVING子句做过滤。</em></strong></p><p><strong>HAVING短语与WHERE子句的区别：</strong></p><ul><li>作用对象不同</li><li>WHERE子句作用于基表或视图， 从中选择满足条件的元组</li><li>HAVING短语作用于组， 从中选择满足条件的组。</li></ul><h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><blockquote><p>同时涉及两个以上的表的查询,使用连接条件同时将两个表连接起来。</p></blockquote><p><strong>连接条件的格式：</strong></p><ul><li>[&lt;表名1&gt;.]&lt;列名1&gt;  &lt;比较运算符&gt;  [&lt;表名2&gt;.]&lt;列名2&gt;</li><li>[&lt;表名1&gt;.]&lt;列名1&gt;  BETWEEN   [&lt;表名2&gt;.]&lt;列名2&gt; AND [&lt;表名2&gt;.]&lt;列名3&gt;</li></ul><p><strong><em>连接条件中的各连接字段类型必须是可比的， 但名字不必相同。</em></strong></p><h3 id="等值与非等值连接查询-内连接"><a href="#等值与非等值连接查询-内连接" class="headerlink" title="等值与非等值连接查询(内连接)"></a>等值与非等值连接查询(内连接)</h3><p><strong>等值连接：连接运算符为=</strong></p><pre><code>// 查询每个学生及其选修课程的情况mysql&gt; SELECT Student.*,SC.* FROM Student,SC WHERE Student.Sno=sc.Sno;+-----------+-------+------+------+-------+-----------+-----+-------+| Sno       | Sname | Ssex | Sage | Sdept | Sno       | Cno | Grade |+-----------+-------+------+------+-------+-----------+-----+-------+| 201215121 | 李勇  | 男   |   20 | CS    | 201215121 | 1   |    92 || 201215121 | 李勇  | 男   |   20 | CS    | 201215121 | 2   |    85 || 201215121 | 李勇  | 男   |   20 | CS    | 201215121 | 3   |    88 || 201215122 | 刘晨  | 女   |   19 | CS    | 201215122 | 2   |    90 || 201215122 | 刘晨  | 女   |   19 | CS    | 201215122 | 3   |    80 || 201215125 | 张立  | 男   |   19 | IS    | 201215125 | 2   |  NULL |+-----------+-------+------+------+-------+-----------+-----+-------+</code></pre><p><strong>连接操作的执行过程:</strong></p><ul><li><a href="https://www.chinadb.org/home/nav/5/sub/25/third/110" target="_blank" rel="noopener">嵌套循环法</a>（ NESTED-LOOP）</li><li><a href="https://www.chinadb.org/home/nav/5/sub/25/third/111" target="_blank" rel="noopener">排序合并法</a>（ SORT-MERGE）</li><li><a href="https://www.chinadb.org/home/nav/5/sub/25/third/112" target="_blank" rel="noopener">散列连接</a> (HASH-JOIN)</li><li><a href="https://www.chinadb.org/home/nav/5/sub/25/third/113" target="_blank" rel="noopener">索引连接</a>（ INDEX-JOIN）</li></ul><h4 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h4><pre><code>// 使用自然连接,查询每个学生及其选修课程的情况:mysql&gt; SELECT Student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade FROM Student,SC WHERE Student.Sno=Sc.Sno;+-----------+-------+------+------+-------+-----+-------+| Sno       | Sname | Ssex | Sage | Sdept | Cno | Grade |+-----------+-------+------+------+-------+-----+-------+| 201215121 | 李勇  | 男   |   20 | CS    | 1   |    92 || 201215121 | 李勇  | 男   |   20 | CS    | 2   |    85 || 201215121 | 李勇  | 男   |   20 | CS    | 3   |    88 || 201215122 | 刘晨  | 女   |   19 | CS    | 2   |    90 || 201215122 | 刘晨  | 女   |   19 | CS    | 3   |    80 || 201215125 | 张立  | 男   |   19 | IS    | 2   |  NULL |+-----------+-------+------+------+-------+-----+-------+</code></pre><h4 id="复合查询"><a href="#复合查询" class="headerlink" title="复合查询"></a>复合查询</h4><blockquote><p>一条SQL语句可以同时完成选择和连接查询，这时WHERE子句是由连接谓词和选择谓词组成的复合条件。</p></blockquote><pre><code>// 查询选修2号课程且成绩在85分以上的所有学生的学号和姓名。mysql&gt; SELECT Student.Sno,Sname FROM Student,Sc WHERE Student.Sno=Sc.Sno AND SC.Cno=&apos;2&apos; AND SC.Grade&gt;85;+-----------+-------+| Sno       | Sname |+-----------+-------+| 201215122 | 刘晨  |+-----------+-------+</code></pre><p><strong><em>执行过程：</em></strong></p><ul><li>先执行选择语句，然后再执行连接语句</li><li>先从SC中挑选出Cno=’2’并且Grade&gt;90的元组形成一个中间关系</li><li>再和Student中满足连接条件的元组进行连接得到最终的结果关系</li></ul><h3 id="自身连接"><a href="#自身连接" class="headerlink" title="自身连接"></a>自身连接</h3><ul><li>一个表与其自己进行连接</li><li>需要给表起别名以示区别</li><li>由于所有属性名都是同名属性，因此必须使用别名前缀</li></ul><p><strong>范例：</strong></p><pre><code>// 查询每一门课的间接先修课（即先修课的先修课）SELECT FIRST.Cno,SECOND.Cpno FROM course FIRST,course SECOND WHERE FIRST.Cpno=SECOND.Cno;    +-----+------+| Cno | Cpno |+-----+------+| 3   | 5    || 1   | 7    || 4   | NULL || 7   | NULL || 5   | 6    |+-----+------+</code></pre><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p><strong>外连接与普通连接的区别</strong></p><ul><li>普通连接操作只输出满足连接条件的元组</li><li>外连接操作以指定表为连接主体，将主体表中不满足连接条件的元组一并输出</li><li>左外连接<ul><li>列出左边关系中所有的元组</li></ul></li><li>右外连接<ul><li>列出右边关系中所有的元组</li></ul></li></ul><p><strong>范例：</strong></p><pre><code>// 查询每个学生及其选修课程的情况mysql&gt; SELECT Student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade FROM Student LEFT  JOIN SC ON (Student.Sno=SC.Sno);+-----------+-------+------+------+-------+------+-------+| Sno       | Sname | Ssex | Sage | Sdept | Cno  | Grade |+-----------+-------+------+------+-------+------+-------+| 201215121 | 李勇  | 男   |   20 | CS    | 1    |    92 || 201215121 | 李勇  | 男   |   20 | CS    | 2    |    85 || 201215121 | 李勇  | 男   |   20 | CS    | 3    |    88 || 201215122 | 刘晨  | 女   |   19 | CS    | 2    |    90 || 201215122 | 刘晨  | 女   |   19 | CS    | 3    |    80 || 201215125 | 张立  | 男   |   19 | IS    | 2    |  NULL || 201215123 | 王敏  | 女   |   18 | MA    | NULL |  NULL |+-----------+-------+------+------+-------+------+-------+</code></pre><h3 id="多表连接"><a href="#多表连接" class="headerlink" title="多表连接"></a>多表连接</h3><blockquote><p>两个以上的表进行连接</p></blockquote><p><strong>范例：</strong></p><pre><code>//查询每个学生的学号、 姓名、 选修的课程名及成绩mysql&gt; SELECT Student.Sno,Sname,Cname,Grade FROM Student,SC,Course WHERE Student.Sno=SC.Sno AND SC.Cno=Course.Cno;+-----------+-------+----------+-------+| Sno       | Sname | Cname    | Grade |+-----------+-------+----------+-------+| 201215121 | 李勇  | 数据库   |    92 || 201215121 | 李勇  | 数学     |    85 || 201215121 | 李勇  | 信息系统 |    88 || 201215122 | 刘晨  | 数学     |    90 || 201215122 | 刘晨  | 信息系统 |    80 || 201215125 | 张立  | 数学     |  NULL |+-----------+-------+----------+-------+</code></pre><h2 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h2><blockquote><p>一个SELECT-FROM-WHERE语句称为一个查询块,将一个查询块嵌套在另一个查询块的WHERE子句<br>或HAVING短语的条件中的查询称为嵌套查询。</p></blockquote><ul><li>上层的查询块称为外层查询或父查询</li><li>下层查询块称为内层查询或子查询</li><li>SQL语言允许多层嵌套查询：即一个子查询中还可以嵌套其他子查询</li><li>子查询的限制：不能使用ORDER BY子句</li></ul><p><strong>嵌套查询求解方法</strong></p><ul><li>不相关子查询：子查询的查询条件不依赖于父查询<ul><li>由里向外 逐层处理。即每个子查询在上一级查询处理之前求解，子查询的结果用于建立其父查询的查找条<br>件。</li></ul></li><li>相关子查询：子查询的查询条件依赖于父查询<ul><li>首先取外层查询中表的第一个元组，根据它与内层查询相关的属性值处理内层查询，若WHERE子句返回值为真，则取此元组放入结果表</li><li>然后再取外层表的下一个元组</li><li>重复这一过程，直至外层表全部检查完为止</li></ul></li></ul><h3 id="带有IN谓词的子查询"><a href="#带有IN谓词的子查询" class="headerlink" title="带有IN谓词的子查询"></a>带有IN谓词的子查询</h3><pre><code>// 查询与“刘晨”在同一个系学习的学生:(1) 确定刘晨所在的系    mysql&gt; SELECT Sdept FROM Student WHERE Sname=&apos;刘晨&apos;;    +-------+    | Sdept |    +-------+    | CS    |    +-------+（2）查找所有在CS系学习的学生    mysql&gt; SELECT Sno,Sname,Sdept FROM Student WHERE Sdept=&apos;CS&apos;;    +-----------+-------+-------+    | Sno       | Sname | Sdept |    +-----------+-------+-------+    | 201215121 | 李勇  | CS    |    | 201215122 | 刘晨  | CS    |    +-----------+-------+-------+ (3) 将第一步查询嵌入到第二步查询的条件中    mysql&gt; SELECT Sno,Sname,Sdept FROM Student WHERE Sdept IN (SELECT Sdept FROM Student WHERE Sname=&apos;刘晨&apos;);    +-----------+-------+-------+    | Sno       | Sname | Sdept |    +-----------+-------+-------+    | 201215121 | 李勇  | CS    |    | 201215122 | 刘晨  | CS    |    +-----------+-------+-------+ // 使用自身连接也可以完成操作    mysql&gt; SELECT S1.Sno,S1.Sname,S1.Sdept FROM Student S1,Student S2 WHERE S1.Sdept=S2.Sdept AND S2.Sname=&apos;刘晨&apos;;    +-----------+-------+-------+    | Sno       | Sname | Sdept |    +-----------+-------+-------+    | 201215121 | 李勇  | CS    |    | 201215122 | 刘晨  | CS    |    +-----------+-------+-------+</code></pre><h3 id="带有比较运算符的子查询"><a href="#带有比较运算符的子查询" class="headerlink" title="带有比较运算符的子查询"></a>带有比较运算符的子查询</h3><blockquote><p>当能确切知道内层查询返回单值时，可用比较运<br>算符（ &gt;， &lt;， =， &gt;=， &lt;=， !=或&lt; &gt;）</p></blockquote><pre><code>// 找出每个学生超过他选修课程平均成绩的课程号:mysql&gt; SELECT Sno,Cno FROM SC x WHERE Grade&gt;=(SELECT AVG(Grade) FROM SC y WHERE y.Sno=x.Sno);+-----------+-----+| Sno       | Cno |+-----------+-----+| 201215121 | 1   || 201215122 | 2   |+-----------+-----+</code></pre><p><strong>可能的执行过程:</strong></p><ul><li><p>从外层查询中取出SC的一个元组x，将元组x的Sno值（ 201215121）传送给内层查询</p><p>  SELECT AVG(Grade)<br>  FROM SC y<br>  WHERE y.Sno=’201215121’;</p></li><li><p>执行内层查询，得到值88（近似值），用该值代替内层查询，得到外层查询</p><p>   SELECT Sno,Cno<br>  FROM SC x<br>  WHERE Grade &gt;=88;</p></li><li><p>执行这个查询，得到</p><p>  （ 201215121,1）<br>  （ 201215121,3）</p></li><li><p>然后外层查询取出下一个元组重复做上述上面的步骤，直到外层的SC元组全部处理完毕。</p></li></ul><h3 id="带有ANY（-SOME）或ALL谓词的子查询"><a href="#带有ANY（-SOME）或ALL谓词的子查询" class="headerlink" title="带有ANY（ SOME）或ALL谓词的子查询"></a>带有ANY（ SOME）或ALL谓词的子查询</h3><p><strong>语法：</strong></p><ul><li><blockquote><p>ANY 大于子查询结果中的某个值</p></blockquote></li><li><blockquote><p>ALL 大于子查询结果中的所有值</p></blockquote></li><li>（&gt;,&gt;=,&lt;,&lt;=,!= 或者&lt;&gt;）<br>使用ANY或ALL谓词时必须同时使用比较运算</li></ul><p><strong>范例：</strong></p><pre><code>// 查询非计算机科学系中比计算机科学系任意一个，学生年龄小的学生姓名和年龄。mysql&gt; SELECT Sname,Sage FROM Student WHERE Sage &lt; ANY (SELECT Sage FROM Student WHERE Sdept=&apos;CS&apos;) AND Sdept &lt;&gt; &apos;CS&apos; ;+-------+------+| Sname | Sage |+-------+------+| 王敏  |   18 || 张立  |   19 |+-------+------+</code></pre><h3 id="带有EXISTS谓词的子查询"><a href="#带有EXISTS谓词的子查询" class="headerlink" title="带有EXISTS谓词的子查询"></a>带有EXISTS谓词的子查询</h3><p><strong>EXISTS谓词</strong></p><ul><li>带有EXISTS谓词的子查询不返回任何数据，只产生逻辑<br>真值“ true”或逻辑假值“ false”。<ul><li>若内层查询结果非空，则外层的WHERE子句返回真值</li><li>若内层查询结果为空，则外层的WHERE子句返回假值</li></ul></li><li>由EXISTS引出的子查询，其目标列表达式通常都用 * ，<br>因为带EXISTS的子查询只返回真值或假值，给出列名无<br>实际意义。</li></ul><p><strong>NOT EXISTS谓词</strong></p><ul><li>若内层查询结果非空，则外层的WHERE子句返回假值</li><li>若内层查询结果为空，则外层的WHERE子句返回真值</li></ul><p><strong>范例：</strong></p><pre><code>// 查询所有选修了1号课程的学生姓名:// 1.本查询涉及Student和SC关系// 2.在Student中依次取每个元组的Sno值，用此值去检查SC表// 3.若SC中存在这样的元组，其Sno值等于此Student.Sno值，并且其Cno= ‘1’，则取此Student.Sname送入结果表mysql&gt; SELECT Sname FROM Student WHERE EXISTS (SELECT * FROM SC WHERE Sno=Student.Sno AND Cno=&apos;1&apos;);+-------+| Sname |+-------+| 李勇  |+-------+// 查询没有选修1号课程的学生姓名:mysql&gt; SELECT Sname FROM Student WHERE NOT EXISTS (SELECT * FROM SC WHERE Sno=Student.Sno AND Cno=&apos;1&apos;);+-------+| Sname |+-------+| 刘晨  || 张立  || 王敏  |+-------+// 查询与“刘晨”在同一个系学习的学生mysql&gt; SELECT Sno,Sname,Sdept FROM Student S1 WHERE EXISTS (SELECT * FROM Student S2 WHERE S2.Sdept = S1.Sdept AND S2.Sname=&apos;刘晨&apos;);+-----------+-------+-------+| Sno       | Sname | Sdept |+-----------+-------+-------+| 201215121 | 李勇  | CS    || 201215122 | 刘晨  | CS    |+-----------+-------+-------+</code></pre><h2 id="集合查询"><a href="#集合查询" class="headerlink" title="集合查询"></a>集合查询</h2><p><strong>集合操作的种类:</strong></p><ul><li>并操作UNION</li><li>交操作INTERSECT</li><li>差操作EXCEPT</li></ul><p><strong><em>1.MySQL并不支持交与差运算，考虑用子查询（差）或多表连接查询（交）代替！</em></strong></p><p><strong><em>2.参加集合操作的各查询结果的列数必须相同;对应项的数据类型也必须相同</em></strong></p><p>UNION：将多个查询结果合并起来时，系统自动去掉重复元组<br>UNION ALL：将多个查询结果合并起来时，保留重复元组</p><p><strong>范例：</strong></p><pre><code>// 查询计算机科学系的学生及年龄不大于19岁的学生。(UNION)mysql&gt; SELECT * FROM Student WHERE Sdept=&apos;CS&apos; UNION SELECT * FROM Student WHERE Sage&lt;=19;+-----------+-------+------+------+-------+| Sno       | Sname | Ssex | Sage | Sdept |+-----------+-------+------+------+-------+| 201215121 | 李勇  | 男   |   20 | CS    || 201215122 | 刘晨  | 女   |   19 | CS    || 201215123 | 王敏  | 女   |   18 | MA    || 201215125 | 张立  | 男   |   19 | IS    |+-----------+-------+------+------+-------+// 查询计算机科学系的学生与年龄不大于19岁的学生的交集。</code></pre><h2 id="SELECT语句的一般格式"><a href="#SELECT语句的一般格式" class="headerlink" title="SELECT语句的一般格式"></a>SELECT语句的一般格式</h2><pre><code>SELECT [ALL|DISTINCT]&lt;目标列表达式&gt; [别名] [ ,&lt;目标列表达式&gt; [别名]] …FROM &lt;表名或视图名&gt; [别名][ ,&lt;表名或视图名&gt; [别名]] …|(&lt;SELECT语句&gt;)[AS]&lt;别名&gt;[WHERE &lt;条件表达式&gt;][GROUP BY &lt;列名1&gt;[HAVING&lt;条件表达式&gt;]][ORDER BY &lt;列名2&gt; [ASC|DESC]];</code></pre><h3 id="目标列表达式格式"><a href="#目标列表达式格式" class="headerlink" title="目标列表达式格式"></a>目标列表达式格式</h3><ul><li>*</li><li>&lt;表名&gt;.*</li><li>COUNT([DISTINCT|ALL]* )</li><li>[&lt;表名&gt;.]&lt;属性列名表达式&gt;[,&lt;表名&gt;.]&lt;属性列名<br>表达式&gt;]…</li></ul><p>其中&lt;属性列名表达式&gt;可以是由属性列、作用于属性列的聚集函数和常量的任意算术运算（ +， -， *， /）组成的运算公式</p><h3 id="聚集函数的一般格式"><a href="#聚集函数的一般格式" class="headerlink" title="聚集函数的一般格式"></a>聚集函数的一般格式</h3><p>{COUNT SUM  AVG MAX MIN}（ [DISTINCT|ALL] &lt;列名&gt;）</p><h3 id="WHERE子句的条件表达式的可选格式"><a href="#WHERE子句的条件表达式的可选格式" class="headerlink" title="WHERE子句的条件表达式的可选格式"></a>WHERE子句的条件表达式的可选格式</h3><p><img src="https://s1.ax1x.com/2018/02/05/9ubHII.png" alt="条件表达式"><br><img src="https://s1.ax1x.com/2018/02/05/9uqJyD.png" alt="条件表达式1"><br><img src="https://s1.ax1x.com/2018/02/05/9uq6Og.png" alt="条件表达式2"></p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="视图的特点"><a href="#视图的特点" class="headerlink" title="视图的特点"></a>视图的特点</h3><ul><li>虚表，是从一个或几个基本表（或视图）导出的表</li><li>只存放视图的定义，不存放视图对应的数据</li><li>基表中的数据发生变化，从视图中查询出的数据也随之改变</li><li>关系数据库管理系统执行CREATE VIEW语句时只是把视图定义存入数据字典，并不执行其中的<br>SELECT语句</li><li>在对视图查询时，按视图的定义从基本表中将数<br>据查出</li></ul><h3 id="建立视图"><a href="#建立视图" class="headerlink" title="建立视图"></a>建立视图</h3><h4 id="语句格式"><a href="#语句格式" class="headerlink" title="语句格式"></a>语句格式</h4><pre><code>CREATE VIEW&lt;视图名&gt; [(&lt;列名&gt; [,&lt;列名&gt;]…)]AS &lt;子查询&gt;[WITH CHECK OPTION];</code></pre><h4 id="WITH-CHECK-OPTION"><a href="#WITH-CHECK-OPTION" class="headerlink" title="WITH CHECK OPTION"></a>WITH CHECK OPTION</h4><blockquote><p>对视图进行UPDATE， INSERT和DELETE操作时要保<br>证更新、插入或删除的行满足视图定义中的谓词条件<br>（即子查询中的条件表达式）</p></blockquote><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><blockquote><p>可以是任意的SELECT语句，是否可以含<br>有ORDER BY子句和DISTINCT短语，则决定具<br>体系统的实现。</p></blockquote><h4 id="组成视图的属性列名"><a href="#组成视图的属性列名" class="headerlink" title="组成视图的属性列名"></a>组成视图的属性列名</h4><ul><li>全部省略:由子查询中SELECT目标列中的诸字段组成</li><li>明确指定视图的所有列名<ul><li>某个目标列是聚集函数或列表达式</li><li>多表连接时选出了几个同名列作为视图的字段</li><li>需要在视图中为某个列启用新的更合适的名字</li></ul></li></ul><h4 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h4><pre><code>//建立信息系学生的视图  CREATE VIEW IS_Student1 AS SELECT Sno,Sname,Sage FROM Student WHERE Sdept=&apos;IS&apos; WITH CHECK OPTION;// 定义一个反映学生出生年份的视图mysql&gt; CREATE VIEW BT_S(Sno,Sname,Sbirth) AS SELECT Sno,Sname,2014-Sage FROM Student; Query OK, 0 rows affected (0.10 sec)mysql&gt; SELECT * FROM BT_S;+-----------+-------+--------+| Sno       | Sname | Sbirth |+-----------+-------+--------+| 201215121 | 李勇  |   1994 || 201215122 | 刘晨  |   1995 || 201215123 | 王敏  |   1996 || 201215125 | 张立  |   1995 |+-----------+-------+--------+ // 将学生的学号及平均成绩定义为一个视图mysql&gt; CREATE  VIEW S_G(Sno,Gavg) AS SELECT Sno,AVG(Grade) FROM SC GROUP BY Sno;mysql&gt; SELECT * FROM S_G;+-----------+---------+| Sno       | Gavg    |+-----------+---------+| 201215121 | 88.3333 || 201215122 | 85.0000 || 201215125 |    NULL |+-----------+---------+</code></pre><p><strong><em>定义IS_Student视图时加上了WITH CHECK OPTION子句，对该视图进行插入、修改和删除操作<br>时,RDBMS会自动加上Sdept=’IS’的条件。</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SELECT&quot;&gt;&lt;a href=&quot;#SELECT&quot; class=&quot;headerlink&quot; title=&quot;SELECT&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/subqueries.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SELECT&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;SELECT语法格式&quot;&gt;&lt;a href=&quot;#SELECT语法格式&quot; class=&quot;headerlink&quot; title=&quot;SELECT语法格式&quot;&gt;&lt;/a&gt;SELECT语法格式&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;SELECT values_to_display
    FROM table_name
    WHERE expression
    GROUP BY how_to_group
    HAVING expression
    ORDER BY how_to_sort
    LIMIT row_count;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;SELECT子句：指定要显示的属性列&lt;/li&gt;
&lt;li&gt;FROM子句：指定查询的对象(基本表或视图)&lt;/li&gt;
&lt;li&gt;WHERE子句：指定查询的条件&lt;/li&gt;
&lt;li&gt;GROUP BY子句：对查询的结果按指定列的值分组,该属性列值相等的记录为一组。通常会在每组中作用聚集函数&lt;/li&gt;
&lt;li&gt;HAVING短语：只有满足指定条件的组才予以输出，对聚集计算的结果做过滤&lt;/li&gt;
&lt;li&gt;ORDER BY子句：对查询结果按指定的列升序（ASC）或者降序（DESC）排序&lt;/li&gt;
&lt;li&gt;LIMIT num ： 限制操作的行&lt;/li&gt;
&lt;li&gt;执行过程： FROM –&amp;gt; WHERE –&amp;gt; GROUP BY –&amp;gt; HAVING –&amp;gt; ORDER BY –&amp;gt; SELECT –&amp;gt; LIMIT&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;WHERE expression: 比较表达式，内置函数；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/02/02/9EvdV1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;特殊的比较操作符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BETWEEN… AND …:&lt;/li&gt;
&lt;li&gt;IN：指定范围内值的存在性测试&lt;/li&gt;
&lt;li&gt;IN(list): 指定的字段取的取值在此list中，则表示符合条件；&lt;/li&gt;
&lt;li&gt;IS NULL&lt;/li&gt;
&lt;li&gt;IS NOT NULL&lt;/li&gt;
&lt;li&gt;LIKE：可使用通配符，%, _&lt;/li&gt;
&lt;li&gt;RLIKE或REGEXP：可使用正则表达式的模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;逻辑操作符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AND&lt;/li&gt;
&lt;li&gt;OR&lt;/li&gt;
&lt;li&gt;NOT&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="MySQL基础入门" scheme="http://www.chenfanlinux.org/categories/MySQL%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="MySQL" scheme="http://www.chenfanlinux.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据类型及SQL语句(二)</title>
    <link href="http://www.chenfanlinux.org/2018/02/02/MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8ASQL%E8%AF%AD%E5%8F%A5-%E4%BA%8C/"/>
    <id>http://www.chenfanlinux.org/2018/02/02/MySQL数据类型及SQL语句-二/</id>
    <published>2018-02-02T03:22:50.000Z</published>
    <updated>2018-02-02T03:24:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL数据类型"><a href="#MySQL数据类型" class="headerlink" title="MySQL数据类型"></a>MySQL数据类型</h2><blockquote><p>MySQL中定义数据字段的类型对你数据库的优化是非常重要的。MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。</p></blockquote><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><ul><li>精确数值型<ul><li>整形: TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT</li><li>十进制: DECIMAL</li></ul></li><li>近似数值型(浮点型):<ul><li>FLOAT</li><li>DOUBLE</li></ul></li></ul><p><img src="https://s1.ax1x.com/2018/01/31/9PaLMF.png" alt="数值类型"></p><h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><blockquote><p>char使用固定长度的空间进行存储，char(4)存储4个字符，根据编码方式的不同占用不同的字节，gbk编码方式，不论是中文还是英文，每个字符占用2个字节的空间，utf8编码方式，每个字符占用3个字节的空间。如果需要存储的字符串的长度跟所有值的平均长度相差不大，适合用char，如MD5。</p></blockquote><ul><li>CHAR,BINARY: 定长数据类型(CHAR不区分字符大小写,BINARY区分字符大小写)</li><li>VARCHAR,VARBINARY: 变长数据类型,需要结束符</li><li>TEXT: TINYTEXT, TEXT, MEDIUMTEXT, LOGTEXT</li><li>BLOB: TINYBLOB, BLOB, MEDIUMBLOB, LONGBLOB</li><li>ENUM,SET</li></ul><p><strong><em>注意：binary保存二进制字符串，就是说它们包含字节字符串而不是字符字符串，没有字符集限制</em></strong></p><p><img src="https://s1.ax1x.com/2018/01/31/9PdYon.png" alt="字符类型"><br><strong><em>注意：CHAR,VARCHAR,TEXT 不区分字符大小写；BINARY,VARBINARY,BLOB 区分字符大小写</em></strong></p><h3 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h3><ul><li>DATE</li><li>TIME</li><li>DATETIME</li><li>TIMESTAMP</li><li>YEAR(2), YEAR(4)</li></ul><p><img src="https://s1.ax1x.com/2018/01/31/9PwwtI.png" alt="日期时间型"></p><h3 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h3><ul><li>ENUM:从给定的字符串中选择一个字串</li><li>SET:集合,从指定字符集合中选择多个组合成一种变化形式</li></ul><a id="more"></a><h3 id="MySQL中字符大小写"><a href="#MySQL中字符大小写" class="headerlink" title="MySQL中字符大小写"></a>MySQL中字符大小写</h3><ol><li>SQL关键字及函数名不区字符大小写；<ul><li>SELECT, Select, select</li><li>切记：遵循同一种风格</li></ul></li><li>数据库、表、索引及视图的名称是否区分大小写取决于低层的OS及FS；</li><li>存储过程、存储函数及事件调度器不区分字符大小写；但触发器区分；</li><li>表别名不区分大小写；</li><li>字段中字符数据，类型为binary、blog、varbinary时区分大小写；其它的不区分；</li></ol><h3 id="数据类型的修饰符"><a href="#数据类型的修饰符" class="headerlink" title="数据类型的修饰符"></a>数据类型的修饰符</h3><h4 id="整形修饰符"><a href="#整形修饰符" class="headerlink" title="整形修饰符"></a>整形修饰符</h4><ul><li>NOT NULL</li><li>NULL</li><li>DEFAULT NUMBER</li><li>AUTO_INCREMENT:自动增长,需要下面三个条件的支持。<ul><li>UNSIGNED: 无符号,必须放在仅放在字段类型后</li><li>PRIMARY KEY | UNIQUE KEY</li><li>NOT NULL</li></ul></li></ul><p>例如:<br><code>CREATE TABLE t1 (id INT UNSIGNED AUTO_INCREMNET PRIMAY KEY NOT NULL,name VARCHAR(5) NOT NULL);</code></p><h4 id="字符型修饰符"><a href="#字符型修饰符" class="headerlink" title="字符型修饰符"></a>字符型修饰符</h4><blockquote><p>字符类型的修饰符: 定义在字段类型之后</p></blockquote><ul><li>NOT NULL: 非空约束</li><li>NULL: 默认为空</li><li>DEFAULT ‘STRING’: 指明默认值</li><li>CHARACTE SET ‘’: 使用字符集</li><li>COLLATION: 使用的排序规则</li></ul><p>查看字符集和排序规则: 在数据库上定义后,表可以继承,一般无须定义</p><p><code>mysql&gt;SHOW CHARACTER SET;</code><br><code>mysql&gt;SHOW COLLATION;</code></p><p>字符有通配符：</p><ul><li>%: 匹配任意长度的任意字符</li><li>_: 匹配任意单个字符；</li></ul><h4 id="日期时间型的修饰符"><a href="#日期时间型的修饰符" class="headerlink" title="日期时间型的修饰符:"></a>日期时间型的修饰符:</h4><ul><li>NOUT NULL</li><li>NULL</li><li>DEFAULT</li></ul><h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><blockquote><p><a href="https://zh.wikipedia.org/wiki/SQL" target="_blank" rel="noopener">SQL</a>（Structured Query Language),结构化查询语言，是关系数据库的标准语言;集数据定义语言（ DDL),数据操纵语言（ DML),<br>数据控制语言（ DCL）功能于一体。</p></blockquote><h3 id="SQL动词"><a href="#SQL动词" class="headerlink" title="SQL动词"></a>SQL动词</h3><table><thead><tr><th>SQL功能</th><th style="text-align:center">动词</th></tr></thead><tbody><tr><td>数据定义</td><td style="text-align:center">CREATE, DROP, ALTER</td></tr><tr><td>数据操作</td><td style="text-align:center">SELECT, INSERT, DELETE, UPDATE</td></tr><tr><td>数据控制</td><td style="text-align:center">GRANT, REVOKE</td></tr></tbody></table><h3 id="MySQL三级模式"><a href="#MySQL三级模式" class="headerlink" title="MySQL三级模式"></a>MySQL三级模式</h3><p><img src="https://s1.ax1x.com/2018/02/01/9kw5Q0.png" alt=""></p><h3 id="DDL-数据定义语言"><a href="#DDL-数据定义语言" class="headerlink" title="DDL 数据定义语言"></a>DDL 数据定义语言</h3><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E5%AE%9A%E7%BE%A9%E8%AA%9E%E8%A8%80" target="_blank" rel="noopener">数据定义语言</a>（Data Definition Language，DDL）是SQL语言集中负责数据结构定义与数据库对象定义的语言，由CREATE、ALTER与DROP三个语法所组成，最早是由Codasyl（Conference on Data Systems Languages）数据模型开始，现在被纳入SQL指令中作为其中一个子集。</p></blockquote><h4 id="CREATE对象"><a href="#CREATE对象" class="headerlink" title="CREATE对象"></a>CREATE对象</h4><p>CREATE操作的对象包括: 数据库表，索引，视图，用户，存储过程，存储函数，触发器，时间调度器等</p><pre><code>MariaDB [(none)]&gt; help createMany help items for your request exist.To make a more specific request, please type &apos;help &lt;item&gt;&apos;,where &lt;item&gt; is one of the followingtopics:   CREATE DATABASE  //数据库   CREATE EVENT    //事件   CREATE FUNCTION //函数   CREATE FUNCTION UDF //自定义函数   CREATE INDEX    //索引   CREATE PROCEDURE  //存储函数   CREATE SERVER     //服务器   CREATE TABLE   //表   CREATE TABLESPACE   //表空间   CREATE TRIGGER      //触发器   CREATE USER         //用户   CREATE VIEW         //视图   SHOW                //看CREATE语句过程   SHOW CREATE DATABASE   SHOW CREATE EVENT   SHOW CREATE FUNCTION   SHOW CREATE PROCEDURE   SHOW CREATE TABLE   SPATIAL</code></pre><h4 id="CREATE-DATABASE"><a href="#CREATE-DATABASE" class="headerlink" title="CREATE DATABASE"></a><a href="http://dev.mysql.com/doc/refman/5.5/en/create-database.html" target="_blank" rel="noopener">CREATE DATABASE</a></h4><p><strong>语法:</strong></p><pre><code>MariaDB [(none)]&gt; help create databaseCREATE {DATABASE | SCHEMA} [IF NOT EXISTS] db_name    [create_specification] ...create_specification:    [DEFAULT] CHARACTER SET [=] charset_name  | [DEFAULT] COLLATE [=] collation_name</code></pre><p><strong>实例:</strong><br><code>CREATE DATABASE IF NOT EXISTS test_db DEFAULT CHARACTER SET  utf8 COLLATE utf8_general_ci;</code></p><h4 id="CREATE-TABLE"><a href="#CREATE-TABLE" class="headerlink" title="CREATE TABLE"></a><a href="https://dev.mysql.com/doc/refman/5.5/en/create-table.html" target="_blank" rel="noopener">CREATE TABLE</a></h4><p><strong>语法：</strong></p><pre><code>CREATE TABLE [IF NOT EXISTS] tb_name(col1_def, col2_def,PRIMARY KEY(col_name,...),UNIQUE (col1,...), INDEX (col1,...))[table_option]------------------------table_option:ENGINE [=] engine_nameCOMMENT [=] &apos;string&apos;ROW_FORMAT [=] {DEFAULT|DYNAMIC|FIXED|COMPRESSED|REDUNDANT|COMPACT}TABLESPACE tablespace_name [STORAGE {DISK|MEMORY|DEFAULT}]</code></pre><p>显示表上的索引：<br><code>SHOW INDEXES FROM tb_name;</code></p><p><strong><em>注意: Storage Engine是指的表类型,也即在表创建时指明其使用的存储引擎:同一个库中要使用同一种存储引擎类型</em></strong></p><p><strong>范例:</strong><br><code>CREATE TABLE tb1 (id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY NOT NULL,name CHAR(5) NOT NULL);</code></p><p><strong>查看表结构：</strong><br><code>DESCRIBE tb1_name</code></p><p><strong>查看表状态信息：</strong><br><code>SHOW [FULL] TABLE STATUS [{FROM|IN} db_name] [LIKE &#39;pattern&#39; | WHERE expr]</code></p><p><strong>查看存储引擎：</strong><br><code>SELECT @@SESSION.default_storage_engine;</code></p><h4 id="ALTER-TABLE"><a href="#ALTER-TABLE" class="headerlink" title="ALTER TABLE"></a><a href="https://dev.mysql.com/doc/refman/5.5/en/alter-table.html" target="_blank" rel="noopener">ALTER TABLE</a></h4><p><strong>语法：</strong></p><pre><code>ALTER [ONLINE | OFFLINE] [IGNORE] TABLE tbl_name    [alter_specification [, alter_specification] ...]    [partition_options]    alter_specification:    table_options  | ADD [COLUMN] col_name column_definition        [FIRST | AFTER col_name ]  | ADD [COLUMN] (col_name column_definition,...)  | ADD {INDEX|KEY} [index_name]        [index_type] (index_col_name,...) [index_option] ...  | ALTER [COLUMN] col_name {SET DEFAULT literal | DROP DEFAULT}  | CHANGE [COLUMN] old_col_name new_col_name column_definition    [FIRST|AFTER col_name]  | DROP [COLUMN] col_name  ......</code></pre><p><strong>添加单列：</strong><br><code>ALTER TABLE tb_name ADD [COLUMN] col_name column_definition [FIRST|AFTER col_name]</code></p><p>范例:</p><pre><code>MariaDB [db1]&gt; ALTER TABLE tb1 ADD COLUMN sex ENUM(&apos;man&apos;,&apos;woman&apos;) AFTER name;Query OK, 0 rows affected (0.10 sec)Records: 0  Duplicates: 0  Warnings: 0MariaDB [db1]&gt; DESC tb1;+-------+---------------------+------+-----+---------+----------------+| Field | Type                | Null | Key | Default | Extra          |+-------+---------------------+------+-----+---------+----------------+| id    | int(10) unsigned    | NO   | PRI | NULL    | auto_increment || name  | char(5)             | NO   |     | NULL    |                || sex   | enum(&apos;man&apos;,&apos;woman&apos;) | YES  |     | NULL    |                |+-------+---------------------+------+-----+---------+----------------+</code></pre><p><strong>删除列：</strong><br><code>ALTER TABLE tb_name DROP [column] col_name</code></p><p>范例：</p><pre><code>MariaDB [db1]&gt; ALTER TABLE tb1 DROP sex;Query OK, 0 rows affected (0.14 sec)Records: 0  Duplicates: 0  Warnings: 0MariaDB [db1]&gt; DESC tb1;+-------+------------------+------+-----+---------+----------------+| Field | Type             | Null | Key | Default | Extra          |+-------+------------------+------+-----+---------+----------------+| id    | int(10) unsigned | NO   | PRI | NULL    | auto_increment || name  | char(5)          | NO   |     | NULL    |                |+-------+------------------+------+-----+---------+----------------+2 rows in set (0.00 sec)</code></pre><p><strong>修改列的类型：</strong><br><code>ALTER TABLE tb_name MODIFY [COLUMN] col_name column_definition</code></p><pre><code>MariaDB [db1]&gt; ALTER TABLE tb1 MODIFY  name  CHAR(6);Query OK, 0 rows affected (0.09 sec)Records: 0  Duplicates: 0  Warnings: 0MariaDB [db1]&gt; DESC tb1;+-------+------------------+------+-----+---------+----------------+| Field | Type             | Null | Key | Default | Extra          |+-------+------------------+------+-----+---------+----------------+| id    | int(10) unsigned | NO   | PRI | NULL    | auto_increment || name  | char(6)          | YES  |     | NULL    |                |+-------+------------------+------+-----+---------+----------------+2 rows in set (0.01 sec)</code></pre><h4 id="DROP-TABLE"><a href="#DROP-TABLE" class="headerlink" title="DROP TABLE"></a><a href="https://dev.mysql.com/doc/refman/5.5/en/drop-table.html" target="_blank" rel="noopener">DROP TABLE</a></h4><p><strong>语法：</strong></p><pre><code>DROP [TEMPORARY] TABLE [IF EXISTS]    tbl_name [, tbl_name] ...    [RESTRICT | CASCADE]</code></pre><ul><li>RESTRICT：删除表是有限制的<ul><li>欲删除的基本表不能被其他表的约束所引用</li><li>如果存在依赖该表的对象，则此表不能被删除</li></ul></li><li>CASCADE: 在删除基本表的同时，相关的依赖对象一起删除</li></ul><h3 id="DML-数据操作语言"><a href="#DML-数据操作语言" class="headerlink" title="DML 数据操作语言"></a>DML 数据操作语言</h3><blockquote><p><a href="http://www.360doc.com/content/16/0309/09/31217954_540682216.shtml" target="_blank" rel="noopener">数据操作语言</a>(Data Manipulation Language, DML）包含了数据库数据的增删改查操作，也是我们经常会见到的’CRUD’操作，其主要包括INSERT、SELECT、UPDATE和DELETE四条命令。</p></blockquote><h4 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h4><p><strong>语法：</strong></p><pre><code>INSERT [INTO] tbl_name [(col_name [, col_name] ...)]{VALUES | VALUE} ( value [, value] ...) [, ( value [, value] ...)] ...//批量插入INSERT  [INTO] tbl_name [(col_name,...)] SELECT ...INSERT [INTO] tbl_name SET col_name={expr | DEFAULT}, ...</code></pre><p><strong>范例：</strong></p><p>单行插入：</p><pre><code>mysql&gt; INSERT INTO tb1 (name) VALUES (&apos;chenfan&apos;);ERROR 1406 (22001): Data too long for column &apos;name&apos; at row 1mysql&gt; INSERT INTO tb1 (name) VALUES (&apos;chen&apos;);Query OK, 1 row affected (0.06 sec)mysql&gt; SELECT * FROM tb1;+----+------+| id | name |+----+------+|  1 | chen |+----+------+1 row in set (0.00 sec)</code></pre><p>插入查询到的数据:</p><pre><code>mysql&gt; INSERT INTO tb1 (name) SELECT name FROM tb1;Query OK, 1 row affected (0.06 sec)Records: 1  Duplicates: 0  Warnings: 0mysql&gt; SELECT * FROM tb1;+----+------+| id | name |+----+------+|  1 | chen ||  2 | chen |+----+------+2 rows in set (0.00 sec)</code></pre><h4 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h4><p><strong>语法:</strong></p><pre><code>UPDATE [LOW_PRIORITY] [IGNORE] table_reference    SET assignment_list    [WHERE where_condition]    [ORDER BY col1[,...] {ASC|DESC}]    [LIMIT row_count]assignment: col_name = valueassignment_list: assignment [, assignment] ...判断某字段值为空：IS NULL          不空：IS NOT NULLASC：升序DESC：降序</code></pre><p><strong>范例：</strong></p><pre><code>mysql&gt; SELECT * FROM tb1;+----+------+| id | name |+----+------+|  1 | chen ||  2 | chen |+----+------+2 rows in set (0.00 sec)mysql&gt; UPDATE tb1 SET name=&apos;fan&apos; WHERE id=&apos;2&apos; ;Query OK, 1 row affected (0.10 sec)Rows matched: 1  Changed: 1  Warnings: 0mysql&gt; SELECT * FROM tb1;+----+------+| id | name |+----+------+|  1 | chen ||  2 | fan  |+----+------+2 rows in set (0.00 sec)</code></pre><h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><p><strong>语法：</strong></p><pre><code>DELETE FROM tbl_name [WHERE where_condition]    [ORDER BY ...] [LIMIT row_count]</code></pre><p><strong>范例：</strong></p><pre><code>mysql&gt; DELETE FROM tb1 WHERE name=&apos;fan&apos;;Query OK, 1 row affected (0.06 sec)mysql&gt; SELECT * FROM tb1;+----+------+| id | name |+----+------+|  1 | chen |+----+------+1 row in set (0.00 sec)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MySQL数据类型&quot;&gt;&lt;a href=&quot;#MySQL数据类型&quot; class=&quot;headerlink&quot; title=&quot;MySQL数据类型&quot;&gt;&lt;/a&gt;MySQL数据类型&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;MySQL中定义数据字段的类型对你数据库的优化是非常重要的。MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;数值类型&quot;&gt;&lt;a href=&quot;#数值类型&quot; class=&quot;headerlink&quot; title=&quot;数值类型&quot;&gt;&lt;/a&gt;数值类型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;精确数值型&lt;ul&gt;
&lt;li&gt;整形: TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT&lt;/li&gt;
&lt;li&gt;十进制: DECIMAL&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;近似数值型(浮点型):&lt;ul&gt;
&lt;li&gt;FLOAT&lt;/li&gt;
&lt;li&gt;DOUBLE&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/01/31/9PaLMF.png&quot; alt=&quot;数值类型&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;字符型&quot;&gt;&lt;a href=&quot;#字符型&quot; class=&quot;headerlink&quot; title=&quot;字符型&quot;&gt;&lt;/a&gt;字符型&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;char使用固定长度的空间进行存储，char(4)存储4个字符，根据编码方式的不同占用不同的字节，gbk编码方式，不论是中文还是英文，每个字符占用2个字节的空间，utf8编码方式，每个字符占用3个字节的空间。如果需要存储的字符串的长度跟所有值的平均长度相差不大，适合用char，如MD5。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;CHAR,BINARY: 定长数据类型(CHAR不区分字符大小写,BINARY区分字符大小写)&lt;/li&gt;
&lt;li&gt;VARCHAR,VARBINARY: 变长数据类型,需要结束符&lt;/li&gt;
&lt;li&gt;TEXT: TINYTEXT, TEXT, MEDIUMTEXT, LOGTEXT&lt;/li&gt;
&lt;li&gt;BLOB: TINYBLOB, BLOB, MEDIUMBLOB, LONGBLOB&lt;/li&gt;
&lt;li&gt;ENUM,SET&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意：binary保存二进制字符串，就是说它们包含字节字符串而不是字符字符串，没有字符集限制&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/01/31/9PdYon.png&quot; alt=&quot;字符类型&quot;&gt;&lt;br&gt;&lt;strong&gt;&lt;em&gt;注意：CHAR,VARCHAR,TEXT 不区分字符大小写；BINARY,VARBINARY,BLOB 区分字符大小写&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;日期和时间类型&quot;&gt;&lt;a href=&quot;#日期和时间类型&quot; class=&quot;headerlink&quot; title=&quot;日期和时间类型&quot;&gt;&lt;/a&gt;日期和时间类型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;DATE&lt;/li&gt;
&lt;li&gt;TIME&lt;/li&gt;
&lt;li&gt;DATETIME&lt;/li&gt;
&lt;li&gt;TIMESTAMP&lt;/li&gt;
&lt;li&gt;YEAR(2), YEAR(4)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/01/31/9PwwtI.png&quot; alt=&quot;日期时间型&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;特殊类型&quot;&gt;&lt;a href=&quot;#特殊类型&quot; class=&quot;headerlink&quot; title=&quot;特殊类型&quot;&gt;&lt;/a&gt;特殊类型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;ENUM:从给定的字符串中选择一个字串&lt;/li&gt;
&lt;li&gt;SET:集合,从指定字符集合中选择多个组合成一种变化形式&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="MySQL基础入门" scheme="http://www.chenfanlinux.org/categories/MySQL%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="MySQL" scheme="http://www.chenfanlinux.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL基础概念及安装(一)</title>
    <link href="http://www.chenfanlinux.org/2018/01/30/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%89%E8%A3%85-%E4%B8%80/"/>
    <id>http://www.chenfanlinux.org/2018/01/30/MySQL基础概念及安装-一/</id>
    <published>2018-01-30T04:22:21.000Z</published>
    <updated>2018-02-02T03:24:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库概念及相关术语"><a href="#数据库概念及相关术语" class="headerlink" title="数据库概念及相关术语"></a>数据库概念及相关术语</h2><h3 id="什么是数据库？"><a href="#什么是数据库？" class="headerlink" title="什么是数据库？"></a>什么是数据库？</h3><p><a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93" target="_blank" rel="noopener">数据库</a>（Database）是按照数据结构来组织、存储和管理数据的仓库，每个数据库都有一个或多个不同的API用于创建，访问，管理，搜索和复制所保存的数据。我们也可以将数据存储在文件中，但是在文件中读写数据速度相对较慢。所以，现在我们使用关系型数据库管理系统（RDBMS）来存储和管理的大数据量。所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。</p><h3 id="RDBMS的特点"><a href="#RDBMS的特点" class="headerlink" title="RDBMS的特点"></a>RDBMS的特点</h3><blockquote><p>RDBMS即关系数据库管理系统(Relational Database Management System)</p></blockquote><ul><li>数据库中的数据集合都放在数据表(table)中</li><li>数据表由数据行(row)和数据列(column)构成</li><li>一个数据行就是一个数据表中的一条记录(record)</li><li>记录中包含多个信息项，数据表中的每一个数据列都对应一个信息项</li></ul><h3 id="RDBMS-术语"><a href="#RDBMS-术语" class="headerlink" title="RDBMS 术语"></a>RDBMS 术语</h3><ul><li><p>数据库：数据库是一些关联表的集合。</p></li><li><p>数据表：表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。</p></li><li><p>列： 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。</p></li><li><p>行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。</p></li><li><p>冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。</p></li><li><p>主键：主键是唯一的。必须提供数据，即字段不为空（null）；字段不重复，即唯一标识本行；一张表只能有一个主键。</p></li><li><p>外键：一个表中的某字段可填入的数据取决于另一个表的主 键或唯一键已有的数据 ，键表示了两个表之间的相关联系。一个表的主键是另外一张表的外键（唯一键也可以做外键）。</p></li><li><p>复合键：表中一个属性无法唯一标识一条记录，用两条属性组才可以唯一标识一条记录，那么两条属性主就组成了符合主键。单独的每列的字段可重复，但是两个列组成主键后总字段是不重复的，一般用于复合索引。</p></li><li><p>唯一键：一个或多个字段的组合，填入的数据必须能在本表唯一标识本行。和主键不同之处：在表中可以有多个；允许为空值。</p></li><li><p>索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构，类似于书籍的目录。</p></li></ul><h3 id="MySQL核心组件"><a href="#MySQL核心组件" class="headerlink" title="MySQL核心组件"></a>MySQL核心组件</h3><ul><li>连接池：认证、线程重用、连接数限制、内存检查、缓存；</li><li>SQL接口：DDL, DML, 关系型数据库的基本抽象；</li><li>parser: 查询转换、对象权限检查；</li><li>优化器：访问路径，性能相关的统计数据；</li><li>caches和buffers：与存储引擎自身相关的I/O性能提升工具；</li><li>存储引擎：<ul><li>MyISAM、InnoDB(变种：XtraDB)、Memory、Merge、Federated、CSV、Archive、Blackholl、Aria、SphinxSE、TokuDB</li></ul></li></ul><h3 id="数据库设计规范化"><a href="#数据库设计规范化" class="headerlink" title="数据库设计规范化"></a>数据库设计规范化</h3><blockquote><p>仅有好的DBMS并不足以避免数据冗余，必须在数据库的设计中创建好的表结构，数据库规范化的三个级别，范式是具有最小冗余的表结构。</p></blockquote><ul><li><p>第一范式(1NF)<br>就是属性不可分割，这个字段只能是一个值，不能被拆分成多个字段。</p></li><li><p>第二范式(2NF)<br>就是要有主键，要求其他字段都依赖于主键。为什么要有主键？没有主键就没有唯一性，没有唯一性在集合中就定位不到这行记录，所以要主键。</p></li><li><p>第三范式(3NF)<br>关系模式R中的非主关键字不能依赖于其他非主关键，即非主关键字之间不能有函数(传递)依赖关系，要消除传递依赖，消除冗余应该比较好理解一些，就是各种信息只在一个地方存储，不出现在多张表中。</p></li></ul><h3 id="事务（transaction）"><a href="#事务（transaction）" class="headerlink" title="事务（transaction）"></a>事务（transaction）</h3><blockquote><p>事务(Transaction)，一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)，通常就是指数据库事务。一个支持事务（Transaction）的数据库系统，必需要具有ACID特性。</p></blockquote><ul><li>原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</li><li>一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。</li><li>隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li><li>持久性（Durability）：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。</li></ul><a id="more"></a><h3 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h3><ul><li>域的完整性: domain integrity 该类型主要限制了列中的值大小。</li><li>实体完整性：entity integrity 实体属性中的标识属性不能为空、不能重复，该约束通过制定的主键实现，其约束有系统强制实施。</li><li>参照完整性：referential integrity 实体中的外键可以为空，但不能是错的。主要管理表（table）之间的关系。</li></ul><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><blockquote><p>约束主要完成对数据的检验和限制，从而保证数据库的完整性。</p></blockquote><ul><li><p>主键约束(PRIMARY KEY)<br>主键约束列不允许重复，即任意两行的主键值都不相同；每行都具有一个主键值，也不允许出现空值；</p></li><li><p>联合主键<br>有时候一个列的字段可能有重复，可以联合多个列设为主键。</p></li><li><p>外键约束(FOREIGN KEY)<br>外键约束是保证一个或两个表之间的参照完整性,保持数据一致性。表的外键可以是另一表的主键, 外键可以有重复的, 可以是空值。实现一对一或一对多关系。</p></li><li><p>唯一约束(UNIQUE)<br>指定表中某一列或多个列不能有相同的两行或者两行以上的数据存在</p></li><li><p>非空约束(NOT NULL)<br>输入值必须是非空的，需要注意的是允许控制尽量不要太多，太多会更消耗数据库性能。</p></li><li><p>默认约束(DEFAULT)<br>定义的常量必须与该列的数据类型、精度等匹配;每个列只能定义一个DEFAULT约束;DEFAULT约束会在使用INSERT语句。</p></li></ul><h2 id="安装MariaDB"><a href="#安装MariaDB" class="headerlink" title="安装MariaDB"></a>安装MariaDB</h2><blockquote><p>MariaDB的安装方式大致分为三种，第一种是利用程序包管理器的程序包进行安装，简单说可以通过配置yum源来进行安装；第二种是通过对源码进行编译安装进行一些功能选择，以满足生产活动中对一些特殊功能的要求；第三种是利用官网提供的已经编译好的二进制格式程序包进行安装。下面我们主要介绍如何在CentOS7上利用第三种方式进行安装。</p></blockquote><h3 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h3><h4 id="准备用户"><a href="#准备用户" class="headerlink" title="准备用户"></a>准备用户</h4><blockquote><p>因为MariaDB是通过用户身份进行运行的，因此要提前为其准备好运行账户和组。</p></blockquote><pre><code>[root@test ~] groupadd -r -g 306 mysql[root@test ~] useradd -r -g 306 -u 306 -s /sbin/nologin –m –d /app/data mysql[root@test ~] chown mysql:mysql /app/data</code></pre><p>改变目录/app/data目录的所有者和属组，我们可以用其当做数据库的存放目录，这也是我们之所以指定为其创建家目录的原因所在。</p><h4 id="准备二进制程序包"><a href="#准备二进制程序包" class="headerlink" title="准备二进制程序包"></a>准备二进制程序包</h4><pre><code>[root@test ~] tar xf mariadb-VERSION-linux-x86_64.tar.gz -C /usr/local[root@test ~] cd /usr/local;ln -sv mariadb-VERSION mysql[root@test ~] chown -R root:mysql /usr/local/mysql/</code></pre><h4 id="为数据库准备配置文件"><a href="#为数据库准备配置文件" class="headerlink" title="为数据库准备配置文件"></a>为数据库准备配置文件</h4><blockquote><p>数据库已经为我们准备了配置文件模板，我们可以通过这条命令查询并进行选择。而且有”my-small.cnf my-medium.cnf my-large.cnf my-huge.cnf”适合多种类型数据库的配置文件模板供我们选择。这里我们选择huge模板。</p></blockquote><pre><code>[root@test ~] cp  /usr/local/mysql/support-files/my-large.cnf /etc/my.cnf    [root@test ~] vim /etc/mysql/my.cnf  datadir = /app/data 指定数据库位置,必须要指定到我们之前选定的数据库存放目录。    innodb_file_per_table = on 允许每个表格单独存放,方便管理，可省略。    skip_name_resolve = on 禁止主机名反向解析，加快登录速度，可省略。</code></pre><p>数据库会在启动时自动读取配置文件，读取的次序是:<br>/etc/my.cnf —-&gt;/etc/mysql/my.cnf —-&gt;$MYSQL_HOME/my.cnf —&gt;default-extra-file=/path/to/somedir/my.cnf —&gt;~/.my.cnf</p><p>集中式的配置文件，能够为mysql的下面各应用程序提供配置信息</p><ul><li>[mysqld]</li><li>[mysqld_safe]</li><li>[mysqld-multi]</li><li>[server]</li><li>[mysql]</li><li>[mysqldump]</li><li>[client]</li></ul><h3 id="开始配置启动mysql"><a href="#开始配置启动mysql" class="headerlink" title="开始配置启动mysql"></a>开始配置启动mysql</h3><h4 id="为数据库准备配置文件-1"><a href="#为数据库准备配置文件-1" class="headerlink" title="为数据库准备配置文件"></a>为数据库准备配置文件</h4><blockquote><p>创建数据库文件并不需要我们直接手动进行，数据库为我们准备了脚本，我们只需要执行脚本即可。注意必须在目录/usr/local/mysql中，我们才可以执行这个脚本。</p></blockquote><pre><code>[root@test ~] cd /usr/local/mysql/[root@test ~] ./scripts/mysql_install_db --datadir=/app/data --user=mysql</code></pre><h4 id="创建日志文件"><a href="#创建日志文件" class="headerlink" title="创建日志文件"></a>创建日志文件</h4><blockquote><p>为了方便对数据进行管理和排错，我们要自己手动创建数据库文件，并且要给予数据库的运行账户mysql以权限，让其可以写数据进去。</p></blockquote><pre><code>[root@test ~] touch /var/log/mysqld.log[root@test ~] chown mysql /var/log/mysqld.log</code></pre><h4 id="配置服务脚本及开机自启"><a href="#配置服务脚本及开机自启" class="headerlink" title="配置服务脚本及开机自启"></a>配置服务脚本及开机自启</h4><pre><code>[root@test ~] install /usr/local/mysql/support-files/mysql.server /etc/rc.d/init.d/mysqld[root@test ~] chkconfig --add mysqld[root@test ~] chkconfig mysqld on[root@test ~] service mysqld start;ss -ntl</code></pre><p>为了使服务脚本可以利用service命令进行管理，我们需要将服务脚本copy进固定目录中，用install命令是因为这个命令既可以复制又可以加权限。</p><h4 id="为客户端工具指明PATH路径"><a href="#为客户端工具指明PATH路径" class="headerlink" title="为客户端工具指明PATH路径"></a>为客户端工具指明PATH路径</h4><blockquote><p>我们在安装编译好的二进制程序包的时候，不仅安装了服务端程序，也安装了客户端程序。所以我们要为客户端程序指明PATH路径。</p></blockquote><pre><code>[root@test ~] vim /etc/profile.d/mysql.sh   export PATH=/usr/local/mysql/bin:$PATH[root@test ~] source /etc/profile.d/mysql.sh</code></pre><h4 id="执行安全初始化脚本"><a href="#执行安全初始化脚本" class="headerlink" title="执行安全初始化脚本"></a>执行安全初始化脚本</h4><blockquote><p>刚安装好的数据库是无论什么身份都可以登录的，所以需要进行安全初始化，为数据库的root用户创建密码，以及禁止非数据库目录登录数据库。</p></blockquote><pre><code>[root@test ~] mysql_secure_installation\\ 执行后按照提示一步步进行设置即可。</code></pre><h4 id="安装后的设定"><a href="#安装后的设定" class="headerlink" title="安装后的设定"></a>安装后的设定</h4><p><strong>为所有root用户设定密码：</strong></p><ul><li><code>mysql&gt; SET PASSWORD FOR &#39;username&#39;@&#39;host&#39; = PASSWORD(&#39;your_password&#39;);</code></li><li><code>mysql&gt; update mysql.user SET password=PASSWORD(&#39;your_pass&#39;) WHERE clase;</code></li><li><code>$ mysqladmin -uUSERNMAE -hHOSTNAME_OR_IP -p password &#39;new_password&#39;</code></li></ul><p><strong>删除所有的匿名用户:</strong></p><p><code>mysql&gt; DORP USER &#39;&#39;@&#39;localhost&#39;;</code><br>上述可用 mysql_secure_installation 完成</p><p><strong>建议关闭主机名反解功能</strong></p><h2 id="MySQL客户端和服务端特性"><a href="#MySQL客户端和服务端特性" class="headerlink" title="MySQL客户端和服务端特性"></a>MySQL客户端和服务端特性</h2><h3 id="mysql客户端程序"><a href="#mysql客户端程序" class="headerlink" title="mysql客户端程序"></a>mysql客户端程序</h3><h4 id="常见的客户端程序"><a href="#常见的客户端程序" class="headerlink" title="常见的客户端程序"></a>常见的客户端程序</h4><ul><li><p>mysql: 交互式的CLI工具</p></li><li><p>mysqldump: 备份工具,基础mysql协议向mysqld发起查询请求,并将查得的数据保存在文本文件中,转换成create,insert语句保存在文本文件中</p></li><li><p>mysqladmin: 基于mysql协议管理mysqld</p></li><li><p>mysqlimport:数据导入工具</p></li><li>非客户端类的管理工具： myisamchk,myisampak</li></ul><h4 id="客户端类应用程序的可用选项"><a href="#客户端类应用程序的可用选项" class="headerlink" title="客户端类应用程序的可用选项:"></a>客户端类应用程序的可用选项:</h4><ul><li>-u, –user=</li><li>-h, –host=</li><li>-p, –password=</li><li>-P, –port=</li><li>–protocol={tcp|sock}</li><li>-S, –socket= 客户端和服务端位于同一主机</li><li>-D, –database=</li><li>-C, –compress</li><li>-e, 执行sql语句</li></ul><h4 id="如何获取程序默认使用的配置？"><a href="#如何获取程序默认使用的配置？" class="headerlink" title="如何获取程序默认使用的配置？"></a>如何获取程序默认使用的配置？</h4><ul><li>$ mysql  –print-defaults  客户端</li><li>$ mysqld –print-defaults  服务端</li></ul><h4 id="mysql的使用模式"><a href="#mysql的使用模式" class="headerlink" title="mysql的使用模式:"></a>mysql的使用模式:</h4><ul><li>交互式模式:可运行命令有两类<ul><li>客户端命令:<br>\h,help</li><li>服务器端命令:<br>SQL,需要语句结束符’;’</li></ul></li><li>脚本模式:<ul><li>$ mysql -uUSERNAME -hHOST -pPASSWORD &lt;/path/from/somefile.sql</li><li>mysql&gt; source /path/from/somefile.sql</li></ul></li></ul><h3 id="mysql服务端程序-mysqld）"><a href="#mysql服务端程序-mysqld）" class="headerlink" title="mysql服务端程序(mysqld）"></a>mysql服务端程序(mysqld）</h3><h4 id="获取配置文件参数"><a href="#获取配置文件参数" class="headerlink" title="获取配置文件参数"></a>获取配置文件参数</h4><pre><code>[root@docker mysql]# mysqld --verbose --helpsync-frm                                          TRUEsync-master-info                                  0sync-relay-log                                    0sync-relay-log-info                               0sysdate-is-now                                    FALSEtable-cache                                       256table-definition-cache                            400table-open-cache                                  256tc-heuristic-recover                              COMMITtemp-pool                                         TRUEthread-cache-size                                 8thread-concurrency                                8thread-handling                                   one-thread-per-connectionthread-pool-idle-timeout                          60thread-pool-max-threads                           500thread-pool-oversubscribe                         3thread-pool-size                                  1thread-pool-stall-limit                           500thread-stack                                      294912time-format                                       %H:%i:%stimed-mutexes                                     FALSEtmp-table-size                                    16777216tmpdir                                            /tmptransaction-alloc-block-size                      8192transaction-isolation                             REPEATABLE-READtransaction-prealloc-size                         4096updatable-views-with-limit                        YESuserstat                                          FALSEverbose                                           TRUEwait-timeout                                      28800xtradb-admin-command                              ON</code></pre><h4 id="获取运行中的mysql进程使用各参数及其值"><a href="#获取运行中的mysql进程使用各参数及其值" class="headerlink" title="获取运行中的mysql进程使用各参数及其值"></a>获取运行中的mysql进程使用各参数及其值</h4><pre><code>mysql&gt; SHOW GLOBAL VARIABLES;  //全局参数mysql&gt; SHOW SESSION VARIABLES; //会话级别参数</code></pre><p><strong><em>注意: 其中有些参数支持运行时修改，会立即生效;有些参数不支持,且只能通过修改配置文件,并重启服务器程序生效.有些参数的作用域是全局的,且不可改变;有些可以为每个用户提供单独的配置.</em></strong></p><h4 id="MySQL的服务器及状态变量"><a href="#MySQL的服务器及状态变量" class="headerlink" title="MySQL的服务器及状态变量"></a>MySQL的服务器及状态变量</h4><pre><code>SHOW {GLOBAL|SESSION} VARIABLES [LIKE CLAUSE];  //服务器变量SHOW {GLOBAL|SESSION} STATUS [LIKE CLAUSE];     //状态变量</code></pre><p> 状态变量：用户保存mysqld运行中的统计数据变量</p><h4 id="修改服务器变量的值"><a href="#修改服务器变量的值" class="headerlink" title="修改服务器变量的值"></a>修改服务器变量的值</h4><p><code>mysql&gt; help SET</code>  // 查看设置帮助</p><ul><li>全局:<ul><li>mysql&gt; SET GLOBAL system_var_name=value;</li><li>mysql&gt; SET @@global.system_var_name=value;</li></ul></li><li>会话:<ul><li>mysql&gt; SET [SESSION] system_var_name=value;</li><li>mysql&gt; SET @@[session.]system_var_name=value;</li></ul></li></ul><h4 id="SQL-MODE"><a href="#SQL-MODE" class="headerlink" title="SQL MODE"></a>SQL MODE</h4><blockquote><p>定义mysqld对约束等的响应行为</p></blockquote><pre><code>mysql&gt; SHOW GLOBAL VARIABLES LIKE &apos;sql_mode&apos;;mysql&gt; SET GLOBAL sql_mode=&apos;MODE&apos;mysql&gt; SET @@global.sql_mode=&apos;MODE&apos;</code></pre><p>常用的MODE:</p><ul><li>TRADITIONAL</li><li>STRICT_TRANS_TABLES：对支持事务的表使用严格模式</li><li>STRICT_ALL_TABLES：对所有表使用严格模式</li></ul><p><strong><em>使用global修改的变量仅对修改后的新创建的会话有效,对于已经建立的会话无效,无论是SESSION级别或者GLOBAL级别的,重启后都会失效,永久生效需要修改配置文件并重启</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据库概念及相关术语&quot;&gt;&lt;a href=&quot;#数据库概念及相关术语&quot; class=&quot;headerlink&quot; title=&quot;数据库概念及相关术语&quot;&gt;&lt;/a&gt;数据库概念及相关术语&lt;/h2&gt;&lt;h3 id=&quot;什么是数据库？&quot;&gt;&lt;a href=&quot;#什么是数据库？&quot; class=&quot;headerlink&quot; title=&quot;什么是数据库？&quot;&gt;&lt;/a&gt;什么是数据库？&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数据库&lt;/a&gt;（Database）是按照数据结构来组织、存储和管理数据的仓库，每个数据库都有一个或多个不同的API用于创建，访问，管理，搜索和复制所保存的数据。我们也可以将数据存储在文件中，但是在文件中读写数据速度相对较慢。所以，现在我们使用关系型数据库管理系统（RDBMS）来存储和管理的大数据量。所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。&lt;/p&gt;
&lt;h3 id=&quot;RDBMS的特点&quot;&gt;&lt;a href=&quot;#RDBMS的特点&quot; class=&quot;headerlink&quot; title=&quot;RDBMS的特点&quot;&gt;&lt;/a&gt;RDBMS的特点&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;RDBMS即关系数据库管理系统(Relational Database Management System)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;数据库中的数据集合都放在数据表(table)中&lt;/li&gt;
&lt;li&gt;数据表由数据行(row)和数据列(column)构成&lt;/li&gt;
&lt;li&gt;一个数据行就是一个数据表中的一条记录(record)&lt;/li&gt;
&lt;li&gt;记录中包含多个信息项，数据表中的每一个数据列都对应一个信息项&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;RDBMS-术语&quot;&gt;&lt;a href=&quot;#RDBMS-术语&quot; class=&quot;headerlink&quot; title=&quot;RDBMS 术语&quot;&gt;&lt;/a&gt;RDBMS 术语&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;数据库：数据库是一些关联表的集合。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数据表：表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;列： 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;主键：主键是唯一的。必须提供数据，即字段不为空（null）；字段不重复，即唯一标识本行；一张表只能有一个主键。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;外键：一个表中的某字段可填入的数据取决于另一个表的主 键或唯一键已有的数据 ，键表示了两个表之间的相关联系。一个表的主键是另外一张表的外键（唯一键也可以做外键）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;复合键：表中一个属性无法唯一标识一条记录，用两条属性组才可以唯一标识一条记录，那么两条属性主就组成了符合主键。单独的每列的字段可重复，但是两个列组成主键后总字段是不重复的，一般用于复合索引。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;唯一键：一个或多个字段的组合，填入的数据必须能在本表唯一标识本行。和主键不同之处：在表中可以有多个；允许为空值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构，类似于书籍的目录。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;MySQL核心组件&quot;&gt;&lt;a href=&quot;#MySQL核心组件&quot; class=&quot;headerlink&quot; title=&quot;MySQL核心组件&quot;&gt;&lt;/a&gt;MySQL核心组件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;连接池：认证、线程重用、连接数限制、内存检查、缓存；&lt;/li&gt;
&lt;li&gt;SQL接口：DDL, DML, 关系型数据库的基本抽象；&lt;/li&gt;
&lt;li&gt;parser: 查询转换、对象权限检查；&lt;/li&gt;
&lt;li&gt;优化器：访问路径，性能相关的统计数据；&lt;/li&gt;
&lt;li&gt;caches和buffers：与存储引擎自身相关的I/O性能提升工具；&lt;/li&gt;
&lt;li&gt;存储引擎：&lt;ul&gt;
&lt;li&gt;MyISAM、InnoDB(变种：XtraDB)、Memory、Merge、Federated、CSV、Archive、Blackholl、Aria、SphinxSE、TokuDB&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;数据库设计规范化&quot;&gt;&lt;a href=&quot;#数据库设计规范化&quot; class=&quot;headerlink&quot; title=&quot;数据库设计规范化&quot;&gt;&lt;/a&gt;数据库设计规范化&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;仅有好的DBMS并不足以避免数据冗余，必须在数据库的设计中创建好的表结构，数据库规范化的三个级别，范式是具有最小冗余的表结构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一范式(1NF)&lt;br&gt;就是属性不可分割，这个字段只能是一个值，不能被拆分成多个字段。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二范式(2NF)&lt;br&gt;就是要有主键，要求其他字段都依赖于主键。为什么要有主键？没有主键就没有唯一性，没有唯一性在集合中就定位不到这行记录，所以要主键。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第三范式(3NF)&lt;br&gt;关系模式R中的非主关键字不能依赖于其他非主关键，即非主关键字之间不能有函数(传递)依赖关系，要消除传递依赖，消除冗余应该比较好理解一些，就是各种信息只在一个地方存储，不出现在多张表中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;事务（transaction）&quot;&gt;&lt;a href=&quot;#事务（transaction）&quot; class=&quot;headerlink&quot; title=&quot;事务（transaction）&quot;&gt;&lt;/a&gt;事务（transaction）&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;事务(Transaction)，一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)，通常就是指数据库事务。一个支持事务（Transaction）的数据库系统，必需要具有ACID特性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。&lt;/li&gt;
&lt;li&gt;一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。&lt;/li&gt;
&lt;li&gt;隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。&lt;/li&gt;
&lt;li&gt;持久性（Durability）：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="MySQL基础入门" scheme="http://www.chenfanlinux.org/categories/MySQL%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="MySQL" scheme="http://www.chenfanlinux.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础之进程管理</title>
    <link href="http://www.chenfanlinux.org/2018/01/29/Linux%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>http://www.chenfanlinux.org/2018/01/29/Linux基础之进程管理/</id>
    <published>2018-01-29T15:10:26.000Z</published>
    <updated>2018-01-29T15:14:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程?"></a>什么是进程?</h2><h3 id="进程的基本概念"><a href="#进程的基本概念" class="headerlink" title="进程的基本概念"></a>进程的基本概念</h3><blockquote><p>程序本身只是指令、数据及其组织形式的描述，<a href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B" target="_blank" rel="noopener">进程</a>才是程序（那些指令和数据）的真正运行实例。现代计算机系统可在同一段时间内以进程的形式将多个程序加载到内存中，并借由时间共享（或称时分复用），以在一个处理器上表现出同时（平行性）运行的感觉。同样的，使用多线程技术（多线程即每一个线程都代表一个内的一个独立执行上下文）的操作系统或计算机架构，同样程序的平行线程，可在多CPU主机或网络上真正同时运行（在不同的CPU上）。</p></blockquote><h3 id="进程包含的资源"><a href="#进程包含的资源" class="headerlink" title="进程包含的资源"></a>进程包含的资源</h3><p>一个计算机系统进程包括（或者说“拥有”）下列数据：</p><ul><li>那个程序的可执行机器码的一个在内存的映像。</li><li>分配到的内存（通常是虚拟的一个内存区域）。内存的内容包括可执行代码、特定于进程的数据（输入、输出）、调用堆栈、堆栈（用于保存运行时运输中途产生的数据）。</li><li>分配给该进程的资源的操作系统描述符，诸如文件描述符（Unix术语）或文件句柄（Windows）、数据源和数据终端。</li><li>安全特性，诸如进程拥有者和进程的权限集（可以容许的操作）。</li><li>处理器状态（内文），诸如寄存器内容、物理内存定址等。当进程正在运行时，状态通常存储在寄存器，其他情况在内存。</li></ul><h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><ul><li>运行态：running</li><li>就绪态：ready</li><li>睡眠态：又称阻塞态或等待态,可以分为中断睡眠、不可中断睡眠<ul><li>可中断：interruptable</li><li>不可中断：uninterruptable</li></ul></li><li>停止态：暂停于内存中，但不会被调度，除非手动启动之；stopped</li><li><a href="https://zh.wikipedia.org/wiki/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener">僵死态</a>：zombie</li><li>空闲状态（idle）</li></ul><a id="more"></a><p><strong>R (task_running) : 可执行状态</strong></p><blockquote><p>只有在该状态的进程才可能在CPU上运行。而同一时刻可能有多个进程处于可执行状态，这些进程的task_struct结构（进程控制块）被放入对应CPU的可执行队列中（一个进程最多只能出现在一个CPU的可执行队列中）。进程调度器的任务就是从各个CPU的可执行队列中分别选择一个进程在该CPU上运行。<br>很多操作系统教科书将正在CPU上执行的进程定义为RUNNING状态、而将可执行但是尚未被调度执行的进程定义为READY状态，这两种状态在linux下统一为 TASK_RUNNING状态。</p></blockquote><p><strong>S 可中断睡眠: interruptible</strong></p><blockquote><p>处于这个状态的进程因为等待某某事件的发生（比如等待socket连接、等待信号量），而被挂起。这些进程的task_struct结构被放入对应事件的等待队列中。当这些事件发生时（由外部中断触发、或由其他进程触发），对应的等待队列中的一个或多个进程将被唤醒。通过ps命令我们会看到，一般情况下，进程列表中的绝大多数进程都处于task_interruptible状态（除非机器的负载很高）。毕竟CPU就这么一两个，进程动辄几十上百个，如果不是绝大多数进程都在睡眠，CPU又怎么响应得过来。</p></blockquote><p><strong>D 不可中断的睡眠: uninterruptible</strong></p><blockquote><p>进程处于睡眠状态，但是此刻进程是不可中断的。不可中断，指的并不是CPU不响应外部硬件的中断，而是指进程不响应异步信号。绝大多数情况下，进程处在睡眠状态时，总是应该能够响应异步信号的。但是uninterruptible sleep 状态的进程不接受外来的任何信号，因此无法用kill杀掉这些处于D状态的进程，无论是”kill”, “kill -9″还是”kill -15″，这种情况下，一个可选的方法就是reboot。处于uninterruptible sleep状态的进程通常是在等待IO，比如磁盘IO，网络IO，其他外设IO，如果进程正在等待的IO在较长的时间内都没有响应，那么就被ps看到了，同时也就意味着很有可能有IO出了问题，可能是外设本身出了故障，也可能是比如挂载的远程文件系统已经不可访问了。而task_uninterruptible状态存在的意义就在于，内核的某些处理流程是不能被打断的。如果响应异步信号，程序的执行流程中就会被插入一段用于处理异步信号的流程（这个插入的流程可能只存在于内核态，也可能延伸到用户态），于是原有的流程就被中断了。 在进程对某些硬件进行操作时（比如进程调用read系统调用对某个设备文件进行读操作，而read系统调用最终执行到对应设备驱动的代码，并与对应的物理设备进行交互），可能需要使用task_uninterruptible状态对进程进行保护，以避免进程与设备交互的过程被打断，造成设备陷入不可控的状态。这种情况下的task_uninterruptible状态总是非常短暂的，通过ps命令基本上不可能捕捉到。</p></blockquote><p><strong>Z 僵尸进程：zombie</strong></p><blockquote><p>在Linux进程的状态中，僵尸进程是非常特殊的一种，它是已经结束了的进程，但是没有从进程表中删除。太多了会导致进程表里面条目满了，进而导致系统崩溃，倒是不占用其他系统资源。它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的退出状态等信息供其他进程收集，除此之外，僵尸进程不再占有任何内存空间。<br>进程在退出的过程中，处于TASK_DEAD状态。在这个退出过程中，进程占有的所有资源将被回收，除了task_struct结构（以及少数资源）以外。于是进程就只剩下task_struct这么个空壳，故称为僵尸。<br>子进程在退出的过程中，内核会给其父进程发送一个信号，通知父进程来“收尸”。 父进程可以通过wait系列的系统调用（如wait4、waitid）来等待某个或某些子进程的退出，并获取它的退出信息。然后wait系列的系统调用会顺便将子进程的尸体（task_struct）也释放掉。<br>这个信号默认是SIGCHLD，但是在通过clone系统调用创建子进程时，可以设置这个信号。<br>如果他的父进程没安装SIGCHLD信号处理函数调用wait或waitpid()等待子进程结束，又没有显式忽略该信号，那么它就一直保持僵尸状态，子进程的尸体（task_struct）也就无法释放掉。<br>如果这时父进程结束了，那么init进程自动会接手这个子进程，为它收尸，它还是能被清除的。但是如果如果父进程是一个循环，不会结束，那么子进程就会一直保持僵尸状态，这就是为什么系统中有时会有很多的僵尸进程。</p></blockquote><p><strong>Unix/Linux 处理僵尸进程的方法：</strong></p><p>找出父进程号，然后kill 父进程，之后子进程（僵尸进程）会被托管到其他进程，如init进程，然后由init进程将子进程的尸体（task_struct）释放掉。</p><p><strong>T：Stopped：停止状态</strong></p><blockquote><p>向进程发送一个sigstop信号，它就会因响应该信号而进入task_stopped状态（除非该进程本身处于task_uninterruptible状态而不响应信号）。（sigstop与sigkill信号一样，是非常强制的。不允许用户进程通过signal系列的系统调用重新设置对应的信号处理函数。）<br> 向进程发送一个sigcont信号，可以让其从task_stopped状态恢复到task_running状态。<br> 当进程正在被跟踪时，它处于task_traced这个特殊的状态。“正在被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。比如在gdb中对被跟踪的进程下一个断点，进程在断点处停下来的时候就处于task_traced状态。而在其他时候，被跟踪的进程还是处于前面提到的那些状态。<br> 对于进程本身来说，task_stopped和task_traced状态很类似，都是表示进程暂停下来。<br> 而task_traced状态相当于在task_stopped之上多了一层保护，处于task_traced状态的进程不能响应sigcont信号而被唤醒。只能等到调试进程通过ptrace系统调用执行ptrace_cont、ptrace_detach等操作（通过ptrace系统调用的参数指定操作），或调试进程退出，被调试的进程才能恢复task_running状态。</p></blockquote><h3 id="IPC进程间通信"><a href="#IPC进程间通信" class="headerlink" title="IPC进程间通信"></a>IPC进程间通信</h3><ul><li>同一主机上：signal信号、shm: shared memory共享内存、semerphor旗语手势</li><li>不同主机上：rpc: remote process  call远程过程调用、socket套接字</li></ul><h3 id="fork-amp-exec"><a href="#fork-amp-exec" class="headerlink" title="fork &amp; exec"></a>fork &amp; exec</h3><ul><li><p>当计算机开机的时候，内核（kernel）只建立了一个 init 进程。Linux kernel 并不提供直接建立新进程的系统调用。剩下的所有进程都是 init 进程通过 fork 机制建立的。</p></li><li><p>新的进程要通过老的进程复制自身得到，这就是 fork。fork 是一个系统调用。进程存活于内存中。每个进程都在内存中分配有属于自己的一片空间 (内存空间，包含栈、堆、全局静态区、文本常量区、程序代码区)。</p></li><li><p>当一个程序调用 fork 的时候，实际上就是将上面的内存空间，又复制出来一个，构成一个新的进程，并在内核中为该进程创建新的附加信息 (比如新的 PID，而 PPID 为原进程的 PID)。此后，两个进程分别地继续运行下去。新的进程和原有进程有相同的运行状态(相同的变量值，相同的指令…)。我们只能通过进程的附加信息来区分两者。</p></li><li><p>程序调用 exec 的时候，进程清空自身的内存空间，并根据新的程序文件重建程序代码、文本常量、全局静态、堆和栈(此时堆和栈大小都为 0)，并开始运行。</p></li></ul><h2 id="进程管理相关命令"><a href="#进程管理相关命令" class="headerlink" title="进程管理相关命令"></a>进程管理相关命令</h2><h3 id="ps-用于显示当前进程的状态（非动态）"><a href="#ps-用于显示当前进程的状态（非动态）" class="headerlink" title="ps 用于显示当前进程的状态（非动态）"></a>ps 用于显示当前进程的状态（非动态）</h3><p>选项有三种风格：</p><ul><li><p>UNIX风格，必须在选项前面加“-”</p></li><li><p>BSD风格，选项前不能加“-”</p></li><li><p>GNU风格，选项前为两个“-”</p></li></ul><p><strong>常用组合之一：aux</strong></p><ul><li>a：所有与终端相关的进程</li><li>x：所有与终端无关的进程</li><li>u：以用户为中心组织进程状态信息显示</li></ul><p><img src="https://s1.ax1x.com/2018/01/29/9STeaV.png" alt="ps aux"></p><ul><li>USER：用户名</li><li>PID：进程号</li><li>CPU%：cpu时间占用比率</li><li>MEM%：内存占用百分比</li><li>VSZ：virtual size虚拟内存集</li><li>RSS：Resident Size，常驻内存集</li><li>STAT: 进程状态<ul><li>R：running 运行</li><li>S：interruptable sleeping 可中断睡眠</li><li>D：uninterruptable sleeping 不可中断睡眠</li><li>T：Stopped 停止</li><li>Z：zombie 僵死态</li><li>+：前台进程</li><li>l：多线程进程</li><li>N：低优先级进程</li><li>&lt;：高优先级进程</li><li>s：session leader  进程领导者</li></ul></li></ul><p><strong>常用组合之二：-ef</strong></p><ul><li>-e：显示所有进程</li><li>-f：显示完整格式的进程信息</li></ul><p><img src="https://s1.ax1x.com/2018/01/29/9SLS1O.png" alt="ps -ef "></p><h3 id="top动态查看进程状态"><a href="#top动态查看进程状态" class="headerlink" title="top动态查看进程状态"></a>top动态查看进程状态</h3><blockquote><p>系统响应变慢，首先得定位大致的问题出在哪里，是IO瓶颈、CPU瓶颈、内存瓶颈还是程序导致的系统问题；使用top工具能够比较全面的查看我们关注的点。</p></blockquote><p><img src="https://s1.ax1x.com/2018/01/29/9SLAAI.png" alt="top"></p><p><strong>top命令个参数具体含义：</strong></p><p><strong><em>系统状态</em></strong><br>top - 22:08:50 up 16 days, 10:03,  1 user,  load average: 0.00, 0.01, 0.05</p><ul><li>14:58:34：当前时间</li><li>up  5:28：运行时长</li><li>1 user：登录当前系统上的用户数</li><li>load average: 0.00, 0.01, 0.05：<a href="http://blog.scoutapp.com/articles/2009/07/31/understanding-load-averages" target="_blank" rel="noopener">平均负载</a>（等待运行的队列长度的负载）</li></ul><p><strong><em>系统任务情况</em></strong><br>Tasks: 232 total,   1 running, 231 sleeping,   0 stopped,   0 zombie</p><ul><li>232 total：一共运行多少进程</li><li>1 running：几个处于运行</li><li>231 sleeping：多少个睡眠</li><li>0 stopped：多少个停止</li><li>0 zombie：多少个僵死</li></ul><p><strong><em>占用Cpu百分比</em></strong><br>%Cpu(s):  0.1 us,  0.2 sy,  0.0 ni, 99.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</p><ul><li>0.1 us：用户空间占用时间的百分比</li><li>0.2 sy：内核空间占用时间的百分比</li><li>0.0 ni：对nice调整占用的内存百分比</li><li>99.8 id：Cpu的空闲百分比</li><li>0.0 wa：等待IO完成所消耗的百分比</li><li>0.0 hi：处理硬件中断所占用的百分比</li><li>0.0 si：处理软件中断所占用的百分比</li><li>0.0 st：被偷走的百分比（虚拟化程序）</li></ul><p><strong><em>内存的使用情况</em></strong><br>KiB Mem :  8003404 total,   458404 free,  2139240 used,  5405760 buff/cache</p><ul><li>KiB Mem：内存空间占用，以KB为单位：</li><li>8003404 total：总内存空间</li><li>458404 free：剩余内存空间</li><li>2139240 used：已用内存空间</li><li>5405760 buff/cache：用于缓存和缓冲的内存空间<ul><li>A buffer is something that has yet to be “written” to disk</li><li>A cache is something that has been “read” from the disk and stored for later use</li></ul></li></ul><p>注意：系统实际可用的内存为free工具输出第二行的free+buffer+cached,<br>也就是说buffer是用于存放要输出到disk（块设备）的数据的，而cache是存放从disk上读出的数据。这二者是为了提高IO性能的，并由OS管理。</p><p><strong><em>交换分区信息</em></strong></p><ul><li>6881272k total：交换区总量</li><li>4010444k used：使用的交换区量</li><li>2870828k free：空闲的交换区量</li><li>4336992k cached：缓冲交换区总量</li></ul><p><strong><em>进程状态</em></strong></p><ul><li>PID:用户pid</li><li>USER:用户名称</li><li>PR:优先级</li><li>NI:nice值</li><li>VIRT:virtual size虚拟内存集</li><li>RES:常驻内存集</li><li>SHR:共享内存空间</li><li>S:当前状态</li><li>%CPU:占据CPU百分比</li><li>%MEM:占据MEM百分比</li><li>TIME+:运行时长</li><li>COMMAND:命令</li></ul><p><strong><em>top内排序</em></strong></p><ul><li>P：按%CPU使用率排行</li><li>T：按MITE+排行</li><li>M：按%MEM排行</li></ul><h3 id="vmstat-监视内存使用情况"><a href="#vmstat-监视内存使用情况" class="headerlink" title="vmstat 监视内存使用情况"></a>vmstat 监视内存使用情况</h3><blockquote><p>vmstat是Virtual Meomory Statistics（虚拟内存统计）的缩写，可实时动态监视操作系统的虚拟内存、进程、CPU活动。</p></blockquote><p>语法格式：<br><code>vmstat [-V] [-n] [delay [count]]</code></p><ul><li>-V表示打印出版本信息；</li><li>-n表示在周期性循环输出时，输出的头部信息仅显示一次；</li><li>delay是两次输出之间的延迟时间；</li><li>count是指按照这个时间间隔统计的次数。</li></ul><p><img src="https://s1.ax1x.com/2018/01/29/9pPwAU.png" alt="vmstat"></p><ul><li><p>Procs（进程）:</p><ul><li>r: 等待运行进程的个数</li><li>b: 等待IO的进程数量</li></ul></li><li><p>Memory（内存）:</p><ul><li>swpd: 使用虚拟内存大小</li><li>free: 可用内存大小</li><li>buff: 用作缓冲的内存大小</li><li>cache: 用作缓存的内存大小</li></ul></li><li>Swap:<ul><li>si: 每秒从交换区写到内存的大小</li><li>so: 每秒写入交换区的内存大小</li><li>IO：（现在的Linux版本块的大小为1024bytes）</li><li>bi: 每秒读取的块数</li><li>bo: 每秒写入的块数</li></ul></li><li>system：<ul><li>in: 每秒中断数，包括时钟中断</li><li>cs: 每秒上下文切换数</li></ul></li><li>CPU（以百分比表示）<ul><li>us: 用户进程执行时间(user time)</li><li>sy: 系统进程执行时间(system time)</li><li>id: 空闲时间(包括IO等待时间)</li><li>wa: 等待IO时间</li></ul></li></ul><h3 id="dstat系统资源统计命令（动态）"><a href="#dstat系统资源统计命令（动态）" class="headerlink" title="dstat系统资源统计命令（动态）"></a>dstat系统资源统计命令（动态）</h3><blockquote><p>dstat 是一个用来替换 vmstat, iostat, netstat, nfsstat 和 ifstat 这些命令的工具，是一个全能系统信息统计工具。</p></blockquote><p>语法格式：<br><code>dstat [-afv] [options..] [delay [count]]</code></p><p><img src="https://s1.ax1x.com/2018/01/29/9pFDyR.png" alt="dstat"></p><ul><li>-c: 显示cpu信息,默认显示cpu</li><li>-d: 显示disk相关信息</li><li>-D total,sda,sdb</li><li>-g: 显示页面换进换出</li><li>-m :显示内存信息</li><li>-n :显示网络相关信息</li><li>-p :显示process相关统计数据</li><li>-s :显示交互内存的统计数据</li><li>–ipc:进程间通信</li><li>-fs:打开的文件</li><li>–tcp</li><li>–upd</li><li>–socket:socker显示信息</li><li>–top-cpu:显示最消耗cpu的进程</li><li>–top-io:显示最消耗io的进程</li><li>–top-mem:显示最占用内存的进程</li><li>–top-lantency: 显示延迟最大的进程</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是进程&quot;&gt;&lt;a href=&quot;#什么是进程&quot; class=&quot;headerlink&quot; title=&quot;什么是进程?&quot;&gt;&lt;/a&gt;什么是进程?&lt;/h2&gt;&lt;h3 id=&quot;进程的基本概念&quot;&gt;&lt;a href=&quot;#进程的基本概念&quot; class=&quot;headerlink&quot; title=&quot;进程的基本概念&quot;&gt;&lt;/a&gt;进程的基本概念&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;程序本身只是指令、数据及其组织形式的描述，&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;进程&lt;/a&gt;才是程序（那些指令和数据）的真正运行实例。现代计算机系统可在同一段时间内以进程的形式将多个程序加载到内存中，并借由时间共享（或称时分复用），以在一个处理器上表现出同时（平行性）运行的感觉。同样的，使用多线程技术（多线程即每一个线程都代表一个内的一个独立执行上下文）的操作系统或计算机架构，同样程序的平行线程，可在多CPU主机或网络上真正同时运行（在不同的CPU上）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;进程包含的资源&quot;&gt;&lt;a href=&quot;#进程包含的资源&quot; class=&quot;headerlink&quot; title=&quot;进程包含的资源&quot;&gt;&lt;/a&gt;进程包含的资源&lt;/h3&gt;&lt;p&gt;一个计算机系统进程包括（或者说“拥有”）下列数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;那个程序的可执行机器码的一个在内存的映像。&lt;/li&gt;
&lt;li&gt;分配到的内存（通常是虚拟的一个内存区域）。内存的内容包括可执行代码、特定于进程的数据（输入、输出）、调用堆栈、堆栈（用于保存运行时运输中途产生的数据）。&lt;/li&gt;
&lt;li&gt;分配给该进程的资源的操作系统描述符，诸如文件描述符（Unix术语）或文件句柄（Windows）、数据源和数据终端。&lt;/li&gt;
&lt;li&gt;安全特性，诸如进程拥有者和进程的权限集（可以容许的操作）。&lt;/li&gt;
&lt;li&gt;处理器状态（内文），诸如寄存器内容、物理内存定址等。当进程正在运行时，状态通常存储在寄存器，其他情况在内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;进程的状态&quot;&gt;&lt;a href=&quot;#进程的状态&quot; class=&quot;headerlink&quot; title=&quot;进程的状态&quot;&gt;&lt;/a&gt;进程的状态&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;运行态：running&lt;/li&gt;
&lt;li&gt;就绪态：ready&lt;/li&gt;
&lt;li&gt;睡眠态：又称阻塞态或等待态,可以分为中断睡眠、不可中断睡眠&lt;ul&gt;
&lt;li&gt;可中断：interruptable&lt;/li&gt;
&lt;li&gt;不可中断：uninterruptable&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;停止态：暂停于内存中，但不会被调度，除非手动启动之；stopped&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;僵死态&lt;/a&gt;：zombie&lt;/li&gt;
&lt;li&gt;空闲状态（idle）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="linux基础" scheme="http://www.chenfanlinux.org/categories/linux%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="进程" scheme="http://www.chenfanlinux.org/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="linux" scheme="http://www.chenfanlinux.org/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>awk学习笔记</title>
    <link href="http://www.chenfanlinux.org/2018/01/26/awk%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.chenfanlinux.org/2018/01/26/awk学习笔记/</id>
    <published>2018-01-26T03:52:25.000Z</published>
    <updated>2018-01-26T03:53:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="awk简介"><a href="#awk简介" class="headerlink" title="awk简介"></a>awk简介</h2><blockquote><p>awk是一种编程语言，用于在linux/unix下对文本和数据进行处理。数据可以来自标准输入、一个或多个文件，或其它命令的输出。它支持用户自定义函数和动态正则表达式等先进功能，是linux/unix下的一个强大编程工具。</p></blockquote><h3 id="特性介绍"><a href="#特性介绍" class="headerlink" title="特性介绍"></a>特性介绍</h3><ul><li>awk的处理文本和数据的方式是这样的，它逐行扫描文件，从第一行到最后一行，寻找匹配的特定模式的行，并在这些行上进行你想要的操作。</li><li>如果没有指定处理动作，则把匹配的行显示到标准输出(屏幕)；如果没有指定模式，则所有被操作所指定的行都被处理。</li><li>下面介绍的awk是以GUN的gawk为例的，在linux系统中已把awk链接到gawk，所以下面全部以awk进行介绍。</li></ul><h2 id="awk命令格式和选项"><a href="#awk命令格式和选项" class="headerlink" title="awk命令格式和选项"></a>awk命令格式和选项</h2><h3 id="awk的语法"><a href="#awk的语法" class="headerlink" title="awk的语法"></a>awk的语法</h3><ul><li>awk [options] ‘script’ var=value file(s)</li><li>awk [options] -f scriptfile var=value file(s)</li></ul><p><code>script= PATTERN {ACTION STATEMENTS}</code></p><ul><li>PATTERN: 模式,用于地址定界</li><li>ACTION STATEMENTS:动作语句,语句之间用分号分隔</li></ul><h3 id="2-2-命令选项"><a href="#2-2-命令选项" class="headerlink" title="2.2. 命令选项"></a>2.2. 命令选项</h3><pre><code>-F fs ：指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:-v var=val ： 自定义变量</code></pre><h2 id="awk的模式与动作"><a href="#awk的模式与动作" class="headerlink" title="awk的模式与动作"></a>awk的模式与动作</h2><blockquote><p>awk脚本是由模式(PATTERN)和操作语句(ACTION STATEMENTS)两个部分组成,下面将详细介绍这两个部分。</p></blockquote><h3 id="模式-地址定界"><a href="#模式-地址定界" class="headerlink" title="模式(地址定界)"></a>模式(地址定界)</h3><ul><li>empty: 匹配每一行。</li><li>/regular expression/: 正则表达式,仅处理被模式匹配到的行。<br><code>awk -F: &#39;!/^UUID/{print $1}&#39; /etc/fstab</code></li><li>relation expression: 关系表达式,结果有”真”有假: 结果为”真”的行才会被处理。<br><code>awk -F: &#39;$3&lt;1000{print $1,$3}&#39; /etc/passwd</code><br><code>awk -F: &#39;$NF~/bash$/{print $1,$NF}&#39; /etc/passwd</code></li><li>line ranges:行范围<ul><li>(NR&gt;2&amp;&amp;NR&lt;10)  行匹配</li><li>/pattern1/,/pattern2/ 第一次匹配模式1起始和第一次匹配模式2终</li></ul></li><li>BEGIN/END模式<ul><li>BEGIN{}: 仅在开始处理文件中的文本之前执行一次，通常可在这里设置全局变量。</li><li>END{}: 仅在文本处理完成后执行一次<br><code>awk -F: &#39;BEGIN{print &quot;     username   uid\n---------------&quot;} {print $1,$3} END {print &quot;==============\n  end&quot;}&#39; /etc/passwd</code></li></ul></li></ul><a id="more"></a><h3 id="动作语句"><a href="#动作语句" class="headerlink" title="动作语句"></a>动作语句</h3><blockquote><p>动作由一个或多个命令、函数、表达式组成，之间由换行符或分号隔开，并位于大括号内，主要有下面四部分。</p></blockquote><ul><li><p>变量或数组赋值</p></li><li><p>输出命令</p></li><li><p>内置函数</p></li><li><p>控制流命令</p></li></ul><h3 id="awk变量"><a href="#awk变量" class="headerlink" title="awk变量"></a>awk变量</h3><p><strong>awk的环境变量</strong></p><table><thead><tr><th>变量</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>$n</td><td style="text-align:center">当前行的第n个字段，字段间由FS分隔。</td></tr><tr><td>$0</td><td style="text-align:center">完整的行</td></tr><tr><td>FS</td><td style="text-align:center">输入字段分隔符，默认为空格</td></tr><tr><td>OFS</td><td style="text-align:center">输出字段分隔符，默认为空格</td></tr><tr><td>NF</td><td style="text-align:center">当前行的字段总数</td></tr><tr><td>NR</td><td style="text-align:center">当前行的记录数,行号</td></tr><tr><td>RS</td><td style="text-align:center">输入时的行的分隔符,默认换行符(\n)</td></tr><tr><td>ORS</td><td style="text-align:center">输出时的行的分隔符,默认换行符(\n)</td></tr><tr><td>ARGC</td><td style="text-align:center">命令行参数个数</td></tr><tr><td>ARGV</td><td style="text-align:center">数组,命令行中所给定的各参数</td></tr></tbody></table><p><strong><em>注意事项:awk 内部引用变量,无须加$</em></strong></p><p><strong>自定义变量</strong></p><ul><li><p>-v var=value<br><code>awk -v test=&#39;hello&#39; &#39;BEGIN{print test}&#39; /etc/fstab</code></p></li><li><p>在program中直接定义<br><code>awk &#39;BEGIN{test=&quot;hello&quot;;print test}&#39; /etc/fstab</code></p></li></ul><h3 id="运算操作符"><a href="#运算操作符" class="headerlink" title="运算操作符"></a>运算操作符</h3><p><strong>算术操作符</strong><br> x+y,x-y,x*y,x/y,x%y,x^y,-x，+x</p><p><strong>字符串操作符</strong><br>没有符号的操作符,字符串连接</p><p><strong>赋值操作符</strong><br> =,+=,-=,/=,%=,^=,++,–</p><p><strong>比较操作符</strong><br>&lt;,&gt;=,&lt;,&lt;=,!=,==</p><p><strong>模式匹配符</strong><br>~ :是否匹配正则表达式<br>!~：是否不匹正则表达式</p><p><strong>逻辑操作符</strong><br>&amp;&amp;  与<br>||  或<br>!   非</p><p><strong>函数调用</strong><br><code>function_name(argu1,argu2,....）</code></p><p><strong>条件表达式 ?: 选择器</strong><br>语法：selector? if-true-expression:if-fales-expression<br><code>awk -F: &#39;{$3&gt;=1000?usertype=&quot;common user&quot;:usertype=&quot;sysadmin or sysuser&quot;;printf&quot;%15s:%s\n&quot;,$1,usertype}&#39; /etc/passwd</code></p><h3 id="printf命令"><a href="#printf命令" class="headerlink" title="printf命令"></a>printf命令</h3><p>格式化输出: <code>printf FORMAT,item1,item2....</code></p><p>FORMAT注意点：</p><ul><li>FORMAT必须给出</li><li>不会自动换行,需要显示给出换行符,\n</li><li>FORMAT中需要分别为后面的每个item指定一个格式化符号</li></ul><p>格式符:</p><ul><li>%c: 显示字符的ASCII码</li><li>%d: 显示十进制整数</li><li>%e: 科学计数数值显示</li><li>%f: 显示浮点数</li><li>%g: 科学计数法或浮点形式</li><li>%s: 显示字符串</li><li>%u: 无符号整数</li><li>%%: 显示%自身</li></ul><p>修饰符:</p><ul><li>num[.num]: 第一个数字控制显示的宽度,第二个表示小数的精度<br> %3.1f</li><li>-: 左对齐</li><li>+: 显示数值的符号</li></ul><p>范例：<br><code>awk -F: &#39;{printf &quot;Username: %s Uid:%d\n&quot;,$1,$3}&#39; /etc/passwd</code></p><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><blockquote><p>awk中的条件语句是从C语言中借鉴过来的，可控制程序的流程。</p></blockquote><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>格式：</p><pre><code>{if (expression){                  statement; statement; ...                    }       }</code></pre><p>范例：<br><code>awk -F: &#39;{if($3&gt;1000) {print$1,$3}}&#39; /etc/passwd</code></p><h3 id="if-else语句，用于双重判断"><a href="#if-else语句，用于双重判断" class="headerlink" title="if/else语句，用于双重判断"></a>if/else语句，用于双重判断</h3><p>格式：</p><pre><code>{if (expression){                statement; statement; ...                    }     else{                statement; statement; ...                    }     }</code></pre><p>范例：<br><code>awk -F: &#39;{if ($3&gt;=1000) {printf &quot;Admin user: %s\n&quot;,$1} else {printf &quot;Common user: %s\n&quot;,$1}}&#39; /etc/passwd</code></p><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>格式：</p><pre><code>{while (expression) {        statement;statement;....                     }     }</code></pre><p>范例：<br><code>awk &#39;/^[[:space:]]*linux16*/  {i=1;while(i&lt;=NF) {if(length($i)&gt;20) {print $i,length($i)};i++}}&#39; /etc/grub2.cfg</code></p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>格式:<br><code>for(expr1,expr2,expr3) statement</code><br><code>for (variable assignment;condition;iteration process) {for-body}</code><br>      <strong><em>初始化变量，条件，自增加程序</em></strong></p><p>范例:<br><code>awk &#39;/^[[:space:]]*linux16*/ {for (i=1;i&lt;=NF;i++) {print $i,length($i)}}&#39; /etc/grub2.cfg</code></p><h3 id="next"><a href="#next" class="headerlink" title="next"></a>next</h3><p><strong><em>提前结束对本行的处理,直接进入下一行</em></strong></p><p>范例：<br><code>awk -F: &#39;{if($3%2!=0) next;print $1,$3}&#39; /etc/passwd</code></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>关联数组: array[index-expression]</p><p>index-expression: 索引表达式</p><ul><li>可以使用任意字符串:字符串需要加双引号。</li><li>如果某数组元素事先不存在,在引用时,awk会自动创建此元素,并将其值初始化为空。</li></ul><p><strong>若要判断数组中是否存在某元素要使用”index in array”格式进行</strong></p><p><code>awk &#39;BEGIN{weekdays[&quot;mon&quot;]=&quot;Monday&quot;;weekdays[&quot;tue&quot;]=&quot;Tuesday&quot;;print weekdays[&quot;mon&quot;]}&#39;</code></p><p><strong>若要遍历数组中的每一个元素,要使用for循环</strong></p><p>格式：<br><code>for ( var in array) {for-body}</code><br><strong><em>注意: var会遍历array中的每个索引</em></strong></p><p>范例：<br><code>awk &#39;BEGIN{weekdays[&quot;mon&quot;]=&quot;Monday&quot;;weekdays[&quot;tue&quot;]=&quot;Tuesday&quot;;for (i in weekdays) {print weekdays[i]}}&#39;</code></p><p><strong><em>注意： i保存数组中的索引,而不是$i数组中的元素的值</em></strong></p><p>范例：统计tcp连接状态:<br><code>netstat -tan |awk &#39;/^tcp\&gt;/{state[$NF]++}END{for (i in state) {print i,state[i]}}&#39;</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;awk简介&quot;&gt;&lt;a href=&quot;#awk简介&quot; class=&quot;headerlink&quot; title=&quot;awk简介&quot;&gt;&lt;/a&gt;awk简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;awk是一种编程语言，用于在linux/unix下对文本和数据进行处理。数据可以来自标准输入、一个或多个文件，或其它命令的输出。它支持用户自定义函数和动态正则表达式等先进功能，是linux/unix下的一个强大编程工具。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;特性介绍&quot;&gt;&lt;a href=&quot;#特性介绍&quot; class=&quot;headerlink&quot; title=&quot;特性介绍&quot;&gt;&lt;/a&gt;特性介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;awk的处理文本和数据的方式是这样的，它逐行扫描文件，从第一行到最后一行，寻找匹配的特定模式的行，并在这些行上进行你想要的操作。&lt;/li&gt;
&lt;li&gt;如果没有指定处理动作，则把匹配的行显示到标准输出(屏幕)；如果没有指定模式，则所有被操作所指定的行都被处理。&lt;/li&gt;
&lt;li&gt;下面介绍的awk是以GUN的gawk为例的，在linux系统中已把awk链接到gawk，所以下面全部以awk进行介绍。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;awk命令格式和选项&quot;&gt;&lt;a href=&quot;#awk命令格式和选项&quot; class=&quot;headerlink&quot; title=&quot;awk命令格式和选项&quot;&gt;&lt;/a&gt;awk命令格式和选项&lt;/h2&gt;&lt;h3 id=&quot;awk的语法&quot;&gt;&lt;a href=&quot;#awk的语法&quot; class=&quot;headerlink&quot; title=&quot;awk的语法&quot;&gt;&lt;/a&gt;awk的语法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;awk [options] ‘script’ var=value file(s)&lt;/li&gt;
&lt;li&gt;awk [options] -f scriptfile var=value file(s)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;script= PATTERN {ACTION STATEMENTS}&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PATTERN: 模式,用于地址定界&lt;/li&gt;
&lt;li&gt;ACTION STATEMENTS:动作语句,语句之间用分号分隔&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-2-命令选项&quot;&gt;&lt;a href=&quot;#2-2-命令选项&quot; class=&quot;headerlink&quot; title=&quot;2.2. 命令选项&quot;&gt;&lt;/a&gt;2.2. 命令选项&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;-F fs ：指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:
-v var=val ： 自定义变量
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;awk的模式与动作&quot;&gt;&lt;a href=&quot;#awk的模式与动作&quot; class=&quot;headerlink&quot; title=&quot;awk的模式与动作&quot;&gt;&lt;/a&gt;awk的模式与动作&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;awk脚本是由模式(PATTERN)和操作语句(ACTION STATEMENTS)两个部分组成,下面将详细介绍这两个部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;模式-地址定界&quot;&gt;&lt;a href=&quot;#模式-地址定界&quot; class=&quot;headerlink&quot; title=&quot;模式(地址定界)&quot;&gt;&lt;/a&gt;模式(地址定界)&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;empty: 匹配每一行。&lt;/li&gt;
&lt;li&gt;/regular expression/: 正则表达式,仅处理被模式匹配到的行。&lt;br&gt;&lt;code&gt;awk -F: &amp;#39;!/^UUID/{print $1}&amp;#39; /etc/fstab&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;relation expression: 关系表达式,结果有”真”有假: 结果为”真”的行才会被处理。&lt;br&gt;&lt;code&gt;awk -F: &amp;#39;$3&amp;lt;1000{print $1,$3}&amp;#39; /etc/passwd&lt;/code&gt;&lt;br&gt;&lt;code&gt;awk -F: &amp;#39;$NF~/bash$/{print $1,$NF}&amp;#39; /etc/passwd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;line ranges:行范围&lt;ul&gt;
&lt;li&gt;(NR&amp;gt;2&amp;amp;&amp;amp;NR&amp;lt;10)  行匹配&lt;/li&gt;
&lt;li&gt;/pattern1/,/pattern2/ 第一次匹配模式1起始和第一次匹配模式2终&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BEGIN/END模式&lt;ul&gt;
&lt;li&gt;BEGIN{}: 仅在开始处理文件中的文本之前执行一次，通常可在这里设置全局变量。&lt;/li&gt;
&lt;li&gt;END{}: 仅在文本处理完成后执行一次&lt;br&gt;&lt;code&gt;awk -F: &amp;#39;BEGIN{print &amp;quot;     username   uid\n---------------&amp;quot;} {print $1,$3} END {print &amp;quot;==============\n  end&amp;quot;}&amp;#39; /etc/passwd&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="linux基础" scheme="http://www.chenfanlinux.org/categories/linux%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="awk" scheme="http://www.chenfanlinux.org/tags/awk/"/>
    
  </entry>
  
  <entry>
    <title>Bash编程入门之流程控制(四)</title>
    <link href="http://www.chenfanlinux.org/2018/01/25/Bash%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E4%B9%8B%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6-%E5%9B%9B/"/>
    <id>http://www.chenfanlinux.org/2018/01/25/Bash编程入门之流程控制-四/</id>
    <published>2018-01-25T03:17:48.000Z</published>
    <updated>2018-01-29T10:10:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><blockquote><p>bash shell中会根据命令的执行状态结果(0或1),来表示条件的true或false,根据不同的条件,选择的执行不同的语句,来达到流程控制的目的。</p></blockquote><h3 id="单分支-if结构"><a href="#单分支-if结构" class="headerlink" title="单分支 if结构"></a>单分支 if结构</h3><pre><code>if CONDITON;then    if-truefi---------------------------------------------if  [[ expression  ]];then    if-truefi</code></pre><p><strong><em>注意：此处的CONDITION相当于bash中的命令,根据命令的执行状态结构，来选择语句是否执行。</em></strong></p><h3 id="双分支-if-else结构"><a href="#双分支-if-else结构" class="headerlink" title="双分支 if/else结构"></a>双分支 if/else结构</h3><pre><code>if CONDITION;then    if-trueelse    if-falsefi----------------------------------------------if  [[ expression ]];then   if-trueelse  if-falsefi</code></pre><a id="more"></a><h3 id="多分支-if-elif-else结构"><a href="#多分支-if-elif-else结构" class="headerlink" title="多分支 if/elif/else结构"></a>多分支 if/elif/else结构</h3><pre><code>if CONDITION1;then    if-trueelif CONDITON2;then    if-trueelif CONDITION3;then    if-true........else    all-falsefi</code></pre><p><strong><em>注意: 逐条件判断,第一次遇到为”真的条件”时,执行其分支,而后结束。</em></strong></p><h3 id="case-esac结构"><a href="#case-esac结构" class="headerlink" title="case/esac结构"></a>case/esac结构</h3><pre><code>case variable_name in   pattern1)      statements         ;;   pattern2)      statements         ;;   pattern3)         ;;esac</code></pre><p><strong><em>注意：根据变量取值得不同，执行不同的语句，适合菜单功能的实现</em></strong></p><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><blockquote><p>根据循环的进入条件,开始执行循环语句,然后根据循环的退出条件,退出循环语句的执行。常见的循环有三种类型: while、until、for。</p></blockquote><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><pre><code>while CONDITONdo   循环体done------------------------------------while [[ string expression ]]do   循环体done------------------------------------while (( numeric expression ))do   循环体done</code></pre><p><strong><em>while循环,只要表达式为真，循环体就会被一直执行。</em></strong></p><h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><pre><code>while :do    循环体done--------------while truedo    循环体done--------------for (( ; ; ))</code></pre><h3 id="until-循环"><a href="#until-循环" class="headerlink" title="until 循环"></a>until 循环</h3><blockquote><p>until循环执行一系列命令直至条件为真时停止。until循环与while循环在处理方式上刚好相反。一般while循环优于until循环，但在某些时候—也只是极少数情况下，until循环更加有用。</p></blockquote><pre><code>until conditiondo    commanddone</code></pre><p><strong><em>注意：条件可为任意测试条件，测试发生在循环末尾，因此循环至少执行一次。</em></strong></p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><blockquote><p>依次将列表中的元素当值赋值给”变量名”,每次赋值后即执行一次循环体;直到列表中的元素耗尽,循环结束。</p></blockquote><pre><code>for 变量名  in 列表do 循环体done</code></pre><p><strong>列表生成的方式:</strong></p><ul><li><p>直接给出列表</p></li><li><p>整数列表</p><ul><li>{start..end}</li><li>`seq 1 10`</li></ul></li><li><p>返回列表的命令 $(COMMAND)</p></li><li><p>glob   /var/*</p></li><li>变量引用<br>$@,$*</li></ul><p><strong>for循环的特殊用法</strong></p><pre><code>for ((控制变量初始化;条件表达式;控制变量的修正表达式));do循环体done \\范例 declare -i sum=0 for ((i=0;i&lt;=100;i++));do let sum+=$i done echo &quot;$sum&quot;</code></pre><p><strong><em>控制变量的初始化:仅在运行循环代码段时执行一次</em></strong><br><strong><em>控制变量的修正表达式:每轮循环结束会先进行控制变量修正运算,而后进行条件判断。</em></strong></p><h3 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a>跳出循环</h3><blockquote><p>在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，Shell使用两个命令来实现该功能：break和continue。</p></blockquote><p><strong>break命令</strong><br>break命令允许跳出所有循环（终止执行后面的所有循环）。</p><p><strong>continue命令</strong><br>continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;条件判断&quot;&gt;&lt;a href=&quot;#条件判断&quot; class=&quot;headerlink&quot; title=&quot;条件判断&quot;&gt;&lt;/a&gt;条件判断&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;bash shell中会根据命令的执行状态结果(0或1),来表示条件的true或false,根据不同的条件,选择的执行不同的语句,来达到流程控制的目的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;单分支-if结构&quot;&gt;&lt;a href=&quot;#单分支-if结构&quot; class=&quot;headerlink&quot; title=&quot;单分支 if结构&quot;&gt;&lt;/a&gt;单分支 if结构&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;if CONDITON;then
    if-true
fi
---------------------------------------------
if  [[ expression  ]];then
    if-true
fi
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意：此处的CONDITION相当于bash中的命令,根据命令的执行状态结构，来选择语句是否执行。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;双分支-if-else结构&quot;&gt;&lt;a href=&quot;#双分支-if-else结构&quot; class=&quot;headerlink&quot; title=&quot;双分支 if/else结构&quot;&gt;&lt;/a&gt;双分支 if/else结构&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;if CONDITION;then
    if-true
else
    if-false
fi

----------------------------------------------
if  [[ expression ]];then
   if-true
else
  if-false
fi
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Bash Shell编程" scheme="http://www.chenfanlinux.org/categories/Bash-Shell%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Bash" scheme="http://www.chenfanlinux.org/tags/Bash/"/>
    
  </entry>
  
  <entry>
    <title>awk应用指南</title>
    <link href="http://www.chenfanlinux.org/2018/01/23/awk%E5%BA%94%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://www.chenfanlinux.org/2018/01/23/awk应用指南/</id>
    <published>2018-01-23T01:08:59.000Z</published>
    <updated>2018-01-26T03:58:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="awk简介"><a href="#awk简介" class="headerlink" title="awk简介"></a>awk简介</h2><blockquote><p>awk是一种编程语言，用于在linux/unix下对文本和数据进行处理。数据可以来自标准输入、一个或多个文件，或其它命令的输出。它支持用户自定义函数和动态正则表达式等先进功能，是linux/unix下的一个强大编程工具。</p></blockquote><h3 id="特性介绍"><a href="#特性介绍" class="headerlink" title="特性介绍"></a>特性介绍</h3><ul><li>awk的处理文本和数据的方式是这样的，它逐行扫描文件，从第一行到最后一行，寻找匹配的特定模式的行，并在这些行上进行你想要的操作。</li><li>如果没有指定处理动作，则把匹配的行显示到标准输出(屏幕)；如果没有指定模式，则所有被操作所指定的行都被处理。</li><li>下面介绍的awk是以GUN的gawk为例的，在linux系统中已把awk链接到gawk，所以下面全部以awk进行介绍。</li></ul><h2 id="awk命令格式和选项"><a href="#awk命令格式和选项" class="headerlink" title="awk命令格式和选项"></a>awk命令格式和选项</h2><h3 id="awk的语法"><a href="#awk的语法" class="headerlink" title="awk的语法"></a>awk的语法</h3><ul><li>awk [options] ‘script’ var=value file(s)</li><li>awk [options] -f scriptfile var=value file(s)</li></ul><p><code>script= PATTERN {ACTION STATEMENTS}</code></p><ul><li>PATTERN: 模式,用于地址定界</li><li>ACTION STATEMENTS:动作语句,语句之间用分号分隔</li></ul><h3 id="2-2-命令选项"><a href="#2-2-命令选项" class="headerlink" title="2.2. 命令选项"></a>2.2. 命令选项</h3><pre><code>-F fs ：指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:-v var=val ： 自定义变量</code></pre><h2 id="awk的模式与动作"><a href="#awk的模式与动作" class="headerlink" title="awk的模式与动作"></a>awk的模式与动作</h2><blockquote><p>awk脚本是由模式(PATTERN)和操作语句(ACTION STATEMENTS)两个部分组成,下面将详细介绍这两个部分。</p></blockquote><h3 id="模式-地址定界"><a href="#模式-地址定界" class="headerlink" title="模式(地址定界)"></a>模式(地址定界)</h3><ul><li>empty: 匹配每一行。</li><li>/regular expression/: 正则表达式,仅处理被模式匹配到的行。<br><code>awk -F: &#39;!/^UUID/{print $1}&#39; /etc/fstab</code></li><li>relation expression: 关系表达式,结果有”真”有假: 结果为”真”的行才会被处理。<br><code>awk -F: &#39;$3&lt;1000{print $1,$3}&#39; /etc/passwd</code><br><code>awk -F: &#39;$NF~/bash$/{print $1,$NF}&#39; /etc/passwd</code></li><li>line ranges:行范围<ul><li>(NR&gt;2&amp;&amp;NR&lt;10)  行匹配</li><li>/pattern1/,/pattern2/ 第一次匹配模式1起始和第一次匹配模式2终</li></ul></li><li>BEGIN/END模式<ul><li>BEGIN{}: 仅在开始处理文件中的文本之前执行一次，通常可在这里设置全局变量。</li><li>END{}: 仅在文本处理完成后执行一次<br><code>awk -F: &#39;BEGIN{print &quot;     username   uid\n---------------&quot;} {print $1,$3} END {print &quot;==============\n  end&quot;}&#39; /etc/passwd</code></li></ul></li></ul><a id="more"></a><h3 id="动作语句"><a href="#动作语句" class="headerlink" title="动作语句"></a>动作语句</h3><blockquote><p>动作由一个或多个命令、函数、表达式组成，之间由换行符或分号隔开，并位于大括号内，主要有下面四部分。</p></blockquote><ul><li><p>变量或数组赋值</p></li><li><p>输出命令</p></li><li><p>内置函数</p></li><li><p>控制流命令</p></li></ul><h3 id="awk变量"><a href="#awk变量" class="headerlink" title="awk变量"></a>awk变量</h3><p><strong>awk的环境变量</strong></p><table><thead><tr><th>变量</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>$n</td><td style="text-align:center">当前行的第n个字段，字段间由FS分隔。</td></tr><tr><td>$0</td><td style="text-align:center">完整的行</td></tr><tr><td>FS</td><td style="text-align:center">输入字段分隔符，默认为空格</td></tr><tr><td>OFS</td><td style="text-align:center">输出字段分隔符，默认为空格</td></tr><tr><td>NF</td><td style="text-align:center">当前行的字段总数</td></tr><tr><td>NR</td><td style="text-align:center">当前行的记录数,行号</td></tr><tr><td>RS</td><td style="text-align:center">输入时的行的分隔符,默认换行符(\n)</td></tr><tr><td>ORS</td><td style="text-align:center">输出时的行的分隔符,默认换行符(\n)</td></tr><tr><td>ARGC</td><td style="text-align:center">命令行参数个数</td></tr><tr><td>ARGV</td><td style="text-align:center">数组,命令行中所给定的各参数</td></tr></tbody></table><p><strong><em>注意事项:awk 内部引用变量,无须加$</em></strong></p><p><strong>自定义变量</strong></p><ul><li><p>-v var=value<br><code>awk -v test=&#39;hello&#39; &#39;BEGIN{print test}&#39; /etc/fstab</code></p></li><li><p>在program中直接定义<br><code>awk &#39;BEGIN{test=&quot;hello&quot;;print test}&#39; /etc/fstab</code></p></li></ul><h3 id="运算操作符"><a href="#运算操作符" class="headerlink" title="运算操作符"></a>运算操作符</h3><p><strong>算术操作符</strong><br> x+y,x-y,x*y,x/y,x%y,x^y,-x，+x</p><p><strong>字符串操作符</strong><br>没有符号的操作符,字符串连接</p><p><strong>赋值操作符</strong><br> =,+=,-=,/=,%=,^=,++,–</p><p><strong>比较操作符</strong><br>&lt;,&gt;=,&lt;,&lt;=,!=,==</p><p><strong>模式匹配符</strong><br>~ :是否匹配正则表达式<br>!~：是否不匹正则表达式</p><p><strong>逻辑操作符</strong><br>&amp;&amp;  与<br>||  或<br>!   非</p><p><strong>函数调用</strong><br><code>function_name(argu1,argu2,....）</code></p><p><strong>条件表达式 ?: 选择器</strong><br>语法：selector? if-true-expression:if-fales-expression<br><code>awk -F: &#39;{$3&gt;=1000?usertype=&quot;common user&quot;:usertype=&quot;sysadmin or sysuser&quot;;printf&quot;%15s:%s\n&quot;,$1,usertype}&#39; /etc/passwd</code></p><h3 id="printf命令"><a href="#printf命令" class="headerlink" title="printf命令"></a>printf命令</h3><p>格式化输出: <code>printf FORMAT,item1,item2....</code></p><p>FORMAT注意点：</p><ul><li>FORMAT必须给出</li><li>不会自动换行,需要显示给出换行符,\n</li><li>FORMAT中需要分别为后面的每个item指定一个格式化符号</li></ul><p>格式符:</p><ul><li>%c: 显示字符的ASCII码</li><li>%d: 显示十进制整数</li><li>%e: 科学计数数值显示</li><li>%f: 显示浮点数</li><li>%g: 科学计数法或浮点形式</li><li>%s: 显示字符串</li><li>%u: 无符号整数</li><li>%%: 显示%自身</li></ul><p>修饰符:</p><ul><li>num[.num]: 第一个数字控制显示的宽度,第二个表示小数的精度<br> %3.1f</li><li>-: 左对齐</li><li>+: 显示数值的符号</li></ul><p>范例：<br><code>awk -F: &#39;{printf &quot;Username: %s Uid:%d\n&quot;,$1,$3}&#39; /etc/passwd</code></p><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><blockquote><p>awk中的条件语句是从C语言中借鉴过来的，可控制程序的流程。</p></blockquote><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>格式：</p><pre><code>{if (expression){                  statement; statement; ...                    }       }</code></pre><p>范例：<br><code>awk -F: &#39;{if($3&gt;1000) {print$1,$3}}&#39; /etc/passwd</code></p><h3 id="if-else语句，用于双重判断"><a href="#if-else语句，用于双重判断" class="headerlink" title="if/else语句，用于双重判断"></a>if/else语句，用于双重判断</h3><p>格式：</p><pre><code>{if (expression){                statement; statement; ...                    }     else{                statement; statement; ...                    }     }</code></pre><p>范例：<br><code>awk -F: &#39;{if ($3&gt;=1000) {printf &quot;Admin user: %s\n&quot;,$1} else {printf &quot;Common user: %s\n&quot;,$1}}&#39; /etc/passwd</code></p><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>格式：</p><pre><code>{while (expression) {        statement;statement;....                     }     }</code></pre><p>范例：<br><code>awk &#39;/^[[:space:]]*linux16*/  {i=1;while(i&lt;=NF) {if(length($i)&gt;20) {print $i,length($i)};i++}}&#39; /etc/grub2.cfg</code></p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>格式:<br><code>for(expr1,expr2,expr3) statement</code><br><code>for (variable assignment;condition;iteration process) {for-body}</code><br>      <strong><em>初始化变量，条件，自增加程序</em></strong></p><p>范例:<br><code>awk &#39;/^[[:space:]]*linux16*/ {for (i=1;i&lt;=NF;i++) {print $i,length($i)}}&#39; /etc/grub2.cfg</code></p><h3 id="next"><a href="#next" class="headerlink" title="next"></a>next</h3><p><strong><em>提前结束对本行的处理,直接进入下一行</em></strong></p><p>范例：<br><code>awk -F: &#39;{if($3%2!=0) next;print $1,$3}&#39; /etc/passwd</code></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>关联数组: array[index-expression]</p><p>index-expression: 索引表达式</p><ul><li>可以使用任意字符串:字符串需要加双引号。</li><li>如果某数组元素事先不存在,在引用时,awk会自动创建此元素,并将其值初始化为空。</li></ul><p><strong>若要判断数组中是否存在某元素要使用”index in array”格式进行</strong></p><p><code>awk &#39;BEGIN{weekdays[&quot;mon&quot;]=&quot;Monday&quot;;weekdays[&quot;tue&quot;]=&quot;Tuesday&quot;;print weekdays[&quot;mon&quot;]}&#39;</code></p><p><strong>若要遍历数组中的每一个元素,要使用for循环</strong></p><p>格式：<br><code>for ( var in array) {for-body}</code><br><strong><em>注意: var会遍历array中的每个索引</em></strong></p><p>范例：<br><code>awk &#39;BEGIN{weekdays[&quot;mon&quot;]=&quot;Monday&quot;;weekdays[&quot;tue&quot;]=&quot;Tuesday&quot;;for (i in weekdays) {print weekdays[i]}}&#39;</code></p><p><strong><em>注意： i保存数组中的索引,而不是$i数组中的元素的值</em></strong></p><p>范例：统计tcp连接状态:<br><code>netstat -tan |awk &#39;/^tcp\&gt;/{state[$NF]++}END{for (i in state) {print i,state[i]}}&#39;</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;awk简介&quot;&gt;&lt;a href=&quot;#awk简介&quot; class=&quot;headerlink&quot; title=&quot;awk简介&quot;&gt;&lt;/a&gt;awk简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;awk是一种编程语言，用于在linux/unix下对文本和数据进行处理。数据可以来自标准输入、一个或多个文件，或其它命令的输出。它支持用户自定义函数和动态正则表达式等先进功能，是linux/unix下的一个强大编程工具。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;特性介绍&quot;&gt;&lt;a href=&quot;#特性介绍&quot; class=&quot;headerlink&quot; title=&quot;特性介绍&quot;&gt;&lt;/a&gt;特性介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;awk的处理文本和数据的方式是这样的，它逐行扫描文件，从第一行到最后一行，寻找匹配的特定模式的行，并在这些行上进行你想要的操作。&lt;/li&gt;
&lt;li&gt;如果没有指定处理动作，则把匹配的行显示到标准输出(屏幕)；如果没有指定模式，则所有被操作所指定的行都被处理。&lt;/li&gt;
&lt;li&gt;下面介绍的awk是以GUN的gawk为例的，在linux系统中已把awk链接到gawk，所以下面全部以awk进行介绍。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;awk命令格式和选项&quot;&gt;&lt;a href=&quot;#awk命令格式和选项&quot; class=&quot;headerlink&quot; title=&quot;awk命令格式和选项&quot;&gt;&lt;/a&gt;awk命令格式和选项&lt;/h2&gt;&lt;h3 id=&quot;awk的语法&quot;&gt;&lt;a href=&quot;#awk的语法&quot; class=&quot;headerlink&quot; title=&quot;awk的语法&quot;&gt;&lt;/a&gt;awk的语法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;awk [options] ‘script’ var=value file(s)&lt;/li&gt;
&lt;li&gt;awk [options] -f scriptfile var=value file(s)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;script= PATTERN {ACTION STATEMENTS}&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PATTERN: 模式,用于地址定界&lt;/li&gt;
&lt;li&gt;ACTION STATEMENTS:动作语句,语句之间用分号分隔&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-2-命令选项&quot;&gt;&lt;a href=&quot;#2-2-命令选项&quot; class=&quot;headerlink&quot; title=&quot;2.2. 命令选项&quot;&gt;&lt;/a&gt;2.2. 命令选项&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;-F fs ：指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:
-v var=val ： 自定义变量
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;awk的模式与动作&quot;&gt;&lt;a href=&quot;#awk的模式与动作&quot; class=&quot;headerlink&quot; title=&quot;awk的模式与动作&quot;&gt;&lt;/a&gt;awk的模式与动作&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;awk脚本是由模式(PATTERN)和操作语句(ACTION STATEMENTS)两个部分组成,下面将详细介绍这两个部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;模式-地址定界&quot;&gt;&lt;a href=&quot;#模式-地址定界&quot; class=&quot;headerlink&quot; title=&quot;模式(地址定界)&quot;&gt;&lt;/a&gt;模式(地址定界)&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;empty: 匹配每一行。&lt;/li&gt;
&lt;li&gt;/regular expression/: 正则表达式,仅处理被模式匹配到的行。&lt;br&gt;&lt;code&gt;awk -F: &amp;#39;!/^UUID/{print $1}&amp;#39; /etc/fstab&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;relation expression: 关系表达式,结果有”真”有假: 结果为”真”的行才会被处理。&lt;br&gt;&lt;code&gt;awk -F: &amp;#39;$3&amp;lt;1000{print $1,$3}&amp;#39; /etc/passwd&lt;/code&gt;&lt;br&gt;&lt;code&gt;awk -F: &amp;#39;$NF~/bash$/{print $1,$NF}&amp;#39; /etc/passwd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;line ranges:行范围&lt;ul&gt;
&lt;li&gt;(NR&amp;gt;2&amp;amp;&amp;amp;NR&amp;lt;10)  行匹配&lt;/li&gt;
&lt;li&gt;/pattern1/,/pattern2/ 第一次匹配模式1起始和第一次匹配模式2终&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BEGIN/END模式&lt;ul&gt;
&lt;li&gt;BEGIN{}: 仅在开始处理文件中的文本之前执行一次，通常可在这里设置全局变量。&lt;/li&gt;
&lt;li&gt;END{}: 仅在文本处理完成后执行一次&lt;br&gt;&lt;code&gt;awk -F: &amp;#39;BEGIN{print &amp;quot;     username   uid\n---------------&amp;quot;} {print $1,$3} END {print &amp;quot;==============\n  end&amp;quot;}&amp;#39; /etc/passwd&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="linux基础" scheme="http://www.chenfanlinux.org/categories/linux%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Awk" scheme="http://www.chenfanlinux.org/tags/Awk/"/>
    
  </entry>
  
  <entry>
    <title>流编辑器sed学习笔记</title>
    <link href="http://www.chenfanlinux.org/2018/01/21/%E6%B5%81%E7%BC%96%E8%BE%91%E5%99%A8sed%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.chenfanlinux.org/2018/01/21/流编辑器sed学习笔记/</id>
    <published>2018-01-21T15:25:16.000Z</published>
    <updated>2018-01-26T03:39:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Sed"><a href="#Sed" class="headerlink" title="Sed"></a>Sed</h2><blockquote><p>全称Stream Editor,Sed从本质上来讲其实是一种非交互式的编辑器。</p></blockquote><h3 id="sed的处理流程"><a href="#sed的处理流程" class="headerlink" title="sed的处理流程"></a>sed的处理流程</h3><blockquote><p>sed中script执行是有先后顺序的</p></blockquote><ol><li>读入一行内行到缓存空间(模式空间)</li><li>从script中取出一条命令, 判断是否匹配pattern(一般为正则表达式)</li><li>如果不匹配, 则忽略后续命令, 回到第二步取下一条命令</li><li>如果匹配, 则对缓存的行执行后续的编辑命令; 完成后, 回到第二步继续取下一条命令</li><li>当所有命令应用后, 输出缓存行的内容, 回到第一步读取下一行</li><li>当所有行处理完则执行结束</li></ol><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><p><code>sed [options] &#39;script&#39; inputfile</code><br>对于script的语法有两种约定，分别是</p><ul><li>[address]command              指可以为任意地址包括地址对</li><li>[line-address]command         只能为单个地址</li></ul><h3 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h3><pre><code>-n: 不输出模式空间中的内容至屏幕-e: 多点编辑-r: 支持使用扩展的正则表达式-i: 修改原文件</code></pre><h3 id="地址定界"><a href="#地址定界" class="headerlink" title="地址定界"></a>地址定界</h3><ul><li>no-address:对全文进行处理</li><li><p>line-address 单地址</p><ul><li>n1  指定的行,数字表示</li><li>/pattern/ 被此处模式所能匹配到的每一行</li></ul></li><li><p>address 地址对</p><ul><li>n1,n2</li><li>n1,+n2</li><li>/pattern1/,/pattern2/</li><li>n1,/pattern1/</li></ul></li></ul><a id="more"></a><h3 id="sed基础命令"><a href="#sed基础命令" class="headerlink" title="sed基础命令"></a>sed基础命令</h3><p><img src="https://s1.ax1x.com/2018/01/21/pfgjyQ.png" alt="sed基础命令"></p><h3 id="sed命令实践"><a href="#sed命令实践" class="headerlink" title="sed命令实践"></a>sed命令实践</h3><p><strong>删除匹配的某行</strong></p><pre><code>[root@docker ~]# sed &apos;/^UUID/d&apos; /etc/fstab## /etc/fstab# Created by anaconda on Fri Nov 17 00:04:38 2017## Accessible filesystems, by reference, are maintained under &apos;/dev/disk&apos;# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info#fhfh/dev/mapper/centos-root /                       xfs     defaults        0 0/dev/mapper/centos-swap swap                    swap    defaults        0 0</code></pre><p><strong>显示模式空间中内容,仅打印模式空间中被匹配</strong></p><pre><code>[root@docker ~]# sed -n &apos;/^UUID/p&apos; /etc/fstabUUID=377d33fc-dff8-4bb1-9620-20ae6638453d /boot    xfs     defaults        0 0</code></pre><p><strong>a \text 在行后面追加文本: 支持使用\n实现多行追加</strong></p><pre><code>[root@docker ~]# sed &apos;/^UUID/a \hello boy\nwelcome to chenfanlinux.org&apos; /etc/fstab# /etc/fstab# Created by anaconda on Fri Nov 17 00:04:38 2017## Accessible filesystems, by reference, are maintained under &apos;/dev/disk&apos;# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info/dev/mapper/centos-root /                       xfs     defaults        0 0UUID=377d33fc-dff8-4bb1-9620-20ae6638453d /boot                   xfs     defaults        0 0hello boywelcome to chenfanlinux.org/dev/mapper/centos-swap swap                    swap    defaults        0 0</code></pre><p><strong>i \text 在符合条件的行前面追加文本</strong></p><pre><code>[root@docker ~]#  sed &apos;/^UUID/i \hello world\nwelcome&apos; /etc/fstab# /etc/fstab# Created by anaconda on Fri Nov 17 00:04:38 2017## Accessible filesystems, by reference, are maintained under &apos;/dev/disk&apos;# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info/dev/mapper/centos-root /                       xfs     defaults        0 0hello worldwelcomeUUID=377d33fc-dff8-4bb1-9620-20ae6638453d /boot                   xfs     defaults        0 0/dev/mapper/centos-swap swap                    swap    defaults        0 0</code></pre><p><strong>c \text 替换符合添加的行</strong></p><pre><code>[root@docker ~]#  sed &apos;/^UUID/c \hello world\nwelcome&apos; /etc/fstab## /etc/fstab# Created by anaconda on Fri Nov 17 00:04:38 2017## Accessible filesystems, by reference, are maintained under &apos;/dev/disk&apos;# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info/dev/mapper/centos-root /                       xfs     defaults        0 0hello worldwelcome/dev/mapper/centos-swap swap                    swap    defaults        0 0</code></pre><p><strong>s///: 支持使用其他分隔符,如$@@@、$###</strong></p><p>格式： <code>[address]s/pattern/replacement/flag</code></p><p><strong>flag:</strong></p><ul><li>g: 全局替换</li><li>p: 显示替换成功的行</li><li>w /path/to/somefile: 将替换成功的结果保存至指定文件中</li></ul><p><strong><em>替换匹配r..t的字符，并在其后加er</em></strong></p><pre><code>[root@docker ~]# sed -n &apos;s/\(r..t\)#\1er/p&apos; /etc/passwdrooter:x:0:0:root:/root:/bin/bashoperator:x:11:0:operator:/rooter:/sbin/nologinftp:x:14:50:FTP User:/var/fterp:/sbin/nologin</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Sed&quot;&gt;&lt;a href=&quot;#Sed&quot; class=&quot;headerlink&quot; title=&quot;Sed&quot;&gt;&lt;/a&gt;Sed&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;全称Stream Editor,Sed从本质上来讲其实是一种非交互式的编辑器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;sed的处理流程&quot;&gt;&lt;a href=&quot;#sed的处理流程&quot; class=&quot;headerlink&quot; title=&quot;sed的处理流程&quot;&gt;&lt;/a&gt;sed的处理流程&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;sed中script执行是有先后顺序的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;读入一行内行到缓存空间(模式空间)&lt;/li&gt;
&lt;li&gt;从script中取出一条命令, 判断是否匹配pattern(一般为正则表达式)&lt;/li&gt;
&lt;li&gt;如果不匹配, 则忽略后续命令, 回到第二步取下一条命令&lt;/li&gt;
&lt;li&gt;如果匹配, 则对缓存的行执行后续的编辑命令; 完成后, 回到第二步继续取下一条命令&lt;/li&gt;
&lt;li&gt;当所有命令应用后, 输出缓存行的内容, 回到第一步读取下一行&lt;/li&gt;
&lt;li&gt;当所有行处理完则执行结束&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;命令格式&quot;&gt;&lt;a href=&quot;#命令格式&quot; class=&quot;headerlink&quot; title=&quot;命令格式&quot;&gt;&lt;/a&gt;命令格式&lt;/h3&gt;&lt;p&gt;&lt;code&gt;sed [options] &amp;#39;script&amp;#39; inputfile&lt;/code&gt;&lt;br&gt;对于script的语法有两种约定，分别是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[address]command              指可以为任意地址包括地址对&lt;/li&gt;
&lt;li&gt;[line-address]command         只能为单个地址&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;常用选项&quot;&gt;&lt;a href=&quot;#常用选项&quot; class=&quot;headerlink&quot; title=&quot;常用选项&quot;&gt;&lt;/a&gt;常用选项&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;-n: 不输出模式空间中的内容至屏幕
-e: 多点编辑
-r: 支持使用扩展的正则表达式
-i: 修改原文件
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;地址定界&quot;&gt;&lt;a href=&quot;#地址定界&quot; class=&quot;headerlink&quot; title=&quot;地址定界&quot;&gt;&lt;/a&gt;地址定界&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;no-address:对全文进行处理&lt;/li&gt;
&lt;li&gt;&lt;p&gt;line-address 单地址&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;n1  指定的行,数字表示&lt;/li&gt;
&lt;li&gt;/pattern/ 被此处模式所能匹配到的每一行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;address 地址对&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;n1,n2&lt;/li&gt;
&lt;li&gt;n1,+n2&lt;/li&gt;
&lt;li&gt;/pattern1/,/pattern2/&lt;/li&gt;
&lt;li&gt;n1,/pattern1/&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="linux基础" scheme="http://www.chenfanlinux.org/categories/linux%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Sed" scheme="http://www.chenfanlinux.org/tags/Sed/"/>
    
  </entry>
  
  <entry>
    <title>Shell通配符与正则表达式</title>
    <link href="http://www.chenfanlinux.org/2018/01/21/Shell%E9%80%9A%E9%85%8D%E7%AC%A6%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://www.chenfanlinux.org/2018/01/21/Shell通配符与正则表达式/</id>
    <published>2018-01-21T09:26:51.000Z</published>
    <updated>2018-01-26T03:39:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通配符是系统level,而正则表达式需要相关工具的支持:grep,awk,vi,perl。在文本过滤工具里,都是用正则表达式，比如像awk,sed等，是针对文件的内容的。通配符多用在文件名上,比如查找find,ls,cp,等等。</p></blockquote><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><blockquote><p>通配符的作用是用于模糊查询时通配文件名中某些不确定的字符, 通配符只有三个元字符 ？ * []</p></blockquote><h3 id="Bash中的通配符"><a href="#Bash中的通配符" class="headerlink" title="Bash中的通配符"></a>Bash中的通配符</h3><table><thead><tr><th style="text-align:center">通配符</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">?</td><td style="text-align:center">匹配任意单个字符，不包括路径标识”/“</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">匹配任意长度的字符，包括空字符,不包括路径标识”/“</td></tr><tr><td style="text-align:center">**</td><td style="text-align:center">匹配任意级别目录(bash 4.0以上版本支持,不包括路径标识”/“</td></tr><tr><td style="text-align:center">[]</td><td style="text-align:center">匹配一个单字符范围,如[a-z],[0-9],不包括路径标识”/“</td></tr></tbody></table><h3 id="的特殊用例"><a href="#的特殊用例" class="headerlink" title="[ ]的特殊用例"></a>[ ]的特殊用例</h3><ul><li>[]：匹配范围</li><li>[^]：排除匹配范围</li><li>[:alnum:]：所有字母和数字</li><li>[:alpha:]：所有字母</li><li>[:digit:]：所有数字</li><li>[:lower:]：所有小写字母</li><li>[:upper:]：所有大写字母</li><li>[:blank:]：空白字符和TAB制表符</li><li>[:space:]：包括空白字符、TAB制表符(\t)、换页(\f)</li><li>[:cntrl:]：所有控制字符</li><li>[:graph:]：可打印并可看到的字符。空格是可打印的，但是不是可看到的</li><li>[:print:]：所有可打印字符</li><li>[:punct:]：所有标点符号，非字母、数字、控制字符和space字符</li><li>[:xdigit:]：十六进制数的字符</li></ul><p><strong><em>注意：引用时，需要在加一层括号，如[[:alnum:]]</em></strong></p><h3 id="通配符范例"><a href="#通配符范例" class="headerlink" title="通配符范例"></a>通配符范例</h3><ul><li>*.txt               匹配全部后缀为.txt的文件</li><li>file?.log           匹配file1.log, file2.log, …</li><li>[a-z]*.log          匹配a-Z开头的.log文件,这里不区分字母大小写</li><li>[^a-z]*.log         上面的反向匹配</li><li>/etc/<em>*/</em>.conf      匹配/etc目录下第一层子目录下的所有.conf结尾的文件</li></ul><p><strong><em>注意: 反斜杠\或单双引号[‘ “]都会使通配符失效；如:  “\</em>“, ‘*‘都表示*本身，不通配任何文件。</strong></p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><blockquote><p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。</p></blockquote><p>在正则表达式出现后的一段时间里，诸子百家争鸣，乱世显现。这一年诞生了第一个较为统一的标准 —— POSIX，POSIX将正则表达式分为了两种标准Basic Regular Expressions(BREs)和 Extended Regular Expressions(EREs)</p><a id="more"></a><h3 id="BRE正则引擎"><a href="#BRE正则引擎" class="headerlink" title="BRE正则引擎"></a>BRE正则引擎</h3><p><strong>特性</strong></p><ul><li><p>基本正则表达式(Basic Regular Expressions)是速度最快的正则引擎标准。</p></li><li><p>Linux中使用BRE引擎的程序主要有grep和sed,由于sed注重速度，所以只实现了BRE的子集。意味着BRE的特性sed并不能全部支持。</p></li><li><p>正则表达式有元字符和非元字符组成，意味着写正则的时候只需要注意元字符的含义就行了。 非元字符代表直接匹配字符本身。</p></li></ul><p><strong>BRE正则的元字符</strong><br>BRE的元字符很少，只有. [] ^ $ * \ () {}这几种，甚至不支持|这种选择模式。</p><table><thead><tr><th style="text-align:center">元字符</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">.</td><td style="text-align:center">匹配任意单字符，如a, b, 1等等，不包括空白字符</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">不匹配任何字符，代表锚定行首,如^abc代表以abc开头的模式中</td></tr><tr><td style="text-align:center">$</td><td style="text-align:center">不匹配任何字符，代表锚定行尾,如abc$代表以abc结尾的模式</td></tr><tr><td style="text-align:center">[]</td><td style="text-align:center">代表匹配括号内任意一个单字符,如[abc]代表匹配a或b或c任意一个</td></tr><tr><td style="text-align:center">[^]</td><td style="text-align:center">[^pattern]    代表取反匹配,不匹配pattern的模式,如abc代表除abc之外的其他单字符</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">代表匹配前面一个单字符任意次(包括0次) ,如a*b代表匹配b,ab,aab…</td></tr><tr><td style="text-align:center">\</td><td style="text-align:center">转义字符，\会匹配\这个字符</td></tr><tr><td style="text-align:center">()</td><td style="text-align:center">后项引用，后续将详细介绍</td></tr><tr><td style="text-align:center">{}</td><td style="text-align:center">重复前面字符的次数,后续将详细介绍</td></tr></tbody></table><p><strong>注意点</strong></p><ul><li><p>正则都是区分大小写的，，意味着[a-z]不能匹配到ABCD。有些程序的命令或参数支持忽略大小写匹配, 如grep -i。但要注意，对于正则表达式本身是大小写敏感的。</p></li><li><p>^和$出现在模式中间的时候，无特殊含义，如a^b匹配的就是a^b这个字符串。 类似的，只有右半个括号时 ) ] } 也无特殊含义，无需转义, 如 <code>[]abc]</code></p></li><li><p>[]里面的pattern可以配合-简写, 如 <code>[a-zA-Z], [0-9]</code></p></li></ul><p><strong><em>此外，POSIX class也可以在正则表达式中运用，以下是对照表:</em></strong></p><p><img src="https://s1.ax1x.com/2018/01/21/pWMHH0.png" alt="POSIX class"></p><p><strong>\ 的妙用</strong><br>\ 的作用是转义字符，对元字符使用会失去元字符的作用，但对于某些非元字符使用会带来意想不到的妙用。 这里讲解一些边界的匹配问题，后面还会看到更多关于\的奇妙的用法。</p><ul><li><p>如果要匹配单词的起始(左边界)，可以用\&lt;匹配。例如:\&lt;book可以匹配book, bookooooo,但是不能匹配abook。</p></li><li><p>类似的，如果要匹配单词的结尾(右边界),可以用>匹配。例如: do>不能匹配到doing, 但能匹配到todo</p></li><li><p>左右边界的匹配合起来可以使用\b。例如\bset\b匹配的就是set这个单词，等同于\<set\>。</set\></p></li></ul><h3 id="ERE正则引擎"><a href="#ERE正则引擎" class="headerlink" title="ERE正则引擎"></a>ERE正则引擎</h3><blockquote><p>扩展正则表达式(Extended Regular Expression)在BRE的基础上，进行了功能上的扩充，增加了元字符。在Linux中，常见的使用ERE正则的程序有grep -E,egrep，sed -r,awk等。</p></blockquote><p><strong>扩展正则表达式的元字符</strong></p><p>ERE和BRE的元字符完全相同，在此之上，新增了元字符。<br>(),{}在BRE正则中需要配合\使用(),{}),在ERE中不再需要转义字符。 增加了 <strong><em>+ ?  |</em></strong> 这三个元字符。</p><p><img src="https://s1.ax1x.com/2018/01/21/pWjX24.png" alt="扩展的正则表达式"></p><p><strong>*和+的原罪 —— 贪婪匹配</strong></p><p>*和+在正则引擎中，会尽可能多的匹配满足条件的pattern，此外，还有{},? 也满足这个规律。这种规律称为贪婪匹配(greedy matching)。</p><h2 id="grep命令深度实践"><a href="#grep命令深度实践" class="headerlink" title="grep命令深度实践"></a>grep命令深度实践</h2><blockquote><p>grep: Global search REgular expression and Print out the line</p></blockquote><h3 id="使用语法及功能介绍"><a href="#使用语法及功能介绍" class="headerlink" title="使用语法及功能介绍"></a>使用语法及功能介绍</h3><p><strong>特性</strong></p><ul><li>文本搜索工具,根据用户指定的”模式”对目标文本逐行进行匹配检查,然后 打印匹配的行</li><li>模式: 由正则表达式字符及文本字符所编写的过滤条件</li></ul><p><strong>命令语法格式</strong></p><p><code>grep [OPTIONS] PATTERN [FILE...]</code></p><p><strong>常用选项</strong></p><pre><code>-E :使用扩展正则表达式-i :忽略大小写 -o :仅显示匹配到的字符串本身 -A n:after,显示匹配到的行及后n行 -B n:before,前n行-C n:context,前后各n行</code></pre><p><strong>基础正则按功能分类</strong></p><ul><li><p>字符匹配</p><ul><li>.  匹配任意单个字符</li><li>[]  匹配指定范围内的任意单个字符</li><li>[^]  匹配字符外的任意单个字符</li></ul></li><li><p>匹配次数:用在指定次数的字符后面,用于指定前面字符出现的次数</p><ul><li>*  匹配前面的字符任意次(包含0次)</li><li>.*  任意长度的任意字符,包含没有</li><li>\?  匹配前面的字符0次或1次,即前面字符可有可无</li><li>+  匹配前面字符至少一次</li><li>{m}  匹配前面的字符m次</li><li>{m,n}  匹配前面的字符至少m次,至多n次</li></ul></li><li><p>位置锚定</p><ul><li>^           行首锚定: 用于模式最左侧</li><li>$          行尾锚定: 用于模式的最右侧</li><li>^PATTERN$ 用模式匹配整行</li><li>^$ 空行</li><li>\&lt; 或 \b  词首锚定: 用于单词模式的左侧</li><li>> 或 \b  词尾锚定: 用于单词的右边</li><li>>PATTERN> 匹配整个单词</li></ul></li><li><p>分组:将一个或多个字符捆绑在一起,当作一个整体处理</p><ul><li>\(xy\)*  匹配xy任意次</li><li>后向引用: 引用前面的分组括号中的模式所匹配到的字符</li><li>分组括号中的模式匹配到的内容会被正则表达式引擎记录到内部变量中,这些变量的命名为 <strong><em>\1 \2 \3</em></strong></li></ul></li></ul><h3 id="命令实战"><a href="#命令实战" class="headerlink" title="命令实战"></a>命令实战</h3><p><strong>匹配passwd文件中以root开头的所有行</strong></p><pre><code>[root@docker ~]# grep &apos;^root&apos; /etc/passwdroot:x:0:0:root:/root:/bin/bash</code></pre><p><strong>匹配passwd文件中/bin/bash结尾的所有行</strong></p><pre><code>[root@docker ~]# grep &apos;/bin/bash$&apos; /etc/passwdroot:x:0:0:root:/root:/bin/bashchenfan:x:1000:1000::/home/chenfan:/bin/bash</code></pre><p><strong>匹配fatab文件中，以#开头，然后有至少一个空格的行</strong></p><pre><code>[root@docker ~]# grep -E &apos;#[[:space:]]+&apos; /etc/fstab# /etc/fstab# Created by anaconda on Fri Nov 17 00:04:38 2017# Accessible filesystems, by reference, are maintained under &apos;/dev/disk&apos;# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info</code></pre><p><strong>匹配system或System</strong></p><pre><code>[root@docker ~]# grep &apos;[sS]ystem&apos; /etc/passwdsystemd-network:x:192:192:systemd Network Management:/:/sbin/nologindbus:x:81:81:System message bus:/:/sbin/nologin</code></pre><p><strong>匹配至少两次</strong></p><pre><code>[root@docker ~]# grep &apos;o\{2,\}&apos; /etc/passwdroot:x:0:0:root:/root:/bin/bashlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinmail:x:8:12:mail:/var/spool/mail:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologinpostfix:x:89:89::/var/spool/postfix:/sbin/nologin</code></pre><p><strong>匹配root或mail的行</strong></p><pre><code>[root@docker ~]# egrep &apos;/root|mail&apos; /etc/passwdroot:x:0:0:root:/root:/bin/bashmail:x:8:12:mail:/var/spool/mail:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologin</code></pre><p><strong>分组过滤匹配</strong></p><pre><code>[root@docker ~]# grep -E &apos;(no|No)body&apos; /etc/passwdnobody:x:99:99:Nobody:/:/sbin/nologin</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通配符是系统level,而正则表达式需要相关工具的支持:grep,awk,vi,perl。在文本过滤工具里,都是用正则表达式，比如像awk,sed等，是针对文件的内容的。通配符多用在文件名上,比如查找find,ls,cp,等等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;通配符&quot;&gt;&lt;a href=&quot;#通配符&quot; class=&quot;headerlink&quot; title=&quot;通配符&quot;&gt;&lt;/a&gt;通配符&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;通配符的作用是用于模糊查询时通配文件名中某些不确定的字符, 通配符只有三个元字符 ？ * []&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Bash中的通配符&quot;&gt;&lt;a href=&quot;#Bash中的通配符&quot; class=&quot;headerlink&quot; title=&quot;Bash中的通配符&quot;&gt;&lt;/a&gt;Bash中的通配符&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;通配符&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;?&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;匹配任意单个字符，不包括路径标识”/“&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;*&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;匹配任意长度的字符，包括空字符,不包括路径标识”/“&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;**&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;匹配任意级别目录(bash 4.0以上版本支持,不包括路径标识”/“&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;[]&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;匹配一个单字符范围,如[a-z],[0-9],不包括路径标识”/“&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;的特殊用例&quot;&gt;&lt;a href=&quot;#的特殊用例&quot; class=&quot;headerlink&quot; title=&quot;[ ]的特殊用例&quot;&gt;&lt;/a&gt;[ ]的特殊用例&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;[]：匹配范围&lt;/li&gt;
&lt;li&gt;[^]：排除匹配范围&lt;/li&gt;
&lt;li&gt;[:alnum:]：所有字母和数字&lt;/li&gt;
&lt;li&gt;[:alpha:]：所有字母&lt;/li&gt;
&lt;li&gt;[:digit:]：所有数字&lt;/li&gt;
&lt;li&gt;[:lower:]：所有小写字母&lt;/li&gt;
&lt;li&gt;[:upper:]：所有大写字母&lt;/li&gt;
&lt;li&gt;[:blank:]：空白字符和TAB制表符&lt;/li&gt;
&lt;li&gt;[:space:]：包括空白字符、TAB制表符(\t)、换页(\f)&lt;/li&gt;
&lt;li&gt;[:cntrl:]：所有控制字符&lt;/li&gt;
&lt;li&gt;[:graph:]：可打印并可看到的字符。空格是可打印的，但是不是可看到的&lt;/li&gt;
&lt;li&gt;[:print:]：所有可打印字符&lt;/li&gt;
&lt;li&gt;[:punct:]：所有标点符号，非字母、数字、控制字符和space字符&lt;/li&gt;
&lt;li&gt;[:xdigit:]：十六进制数的字符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意：引用时，需要在加一层括号，如[[:alnum:]]&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;通配符范例&quot;&gt;&lt;a href=&quot;#通配符范例&quot; class=&quot;headerlink&quot; title=&quot;通配符范例&quot;&gt;&lt;/a&gt;通配符范例&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;*.txt               匹配全部后缀为.txt的文件&lt;/li&gt;
&lt;li&gt;file?.log           匹配file1.log, file2.log, …&lt;/li&gt;
&lt;li&gt;[a-z]*.log          匹配a-Z开头的.log文件,这里不区分字母大小写&lt;/li&gt;
&lt;li&gt;[^a-z]*.log         上面的反向匹配&lt;/li&gt;
&lt;li&gt;/etc/&lt;em&gt;*/&lt;/em&gt;.conf      匹配/etc目录下第一层子目录下的所有.conf结尾的文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意: 反斜杠\或单双引号[‘ “]都会使通配符失效；如:  “\&lt;/em&gt;“, ‘*‘都表示*本身，不通配任何文件。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在正则表达式出现后的一段时间里，诸子百家争鸣，乱世显现。这一年诞生了第一个较为统一的标准 —— POSIX，POSIX将正则表达式分为了两种标准Basic Regular Expressions(BREs)和 Extended Regular Expressions(EREs)&lt;/p&gt;
    
    </summary>
    
      <category term="linux基础" scheme="http://www.chenfanlinux.org/categories/linux%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="正则表达式" scheme="http://www.chenfanlinux.org/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Bash编程入门之条件测试(三)</title>
    <link href="http://www.chenfanlinux.org/2018/01/18/Bash%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E4%B9%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95-%E4%B8%89/"/>
    <id>http://www.chenfanlinux.org/2018/01/18/Bash编程入门之条件测试-三/</id>
    <published>2018-01-18T02:23:09.000Z</published>
    <updated>2018-01-25T03:09:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="条件测试语法"><a href="#条件测试语法" class="headerlink" title="条件测试语法"></a>条件测试语法</h2><blockquote><p>在bash的各种流程控制结构中通常要进行各种测试，然后根据测试结果执行不同的操作，有时也会通过与if等条件语句相结合，让我们可以方便的完成判断。</p></blockquote><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>支持三种格式的条件测试语法</p><ul><li>test&lt;测试表达式&gt;</li><li>[ &lt;测试表达式&gt; ]</li><li>[[ &lt;测试表达式&gt; ]]</li></ul><p><strong>格式1和格式2是等价的，格式3为扩展的test命令</strong></p><p>在[[]]中可以使用通配符进行匹配。&amp;&amp;、||、&gt;、&lt;等操作符可以应用与[[]]中，但不能应用与[]中。</p><h3 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h3><p><strong>文件存在则输出1，文件不存在则输出0</strong></p><pre><code>[root@chenfanlinux ~]#  [ -f /etc/passwd ] &amp;&amp; echo 1||echo 01[root@chenfanlinux ~]# test -f /etc/passwd &amp;&amp; echo 1||echo 01[root@chenfanlinux ~]#  [[ -f /etc/passwd ]] &amp;&amp; echo 1||echo 01[root@chenfanlinux ~]#  [[ -f /etc/passd ]] &amp;&amp; echo 1||echo 00</code></pre><a id="more"></a><p><strong>非!的写法</strong><br>test.txt文件如果不存在，则创建。</p><pre><code>[root@chenfanlinux ~]# test ! -f test1.txt &amp;&amp; touch test.txt || ehco &quot;test1.txt已经存在&quot;[root@chenfanlinux ~]# test ! -f test1.txt &amp;&amp; touch test1.txt || echo &quot;test1.txt已经存在&quot;test1.txt已经存在[root@chenfanlinux ~]# [ ! -f test.txt ] &amp;&amp; touch test.txt || echo &apos;test.txt已经存在&apos;[root@chenfanlinux~]# [ ! -f test.txt ] &amp;&amp; touch test.txt || echo &apos;test.txt已经存在&apos;test.txt已经存在</code></pre><h2 id="test-或-测试语法"><a href="#test-或-测试语法" class="headerlink" title="test 或 [] 测试语法"></a>test 或 [] 测试语法</h2><p>从功能上来看 <code>test 测试表达式</code> 命令等同于 <code>[测试表达式]</code> ，因此这里将它们归纳在一起进行总结。</p><h3 id="数值测试"><a href="#数值测试" class="headerlink" title="数值测试"></a>数值测试</h3><p><strong>参数说明</strong></p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">-eq</td><td style="text-align:center">等于则为真</td></tr><tr><td style="text-align:center">-ne</td><td style="text-align:center">不等于则为真</td></tr><tr><td style="text-align:center">-gt</td><td style="text-align:center">大于则为真</td></tr><tr><td style="text-align:center">-ge</td><td style="text-align:center">大于等于则为真</td></tr><tr><td style="text-align:center">-lt</td><td style="text-align:center">小于则为真</td></tr><tr><td style="text-align:center">-le</td><td style="text-align:center">小于则为真</td></tr></tbody></table><p><strong>范例</strong></p><p><strong><em>判断两个数是否相等</em></strong></p><pre><code>[root@chenfanlinux ~]# num1=1[root@chenfanlinux ~]#chenfanlinux num2=2[root@chenfanlinux ~]# [ $num1 -eq $num2 ] &amp;&amp; echo &quot;两个数相等&quot; || echo &quot;两个数不相等&quot;两个数不相等</code></pre><p><strong><em>数值运算</em></strong></p><pre><code>[root@chenfanlinux ~]# a=5[root@chenfanlinux ~]# b=6[root@chenfanlinux ~]# c=$[a+b][root@chenfanlinux ~]# echo $c11[root@chenfanlinux ~]# ((c=a+b))[root@chenfanlinux ~]# echo $c11[root@chenfanlinux ~]# c=`expr $a + $b`[root@chenfanlinux ~]# echo $c11[root@chenfanlinux ~]# let c=a+b[root@chenfanlinux ~]# echo $c11</code></pre><ul><li>(())</li><li>let</li><li>expr</li><li>bc(小数)</li><li>$[]</li></ul><h3 id="字符串测试"><a href="#字符串测试" class="headerlink" title="字符串测试"></a>字符串测试</h3><p><strong>参数说明</strong></p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">“串1” = “串2”</td><td style="text-align:center">若串1等于串2则真，可以使用”==”代替”=”</td></tr><tr><td style="text-align:center">“串1” ！= “串2”</td><td style="text-align:center">若串1不等于串2则真，但不能用”!==” 代替”!=”</td></tr><tr><td style="text-align:center">-z “字符串”</td><td style="text-align:center">若串长度为0则真，-z可以理解为zero</td></tr><tr><td style="text-align:center">-n “字符串”</td><td style="text-align:center">若串长度不为0则真，-n可以理解为no zero</td></tr></tbody></table><p><strong>范例</strong></p><p><strong><em>比较两个字符串是否相同</em></strong></p><pre><code>num1=&quot;chenfan&quot;num2=&quot;chenfanlinux&quot;if [ &quot;$num1&quot; = &quot;$num2&quot; ]then    echo &apos;两个字符串相等!&apos;else    echo &apos;两个字符串不相等!&apos;fi</code></pre><h3 id="文件测试"><a href="#文件测试" class="headerlink" title="文件测试"></a>文件测试</h3><p><strong>参数说明</strong></p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">-e 文件名</td><td style="text-align:center">如果文件存在则为真</td></tr><tr><td style="text-align:center">-r 文件名</td><td style="text-align:center">如果文件存在且可读则为真</td></tr><tr><td style="text-align:center">-w 文件名</td><td style="text-align:center">如果文件存在且可写则为真</td></tr><tr><td style="text-align:center">-x 文件名</td><td style="text-align:center">如果文件存在且可执行则为真</td></tr><tr><td style="text-align:center">-s 文件名</td><td style="text-align:center">如果文件存在且至少有一个字符则为真</td></tr><tr><td style="text-align:center">-d 文件名</td><td style="text-align:center">如果文件存在且为目录则为真</td></tr><tr><td style="text-align:center">-f 文件名</td><td style="text-align:center">如果文件存在且为普通文件则为真</td></tr><tr><td style="text-align:center">-c 文件名</td><td style="text-align:center">如果文件存在且为字符型特殊文件则为真</td></tr><tr><td style="text-align:center">-b 文件名</td><td style="text-align:center">如果文件存在且为块特殊文件则为真</td></tr></tbody></table><blockquote><p>以上表格中的字符串测试操作符号务必要用 “字符串” 引起来。</p></blockquote><p><strong>范例</strong></p><p><strong><em>文件存在则打印存在</em></strong></p><pre><code>cd /binif test -e ./bashthen    echo &apos;文件已存在!&apos;else    echo &apos;文件不存在!&apos;fi</code></pre><h3 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h3><p><strong>参数说明</strong></p><p><img src="https://s1.ax1x.com/2018/01/18/ps8WEF.png" alt="逻辑操作符"> </p><p><strong>范例</strong></p><p><strong><em>判断文件是否同时存在</em></strong></p><pre><code>[root@chenfanlinux ~]# f1=&apos;/etc/rc.local&apos;[root@chenfanlinux ~]# f2=&apos;/etc/pass&apos;[root@chenfanlinux ~]# [ -f &quot;$f1&quot; -o -f &quot;$f2&quot; ] &amp;&amp; echo 1|| echo 01[root@chenfanlinux ~]# [ -f &quot;$f1&quot; -a -f &quot;$f2&quot; ] &amp;&amp; echo 1|| echo 00</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;条件测试语法&quot;&gt;&lt;a href=&quot;#条件测试语法&quot; class=&quot;headerlink&quot; title=&quot;条件测试语法&quot;&gt;&lt;/a&gt;条件测试语法&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在bash的各种流程控制结构中通常要进行各种测试，然后根据测试结果执行不同的操作，有时也会通过与if等条件语句相结合，让我们可以方便的完成判断。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h3&gt;&lt;p&gt;支持三种格式的条件测试语法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;test&amp;lt;测试表达式&amp;gt;&lt;/li&gt;
&lt;li&gt;[ &amp;lt;测试表达式&amp;gt; ]&lt;/li&gt;
&lt;li&gt;[[ &amp;lt;测试表达式&amp;gt; ]]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;格式1和格式2是等价的，格式3为扩展的test命令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在[[]]中可以使用通配符进行匹配。&amp;amp;&amp;amp;、||、&amp;gt;、&amp;lt;等操作符可以应用与[[]]中，但不能应用与[]中。&lt;/p&gt;
&lt;h3 id=&quot;范例&quot;&gt;&lt;a href=&quot;#范例&quot; class=&quot;headerlink&quot; title=&quot;范例&quot;&gt;&lt;/a&gt;范例&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;文件存在则输出1，文件不存在则输出0&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@chenfanlinux ~]#  [ -f /etc/passwd ] &amp;amp;&amp;amp; echo 1||echo 0
1
[root@chenfanlinux ~]# test -f /etc/passwd &amp;amp;&amp;amp; echo 1||echo 0
1
[root@chenfanlinux ~]#  [[ -f /etc/passwd ]] &amp;amp;&amp;amp; echo 1||echo 0
1
[root@chenfanlinux ~]#  [[ -f /etc/passd ]] &amp;amp;&amp;amp; echo 1||echo 0
0
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Bash Shell编程" scheme="http://www.chenfanlinux.org/categories/Bash-Shell%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Bash" scheme="http://www.chenfanlinux.org/tags/Bash/"/>
    
  </entry>
  
  <entry>
    <title>Bash编程入门之变量基础(二)</title>
    <link href="http://www.chenfanlinux.org/2018/01/17/Bash%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E4%B9%8B%E5%8F%98%E9%87%8F%E5%9F%BA%E7%A1%80-%E4%B8%80/"/>
    <id>http://www.chenfanlinux.org/2018/01/17/Bash编程入门之变量基础-一/</id>
    <published>2018-01-17T07:39:19.000Z</published>
    <updated>2018-01-26T03:39:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量基础"><a href="#变量基础" class="headerlink" title="变量基础"></a>变量基础</h2><h3 id="什么是变量？"><a href="#什么是变量？" class="headerlink" title="什么是变量？"></a>什么是变量？</h3><blockquote><p>变量的实质是命名的内存空间，变量是一个用固定的字符串（也可能是字符数字等的组合），替代更多更复杂的内容，这个内容里可能还会包含变量和路径，字符串等其他的内容。对于代码一块某个值得改变，只需要改变变量值得内容，不需要全局修改。</p></blockquote><p><strong>变量的类型</strong><br>根据变量的生效范围等标准:</p><ul><li>本地变量：生效范围为当前的shell进程,对当前shell之外的其他进程,包括当前进程的父子shell都无效</li><li>环境变量: 生效范围为当前进程及其子进程</li><li>局部变量: 生效范围为当前进程的某代码片段(通常指函数上下文)</li><li>特殊变量: 包括位置变量和进程状态变量</li></ul><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><blockquote><p>环境变量用于定义shell的运行环境，保证Shell命令的正确执行，通过环境变量来确定登陆用户名、命令路径、终端类型、登陆目录等，所有的环境变量都是系统全局变量，可用于所有子进程中，这包括编辑器、Shell脚本和各类应用。</p></blockquote><p>环境变量可以在命令行中设置，当用户退出时这些变量值也会丢失，因此最好在用户家目录下的.bash_profile文件中或全局配置/etc/bashrc,/etc/profile文件或者/etc/profile.d/中定义。将环境变量放入上述的文件中，每次用户登陆时这些变量值都将被初始化。</p><p>可以通过一下的命令查看环境变量</p><ul><li>env（只显示全局变量）</li><li>set（所有的变量）</li><li>declare（所有变量，包括函数、整数和已导出的）</li></ul><p><strong>定义环境变量</strong></p><pre><code>[root@dokcer ~]# export NAME=chenfanlinux[root@dokcer ~]# declare -x NAME=chenfan</code></pre><p><strong>显示与取消环境变量</strong></p><pre><code>[root@dokcer ~]# echo $NAME chenfan[root@dokcer ~]# $ unset NAME</code></pre><a id="more"></a><h3 id="本地变量"><a href="#本地变量" class="headerlink" title="本地变量"></a>本地变量</h3><p>本地变量在用户当前的Shell生存期内脚本或命令行使用。这个值只在用户当前Shell生存期中有意义，如果在shell中启动另一个进程或退出，本地变量的值无效。</p><p><strong>变量的命名规范</strong></p><ul><li>变量名只能为字母，数字，下划线，字母开头。</li><li>规范的变量名定义方法：见名只意</li><li>避免无意义字符或数字：例如下面的COUNT，并不知道其确切含义；</li></ul><p><strong>变量赋值</strong></p><ol><li>可以是直接字符串: name=”username” 或 name=’username’</li><li>变量引用: name=”$username” 或 ${username}</li><li>命令引用: name= `COMMAND` 或 name=$(COMMAND)</li></ol><p><strong>变量引用</strong><br>${name}或$name</p><ul><li>“$name” : 弱引用,其中变量引用会被替换为变量值，</li><li>‘$name’ : 强引用,其中变量引用不会被替换为变量值,而保持原字符串</li></ul><p>最好以${NAME}加大括号或”$NAME”外面加双引号方式引用变量</p><p><strong>区分单引号和双引号</strong></p><pre><code>[root@yiwutest ~]# echo &apos;Today is `date`&apos;Today is `date`[root@yiwutest ~]# echo &quot;Today is `date`&quot;Today is Wed Jan 17 14:49:51 CST 2018</code></pre><ul><li>单引号    单引号内的所有内容都原样输出，或者描述为单引号里面看到的是什么就会输出什么。</li><li>双引号    把双引号内的所有内容都输出出来，如果内容中有命令（要反引下）、变量、特殊转移符等，会先把变量、命令、转义符解析出来，然后在输出最终内容来。</li><li>无引号    把内容输出出来，会将含有空格的字符串视为一个整体输出出来。</li></ul><p><strong>区分 $name 和 ${name}</strong><br>{变量}可以界定变量名的范围，用于变量之间的组合使用或变量与字符串的组合。</p><pre><code>[root@docker ~]# name=&apos;chenfan&apos;[root@docker ~]# echo &quot;$name_123&quot;[root@docker ~]# echo &quot;${name}_123&quot;chenfan_123[root@docker ~]# test1=&apos;chenfan&apos;[root@docker ~]# test2=&apos;fan&apos;[root@yiwutest ~]# echo &quot;${test1}_$test2&quot;chenfan_fan[root@yiwutest ~]# echo &quot;$test1_${test2}&quot;fan</code></pre><h3 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h3><p><strong>位置变量</strong></p><ul><li><p>$0    获取当前执行的shell脚本文件名，包括脚本路径</p></li><li><p>$n    获取当前执行的shell脚本的第n个参数值，n=1..9，当n为0时表示脚本的文件名，如果n大于9就要用大括号括起来${10}</p></li><li><p>$*    获取当前的shell的所有参数，将所有的命令行参数视为单个字符串，相当于“$1$2$3$4$5”..注意与$#的区别</p></li><li><p>$#    获取当前shell命令行中参数的总个数</p></li><li><p>$@    这额程序的所有参数$1 $2 $3 …，这是将参数传递给其他程序的最佳方式，因为他会保留内嵌在每个参数里的任意空白</p></li></ul><p><strong>进程状态变量</strong></p><ul><li>$$  获取当前shell脚本的进程号（PID）</li><li>$!  执行上一个指令的PID</li><li>$?  获取执行上一个指令的返回值（0为成功，非0为失败）</li><li>$_  在此之前执行的命令或脚本的最后一个参数</li></ul><h3 id="数值计算的命令"><a href="#数值计算的命令" class="headerlink" title="数值计算的命令"></a>数值计算的命令</h3><p>变量的数值计算常见的有如下几个命令：</p><ul><li>(())</li><li>let(推荐使用)</li><li>expr</li><li>bc(小数)$[]</li></ul><p>shell的算术运算符号常置于 $((“…….”)) 的语法中，如果要执行简单的整数运算，只需将特定的算术表达式用” $((表达式))”括起来即可;使用let命令,它用于执行一个或多个表达式,变量计算中不需要使用$来引用变量。</p><h3 id="字符串变量截取"><a href="#字符串变量截取" class="headerlink" title="字符串变量截取"></a>字符串变量截取</h3><p>变量web=”<a href="http://www.chenfanlinux.org/index.html&quot;，接下来介绍几种不同的变量截取方法。">http://www.chenfanlinux.org/index.html&quot;，接下来介绍几种不同的变量截取方法。</a></p><p>（1）#*fs 删除第一个匹配到的分隔符及其左侧的内容,这里的以fs是”/“为例 </p><pre><code>[root@chenfanlinux ~]# echo $webhttp://www.chenfanlinux.org/index.html[root@chenfanlinux ~]# echo ${web#*/}/www.chenfanlinux.org/index.html</code></pre><p> (2)##*fs 删除最后一个匹配到的分隔符及其左侧的内容</p><pre><code>[root@chenfanlinux ~]# echo ${web##*/}index.html</code></pre><p> (3)%fs* 删除最后匹配到的分隔符及其右侧的内容  </p><pre><code>[root@chenfanlinux ~]# echo ${web%/*}http://www.chenfanlinux.org</code></pre><p> (4) %%fs* 删除第一个匹配到的分隔符及其右侧的内容  </p><pre><code>[root@chenfanlinux ~]# echo ${web%%/*}http:</code></pre><p> (5) 删除从左边第几个字符开始，及字符的个数</p><pre><code>[root@inmalltest ~]# echo ${web:0,3}p://www.chenfanlinux.org/index.html0 表示左边第一个字符开始，3表示删除字符的总个数</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;变量基础&quot;&gt;&lt;a href=&quot;#变量基础&quot; class=&quot;headerlink&quot; title=&quot;变量基础&quot;&gt;&lt;/a&gt;变量基础&lt;/h2&gt;&lt;h3 id=&quot;什么是变量？&quot;&gt;&lt;a href=&quot;#什么是变量？&quot; class=&quot;headerlink&quot; title=&quot;什么是变量？&quot;&gt;&lt;/a&gt;什么是变量？&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;变量的实质是命名的内存空间，变量是一个用固定的字符串（也可能是字符数字等的组合），替代更多更复杂的内容，这个内容里可能还会包含变量和路径，字符串等其他的内容。对于代码一块某个值得改变，只需要改变变量值得内容，不需要全局修改。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;变量的类型&lt;/strong&gt;&lt;br&gt;根据变量的生效范围等标准:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本地变量：生效范围为当前的shell进程,对当前shell之外的其他进程,包括当前进程的父子shell都无效&lt;/li&gt;
&lt;li&gt;环境变量: 生效范围为当前进程及其子进程&lt;/li&gt;
&lt;li&gt;局部变量: 生效范围为当前进程的某代码片段(通常指函数上下文)&lt;/li&gt;
&lt;li&gt;特殊变量: 包括位置变量和进程状态变量&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;环境变量&quot;&gt;&lt;a href=&quot;#环境变量&quot; class=&quot;headerlink&quot; title=&quot;环境变量&quot;&gt;&lt;/a&gt;环境变量&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;环境变量用于定义shell的运行环境，保证Shell命令的正确执行，通过环境变量来确定登陆用户名、命令路径、终端类型、登陆目录等，所有的环境变量都是系统全局变量，可用于所有子进程中，这包括编辑器、Shell脚本和各类应用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;环境变量可以在命令行中设置，当用户退出时这些变量值也会丢失，因此最好在用户家目录下的.bash_profile文件中或全局配置/etc/bashrc,/etc/profile文件或者/etc/profile.d/中定义。将环境变量放入上述的文件中，每次用户登陆时这些变量值都将被初始化。&lt;/p&gt;
&lt;p&gt;可以通过一下的命令查看环境变量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;env（只显示全局变量）&lt;/li&gt;
&lt;li&gt;set（所有的变量）&lt;/li&gt;
&lt;li&gt;declare（所有变量，包括函数、整数和已导出的）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;定义环境变量&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@dokcer ~]# export NAME=chenfanlinux
[root@dokcer ~]# declare -x NAME=chenfan
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;显示与取消环境变量&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@dokcer ~]# echo $NAME
 chenfan
[root@dokcer ~]# $ unset NAME
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Bash Shell编程" scheme="http://www.chenfanlinux.org/categories/Bash-Shell%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Bash" scheme="http://www.chenfanlinux.org/tags/Bash/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门之数据管理(六)</title>
    <link href="http://www.chenfanlinux.org/2018/01/16/Docker%E5%85%A5%E9%97%A8%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/"/>
    <id>http://www.chenfanlinux.org/2018/01/16/Docker入门之数据管理/</id>
    <published>2018-01-16T08:33:51.000Z</published>
    <updated>2018-01-26T03:39:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何存储Docker数据"><a href="#如何存储Docker数据" class="headerlink" title="如何存储Docker数据"></a>如何存储Docker数据</h2><p>Docker 为容器提供了两种存放数据的资源：</p><ul><li>Storage Driver 管理的镜像层和容器层。</li><li>Data Volume</li></ul><p><strong>Storage Driver</strong></p><p>容器由最上面一个可写的容器层，以及若干只读的镜像层组成，容器的数据就存放在这些层中。这样的分层结构最大的特性是 <strong><em>Copy-on-Write</em></strong>：</p><ul><li>新数据会直接存放在最上面的容器层。</li><li>修改现有数据会先从镜像层将数据复制到容器层，修改后的数据直接保存在容器层中，镜像层保持不变。</li><li>如果多个层中有命名相同的文件，用户只能看到最上面那层中的文件。</li></ul><p><img src="https://s1.ax1x.com/2018/01/15/pUMMh4.jpg" alt=""><br>Storage Driver 实现了多层数据的堆叠并为用户提供一个单一的合并之后的统一视图。适合无状态的应用，不需要持久化存储数据。</p><p><strong>Data Volume</strong></p><p>Data Volume 本质上是 Docker Host 文件系统中的目录或文件，能够直接被 mount 到容器的文件系统中。适合于持久化数据的需求的数据存储，容器启动时需要加载已有的数据，容器销毁时希望保留产生的新数据，也就是说，这类容器是有状态的。Data Volume有如下特点:</p><ul><li>Data Volume 是目录或文件，而非没有格式化的磁盘（块设备）。</li><li>容器可以读写 volume 中的数据。</li><li>volume 数据可以被永久的保存，即使使用它的容器已经销毁。</li></ul><h2 id="Data-volume的类型"><a href="#Data-volume的类型" class="headerlink" title="Data volume的类型"></a>Data volume的类型</h2><p>在具体的使用上，docker 提供了两种类型的 volume：bind mount 和 docker managed volume。</p><h3 id="bind-mount"><a href="#bind-mount" class="headerlink" title="bind mount"></a>bind mount</h3><p>bind mount 是将 host 上已存在的目录或文件 mount 到容器。</p><pre><code>[root@chenfanlinux ~]# mkdir /root/htdocs[root@chenfanlinux ~]# echo &quot;Welcome to chenfanlinux.org&quot; &gt;/root/htdocs/index.html[root@chenfanlinux ~]# docker run -d -p 80:80 -v /root/htdocs:/usr/local/apache2/htdocs httpdc7a396731c62e35b0704e16ffa6ea0a4b4d7e3488cd220dca0d41958eff46c30[root@chenfanlinux ~]# docker psCONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS                NAMESc7a396731c62        httpd               &quot;httpd-foreground&quot;   15 seconds ago      Up 14 seconds       0.0.0.0:80-&gt;80/tcp   serene_mccarthy[root@chenfanlinux ~]# curl &apos;http://127.0.0.1:80&apos;Welcome to chenfanlinux.org</code></pre><p>通过 <strong><em>-v &lt;host path&gt;:&lt;container path&gt;</em></strong> 这种格式将host上的/root/htdocs挂载到容器/usr/local/apache2/htdocs目录下。由于/root/htdocs目录下有文件，会隐藏容器/usr/local/apache2/htdocs下的文件内容。</p><p>当我们更新一下/root/htdocs目录下的文件内容时，看看容器里的文件是否发生变化。</p><pre><code>[root@chenfanlinux htdocs]# echo &apos;this is www.chenfanlinux.org&apos;&gt; index.html[root@chenfanlinux htdocs]# lsindex.html[root@chenfanlinux htdocs]# curl &apos;http://127.0.0.1&apos;this is www.chenfanlinux.org</code></pre><p>这里的host 目录的/root/htdocs和容器/usr/local/apache2/htdocs属于共享目录，它们会共享数据。<br>下面我们将容器销毁，看看对 bind mount 有什么影响：</p><pre><code>[root@chenfanlinux htdocs]# docker stop 177051349c19177051349c19[root@chenfanlinux htdocs]# docker rm 177051349c19177051349c19[root@chenfanlinux htdocs]# cat /root/htdocs/index.htmlthis is www.chenfanlinux.org</code></pre><p>可以看到/root/htdocs数据依然存在，bind mount是文件系统中的数据，容器在销毁时，这些数据不会删除。</p><p>bind mount 时还可以指定数据的读写权限，默认是可读可写，可指定为只读，ro 设置了只读权限，在容器中是无法对 bind mount 数据进行修改的。只有 host 有权修改数据，提高了安全性。</p><pre><code>[root@chenfanlinux htdocs]# docker run -d -p 80:80 -v /root/htdocs:/usr/local/apache2/htdocs:ro  httpdd0d2fa8b29b120a8c20d88a20a77b18018bb348d6605218af09ec35f2ec59785[root@chenfanlinux htdocs]# docker exec -it d0d2fa8b29b1 /bin/bashroot@d0d2fa8b29b1:/usr/local/apache2#root@d0d2fa8b29b1:/usr/local/apache2# echo &apos;host path:container path:perm&apos; &gt;htdocbash: htdocs//index.htm: Read-only file system</code></pre><p>mount point 有很多应用场景，比如我们可以将源代码目录 mount 到容器中，在 host 中修改代码就能看到应用的实时效果。再比如将 mysql 容器的数据放在 bind mount 里，这样 host 可以方便地备份和迁移数据。</p><p>bind mount 的使用直观高效，易于理解，但它也有不足的地方：bind mount 需要指定 host 文件系统的特定路径，这就限制了容器的可移植性，当需要将容器迁移到其他 host，而该 host 没有要 mount 的数据或者数据不在相同的路径时，操作会失败。移植性更好的方式是 docker managed volume，下面就会讨论。<br><a id="more"></a></p><h3 id="docker-managed-volume"><a href="#docker-managed-volume" class="headerlink" title="docker managed volume"></a>docker managed volume</h3><p><strong><em>docker managed volume</em></strong> 与 <strong><em>bind mount</em></strong> 在使用上的最大区别是不需要指定 mount 源，指明 mount point 就行了。还是以 httpd 容器为例：</p><pre><code>[root@chenfanlinux ~]# docker run -d -p 80:80 -v /usr/local/apache2/htdocs httpd8dcabf706808e73c2801d1f0cc52bad84c7a9206dc35b3284edfaf5086addc30[root@chenfanlinux ~]# docker psCONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS                NAMES8dcabf706808        httpd               &quot;httpd-foreground&quot;   34 seconds ago      Up 33 seconds       0.0.0.0:80-&gt;80/tcp   kind_mirzakh</code></pre><p>我们通过 -v 告诉 docker 需要一个 data volume，并将其 mount 到 /usr/local/apache2/htdocs。这样不需要指定 host 上面的 data volume，只需要指定容器中的 mount point 即可。那么host上的data volume肯定是由系统自动指定的，通过 <code>docker inspect container id</code> 可以看到host上的 data volume 。</p><pre><code>[root@chenfanlinux ~]# docker inspect e23d25dc38c1.................. &quot;Mounts&quot;: [        {            &quot;Type&quot;: &quot;volume&quot;,            &quot;Name&quot;: &quot;57b81889f9ed419b26ef6c87a7ce8e62372febc85ee573cf162d4d96fecc1986&quot;,            &quot;Source&quot;: &quot;/var/lib/docker/volumes/57b81889f9ed419b26ef6c87a7ce8e62372febc85ee573cf162d4d96fecc1986/_data&quot;,            &quot;Destination&quot;: &quot;/usr/local/apache2/htdocs&quot;,            &quot;Driver&quot;: &quot;local&quot;,            &quot;Mode&quot;: &quot;&quot;,            &quot;RW&quot;: true,            &quot;Propagation&quot;: &quot;&quot;        }    ], .........................</code></pre><p>可以看到<strong>Source</strong>就是 data volume为/var/lib/docker/volumes/57b81889f9ed419b26ef6c87a7ce8e62372febc85ee573cf162d4d96fecc1986/_data，mount point就是 <strong>Destination</strong> 挂载点 /usr/local/apache2/htdoc。这里的data volome是系统指定的。</p><p>进一步研究 源host volome和目标 mount point的关系</p><pre><code>[root@chenfanlinux ~]# cat  /var/lib/docker/volumes/57b81889f9ed419b26ef6c87a7ce8e62372febc85ee573cf162d4d96fecc1986/_data/index.html&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;[root@chenfanlinux ~]# docker psCONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS                NAMES8dcabf706808        httpd               &quot;httpd-foreground&quot;   4 minutes ago       Up 4 minutes        0.0.0.0:80-&gt;80/tcp   kind_mirzakhani[root@chenfanlinux ~]# docker exec -it 8dcabf706808 /bin/bashroot@8dcabf706808:/usr/local/apache2# cat htdocs/index.html&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>可以发现data volume和 mount point下的数据是一致的，这是因为当mount point指向host data volume，会将容器的数据复制到host目录中。</p><p>docker managed volume 的创建过程如下：</p><ul><li>容器启动时，简单的告诉 docker “我需要一个 volume 存放数据，帮我 mount 到目录 /abc”。</li><li>docker 在 /var/lib/docker/volumes 中生成一个随机目录作为 mount 源。</li><li>如果 /abc 已经存在，则将数据复制到 mount 源。</li><li>将 volume mount 到 /abc。</li></ul><p>我们也可以用 <code>docker volume ls</code> 命令看查看系统有哪些data volume， 只能查看 docker managed volume，看不到bind mount。<br>通过 <code>docker volume inspect VOLUME NAME</code> 来查看具体的 volume信息。</p><pre><code>[root@chenfanlinux ~]#  docker volume lsDRIVER              VOLUME NAMElocal               57b81889f9ed419b26ef6c87a7ce8e62372febc85ee573cf162d4d96fecc1986local               73eeefd987d049878abeab0f4b9521e8e041ab8af9ab9cbf417e612690d63d20local               ae070fe09d1f55198364c45b40f2deaa48fdd4005faf986b7450aeb24773c39clocal               ceb6f3f1f987c45afaa80fbc15ddf2d51a85583e7793e3e8be277cc31efa4aa2local               f69f555dcd6816d602df1308ce4b845e8d24948a50bdbdfbba10b9ee5a21e540[root@chenfanlinux ~]# docker volume inspect 57b81889f9ed419b26ef6c87a7ce8e62372febc85ee573cf162d4d96fecc1986[{    &quot;CreatedAt&quot;: &quot;2018-01-12T22:54:09+08:00&quot;,    &quot;Driver&quot;: &quot;local&quot;,    &quot;Labels&quot;: null,    &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/57b81889f9ed419b26ef6c87a7ce8e62372febc85ee573cf162d4d96fecc1986/_data&quot;,    &quot;Name&quot;: &quot;57b81889f9ed419b26ef6c87a7ce8e62372febc85ee573cf162d4d96fecc1986&quot;,    &quot;Options&quot;: {},    &quot;Scope&quot;: &quot;local&quot;}]</code></pre><h3 id="bind-mount-对比-docker-manage-volume"><a href="#bind-mount-对比-docker-manage-volume" class="headerlink" title="bind mount 对比 docker manage volume"></a>bind mount 对比 docker manage volume</h3><p><img src="https://s1.ax1x.com/2018/01/15/pa1Hwq.png" alt=""></p><h2 id="volume如何共享数据？"><a href="#volume如何共享数据？" class="headerlink" title="volume如何共享数据？"></a>volume如何共享数据？</h2><h3 id="容器与host共享数据"><a href="#容器与host共享数据" class="headerlink" title="容器与host共享数据"></a>容器与host共享数据</h3><p>bind mount和docker managed volume都可以实现容器与host之间共享数据，但他们的方式有所区别。<br>bind mount:直接将要共享的目录mount到容器中，会隐藏容器中对应目录的内容，显示 data volume内容。<br>docker managed volume:这种机制是容器启动的时候，将挂载点需要共享的数据复制到host volume中。</p><pre><code>[root@docker ~]# docker run -d -p 80:80 -v /usr/local/apache2/htdocs httpdc7a396731c62e35b0704e16ffa6ea0a4b4d7e3488cd220dca0d41958eff46c30[root@docker ~]# curl &apos;http://127.0.0.1:80&apos;&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;[root@docker ~]# docker cp htdocs/index.html c7a396731c62:/usr/local/apache2/htdocs[root@docker ~]# curl &apos;http://127.0.0.1:80&apos;welcome to chenfanlinux.org</code></pre><p><code>docker cp  host_path container_path</code> 可以在容器和 host 之间拷贝数据，当然我们也可以直接通过 Linux 的 cp 命令复制到 /var/lib/docker/volumes/xxx。</p><h3 id="容器之间共享数据"><a href="#容器之间共享数据" class="headerlink" title="容器之间共享数据"></a>容器之间共享数据</h3><p>将要共享的数据放在bind mount中，然后将其mount到多个容器中，三个web应用共享/root/htdocs目录下的内容。</p><pre><code>[root@docker ~]# docker run -d -p 8081:80 -v /root/htdocs:/usr/local/apache2/htdocs httpd6de2eea95249c6cd534424100b692b4b9df3ad6246e533405ae54a4f5e224e3f[root@docker ~]# docker run -d -p 8082:80 -v /root/htdocs:/usr/local/apache2/htdocs httpdecd5da2b050dddbacc12c0c3c976ef26f173ad7968e4664060bb480fbdabd91d[root@docker ~]# docker run -d -p 8083:80 -v /root/htdocs:/usr/local/apache2/htdocs httpd9a56caf5dc8520a8c20d88a20a77b18018bb348d6605218af09ec35f2ec59785[root@docker ~]# curl &apos;http://127.0.0.1:8081&apos;welcome to chenfanlinux.org[root@docker ~]# curl &apos;http://127.0.0.1:8082&apos;welcome to chenfanlinux.org[root@docker ~]# curl &apos;http://127.0.0.1:8083&apos;welcome to chenfanlinux.org[root@docker ~]# docker exec -it 9a56caf5dc85 /bin/bashroot@9a56caf5dc85:/usr/local/apache2# echo &apos;this is new page&apos; &gt;htdocs/index.html[root@docker ~]# curl &apos;http://127.0.0.1:8081&apos;this is new page[root@docker ~]# curl &apos;http://127.0.0.1:8082&apos;this is new page[root@docker ~]# curl &apos;http://127.0.0.1:8083&apos;this is new page</code></pre><p><strong>volume container</strong> 是专门为其他容器提供 volume 的容器。它提供的卷可以是 bind mount，也可以是 docker managed volume。</p><p>创建一个 <strong>volume container</strong>,命令为vc01,而且提供两种类型的 data volume。volume contained的作用只是提供数据，本身不需要运行状态。</p><pre><code>[root@docker ~]# docker create --name=vc01 -v /root/htdocs:/usr/local/apache2/htdocs -v /docker_manage_data  busyboxe23d25dc38c15f91dd9ad4833878a3d965f77f101e91f6c9b2873cef284b3c97[root@docker ~]# docker inspect e23d25dc38c15f91dd9ad4833878a3d965f77f101e91f6c9b2873cef284b3c97        &quot;Mounts&quot;: [        {            &quot;Type&quot;: &quot;bind&quot;,            &quot;Source&quot;: &quot;/root/htdocs&quot;,            &quot;Destination&quot;: &quot;/usr/local/apache2/htdocs&quot;,            &quot;Mode&quot;: &quot;&quot;,            &quot;RW&quot;: true,            &quot;Propagation&quot;: &quot;rprivate&quot;        },        {            &quot;Type&quot;: &quot;volume&quot;,            &quot;Name&quot;: &quot;ceb7995923bfbb0b425f36a492698db6f3f1f987c45afaa80fbc15ddf2d51a85&quot;,            &quot;Source&quot;: &quot;/var/lib/docker/volumes/ceb7995923bfbb0b425f36a492698db6f3f1f987c45afaa80fbc15ddf2d51a85/_data&quot;,            &quot;Destination&quot;: &quot;/docker_manage_data&quot;,            &quot;Driver&quot;: &quot;local&quot;,            &quot;Mode&quot;: &quot;&quot;,            &quot;RW&quot;: true,            &quot;Propagation&quot;: &quot;&quot;        }    ],</code></pre><p>其他容器可以通过 –volumes-from 使用 <strong>vc01</strong>这个 volume container：</p><pre><code>[root@docker ~]# docker run --name web01 -d -p 80 --volumes-from vc01 httpd583e7793e3e8be277cc31efa4aa27c9136b224b3258fafe87be5a8839a827c66[root@docker ~]# docker run --name web02 -d -p 80 --volumes-from vc01 httpdd826c43f2f0fa7e669ed69c59b6d37b00714f84fe490e26139c1a6c2b04225cb[root@docker ~]# docker run --name web03 -d -p 80 --volumes-from vc01 httpd8a5955198364c45b40f2deaa48fdd4005faf986b7450aeb24773c39c0c5d3189[root@docker ~]# docker ps -aCONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS                   NAMES8a5955198364        httpd               &quot;httpd-foreground&quot;   2 minutes ago       Up 2 minutes        0.0.0.0:32770-&gt;80/tcp   web03d826c43f2f0f        httpd               &quot;httpd-foreground&quot;   3 minutes ago       Up 2 minutes        0.0.0.0:32769-&gt;80/tcp   web02583e7793e3e8        httpd               &quot;httpd-foreground&quot;   3 minutes ago       Up 3 minutes        0.0.0.0:32768-&gt;80/tcp   web01[root@docker ~]# curl &apos;http://127.0.0.1:32770&apos;this is new page[root@docker ~]# curl &apos;http://127.0.0.1:32769&apos;this is new page[root@docker ~]# curl &apos;http://127.0.0.1:32768&apos;this is new page[root@docker ~]# echo &apos;This is shared bind mount&apos; &gt;/root/htdocs/index.html[root@docker ~]# curl &apos;http://127.0.0.1:32770&apos;This is shared bind mount[root@docker ~]# curl &apos;http://127.0.0.1:32768&apos;This is shared bind mount[root@docker ~]# curl &apos;http://127.0.0.1:32769&apos;This is shared bind mount</code></pre><p>可见，三个容器已经成功共享了 volume container 中的 volume。</p><ul><li><p>与 bind mount 相比，不必为每一个容器指定 host path，所有 path 都在 volume container 中定义好了，容器只需与 volume container 关联，实现了容器与 host 的解耦。</p></li><li><p>使用 volume container 的容器其 mount point 是一致的，有利于配置的规范和标准化，但也带来一定的局限，使用时需要综合考虑。</p></li></ul><p><strong>data-packed volume container</strong><br>volume container 的数据归根到底还是在 host 里，有没有办法将数据完全放到 volume container 中，同时又能与其他容器共享呢？</p><p>当然可以，通常我们称这种容器为 data-packed volume container。其原理是将数据打包到镜像中，然后通过 docker managed volume 共享。</p><p>先创建一个vc_datapacked镜像</p><pre><code>[root@docker ~]# mkdir build[root@docker ~]# cd build[root@docker build]# mkdir htdocs[root@docker build]# echo &apos;This  data-packed volume container&apos; &gt;htdocs/index.html[root@docker build]# cat DockerfileFROM busybox:latestADD htdocs /usr/local/apache2/htdocsVOLUME /usr/local/apache2/htdocs[root@docker build]# docker build -t vc_datapacked  .Sending build context to Docker daemon  3.584kBStep 1/3 : FROM busybox:latest ---&gt; 807fd4df40d1Step 2/3 : ADD htdocs /usr/local/apache2/htdocs ---&gt; 73edca1e0721Step 3/3 : VOLUME /usr/local/apache2/htdocs ---&gt; Running in 9cbf417e6126Removing intermediate container 9cbf417e6126 ---&gt; 218f809be766Successfully built 218f809be766Successfully tagged vc_datapacked:latest</code></pre><p>再创建一个共享的volume contained (datapacked)</p><pre><code>[root@docker build]# docker inspect datapacked[root@docker build]# docker create --name datapacked vc_datapacked     &quot;Mounts&quot;: [        {            &quot;Type&quot;: &quot;volume&quot;,            &quot;Name&quot;: &quot;cb02a8020d38d9d7e8f68dcabf706808e73c2801d1f0cc52bad84c7a9206dc35&quot;,            &quot;Source&quot;: &quot;/var/lib/docker/volumes/cb02a8020d38d9d7e8f68dcabf706808e73c2801d1f0cc52bad84c7a9206dc35/_data&quot;,            &quot;Destination&quot;: &quot;/usr/local/apache2/htdocs&quot;,            &quot;Driver&quot;: &quot;local&quot;,            &quot;Mode&quot;: &quot;&quot;,            &quot;RW&quot;: true,            &quot;Propagation&quot;: &quot;&quot;        }    ],</code></pre><p>启动一个httpd应用，共享datapacked 数据</p><pre><code>[root@docker build]# docker run -d -p 8081:80 --volumes-from datapacked httpd[root@docker build]# curl http://127.0.0.1:8081This  data-packed volume container</code></pre><p>本质来说，这是一种dokcer managed volume的应用，只是将需要共享的数据放在了volume容器的镜像中。data-packed volume container 是自包含的，不依赖 host 提供数据，具有很强的移植性，非常适合 只使用 静态数据的场景，比如应用的配置信息、web server 的静态文件等。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;如何存储Docker数据&quot;&gt;&lt;a href=&quot;#如何存储Docker数据&quot; class=&quot;headerlink&quot; title=&quot;如何存储Docker数据&quot;&gt;&lt;/a&gt;如何存储Docker数据&lt;/h2&gt;&lt;p&gt;Docker 为容器提供了两种存放数据的资源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Storage Driver 管理的镜像层和容器层。&lt;/li&gt;
&lt;li&gt;Data Volume&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Storage Driver&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;容器由最上面一个可写的容器层，以及若干只读的镜像层组成，容器的数据就存放在这些层中。这样的分层结构最大的特性是 &lt;strong&gt;&lt;em&gt;Copy-on-Write&lt;/em&gt;&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新数据会直接存放在最上面的容器层。&lt;/li&gt;
&lt;li&gt;修改现有数据会先从镜像层将数据复制到容器层，修改后的数据直接保存在容器层中，镜像层保持不变。&lt;/li&gt;
&lt;li&gt;如果多个层中有命名相同的文件，用户只能看到最上面那层中的文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/01/15/pUMMh4.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;Storage Driver 实现了多层数据的堆叠并为用户提供一个单一的合并之后的统一视图。适合无状态的应用，不需要持久化存储数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Data Volume&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Data Volume 本质上是 Docker Host 文件系统中的目录或文件，能够直接被 mount 到容器的文件系统中。适合于持久化数据的需求的数据存储，容器启动时需要加载已有的数据，容器销毁时希望保留产生的新数据，也就是说，这类容器是有状态的。Data Volume有如下特点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Data Volume 是目录或文件，而非没有格式化的磁盘（块设备）。&lt;/li&gt;
&lt;li&gt;容器可以读写 volume 中的数据。&lt;/li&gt;
&lt;li&gt;volume 数据可以被永久的保存，即使使用它的容器已经销毁。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Data-volume的类型&quot;&gt;&lt;a href=&quot;#Data-volume的类型&quot; class=&quot;headerlink&quot; title=&quot;Data volume的类型&quot;&gt;&lt;/a&gt;Data volume的类型&lt;/h2&gt;&lt;p&gt;在具体的使用上，docker 提供了两种类型的 volume：bind mount 和 docker managed volume。&lt;/p&gt;
&lt;h3 id=&quot;bind-mount&quot;&gt;&lt;a href=&quot;#bind-mount&quot; class=&quot;headerlink&quot; title=&quot;bind mount&quot;&gt;&lt;/a&gt;bind mount&lt;/h3&gt;&lt;p&gt;bind mount 是将 host 上已存在的目录或文件 mount 到容器。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@chenfanlinux ~]# mkdir /root/htdocs
[root@chenfanlinux ~]# echo &amp;quot;Welcome to chenfanlinux.org&amp;quot; &amp;gt;/root/htdocs/index.html
[root@chenfanlinux ~]# docker run -d -p 80:80 -v /root/htdocs:/usr/local/apache2/htdocs httpd
c7a396731c62e35b0704e16ffa6ea0a4b4d7e3488cd220dca0d41958eff46c30
[root@chenfanlinux ~]# docker ps
CONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS                NAMES
c7a396731c62        httpd               &amp;quot;httpd-foreground&amp;quot;   15 seconds ago      Up 14 seconds       0.0.0.0:80-&amp;gt;80/tcp   serene_mccarthy
[root@chenfanlinux ~]# curl &amp;apos;http://127.0.0.1:80&amp;apos;
Welcome to chenfanlinux.org
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过 &lt;strong&gt;&lt;em&gt;-v &amp;lt;host path&amp;gt;:&amp;lt;container path&amp;gt;&lt;/em&gt;&lt;/strong&gt; 这种格式将host上的/root/htdocs挂载到容器/usr/local/apache2/htdocs目录下。由于/root/htdocs目录下有文件，会隐藏容器/usr/local/apache2/htdocs下的文件内容。&lt;/p&gt;
&lt;p&gt;当我们更新一下/root/htdocs目录下的文件内容时，看看容器里的文件是否发生变化。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@chenfanlinux htdocs]# echo &amp;apos;this is www.chenfanlinux.org&amp;apos;&amp;gt; index.html
[root@chenfanlinux htdocs]# ls
index.html
[root@chenfanlinux htdocs]# curl &amp;apos;http://127.0.0.1&amp;apos;
this is www.chenfanlinux.org
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里的host 目录的/root/htdocs和容器/usr/local/apache2/htdocs属于共享目录，它们会共享数据。&lt;br&gt;下面我们将容器销毁，看看对 bind mount 有什么影响：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@chenfanlinux htdocs]# docker stop 177051349c19
177051349c19
[root@chenfanlinux htdocs]# docker rm 177051349c19
177051349c19
[root@chenfanlinux htdocs]# cat /root/htdocs/index.html
this is www.chenfanlinux.org
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到/root/htdocs数据依然存在，bind mount是文件系统中的数据，容器在销毁时，这些数据不会删除。&lt;/p&gt;
&lt;p&gt;bind mount 时还可以指定数据的读写权限，默认是可读可写，可指定为只读，ro 设置了只读权限，在容器中是无法对 bind mount 数据进行修改的。只有 host 有权修改数据，提高了安全性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@chenfanlinux htdocs]# docker run -d -p 80:80 -v /root/htdocs:/usr/local/apache2/htdocs:ro  httpd
d0d2fa8b29b120a8c20d88a20a77b18018bb348d6605218af09ec35f2ec59785
[root@chenfanlinux htdocs]# docker exec -it d0d2fa8b29b1 /bin/bash
root@d0d2fa8b29b1:/usr/local/apache2#
root@d0d2fa8b29b1:/usr/local/apache2# echo &amp;apos;host path:container path:perm&amp;apos; &amp;gt;htdoc
bash: htdocs//index.htm: Read-only file system
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;mount point 有很多应用场景，比如我们可以将源代码目录 mount 到容器中，在 host 中修改代码就能看到应用的实时效果。再比如将 mysql 容器的数据放在 bind mount 里，这样 host 可以方便地备份和迁移数据。&lt;/p&gt;
&lt;p&gt;bind mount 的使用直观高效，易于理解，但它也有不足的地方：bind mount 需要指定 host 文件系统的特定路径，这就限制了容器的可移植性，当需要将容器迁移到其他 host，而该 host 没有要 mount 的数据或者数据不在相同的路径时，操作会失败。移植性更好的方式是 docker managed volume，下面就会讨论。&lt;br&gt;
    
    </summary>
    
      <category term="Docker系列" scheme="http://www.chenfanlinux.org/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Docker" scheme="http://www.chenfanlinux.org/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门之网络管理(五)</title>
    <link href="http://www.chenfanlinux.org/2018/01/14/Docker%E5%85%A5%E9%97%A8%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86-%E4%BA%94/"/>
    <id>http://www.chenfanlinux.org/2018/01/14/Docker入门之网络管理-五/</id>
    <published>2018-01-14T12:48:37.000Z</published>
    <updated>2018-01-26T03:39:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker中自带的网络类型"><a href="#Docker中自带的网络类型" class="headerlink" title="Docker中自带的网络类型"></a>Docker中自带的网络类型</h2><blockquote><p>在Docker容器技术中，网络部分算是比较复杂的一部分。了解Docker提供了几种原生的网络，了解容器与外界通信以及外界对容器如何进行访问，这是本文的重点。</p></blockquote><p>Docker 安装时会自动在 host 上创建三个网络，我们可用 docker network ls 命令查看：</p><pre><code>[root@localhost ~]# docker network lsNETWORK ID          NAME                DRIVER              SCOPE39e6a520b768        bridge              bridge              localb31da46610a3        host                host                local7d42c5a35cce        none                null                local</code></pre><p>上面我们可以看到三种类型的网络，包括none、host、bridge这三种原生的网络，还有一种container网络用于容器间通信的后面也会做介绍。</p><h3 id="none网络"><a href="#none网络" class="headerlink" title="none网络"></a>none网络</h3><p>none 网络就是什么都没有的网络。挂在这个网络下的容器除了 lo，没有其他任何网卡。容器创建时，可以通过 –network=none 指定使用 none 网络。</p><pre><code>[root@docker ~]# docker run -it --network=none busyboxUnable to find image &apos;busybox:latest&apos; locallylatest: Pulling from library/busyboxfb46b04c527d: Pull completeDigest: sha256:436bbf48aa1198ebca8eac0ad9a9c80c8929d9242e02608f76ce18334e0cfe6aStatus: Downloaded newer image for busybox:latest/ # ifconfiglo        Link encap:Local Loopback          inet addr:127.0.0.1  Mask:255.0.0.0          UP LOOPBACK RUNNING  MTU:65536  Metric:1          RX packets:0 errors:0 dropped:0 overruns:0 frame:0          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</code></pre><p>这里我们可以看到none网络中只有一个lo，没有其他网卡，就是一个封闭的网络，不与外界通信。封闭意味着隔离，一些对安全性要求高并且不需要联网的应用可以使用 none 网络。</p><h3 id="host网络"><a href="#host网络" class="headerlink" title="host网络"></a>host网络</h3><p>连接到 host 网络的容器共享 Docker host 的网络栈，容器的网络配置与宿主机完全一样。可以通过 –network=host 指定使用 host 网络。</p><pre><code>[root@docker ~]# docker run -it --network=host busybox/ # ifconfigdocker0   Link encap:Ethernet  HWaddr 02:42:02:90:4E:49          inet addr:172.17.0.1  Bcast:0.0.0.0  Mask:255.255.0.0          UP BROADCAST MULTICAST  MTU:1500  Metric:1          RX packets:0 errors:0 dropped:0 overruns:0 frame:0          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:0          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)ens33     Link encap:Ethernet  HWaddr 00:0C:29:95:F6:22          inet addr:192.168.175.40  Bcast:192.168.175.255  Mask:255.255.255.0          inet6 addr: fe80::f1c9:d94d:f12b:990c/64 Scope:Link          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:203380 errors:0 dropped:0 overruns:0 frame:0          TX packets:73455 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1000          RX bytes:270648213 (258.1 MiB)  TX bytes:6886880 (6.5 MiB)lo        Link encap:Local Loopback          inet addr:127.0.0.1  Mask:255.0.0.0          inet6 addr: ::1/128 Scope:Host          UP LOOPBACK RUNNING  MTU:65536  Metric:1          RX packets:0 errors:0 dropped:0 overruns:0 frame:0          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)/ # hostnamedocker</code></pre><p>在容器内可以看到所有宿主机的网卡，跟宿主机ifconfig看到的结果时一致的，并且hostname并不是短ID，而是宿主机的hostname。<br>直接使用 Docker host 的网络最大的好处就是性能，如果容器对网络传输效率有较高要求，则可以选择 host 网络。当然不便之处就是牺牲一些灵活性，比如要考虑端口冲突问题，宿主机上已经使用的端口就不能再用了。</p><a id="more"></a><h3 id="container模式"><a href="#container模式" class="headerlink" title="container模式"></a>container模式</h3><p>这个模式指定新创建的容器和已经存在的一个容器共享一个Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，它可以使两个或多个容器共享一个网络栈等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过lo（127.0.0.1）网卡设备通信，这篇文章的后面降到容器间通信的时候，会讲到这种网络模式。</p><h3 id="bridge网络"><a href="#bridge网络" class="headerlink" title="bridge网络"></a>bridge网络</h3><p>bridge网络是Docker默认的网络类型，具有更广泛的使用价值。也是本文及后续探讨的重点，明确bridge网络原理，对应用Docker技术至关重要。</p><pre><code>[root@docker ~]# ifconfigdocker0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500        inet 172.17.0.1  netmask 255.255.0.0  broadcast 0.0.0.0        ether 02:42:02:90:4e:49  txqueuelen 0  (Ethernet)        RX packets 0  bytes 0 (0.0 B)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 (0.0 B)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0[root@docker ~]# brctl showbridge name    bridge id        STP enabled    interfacesdocker0        8000.02425cb5b194    no</code></pre><p>Docker 安装时会创建一个 命名为 docker0 的 linux bridge。如果不指定–network，创建的容器默认都会挂到 docker0 上。利用brctl show命令可以看到虚拟网桥上暂时是空的，当我运行一个容器的时候，接下来会发现什么变化呢？</p><pre><code>[root@docker ~]# docker run -it busyboxUnable to find image &apos;busybox:latest&apos; locallylatest: Pulling from library/busyboxfb46b04c527d: Pull completeDigest: sha256:7962088087138b6cb316047648316287e110c5d46569900d332b80fbd7840a40Status: Downloaded newer image for busybox:latest[root@docker ~]# brctl showbridge name    bridge id        STP enabled    interfacesdocker0        8000.02425cb5b194    no        vetha36b044</code></pre><p>上面我们运行一个busybox后,发现docker0上多了一个网络接口 <strong><em>vetha36b044</em></strong>，这是新建容器的虚拟网卡。下面我们进入到容器内部看看网卡的信息。</p><pre><code>/ # ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever4: eth0@if5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0       valid_lft forever preferred_lft forever[root@docker ~]# ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever    inet6 ::1/128 scope host       valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000    link/ether 00:0c:29:95:f6:22 brd ff:ff:ff:ff:ff:ff    inet 192.168.175.40/24 brd 192.168.175.255 scope global ens33       valid_lft forever preferred_lft forever    inet6 fe80::f1c9:d94d:f12b:990c/64 scope link       valid_lft forever preferred_lft forever3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP    link/ether 02:42:5c:b5:b1:94 brd ff:ff:ff:ff:ff:ff    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0       valid_lft forever preferred_lft forever    inet6 fe80::42:5cff:feb5:b194/64 scope link       valid_lft forever preferred_lft forever5: vetha36b044@if4: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP    link/ether 4e:23:f7:66:08:13 brd ff:ff:ff:ff:ff:ff link-netnsid 0    inet6 fe80::4c23:f7ff:fe66:813/64 scope link       valid_lft forever preferred_lft forever</code></pre><p>通过上面的实验，我们可以发现通过brctl show看到的dokcer0上挂载网卡接口为<strong><em>vetha36b044</em></strong>，而容器的网卡为eth0@if5，他们两个居然不一样！其实他们两个是一对 <strong>veth pair</strong>，veth pair是用于不同network namespace间进行通信的方式，veth pair将一个network namespace数据发往另一个network namespace的veth。网卡的一头（eth0@if5）在容器中，另一头（vetha36b044）挂在网桥 docker0 上，其效果就是将 eth0@if34 也挂在了 docker0 上。</p><p>进一步分析busybox容器的网络地址为172.17.0.2/16,而docker0的网络地址为172.17.0.1/16，可以通过<code>docker inspect network bridge</code> 来查看bridge网络的配置情况如下。</p><pre><code>[root@docker ~]# docker network inspect bridge[    {        &quot;Name&quot;: &quot;bridge&quot;,        &quot;Id&quot;: &quot;0a38d5dc818f2d1dafce109c3aa955e6d5854f296f0fd34704decb756538c985&quot;,        &quot;Created&quot;: &quot;2018-01-12T10:25:49.592636268+08:00&quot;,        &quot;Scope&quot;: &quot;local&quot;,        &quot;Driver&quot;: &quot;bridge&quot;,        &quot;EnableIPv6&quot;: false,        &quot;IPAM&quot;: {            &quot;Driver&quot;: &quot;default&quot;,            &quot;Options&quot;: null,            &quot;Config&quot;: [                {                    &quot;Subnet&quot;: &quot;172.17.0.0/16&quot;,                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;                }            ]        },        &quot;Internal&quot;: false,        &quot;Attachable&quot;: false,        &quot;Ingress&quot;: false,        &quot;ConfigFrom&quot;: {            &quot;Network&quot;: &quot;&quot;        },        &quot;ConfigOnly&quot;: false,        &quot;Containers&quot;: {            &quot;e519d169f8d3d686245a27d0dfdd05ff3d8dc605534b48f882cd37428ef3b5af&quot;: {                &quot;Name&quot;: &quot;eager_bohr&quot;,                &quot;EndpointID&quot;: &quot;9c6abac0b5336d5415075091209e9779879579a913c00ef4dcb0ac55fca639ed&quot;,                &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,                &quot;IPv4Address&quot;: &quot;172.17.0.2/16&quot;,                &quot;IPv6Address&quot;: &quot;&quot;            }        },        &quot;Options&quot;: {            &quot;com.docker.network.bridge.default_bridge&quot;: &quot;true&quot;,            &quot;com.docker.network.bridge.enable_icc&quot;: &quot;true&quot;,            &quot;com.docker.network.bridge.enable_ip_masquerade&quot;: &quot;true&quot;,            &quot;com.docker.network.bridge.host_binding_ipv4&quot;: &quot;0.0.0.0&quot;,            &quot;com.docker.network.bridge.name&quot;: &quot;docker0&quot;,            &quot;com.docker.network.driver.mtu&quot;: &quot;1500&quot;        },        &quot;Labels&quot;: {}    }][root@docker ~]# ifconfig docker0    docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500    inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255    inet6 fe80::42:5cff:feb5:b194  prefixlen 64  scopeid 0x20&lt;link&gt;    ether 02:42:5c:b5:b1:94  txqueuelen 0  (Ethernet)    RX packets 0  bytes 0 (0.0 B)    RX errors 0  dropped 0  overruns 0  frame 0    TX packets 8  bytes 648 (648.0 B)    TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><p>可以看到bridge网络的 子网”Subnet”: “172.17.0.0/16”； 网关”Gateway”: “172.17.0.1”；容器的网络为”IPv4Address”: “172.17.0.2/16”；可以看出容器的网络由bridge子网分配一个ip地址，而网关就是dokcer0 172.17.0.1。</p><p>因此可以得出当前docker环境下的网络拓扑图如下：</p><p><img src="https://s1.ax1x.com/2018/01/14/pt44gg.png" alt="Docker容器网络拓扑图1"></p><p>容器创建时，docker 会自动从 172.17.0.0/16 中分配一个 IP，这里 16 位的掩码保证有足够多的 IP 可以供容器使用。</p><h2 id="用户自定义网络"><a href="#用户自定义网络" class="headerlink" title="用户自定义网络"></a>用户自定义网络</h2><blockquote><p>除了Docker提供的上面三种none、host、bridge网络，用户还可以根据需求自定义网络。Docker 提供三种 user-defined 网络驱动：bridge, overlay 和 macvlan。overlay 和 macvlan 用于创建跨主机的网络。</p></blockquote><h3 id="系统自动分配网络地址"><a href="#系统自动分配网络地址" class="headerlink" title="系统自动分配网络地址"></a>系统自动分配网络地址</h3><p>我们可通过 bridge 驱动创建类似前面默认的 bridge 网络，网络名为br01，例如：</p><pre><code>[root@docker ~]# docker network create --driver bridge br0151123511575b1593773727c61703ca2b2b86e6e33efe48be398c402b774811c3</code></pre><p>查看host网络网桥的情况：<br>发现多了一个 名为 <strong><em>br-51123511575b</em></strong> 的网桥，这里的 <strong>51123511575b</strong> 正好是新建的网桥 <strong>br01</strong> 的短id.</p><pre><code>[root@docker ~]# brctl showbridge name    bridge id        STP enabled    interfacesbr-51123511575b        8000.02425d1b64f0    nodocker0        8000.02425cb5b194    no        vetha36b044</code></pre><p>使用     <code>docker network inspect br01</code> 看一下具体的br01网络配置信息。使用 <code>docker network inspect br01</code> 前需要通过  <code>docker network ls</code> 看一下 网络名</p><p>docker0（网桥名） —-&gt; bridge（网络名）<br>br-51123511575b（网桥名）—–&gt; br01（网络名）</p><pre><code>[root@docker ~]# docker network lsNETWORK ID          NAME                DRIVER              SCOPE51123511575b        br01                bridge              local0a38d5dc818f        bridge              bridge              local780f6f3484b4        host                host                local26045d3b36ad        none                null                local[root@docker ~]# docker network inspect br01[    {        &quot;Name&quot;: &quot;br01&quot;,        &quot;Id&quot;: &quot;51123511575b1593773727c61703ca2b2b86e6e33efe48be398c402b774811c3&quot;,        &quot;Created&quot;: &quot;2018-01-12T16:30:26.109384839+08:00&quot;,        &quot;Scope&quot;: &quot;local&quot;,        &quot;Driver&quot;: &quot;bridge&quot;,        &quot;EnableIPv6&quot;: false,        &quot;IPAM&quot;: {            &quot;Driver&quot;: &quot;default&quot;,            &quot;Options&quot;: {},            &quot;Config&quot;: [                {                    &quot;Subnet&quot;: &quot;172.18.0.0/16&quot;,                    &quot;Gateway&quot;: &quot;172.18.0.1&quot;                }            ]        },        &quot;Internal&quot;: false,        &quot;Attachable&quot;: false,        &quot;Ingress&quot;: false,        &quot;ConfigFrom&quot;: {            &quot;Network&quot;: &quot;&quot;        },        &quot;ConfigOnly&quot;: false,        &quot;Containers&quot;: {},        &quot;Options&quot;: {},        &quot;Labels&quot;: {}    }]</code></pre><p>刚才新建的bridge网络br01的网络配置信息如上，子网为172.18.0.0/16，网关为172.18.0.1。网络名为 <strong>br01</strong> 的网络对应的网桥名为 <strong>br-51123511575b</strong>，也是它的网关。</p><pre><code>[root@docker ~]# ifconfig br-51123511575bbr-51123511575b: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500        inet 172.18.0.1  netmask 255.255.0.0  broadcast 172.18.255.255        ether 02:42:5d:1b:64:f0  txqueuelen 0  (Ethernet)        RX packets 0  bytes 0 (0.0 B)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 (0.0 B)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><h3 id="用户指定固定网络地址"><a href="#用户指定固定网络地址" class="headerlink" title="用户指定固定网络地址"></a>用户指定固定网络地址</h3><blockquote><p>上面我们创建的bridge网络 <strong>br01</strong> 是系统给分配的子网地址和网关，在创建bridge网络的时候，用户也可以自定义网络地址，配置如下： 只需在创建网段时指定 –subnet 和 –gateway 参数</p></blockquote><pre><code>[root@docker ~]# docker network create --driver bridge --subnet=172.20.0.0/16 --gateway=172.20.0.1 br0210aea5be498f0de091bd078a640cf07d58903ac6af7c8f75d9045752414f8d6f[root@docker ~]# brctl showbridge name    bridge id        STP enabled    interfacesbr-10aea5be498f        8000.0242452b7e17    nobr-51123511575b        8000.02425d1b64f0    nodocker0        8000.02425cb5b194    no        vetha36b044</code></pre><p>可以看到我们新创建了一个网桥<strong>br-10aea5be498f</strong>，<strong>10aea5be498f</strong> 也是网桥的短id。</p><pre><code>[root@docker ~]# docker network lsNETWORK ID          NAME                DRIVER              SCOPE51123511575b        br01                bridge              local10aea5be498f        br02                bridge              local0a38d5dc818f        bridge              bridge              local780f6f3484b4        host                host                local26045d3b36ad        none                null                local[root@docker ~]# docker network inspect br02[    {        &quot;Name&quot;: &quot;br02&quot;,        &quot;Id&quot;: &quot;10aea5be498f0de091bd078a640cf07d58903ac6af7c8f75d9045752414f8d6f&quot;,        &quot;Created&quot;: &quot;2018-01-12T17:01:13.134341096+08:00&quot;,        &quot;Scope&quot;: &quot;local&quot;,        &quot;Driver&quot;: &quot;bridge&quot;,        &quot;EnableIPv6&quot;: false,        &quot;IPAM&quot;: {            &quot;Driver&quot;: &quot;default&quot;,            &quot;Options&quot;: {},            &quot;Config&quot;: [                {                    &quot;Subnet&quot;: &quot;172.20.0.0/16&quot;,                    &quot;Gateway&quot;: &quot;172.20.0.1&quot;                }            ]        },        &quot;Internal&quot;: false,        &quot;Attachable&quot;: false,        &quot;Ingress&quot;: false,        &quot;ConfigFrom&quot;: {            &quot;Network&quot;: &quot;&quot;        },        &quot;ConfigOnly&quot;: false,        &quot;Containers&quot;: {},        &quot;Options&quot;: {},        &quot;Labels&quot;: {}    }]</code></pre><p>进一步可以发现，网络名为 <strong>br02</strong>的网络地址配置为子网172.20.0.0/16，网关为172.20.0.1，对应的也就是网桥 <strong>br-10aea5be498f</strong> 的ip地址。</p><pre><code>[root@docker ~]# ifconfig br-10aea5be498fbr-10aea5be498f: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500        inet 172.20.0.1  netmask 255.255.0.0  broadcast 172.20.255.255        ether 02:42:45:2b:7e:17  txqueuelen 0  (Ethernet)        RX packets 0  bytes 0 (0.0 B)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 (0.0 B)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><h3 id="使用新的网络地址运行容器应用"><a href="#使用新的网络地址运行容器应用" class="headerlink" title="使用新的网络地址运行容器应用"></a>使用新的网络地址运行容器应用</h3><blockquote><p>刚才我们利用创建了两个bridge网络<strong>br01</strong>、<strong>br02</strong>，br01的网络地址是系统分配的,br02的网络地址是用户自定义的。下面我们运行一个容器应用，使用 <strong>br02</strong> 网络来研究当前网络的变化。</p></blockquote><pre><code>[root@docker ~]# docker run -d --network=br02 httpdUnable to find image &apos;httpd:latest&apos; locallylatest: Pulling from library/httpdf49cf87b52c1: Pull complete02ca099fb6cd: Pull completede7acb18da57: Pull complete770c8edb393d: Pull complete0e252730aeae: Pull complete6e6ca341873f: Pull complete2daffd0a6144: Pull completeDigest: sha256:b5f21641a9d7bbb59dc94fb6a663c43fbf3f56270ce7c7d51801ac74d2e70046Status: Downloaded newer image for httpd:latesta91d76993197d93d6757c38179b264000d26cabe4afe771a12090ef48de4f8a6[root@docker ~]# docker psCONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS               NAMESa91d76993197        httpd               &quot;httpd-foreground&quot;   49 seconds ago      Up 38 seconds       80/tcp              happy_visvesvarayae519d169f8d3        busybox             &quot;sh&quot;                 7 hours ago         Up 7 hours                              eager_bohr[root@docker ~]# docker exec -it a91d76993197 /bin/sh/ # ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever8: eth0@if9: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default    link/ether 02:42:ac:14:00:02 brd ff:ff:ff:ff:ff:ff    inet 172.20.0.2/16 brd 172.20.255.255 scope global eth0       valid_lft forever preferred_lft forever</code></pre><p>可以看到以 <strong>br02</strong> 网络创建的新容器应用httpd，分配的IP为  172.20.0.2/16，这个IP是从 <strong>br02</strong> 网络的子网地址中随机分配的IP。如果我们想指定容器的静态IP,可以使用–ip参数指定。</p><pre><code>[root@docker ~]# docker run -d --network=br02 --ip 172.20.0.9  httpd9da4e8e73e3c3a5d19337d53dbad6d846bef63150bd76dc074642e0063a60e28[root@docker ~]# docker psCONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS               NAMES9da4e8e73e3c        httpd               &quot;httpd-foreground&quot;   21 seconds ago      Up 19 seconds       80/tcp              upbeat_wescoffa91d76993197        httpd               &quot;httpd-foreground&quot;   7 minutes ago       Up 7 minutes        80/tcp              happy_visvesvarayae519d169f8d3        busybox             &quot;sh&quot;                 7 hours ago         Up 7 hours                              eager_bohr[root@docker ~]# docker exec -it 9da4e8e73e3c /bin/bashroot@9da4e8e73e3c:/usr/local/apache2# ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever10: eth0@if11: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default    link/ether 02:42:ac:14:00:09 brd ff:ff:ff:ff:ff:ff    inet 172.20.0.9/16 brd 172.20.255.255 scope global eth0       valid_lft forever preferred_lft forever</code></pre><p>上面就可以看到容器ID为 <strong>9da4e8e73e3c</strong> 的httpd应用的IP地址为 172.20.0.9/16 。刚才的br01网络地址是系统自动分配的，看看使用这个网络地址是否能够给容器指定静态地址。</p><pre><code>[root@docker ~]# docker  run -d --network=br01 --ip 172.18.0.9 httpdda7057c2a5f00e68d7f0017e675e25a2cbf44e086944b2d1898f70345f5ada77docker: Error response from daemon: user specified IP address is supported only when connecting to networks with user configured subnets</code></pre><p>可以看到明显的报错信息，用户自定义的IP地址需要用户自定义的网络地址的支持。</p><h2 id="容器之间的通信"><a href="#容器之间的通信" class="headerlink" title="容器之间的通信"></a>容器之间的通信</h2><h3 id="当前Docker的网络拓扑"><a href="#当前Docker的网络拓扑" class="headerlink" title="当前Docker的网络拓扑"></a>当前Docker的网络拓扑</h3><blockquote><p>经过上面创建了两个bridge网络 <strong>br01</strong> 、<strong>br02</strong>。 <strong>br01</strong>是系统分配的网络地址，<strong>br02</strong>是我们指定的网络地址，并且指定 br02 为网络地址，运行了两个httpd应用。其中一个应用利用 –ip 指定了容器的静态IP，另一个是系统分配的IP地址。</p></blockquote><p><img src="https://s1.ax1x.com/2018/01/12/p8X2kR.md.png" alt="Docker网络拓扑"></p><h3 id="容器之间连通性"><a href="#容器之间连通性" class="headerlink" title="容器之间连通性"></a>容器之间连通性</h3><p>由于两个httpd容器应用都挂在同一个网络br02上，他们之间应该是连通的。</p><pre><code>root@cba8fa31d272:/usr/local/apache2# ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever11: eth0@if12: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default    link/ether 02:42:ac:14:00:02 brd ff:ff:ff:ff:ff:ff    inet 172.20.0.2/16 brd 172.20.255.255 scope global eth0       valid_lft forever preferred_lft foreverroot@cba8fa31d272:/usr/local/apache2# ping -c 5 172.20.0.9PING 172.20.0.9 (172.20.0.9): 56 data bytes64 bytes from 172.20.0.9: icmp_seq=0 ttl=64 time=0.232 ms64 bytes from 172.20.0.9: icmp_seq=1 ttl=64 time=0.145 ms64 bytes from 172.20.0.9: icmp_seq=2 ttl=64 time=0.167 ms64 bytes from 172.20.0.9: icmp_seq=3 ttl=64 time=0.169 ms64 bytes from 172.20.0.9: icmp_seq=4 ttl=64 time=0.340 ms--- 172.20.0.9 ping statistics ---5 packets transmitted, 5 packets received, 0% packet lossround-trip min/avg/max/stddev = 0.145/0.211/0.340/0.071 msroot@0cd3ba4c84a1:/usr/local/apache2# ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever9: eth0@if10: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default    link/ether 02:42:ac:14:00:09 brd ff:ff:ff:ff:ff:ff    inet 172.20.0.9/16 brd 172.20.255.255 scope global eth0       valid_lft forever preferred_lft foreverroot@0cd3ba4c84a1:/usr/local/apache2# ping 172.20.0.2 -c 5PING 172.20.0.2 (172.20.0.2): 56 data bytes64 bytes from 172.20.0.2: icmp_seq=0 ttl=64 time=0.295 ms64 bytes from 172.20.0.2: icmp_seq=1 ttl=64 time=0.282 ms64 bytes from 172.20.0.2: icmp_seq=2 ttl=64 time=0.282 ms64 bytes from 172.20.0.2: icmp_seq=3 ttl=64 time=0.182 ms64 bytes from 172.20.0.2: icmp_seq=4 ttl=64 time=0.329 ms--- 172.20.0.2 ping statistics ---5 packets transmitted, 5 packets received, 0% packet lossround-trip min/avg/max/stddev = 0.182/0.274/0.329/0.049 ms</code></pre><p>很明显，两个httpd应用是可以互相通信的，但是httpd应用能够ping通 busybox容器吗？</p><pre><code>root@0cd3ba4c84a1:/usr/local/apache2# ping 172.17.0.2 -c 5PING 172.17.0.2 (172.17.0.2): 56 data bytes/ # ping 172.20.0.2PING 172.20.0.2 (172.20.0.2): 56 data bytes/ # ping 172.20.0.9PING 172.20.0.9 (172.20.0.9): 56 data bytes</code></pre><p>位于bridge的网络容器busybox和位于br02网络的容器httpd互相是ping不通的，因此他们的网络是隔离的。</p><h3 id="容器网络之间的路由情况"><a href="#容器网络之间的路由情况" class="headerlink" title="容器网络之间的路由情况"></a>容器网络之间的路由情况</h3><pre><code>[root@localhost ~]# ifconfig docker0docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255        inet6 fe80::42:22ff:fe51:f07e  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 02:42:22:51:f0:7e  txqueuelen 0  (Ethernet)        RX packets 312  bytes 25368 (24.7 KiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 23  bytes 1278 (1.2 KiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0[root@localhost ~]# ifconfig br-eddf353dd10abr-eddf353dd10a: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 172.20.0.1  netmask 255.255.0.0  broadcast 172.20.255.255        inet6 fe80::42:9aff:fec1:e4ec  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 02:42:9a:c1:e4:ec  txqueuelen 0  (Ethernet)        RX packets 0  bytes 0 (0.0 B)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 (0.0 B)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0[root@localhost ~]# ip routedefault via 192.168.175.2 dev ens33 proto static metric 100172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1172.20.0.0/16 dev br-eddf353dd10a proto kernel scope link src 172.20.0.1192.168.175.0/24 dev ens33 proto kernel scope link src 192.168.175.40 metric 100[root@docker ~]# cat /proc/sys/net/ipv4/ip_forward1</code></pre><p>可以看到两个容器的网段之间的路由已经定义好了，而且路由转发 ip forwarding功能已经启动了，按理说两个网段之间可以通过路由转发机制实现通信，为啥不能访问？首先想到的是主机的防火墙设置，阻断了两个网段之间的通信。</p><pre><code>[root@docker ~]# iptables-save -A DOCKER-ISOLATION -j RETURN -A DOCKER-ISOLATION -i docker0 -o br-b037f1fc0375 -j DROP -A DOCKER-ISOLATION -i br-b037f1fc0375 -o docker0 -j DROP</code></pre><p>可以看到有这样的防火墙规则阻断了docker0和br-b037f1fc0375网关的双向数据流，因此不同网段之间的容器之间的通信是隔离的，这是容器本身的机制。当我尝试删除这两条规则的时候，看看结果如何。</p><pre><code>[root@docker ~]# iptables -D DOCKER-ISOLATION -i br-b037f1fc0375 -o docker0 -j DROP[root@docker ~]# iptables -D  DOCKER-ISOLATION -i docker0 -o br-b037f1fc0375 -j DROP[root@docker ~]# docker run -it busybox/ # ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever13: eth0@if14: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue    link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff    inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0       valid_lft forever preferred_lft forever/ #root@e98fa56e7be1:/usr/local/apache2# ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever9: eth0@if10: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default    link/ether 02:42:ac:14:00:09 brd ff:ff:ff:ff:ff:ff    inet 172.20.0.9/16 brd 172.20.255.255 scope global eth0       valid_lft forever preferred_lft forever    / # ping 172.20.0.9 -c 5PING 172.20.0.9 (172.20.0.9): 56 data bytes64 bytes from 172.20.0.9: seq=0 ttl=63 time=0.579 ms64 bytes from 172.20.0.9: seq=1 ttl=63 time=0.136 ms64 bytes from 172.20.0.9: seq=2 ttl=63 time=0.204 ms64 bytes from 172.20.0.9: seq=3 ttl=63 time=0.181 ms64 bytes from 172.20.0.9: seq=4 ttl=63 time=0.175 ms--- 172.20.0.9 ping statistics ---5 packets transmitted, 5 packets received, 0% packet lossround-trip min/avg/max = 0.136/0.255/0.579 msroot@e98fa56e7be1:/usr/local/apache2# ping 172.17.0.3 -c 3PING 172.17.0.3 (172.17.0.3): 56 data bytes64 bytes from 172.17.0.3: icmp_seq=0 ttl=63 time=1.058 ms64 bytes from 172.17.0.3: icmp_seq=1 ttl=63 time=0.134 ms64 bytes from 172.17.0.3: icmp_seq=2 ttl=63 time=0.351 ms--- 172.17.0.3 ping statistics ---3 packets transmitted, 3 packets received, 0% packet lossround-trip min/avg/max/stddev = 0.134/0.514/1.058/0.395 ms</code></pre><p>发现两个网段的容器之间可以通信，看来真是防火墙阻断了他们之间的通信，这是Docker默认的机制，会隔离不同网段的容器。</p><h3 id="隔离网段的容器互相通信"><a href="#隔离网段的容器互相通信" class="headerlink" title="隔离网段的容器互相通信"></a>隔离网段的容器互相通信</h3><p>通过上面的实验，我们可以知道，两个网段之间的容器通信被防火墙规则阻断了，通过删除防火墙规则可以让其通信，接下来介绍另一种方式。</p><p>可以在httpd容器应用中添加一块docker0网桥所在的bridge网络的网卡。</p><pre><code>[root@docker ~]# docker network connect bridge 2e5ec0b10014[root@docker ~]# docker exec -it 2e5ec0b10014 /bin/bashroot@2e5ec0b10014:/usr/local/apache2# ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever21: eth0@if22: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default    link/ether 02:42:ac:14:00:02 brd ff:ff:ff:ff:ff:ff    inet 172.20.0.2/16 brd 172.20.255.255 scope global eth0       valid_lft forever preferred_lft forever25: eth1@if26: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default    link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff    inet 172.17.0.3/16 brd 172.17.255.255 scope global eth1       valid_lft forever preferred_lft foreverroot@2e5ec0b10014:/usr/local/apache2# ping 172.17.0.2 -c 3PING 172.17.0.2 (172.17.0.2): 56 data bytes64 bytes from 172.17.0.2: icmp_seq=0 ttl=64 time=0.460 ms64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.471 ms64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.171 ms--- 172.17.0.2 ping statistics ---3 packets transmitted, 3 packets received, 0% packet lossround-trip min/avg/max/stddev = 0.171/0.367/0.471/0.139 ms</code></pre><p>在httpd容器应用中就可以看到多出来了一块网卡 eth1 172.17.0.3,这样就可以实现与网桥docker0 所在的网段的busybox应用通信，因此目前的网络拓扑图变化成如下：</p><p><img src="https://s1.ax1x.com/2018/01/14/ptXyAe.png" alt="Docker网络拓扑图3"></p><h2 id="容器间通信的方式"><a href="#容器间通信的方式" class="headerlink" title="容器间通信的方式"></a>容器间通信的方式</h2><p>容器之间可通过 IP，Docker DNS Server 和 joined 容器三种方式通信。</p><h3 id="IP通信"><a href="#IP通信" class="headerlink" title="IP通信"></a>IP通信</h3><p>两个容器想要通信，由于防火墙的限制，两个网段之间的流量被Drop掉了，因此容器的通信需要使容器的网卡处于同一个网段。在创建容器的时候可以通过 <strong>–network</strong> 参数指定容器的网络；创建好的容器也可以通过 <code>docker network connect</code> 新增一块网卡，指定新的网段，来与其他网段的容器通信。</p><h3 id="Docker-DNS-Server"><a href="#Docker-DNS-Server" class="headerlink" title="Docker DNS Server"></a>Docker DNS Server</h3><p>通过IP访问容器这种方式不够灵活，往往在部署完应用后，才能知道容器的IP，部署完再指定IP比较麻烦。可以通过docker自带的DNS服务解决问题，docker daemon 实现了一个内嵌的 DNS server，使容器可以直接通过“容器名”通信。方法很简单，只要在启动时用 –name 为容器命名就可以了。</p><pre><code>[root@docker ~]# docker run -it --name=busybox01 busybox/ # ping busybox02ping: bad address &apos;busybox02&apos;[root@docker ~]# docker run -it --name=busybox02 busybox/ #/ #/ # ping busybox02</code></pre><p>这样却发生报错bad address，不能通过Docker DNS Server通信 ，一番查找后得知，<strong>docker只允许自定义网络之间通过DNS通信</strong>，我们看看下面的结果。</p><pre><code>[root@docker ~]# docker run -it --network=br02 --name=busybox03 busybox/ # ping busybox04 -c 3PING busybox04 (172.20.0.4): 56 data bytes64 bytes from 172.20.0.4: seq=0 ttl=64 time=0.624 ms64 bytes from 172.20.0.4: seq=1 ttl=64 time=0.273 ms64 bytes from 172.20.0.4: seq=2 ttl=64 time=0.257 ms--- busybox04 ping statistics ---3 packets transmitted, 3 packets received, 0% packet lossround-trip min/avg/max = 0.257/0.384/0.624 ms[root@docker ~]# docker run -it --network=br02 --name=busybox04 busybox/ # ping busybox03PING busybox03 (172.20.0.3): 56 data bytes64 bytes from 172.20.0.3: seq=0 ttl=64 time=0.422 ms64 bytes from 172.20.0.3: seq=1 ttl=64 time=0.125 ms64 bytes from 172.20.0.3: seq=2 ttl=64 time=0.273 ms</code></pre><h3 id="joined-容器"><a href="#joined-容器" class="headerlink" title="joined 容器"></a>joined 容器</h3><p>joined 容器是另一种实现容器间通信的方式。joined 容器非常特别，它可以使两个或多个容器共享一个网络栈，共享网卡和配置信息，joined 容器之间可以通过 127.0.0.1 直接通信。</p><pre><code>[root@docker ~]# docker run -it  --name busybox1 busybox/ # ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever39: eth0@if40: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0       valid_lft forever preferred_lft forever/ # wget 127.0.0.1Connecting to 127.0.0.1 (127.0.0.1:80)index.html           100% |*****************************************************************************root@e1ca2c971717:/usr/local/apache2# ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever39: eth0@if40: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0       valid_lft forever preferred_lft forever</code></pre><p>joined 容器非常适合以下场景：</p><ul><li><p>不同容器中的程序希望通过 loopback 高效快速地通信，比如 web server 与 app server。</p></li><li><p>希望监控其他容器的网络流量，比如运行在独立容器中的网络监控程序。</p></li></ul><h2 id="容器与外部网络的通信"><a href="#容器与外部网络的通信" class="headerlink" title="容器与外部网络的通信"></a>容器与外部网络的通信</h2><h3 id="容器访问外部网络"><a href="#容器访问外部网络" class="headerlink" title="容器访问外部网络"></a>容器访问外部网络</h3><p>前面介绍了容器之间如何通信，现在我们来看容器与外界之间是怎么通信的。</p><pre><code>[root@docker ~]# docker run -d   httpd[root@docker ~]# docker exec -it 4004c065d8d4  /bin/bashroot@4004c065d8d4:/usr/local/apache2# ping www.jd.com -c 5PING www.jdcdn.com (112.91.125.129): 56 data bytes64 bytes from 112.91.125.129: icmp_seq=0 ttl=127 time=19.307 ms64 bytes from 112.91.125.129: icmp_seq=1 ttl=127 time=17.492 ms64 bytes from 112.91.125.129: icmp_seq=2 ttl=127 time=21.132 ms64 bytes from 112.91.125.129: icmp_seq=3 ttl=127 time=20.274 ms64 bytes from 112.91.125.129: icmp_seq=4 ttl=127 time=19.644 ms--- www.jdcdn.com ping statistics ---5 packets transmitted, 5 packets received, 0% packet lossround-trip min/avg/max/stddev = 17.492/19.570/21.132/1.211 msroot@4004c065d8d4:/usr/local/apache2# ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever43: eth0@if44: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default    link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff    inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0       valid_lft forever preferred_lft forever</code></pre><p>可以看到我们启动的容器应用是可以ping通外网的，当前的httpd 位于docker0这个bridge私网内，ip地址为172.17.0.3/16，那它是如何与www.jd.com通信的呢？翻阅有关资料，得知是iptables NAT表进行了NAT地址转换，实现这个功能。接下来看看iptables NAT 表的相关信息。</p><pre><code>[root@docker ~]# iptables -t nat -S-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE</code></pre><p>其含义是：如果网桥 docker0 收到来自 172.17.0.0/16 网段的外出包，把它交给 MASQUERADE 处理。而 MASQUERADE 的处理方式是将包的源地址替换成 host 的地址发送出去，即做了一次网络地址转换（NAT）。</p><p>下面我们通过 tcpdump 查看地址是如何转换的,默认路由通过主机ens33 发出去，所以我们要同时监控  ens33 和 docker0 上的 icmp（ping）数据包。</p><p>当httpd容器应用ping www.jd.com的时候，tcpdump输出如下:<br><img src="https://s1.ax1x.com/2018/01/14/ptcAdU.png" alt="pingjd"><br><img src="https://s1.ax1x.com/2018/01/14/ptcEoF.png" alt="tcpdump_docker0"><br>docker0 收到 httpd 的 ping 包，源地址为容器 IP 172.17.0.3，这没问题，交给 MASQUERADE 处理。这时，在 ens333上我们看到了变化,源地址已经转换成ens33 IP地址，期间目的地址都没有发生变化。这就是 iptable NAT 规则处理的结果，从而保证数据包能够到达外网。<br><img src="https://s1.ax1x.com/2018/01/14/ptcYJH.png" alt="tcpdump_ens33"></p><p>因此整个通信过程可以总结如下几点：</p><ul><li>httpd应用向jd.com发送ping包  172.17.0.3 —&gt; 112.91.125.129(jd.com)</li><li>ping包发送到docker0网桥，发现是目的地址是外网地址，交给NAT处理</li><li>NAT将源地址转换成ens33 IP地址，发往外网 192.168.175.40 —&gt; 112.91.125.129(jd.com)</li><li>ping包从ens33发送出去，经过路由到达 jd.com</li></ul><p><strong><em>通过NAT，docker实现了对外网的访问。</em></strong></p><p>整个通信过程图如下：<br><img src="https://s1.ax1x.com/2018/01/14/ptfubq.png" alt="Docker应用于外界通信图"></p><h3 id="外部网络访问容器"><a href="#外部网络访问容器" class="headerlink" title="外部网络访问容器"></a>外部网络访问容器</h3><p>外部网络如何访问到容器,这可能是我们在学习Docker网络的时候会思考得比较多的问题,研究Docker相关的文档会发现,答案是端口映射。docker 可将容器对外提供服务的端口映射到 host 的某个端口,外网通过该端口访问容器。</p><pre><code>[root@docker ~]# docker run -d -p 80 httpd62644d0840faf368e2f136a7eac0256c9aee082417b4ebad9ef5ba46fed19293[root@docker ~]# docker psCONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS                   NAMES62644d0840fa        httpd               &quot;httpd-foreground&quot;   9 seconds ago       Up 3 seconds        0.0.0.0:32768-&gt;80/tcp   gallant_heyrovsky[root@docker ~]# docker port 62644d0840fa80/tcp -&gt; 0.0.0.0:32768[root@docker ~]# docker psCONTAINER ID        IMAGE               COMMAND              CREATED              STATUS              PORTS                   NAMES62644d0840fa        httpd               &quot;httpd-foreground&quot;   About a minute ago   Up 56 seconds       0.0.0.0:32768-&gt;80/tcp   gallant_heyrovsky</code></pre><p>这里我们通过<code>docker run -d -p 80 httpd</code>,指定了容器httpd启动的端口，而主机的端口时随机映射产生的为 <strong><em>32768</em></strong>。这样就可以通过 host ip:32768  访问容器的 web 服务了。</p><p>除了映射动态端口，也可在 -p 中指定映射到 host 某个特定端口，例如可将 80 端口映射到 host 的 8080 端口：</p><pre><code>[root@docker ~]# docker run -d -p 8080:80 httpdae101db7e11a3e04f6529b7a5e80c0fd4c03118f5a89ff777d105e7144f5d213[root@docker ~]# docker psCONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS                   NAMESae101db7e11a        httpd               &quot;httpd-foreground&quot;   8 seconds ago       Up 6 seconds        0.0.0.0:8080-&gt;80/tcp    hungry_bhaskara</code></pre><p>每一个映射的端口，host 都会启动一个 docker-proxy 进程来处理访问容器的流量：</p><pre><code>[root@docker ~]# ps -ef |grep docker-proxyroot      51380  48020  0 09:43 ?        00:00:00 /usr/bin/docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 32768 -container-ip 172.17.0.2 -container-port 80root      51530  48020  0 09:48 ?        00:00:00 /usr/bin/docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 8080 -container-ip 172.17.0.3 -container-port 80</code></pre><p>最后来看看Docker与外网的双向通信拓扑图，做一个总结。<br><img src="https://s1.ax1x.com/2018/01/14/pt4Ch8.png" alt="Docker与外网双向通信拓扑图"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Docker中自带的网络类型&quot;&gt;&lt;a href=&quot;#Docker中自带的网络类型&quot; class=&quot;headerlink&quot; title=&quot;Docker中自带的网络类型&quot;&gt;&lt;/a&gt;Docker中自带的网络类型&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在Docker容器技术中，网络部分算是比较复杂的一部分。了解Docker提供了几种原生的网络，了解容器与外界通信以及外界对容器如何进行访问，这是本文的重点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Docker 安装时会自动在 host 上创建三个网络，我们可用 docker network ls 命令查看：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost ~]# docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
39e6a520b768        bridge              bridge              local
b31da46610a3        host                host                local
7d42c5a35cce        none                null                local
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面我们可以看到三种类型的网络，包括none、host、bridge这三种原生的网络，还有一种container网络用于容器间通信的后面也会做介绍。&lt;/p&gt;
&lt;h3 id=&quot;none网络&quot;&gt;&lt;a href=&quot;#none网络&quot; class=&quot;headerlink&quot; title=&quot;none网络&quot;&gt;&lt;/a&gt;none网络&lt;/h3&gt;&lt;p&gt;none 网络就是什么都没有的网络。挂在这个网络下的容器除了 lo，没有其他任何网卡。容器创建时，可以通过 –network=none 指定使用 none 网络。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@docker ~]# docker run -it --network=none busybox
Unable to find image &amp;apos;busybox:latest&amp;apos; locally
latest: Pulling from library/busybox
fb46b04c527d: Pull complete
Digest: sha256:436bbf48aa1198ebca8eac0ad9a9c80c8929d9242e02608f76ce18334e0cfe6a
Status: Downloaded newer image for busybox:latest
/ # ifconfig
lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里我们可以看到none网络中只有一个lo，没有其他网卡，就是一个封闭的网络，不与外界通信。封闭意味着隔离，一些对安全性要求高并且不需要联网的应用可以使用 none 网络。&lt;/p&gt;
&lt;h3 id=&quot;host网络&quot;&gt;&lt;a href=&quot;#host网络&quot; class=&quot;headerlink&quot; title=&quot;host网络&quot;&gt;&lt;/a&gt;host网络&lt;/h3&gt;&lt;p&gt;连接到 host 网络的容器共享 Docker host 的网络栈，容器的网络配置与宿主机完全一样。可以通过 –network=host 指定使用 host 网络。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@docker ~]# docker run -it --network=host busybox
/ # ifconfig
docker0   Link encap:Ethernet  HWaddr 02:42:02:90:4E:49
          inet addr:172.17.0.1  Bcast:0.0.0.0  Mask:255.255.0.0
          UP BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

ens33     Link encap:Ethernet  HWaddr 00:0C:29:95:F6:22
          inet addr:192.168.175.40  Bcast:192.168.175.255  Mask:255.255.255.0
          inet6 addr: fe80::f1c9:d94d:f12b:990c/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:203380 errors:0 dropped:0 overruns:0 frame:0
          TX packets:73455 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:270648213 (258.1 MiB)  TX bytes:6886880 (6.5 MiB)

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

/ # hostname
docker
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在容器内可以看到所有宿主机的网卡，跟宿主机ifconfig看到的结果时一致的，并且hostname并不是短ID，而是宿主机的hostname。&lt;br&gt;直接使用 Docker host 的网络最大的好处就是性能，如果容器对网络传输效率有较高要求，则可以选择 host 网络。当然不便之处就是牺牲一些灵活性，比如要考虑端口冲突问题，宿主机上已经使用的端口就不能再用了。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker系列" scheme="http://www.chenfanlinux.org/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Docker" scheme="http://www.chenfanlinux.org/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门之容器管理(四)</title>
    <link href="http://www.chenfanlinux.org/2018/01/11/Docker%E5%85%A5%E9%97%A8%E4%B9%8B%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86-%E5%9B%9B/"/>
    <id>http://www.chenfanlinux.org/2018/01/11/Docker入门之容器管理-四/</id>
    <published>2018-01-11T06:45:57.000Z</published>
    <updated>2018-01-26T03:39:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><blockquote><p>docker run 是启动容器的方法。通过前面的Dockerfile 时我们已经学习到，可用三种方式指定容器启动时执行的命令。</p></blockquote><h3 id="容器运行执行的命令"><a href="#容器运行执行的命令" class="headerlink" title="容器运行执行的命令"></a>容器运行执行的命令</h3><p>通过下面三种方式，我们来执行运行在容器中的命令。</p><ul><li>CMD 指令</li><li>ENDPOINT 指令</li><li>在 docker run 命令行中指定</li></ul><h3 id="运行一个容器示例"><a href="#运行一个容器示例" class="headerlink" title="运行一个容器示例"></a>运行一个容器示例</h3><pre><code>[root@docker ~]# docker run ubuntu pwd/[root@docker ~]# docker ps -aCONTAINER ID        IMAGE                                                                      COMMAND                  CREATED              STATUS                          PORTS               NAMESe12b964641c4        ubuntu                                                                     &quot;pwd&quot;                    32 seconds ago       Exited (0) 31 seconds ago                           modest_johnson</code></pre><p><strong>说明：</strong>  此处我们运行一个ubuntu镜像,并运行pwd命令后,容器便退出了,状态为Exited。这种“一闪而过”的容器通常不是我们想要的结果，我们希望容器能够保持 runing 状态，这样才能被我们使用。</p><h3 id="让容器长久的运行"><a href="#让容器长久的运行" class="headerlink" title="让容器长久的运行"></a>让容器长久的运行</h3><p>因为容器的生命周期依赖于启动时执行的命令，只要该命令不结束，容器也就不会退出。理解了这个原理，我们就可以通过执行一个长期运行的命令来保持容器的运行状态。</p><pre><code>[root@docker ~]# docker run ubuntu /bin/bash -c &quot;while true;do sleep 1;done&quot;[root@docker ~]# docker ps -aCONTAINER ID        IMAGE                                                                      COMMAND                  CREATED             STATUS                     PORTS               NAMESd36bbcefec6b        ubuntu                                                                     &quot;/bin/bash -c &apos;while…&quot;   50 seconds ago      Up 49 seconds                                  eager_lumiere</code></pre><p>上面利用执行循环命令，让命令一直执行，容器自然就不会退出(Exited)状态,而是一直运行(Up)状态。但这样终端会被一直占用。可以利用加上参数-d 以后台方式运行容器。</p><pre><code>[root@docker ~]# docker stop d36bbcefec6bd36bbcefec6b[root@docker ~]# docker rm d36bbcefec6bd36bbcefec6b[root@docker ~]# docker run -d ubuntu /bin/bash -c &quot;while true;do sleep 1;done&quot;a141b831a16edbb94ab41553e2be2af79e2d5b68f25877db40750c49cc991649[root@docker ~]# docker ps -aCONTAINER ID        IMAGE                                                                      COMMAND                  CREATED             STATUS                      PORTS               NAMESa141b831a16e        ubuntu</code></pre><p><strong>说明事项：</strong></p><ul><li>CONTAINER ID 是容器的 “短ID”，前面启动容器时返回的是 “长ID”。短ID是长ID的前12个字符。</li><li>NAMES 字段显示容器的名字，在启动容器时可以通过 –name 参数显示地为容器命名，如果不指定，docker 会自动为容器分配名字。</li><li>我们可以利用docker stop CONTAINER ID 停止正在运行的容器，并使用docker rm CONTAINER ID 删除停止的容器;docker run -d COMMAND 以后台的方式运行容器。</li></ul><a id="more"></a><h2 id="进入容器内部"><a href="#进入容器内部" class="headerlink" title="进入容器内部"></a>进入容器内部</h2><blockquote><p>我们经常需要进到容器里去做一些工作，比如查看日志、调试、启动其他进程等。有两种方法进入容器：attach 和 exec。</p></blockquote><h3 id="docker-attach"><a href="#docker-attach" class="headerlink" title="docker attach"></a>docker attach</h3><pre><code>通过 docker attach 可以 attach 到容器启动命令的终端，例如：[root@docker ~]# docker run -d ubuntu /bin/bash -c &quot;while true;do sleep 1;echo &apos;I am in container&apos;;done&quot; 7b0dfb366bcb3259f6ec13e016e1f517b7c56cf0d406fdea4e4215e55cfd7e86</code></pre><p>这次我们通过 “长ID” attach 到了容器的启动命令终端，之后看到的是echo 每隔一秒打印的信息。</p><pre><code>[root@docker ~]# docker attach 7b0dfb366bcb3259f6ec13e016e1f517b7c56cf0d406fdea4e4215e55cfd7e86I am in containerI am in containerI am in containerI am in containerI am in container</code></pre><h3 id="docker-exec"><a href="#docker-exec" class="headerlink" title="docker exec"></a>docker exec</h3><p>通过 docker exec 进入相同的容器：</p><pre><code>[root@docker ~]# docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES7b0dfb366bcb        ubuntu              &quot;/bin/bash -c &apos;while…&quot;   4 minutes ago       Up 4 minutes                            zealous_dubinsky[root@docker ~]# docker exec -it 7b0dfb366bcb  bashroot@7b0dfb366bcb:/# lsbin   dev  home  lib64  mnt  proc  run   srv  tmp  varboot  etc  lib   media  opt  root  sbin  sys  usrroot@7b0dfb366bcb:/# ps -efUID         PID   PPID  C STIME TTY          TIME CMDroot          1      0  0 04:20 ?        00:00:00 /bin/bash -c while true;do sleroot        265      0  0 04:24 pts/0    00:00:00 bashroot        279      1  0 04:24 ?        00:00:00 sleep 1root        280    265  0 04:24 pts/0    00:00:00 ps -ef</code></pre><p><strong>说明事项：</strong></p><ul><li>-it 以交互模式打开 pseudo-TTY，执行 bash，其结果就是打开了一个 bash 终端</li><li>进入到容器中，容器的 hostname 就是其 “短ID”</li><li>可以像在普通 Linux 中一样执行命令。ps -elf 显示了容器启动进程while 以及当前的 bash 进程</li><li>执行 exit 退出容器，回到 docker host</li><li>docker exec -it <container> bash|sh 是执行 exec 最常用的方式</container></li></ul><h3 id="attach-对比-exec"><a href="#attach-对比-exec" class="headerlink" title="attach 对比 exec"></a>attach 对比 exec</h3><ul><li>attach 直接进入容器 启动命令 的终端，不会启动新的进程。</li><li>exec 则是在容器中打开新的终端，并且可以启动新的进程。</li><li>如果想直接在终端中查看启动命令的输出，用 attach；其他情况使用 exec。</li></ul><p>当然，如果只是为了查看启动命令的输出，可以使用 docker logs 命令</p><pre><code>[root@docker ~]# docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES7b0dfb366bcb        ubuntu              &quot;/bin/bash -c &apos;while…&quot;   10 minutes ago      Up 10 minutes                           zealous_dubinskya141b831a16e        ubuntu              &quot;/bin/bash -c &apos;while…&quot;   25 minutes ago      Up 25 minutes                           ecstatic_pasteur[root@docker ~]# docker logs -f 7b0dfb366bcbI am in containerI am in containerI am in containerI am in containerI am in containerI am in containerI am in containerI am in container</code></pre><h2 id="运行Docker的最佳实践"><a href="#运行Docker的最佳实践" class="headerlink" title="运行Docker的最佳实践"></a>运行Docker的最佳实践</h2><blockquote><p>按用途容器大致可分为两类：服务类容器和工具类的容器。</p></blockquote><h3 id="容器功能分类"><a href="#容器功能分类" class="headerlink" title="容器功能分类"></a>容器功能分类</h3><ul><li><p>服务类容器以 daemon 的形式运行，对外提供服务。比如 web server，数据库等。通过 -d 以后台方式启动这类容器是非常合适的。如果要排查问题，可以通过 exec -it 进入容器。</p></li><li><p>工具类容器通常给能我们提供一个临时的工作环境，工具类容器多使用基础镜像，例如 busybox、debian、ubuntu 等，通常以 run -it 方式运行。</p><p>  <code>[root@docker ~]# docker run -it busybox</code><br>  <code>/ # ping www.baidu.com</code><br>  <code>PING www.baidu.com (14.215.177.39): 56 data bytes</code><br>  <code>64 bytes from 14.215.177.39: seq=0 ttl=127 time=5.724 ms</code><br>  <code>64 bytes from 14.215.177.39: seq=1 ttl=127 time=4.829 ms</code></p></li></ul><p>运行 busybox，run -it 的作用是在容器启动后就直接进入。我们这里通过 ping 验证了在容器中访问 internet 的能力。执行 exit 退出终端，同时容器停止。</p><h3 id="容器运行小结"><a href="#容器运行小结" class="headerlink" title="容器运行小结"></a>容器运行小结</h3><p><strong>容器运行相关的知识点：</strong></p><ul><li>当 CMD 或 Entrypoint 或 docker run 命令行指定的命令运行结束时，容器停止。</li><li>通过 -d 参数在后台启动容器。</li><li>通过 exec -it 可进入容器并执行命令。</li></ul><p><strong>指定容器的三种方法：</strong></p><ul><li>短ID</li><li>长ID</li><li>容器名称，可通过 –name 为容器命名</li></ul><p><strong>容器按用途可分为两类：</strong></p><ul><li><p>服务类的容器</p></li><li><p>工具类的容器</p></li></ul><h2 id="常见的容器操作"><a href="#常见的容器操作" class="headerlink" title="常见的容器操作"></a>常见的容器操作</h2><blockquote><p>对容器的生命周期有了大致的理解，下面这张状态机很好地总结了容器各种状态之间是如何转换的。</p></blockquote><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/KLl95a" alt="docker状态转换图"></p><h3 id="create容器"><a href="#create容器" class="headerlink" title="create容器"></a>create容器</h3><p>可以先创建容器，稍后再启动。</p><pre><code>[root@docker ~]# docker create httpdUnable to find image &apos;httpd:latest&apos; locallylatest: Pulling from library/httpdf49cf87b52c1: Pull complete02ca099fb6cd: Pull completede7acb18da57: Pull complete770c8edb393d: Pull complete0e252730aeae: Pull complete6e6ca341873f: Pull complete2daffd0a6144: Pull completeDigest: sha256:fb6b4d40e0a2ab5beb7a40b440b012f49642b45163034c6eb36233b433e8e741Status: Downloaded newer image for httpd:latest910bb90c15f5bcd8976c9c43a882f49fcd781074e7999722b04f07b852f7d1d7[root@docker ~]# docker ps -a |grep httpd910bb90c15f5        httpd               &quot;httpd-foreground&quot;       4 minutes ago       Created                                 distracted_kirch</code></pre><h3 id="start容器"><a href="#start容器" class="headerlink" title="start容器"></a>start容器</h3><p>对于处于停止状态的容器，可以通过 docker start 重新启动。</p><pre><code>[root@docker ~]# docker ps -a |grep httpd910bb90c15f5        httpd               &quot;httpd-foreground&quot;       4 minutes ago       Created                                 distracted_kirch[root@docker ~]# docker start 910bb90c15f5910bb90c15f5[root@docker ~]# docker ps -a |grep httpd910bb90c15f5        httpd               &quot;httpd-foreground&quot;       6 minutes ago       Up 1 second         80/tcp              distracted_kirch</code></pre><h3 id="run容器"><a href="#run容器" class="headerlink" title="run容器"></a>run容器</h3><p>启动容器包括到容器的创建，然后启动容器两个步骤。<br>docker run = docker create + dokcer start</p><pre><code>[root@docker ~]# docker run -it busybox/ #</code></pre><h3 id="stop容器"><a href="#stop容器" class="headerlink" title="stop容器"></a>stop容器</h3><p>容器在 docker host 中实际上是一个进程，docker stop 命令本质上是向该进程发送一个 SIGTERM 信号。</p><pre><code>[root@docker ~]# docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMESf55bae074567        busybox             &quot;sh&quot;                     2 hours ago         Up 2 hours                              affectionate_ramanujan7b0dfb366bcb        ubuntu              &quot;/bin/bash -c &apos;while…&quot;   2 hours ago         Up 2 hours                              zealous_dubinskya141b831a16e        ubuntu              &quot;/bin/bash -c &apos;while…&quot;   2 hours ago         Up 2 hours                              ecstatic_pasteur[root@docker ~]# docker stop 7b0dfb366bcb7b0dfb366bcb[root@docker ~]# docker ps -aCONTAINER ID        IMAGE                                                                      COMMAND                  CREATED             STATUS                        PORTS               NAMESf55bae074567        busybox                                                                    &quot;sh&quot;                     2 hours ago         Up 2 hours                                        affectionate_ramanujan7b0dfb366bcb        ubuntu                                                                     &quot;/bin/bash -c &apos;while…&quot;   2 hours ago         Exited (137) 47 seconds ago</code></pre><h3 id="kill容器"><a href="#kill容器" class="headerlink" title="kill容器"></a>kill容器</h3><p>如果想快速停止容器，可使用 docker kill 命令，其作用是向容器进程发送 SIGKILL 信号。</p><pre><code>[root@docker ~]# docker ps -a |grep httpd910bb90c15f5        httpd               &quot;httpd-foreground&quot;       8 minutes ago       Up About a minute   80/tcp              distracted_kirch[root@docker ~]# docker kill  910bb90c15f5910bb90c15f5[root@docker ~]# docker ps -a |grep httpd910bb90c15f5        httpd               &quot;httpd-foreground&quot;       8 minutes ago       Exited (137) 5 seconds ago                       distracted_kirch</code></pre><h3 id="pause-容器"><a href="#pause-容器" class="headerlink" title="pause 容器"></a>pause 容器</h3><p>有时我们只是希望暂时让容器暂停工作一段时间，比如要对容器的文件系统打个快照，或者 dcoker host 需要使用 CPU，这时可以执行 docker pause。</p><pre><code>[root@docker ~]# docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMESf55bae074567        busybox             &quot;sh&quot;                     2 hours ago         Up 2 hours                              affectionate_ramanujan7b0dfb366bcb        ubuntu              &quot;/bin/bash -c &apos;while…&quot;   2 hours ago         Up 2 minutes                            zealous_dubinskya141b831a16e        ubuntu              &quot;/bin/bash -c &apos;while…&quot;   2 hours ago         Up 2 hours                              ecstatic_pasteur[root@docker ~]# docker pause f55bae074567f55bae074567[root@docker ~]# docker ps -a |grep f55bae074567f55bae074567        busybox                                                                    &quot;sh&quot;                     2 hours ago         Up 2 hours (Paused)                            affectionate_ramanujan</code></pre><h3 id="unpause容器"><a href="#unpause容器" class="headerlink" title="unpause容器"></a>unpause容器</h3><p>处于暂停状态的容器不会占用 CPU 资源，直到通过 docker unpause 恢复运行。</p><pre><code>[root@docker ~]# docker unpause f55bae074567f55bae074567[root@docker ~]# docker ps -a |grep f55bae074567f55bae074567        busybox                                                                    &quot;sh&quot;                     2 hours ago         Up 2 hours                                     affectionate_ramanujan</code></pre><h3 id="rm容器"><a href="#rm容器" class="headerlink" title="rm容器"></a>rm容器</h3><p>使用 docker 一段时间后，host 上可能会有大量已经退出了的容器，这些容器依然会占用 host 的文件系统资源，如果确认不会再重启此类容器，可以通过 docker rm 删除。</p><pre><code>[root@docker ~]# docker ps -a |grep &apos;Exited&apos;e12b964641c4        ubuntu                                                                     &quot;pwd&quot;                    3 hours ago         Exited (0) 3 hours ago                         modest_johnson97eb5d978d46        ubuntu                                                                     &quot;ls&quot;                     3 hours ago         Exited (0) 3 hours ago</code></pre><p>docker rm 一次可以指定多个容器，如果希望批量删除所有已经退出的容器，可以执行如下命令：</p><p><code>docker rm -v $(docker ps -aq -f status=exited)</code></p><pre><code>[root@docker ~]# docker rm -v $(docker ps -aq -f status=exited)e12b964641c497eb5d978d462f5aa14aaa655fb431cd6d5b81fede2842bf28933756a14ab6df60142950[root@docker ~]# docker ps -a |grep &apos;Exited&apos;[root@docker ~]#</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;运行容器&quot;&gt;&lt;a href=&quot;#运行容器&quot; class=&quot;headerlink&quot; title=&quot;运行容器&quot;&gt;&lt;/a&gt;运行容器&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;docker run 是启动容器的方法。通过前面的Dockerfile 时我们已经学习到，可用三种方式指定容器启动时执行的命令。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;容器运行执行的命令&quot;&gt;&lt;a href=&quot;#容器运行执行的命令&quot; class=&quot;headerlink&quot; title=&quot;容器运行执行的命令&quot;&gt;&lt;/a&gt;容器运行执行的命令&lt;/h3&gt;&lt;p&gt;通过下面三种方式，我们来执行运行在容器中的命令。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CMD 指令&lt;/li&gt;
&lt;li&gt;ENDPOINT 指令&lt;/li&gt;
&lt;li&gt;在 docker run 命令行中指定&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;运行一个容器示例&quot;&gt;&lt;a href=&quot;#运行一个容器示例&quot; class=&quot;headerlink&quot; title=&quot;运行一个容器示例&quot;&gt;&lt;/a&gt;运行一个容器示例&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;[root@docker ~]# docker run ubuntu pwd
/
[root@docker ~]# docker ps -a
CONTAINER ID        IMAGE                                                                      COMMAND                  CREATED              STATUS                          PORTS               NAMES
e12b964641c4        ubuntu                                                                     &amp;quot;pwd&amp;quot;                    32 seconds ago       Exited (0) 31 seconds ago                           modest_johnson
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;  此处我们运行一个ubuntu镜像,并运行pwd命令后,容器便退出了,状态为Exited。这种“一闪而过”的容器通常不是我们想要的结果，我们希望容器能够保持 runing 状态，这样才能被我们使用。&lt;/p&gt;
&lt;h3 id=&quot;让容器长久的运行&quot;&gt;&lt;a href=&quot;#让容器长久的运行&quot; class=&quot;headerlink&quot; title=&quot;让容器长久的运行&quot;&gt;&lt;/a&gt;让容器长久的运行&lt;/h3&gt;&lt;p&gt;因为容器的生命周期依赖于启动时执行的命令，只要该命令不结束，容器也就不会退出。理解了这个原理，我们就可以通过执行一个长期运行的命令来保持容器的运行状态。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@docker ~]# docker run ubuntu /bin/bash -c &amp;quot;while true;do sleep 1;done&amp;quot;
[root@docker ~]# docker ps -a
CONTAINER ID        IMAGE                                                                      COMMAND                  CREATED             STATUS                     PORTS               NAMES
d36bbcefec6b        ubuntu                                                                     &amp;quot;/bin/bash -c &amp;apos;while…&amp;quot;   50 seconds ago      Up 49 seconds                                  eager_lumiere
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面利用执行循环命令，让命令一直执行，容器自然就不会退出(Exited)状态,而是一直运行(Up)状态。但这样终端会被一直占用。可以利用加上参数-d 以后台方式运行容器。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@docker ~]# docker stop d36bbcefec6b
d36bbcefec6b
[root@docker ~]# docker rm d36bbcefec6b
d36bbcefec6b
[root@docker ~]# docker run -d ubuntu /bin/bash -c &amp;quot;while true;do sleep 1;done&amp;quot;
a141b831a16edbb94ab41553e2be2af79e2d5b68f25877db40750c49cc991649

[root@docker ~]# docker ps -a
CONTAINER ID        IMAGE                                                                      COMMAND                  CREATED             STATUS                      PORTS               NAMES
a141b831a16e        ubuntu
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;说明事项：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CONTAINER ID 是容器的 “短ID”，前面启动容器时返回的是 “长ID”。短ID是长ID的前12个字符。&lt;/li&gt;
&lt;li&gt;NAMES 字段显示容器的名字，在启动容器时可以通过 –name 参数显示地为容器命名，如果不指定，docker 会自动为容器分配名字。&lt;/li&gt;
&lt;li&gt;我们可以利用docker stop CONTAINER ID 停止正在运行的容器，并使用docker rm CONTAINER ID 删除停止的容器;docker run -d COMMAND 以后台的方式运行容器。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Docker系列" scheme="http://www.chenfanlinux.org/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Docker" scheme="http://www.chenfanlinux.org/tags/Docker/"/>
    
  </entry>
  
</feed>
