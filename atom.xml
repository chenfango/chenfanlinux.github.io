<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陈凡的个人站点</title>
  
  <subtitle>chenfanlinux.org</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.chenfanlinux.org/"/>
  <updated>2018-04-13T02:41:57.000Z</updated>
  <id>http://www.chenfanlinux.org/</id>
  
  <author>
    <name>陈凡</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python时间处理模块</title>
    <link href="http://www.chenfanlinux.org/2018/04/13/python%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E6%A8%A1%E5%9D%97/"/>
    <id>http://www.chenfanlinux.org/2018/04/13/python时间处理模块/</id>
    <published>2018-04-13T02:37:38.000Z</published>
    <updated>2018-04-13T02:41:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文注意讲解datetime模块，注意到datetime是模块，datetime模块还包含一个datetime类，通过from datetime import datetime导入的才是datetime这个类。<br>如果仅导入import datetime，则必须引用全名datetime.datetime。<br>datetime.now()返回当前日期和时间，其类型是datetime。</p></blockquote><p>参考文档：<a href="https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior" target="_blank" rel="noopener">datetime</a></p><h3 id="获取当前日期和时间"><a href="#获取当前日期和时间" class="headerlink" title="获取当前日期和时间"></a>获取当前日期和时间</h3><pre><code>&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; now = datetime.now() # 获取当前datetime&gt;&gt;&gt; print(now)2018-04-12 18:30:31.311945&gt;&gt;&gt; print(type(now))&lt;class &apos;datetime.datetime&apos;&gt;</code></pre><h3 id="获取指定日期和时间"><a href="#获取指定日期和时间" class="headerlink" title="获取指定日期和时间"></a>获取指定日期和时间</h3><p>要指定某个日期和时间，我们直接用参数构造一个datetime</p><pre><code>&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; dt = datetime(2018,4,12,18,32)  # 用指定日期时间创建datetime&gt;&gt;&gt; print(dt)2018-04-12 18:32:00</code></pre><h3 id="datetime转换为timestamp"><a href="#datetime转换为timestamp" class="headerlink" title="datetime转换为timestamp"></a>datetime转换为timestamp</h3><p>timestamp的值与时区毫无关系，因为timestamp一旦确定，其UTC时间就确定了，转换到任意时区的时间也是完全确定的，这就是为什么计算机存储的当前时间是以timestamp表示的，因为全球各地的计算机在任意时刻的timestamp都是完全相同的（假定时间已校准）。</p><pre><code>&gt;&gt;&gt; dt = datetime(2018,4,12,18,40)&gt;&gt;&gt; dt.timestamp()1523529600.0</code></pre><a id="more"></a><h3 id="timestamp转换为datetime"><a href="#timestamp转换为datetime" class="headerlink" title="timestamp转换为datetime"></a>timestamp转换为datetime</h3><p>要把timestamp转换为datetime，使用datetime提供的fromtimestamp()方法</p><pre><code>&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; t = 1523529600.0&gt;&gt;&gt; print(datetime.fromtimestamp(t))2018-04-12 18:40:00</code></pre><p>注意到timestamp是一个浮点数，它没有时区的概念，而datetime是有时区的。上述转换是在timestamp和本地时间做转换。</p><p>本地时间是指当前操作系统设定的时区。例如北京时区是东8区，则本地时间：</p><pre><code>2018-04-12 18:40:00</code></pre><p>实际上就是UTC+8:00时区的时间：</p><pre><code>2015-04-19 12:20:00 UTC+8:00</code></pre><p>而此刻的格林威治标准时间与北京时间差了8小时，也就是UTC+0:00时区的时间应该是：</p><pre><code>2015-04-19 4:20:00 UTC+0:00</code></pre><p>timestamp也可以直接被转换到UTC标准时区的时间：</p><pre><code>&gt;&gt;&gt; t = 1523529600.0&gt;&gt;&gt; print(datetime.fromtimestamp(t))2018-04-12 18:40:00&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; t = 1523529600.0   # 本地时间&gt;&gt;&gt; print(datetime.fromtimestamp(t))2018-04-12 18:40:00  # UTC时间&gt;&gt;&gt; print(datetime.utcfromtimestamp(t))2018-04-12 10:40:00</code></pre><h3 id="str转换为datetime"><a href="#str转换为datetime" class="headerlink" title="str转换为datetime"></a>str转换为datetime</h3><p>很多时候要处理日期和时间字符串，首先必须把str转换为datetime。转换方法是通过datetime.strptime()实现，需要一个日期和时间的格式化字符串：</p><pre><code>&gt;&gt;&gt; cday = datetime.strptime(&apos;2018-4-13 10:10:10&apos;,&apos;%Y-%m-%d %H:%M:%S&apos;)&gt;&gt;&gt; print(type(cday))&lt;class &apos;datetime.datetime&apos;&gt;&gt;&gt;&gt; print(cday)2018-04-13 10:10:10</code></pre><p>字符串’%Y-%m-%d %H:%M:%S’规定了日期和时间部分的格式。详细的说明请参考<a href="https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior" target="_blank" rel="noopener">官方文档</a></p><h3 id="datetime转换为str"><a href="#datetime转换为str" class="headerlink" title="datetime转换为str"></a>datetime转换为str</h3><p>如果已经有了datetime对象，要把它格式化为字符串显示给用户，就需要转换为str，转换方法是通过strftime()实现的，同样需要一个日期和时间的格式化字符串。</p><pre><code>&gt;&gt;&gt; now = datetime.now()&gt;&gt;&gt; print(now.strftime(&apos;%a %b %d %H:%M&apos;))Fri Apr 13 10:16</code></pre><h3 id="datetime加减"><a href="#datetime加减" class="headerlink" title="datetime加减"></a>datetime加减</h3><p>对日期和时间进行加减实际上就是把datetime往后或往前计算，得到新的datetime。加减可以直接用+和-运算符，不过需要导入timedelta这个类。</p><pre><code>&gt;&gt;&gt; from datetime import datetime, timedelta&gt;&gt;&gt; now = datetime.now()&gt;&gt;&gt; nowdatetime.datetime(2018, 4, 13, 10, 20, 33, 99527)&gt;&gt;&gt; now + timedelta(hours=10)datetime.datetime(2018, 4, 13, 20, 20, 33, 99527)&gt;&gt;&gt; now + timedelta(days=1)datetime.datetime(2018, 4, 14, 10, 20, 33, 99527)&gt;&gt;&gt; now + timedelta(days=1,hours=12)datetime.datetime(2018, 4, 14, 22, 20, 33, 99527)</code></pre><h3 id="本地时间转换为UTC时间"><a href="#本地时间转换为UTC时间" class="headerlink" title="本地时间转换为UTC时间"></a>本地时间转换为UTC时间</h3><p>本地时间是指系统设定时区的时间，例如北京时间是UTC+8:00时区的时间，而UTC时间指UTC+0:00时区的时间。一个datetime类型有一个时区属性tzinfo，但是默认为None，所以无法区分这个datetime到底是哪个时区，除非强行给datetime设置一个时区。</p><pre><code>&gt;&gt;&gt; from datetime import datetime, timedelta, timezone&gt;&gt;&gt; tz_utc_8 = timezone(timedelta(hours=8))&gt;&gt;&gt; now = datetime.now()&gt;&gt;&gt; nowdatetime.datetime(2018, 4, 13, 10, 24, 41, 639742)&gt;&gt;&gt; dt = now.replace(tzinfo=tz_utc_8)&gt;&gt;&gt; dtdatetime.datetime(2018, 4, 13, 10, 24, 41, 639742, tzinfo=datetime.timezone(datetime.timedelta(0, 28800)))&gt;&gt;&gt; dtdatetime.datetime(2018, 4, 13, 10, 24, 41, 639742, tzinfo=datetime.timezone(datetime.timedelta(0, 28800)))</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文注意讲解datetime模块，注意到datetime是模块，datetime模块还包含一个datetime类，通过from datetime import datetime导入的才是datetime这个类。&lt;br&gt;如果仅导入import datetime，则必须引用全名datetime.datetime。&lt;br&gt;datetime.now()返回当前日期和时间，其类型是datetime。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考文档：&lt;a href=&quot;https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;datetime&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;获取当前日期和时间&quot;&gt;&lt;a href=&quot;#获取当前日期和时间&quot; class=&quot;headerlink&quot; title=&quot;获取当前日期和时间&quot;&gt;&lt;/a&gt;获取当前日期和时间&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from datetime import datetime
&amp;gt;&amp;gt;&amp;gt; now = datetime.now() # 获取当前datetime
&amp;gt;&amp;gt;&amp;gt; print(now)
2018-04-12 18:30:31.311945
&amp;gt;&amp;gt;&amp;gt; print(type(now))
&amp;lt;class &amp;apos;datetime.datetime&amp;apos;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;获取指定日期和时间&quot;&gt;&lt;a href=&quot;#获取指定日期和时间&quot; class=&quot;headerlink&quot; title=&quot;获取指定日期和时间&quot;&gt;&lt;/a&gt;获取指定日期和时间&lt;/h3&gt;&lt;p&gt;要指定某个日期和时间，我们直接用参数构造一个datetime&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from datetime import datetime
&amp;gt;&amp;gt;&amp;gt; dt = datetime(2018,4,12,18,32)  # 用指定日期时间创建datetime
&amp;gt;&amp;gt;&amp;gt; print(dt)
2018-04-12 18:32:00
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;datetime转换为timestamp&quot;&gt;&lt;a href=&quot;#datetime转换为timestamp&quot; class=&quot;headerlink&quot; title=&quot;datetime转换为timestamp&quot;&gt;&lt;/a&gt;datetime转换为timestamp&lt;/h3&gt;&lt;p&gt;timestamp的值与时区毫无关系，因为timestamp一旦确定，其UTC时间就确定了，转换到任意时区的时间也是完全确定的，这就是为什么计算机存储的当前时间是以timestamp表示的，因为全球各地的计算机在任意时刻的timestamp都是完全相同的（假定时间已校准）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; dt = datetime(2018,4,12,18,40)
&amp;gt;&amp;gt;&amp;gt; dt.timestamp()
1523529600.0
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="python基础知识" scheme="http://www.chenfanlinux.org/categories/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="python模块" scheme="http://www.chenfanlinux.org/tags/python%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>python版本管理工具-pyenv</title>
    <link href="http://www.chenfanlinux.org/2018/04/11/python%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-pyenv/"/>
    <id>http://www.chenfanlinux.org/2018/04/11/python版本管理工具-pyenv/</id>
    <published>2018-04-11T03:35:24.000Z</published>
    <updated>2018-04-11T03:42:13.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Python版本管理工具<a href="https://github.com/pyenv/pyenv" target="_blank" rel="noopener">pyenv</a>，pyenv让你轻松切换多个版本的Python。它很简单，不引人注意，并且遵循UNIX的单一目的工具的传统，可以很好地完成一件事。</p></blockquote><p>相关地址：</p><ul><li>pyenv github地址: <a href="http://github.com/yyuu/pyenv" target="_blank" rel="noopener">http://github.com/yyuu/pyenv</a></li><li>pyenv 安装器: <a href="https://github.com/pyenv/pyenv-installer" target="_blank" rel="noopener">https://github.com/pyenv/pyenv-installer</a></li></ul><h2 id="安装pyenv"><a href="#安装pyenv" class="headerlink" title="安装pyenv"></a>安装pyenv</h2><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><pre><code>$ yum -y install  git</code></pre><a id="more"></a><h3 id="安装pyenv-1"><a href="#安装pyenv-1" class="headerlink" title="安装pyenv"></a>安装pyenv</h3><pre><code>$ curl -L https://github.com/pyenv/pyenv-installer/raw/master/bin/pyenv-installer | bash</code></pre><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><pre><code>$ vim /etc/profile.d/pyenv.shexport PATH=&quot;/root/.pyenv/bin:$PATH&quot;eval &quot;$(pyenv init -)&quot;eval &quot;$(pyenv virtualenv-init -)&quot;$ source /etc/profile</code></pre><h2 id="安装python"><a href="#安装python" class="headerlink" title="安装python"></a>安装python</h2><h3 id="安装编译工具"><a href="#安装编译工具" class="headerlink" title="安装编译工具"></a>安装编译工具</h3><pre><code>$ yum install -y   gcc make patch</code></pre><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><pre><code>$ yum install -y  gdbm-devel openssl-devel sqlite-devel zlib-devel bzip2-devel readline-devel</code></pre><h3 id="安装python-3-5-2"><a href="#安装python-3-5-2" class="headerlink" title="安装python 3.5.2"></a>安装python 3.5.2</h3><pre><code>$ pyenv install 3.5.2 # 这种方式会下载官方源，可能会比较慢$ mkdir   ~/.pyenv/cache/ # 解决下载慢的问题:将包放在cache路径(~/.pyenv/cache/)下</code></pre><h2 id="使用pyenv"><a href="#使用pyenv" class="headerlink" title="使用pyenv"></a>使用pyenv</h2><h3 id="local命令"><a href="#local命令" class="headerlink" title="local命令"></a>local命令</h3><p>local命令切换当前目录及其子目录的python版本, 可以通过删除.python-verson恢复默认的python版本</p><h3 id="global命令"><a href="#global命令" class="headerlink" title="global命令"></a>global命令</h3><p>global命名切换全局默认的Python版本,永远不要使用!!</p><h3 id="virtualenv命令"><a href="#virtualenv命令" class="headerlink" title="virtualenv命令"></a>virtualenv命令</h3><pre><code>$ pyenv virtualenv 3.5.2 chenfanlinux # 创建虚拟环境$ pyenv versions # 查看python版本 * system (set by /root/.pyenv/version)  3.5.2  3.5.2/envs/chenfanlinux  chenfanlinux$ pyenv local chenfanlinux # 切换环境</code></pre><h3 id="uninstall命令"><a href="#uninstall命令" class="headerlink" title="uninstall命令"></a>uninstall命令</h3><pre><code>$ pyenv uninstall chenfanlinux # 卸载某个版本(包括虚拟环境)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Python版本管理工具&lt;a href=&quot;https://github.com/pyenv/pyenv&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pyenv&lt;/a&gt;，pyenv让你轻松切换多个版本的Python。它很简单，不引人注意，并且遵循UNIX的单一目的工具的传统，可以很好地完成一件事。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;相关地址：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pyenv github地址: &lt;a href=&quot;http://github.com/yyuu/pyenv&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://github.com/yyuu/pyenv&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;pyenv 安装器: &lt;a href=&quot;https://github.com/pyenv/pyenv-installer&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/pyenv/pyenv-installer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;安装pyenv&quot;&gt;&lt;a href=&quot;#安装pyenv&quot; class=&quot;headerlink&quot; title=&quot;安装pyenv&quot;&gt;&lt;/a&gt;安装pyenv&lt;/h2&gt;&lt;h3 id=&quot;安装git&quot;&gt;&lt;a href=&quot;#安装git&quot; class=&quot;headerlink&quot; title=&quot;安装git&quot;&gt;&lt;/a&gt;安装git&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;$ yum -y install  git
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="python基础知识" scheme="http://www.chenfanlinux.org/categories/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="pyenv" scheme="http://www.chenfanlinux.org/tags/pyenv/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes-1.9.1-HA生产环境实践</title>
    <link href="http://www.chenfanlinux.org/2018/04/06/Kubernetes-1-9-1-HA%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%AE%9E%E8%B7%B5/"/>
    <id>http://www.chenfanlinux.org/2018/04/06/Kubernetes-1-9-1-HA生产环境实践/</id>
    <published>2018-04-06T05:41:21.000Z</published>
    <updated>2018-04-08T08:20:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="集群环境说明"><a href="#集群环境说明" class="headerlink" title="集群环境说明"></a>集群环境说明</h2><h3 id="服务器信息"><a href="#服务器信息" class="headerlink" title="服务器信息"></a>服务器信息</h3><p>这里配置2Master 2个node, k8s-master01只做 Master, k8s-node01即是Master也是Node, k8s-node02单纯做Node。</p><p><img src="https://s1.ax1x.com/2018/04/02/9z62xH.png" alt="服务器信息"></p><h3 id="集群详情"><a href="#集群详情" class="headerlink" title="集群详情"></a>集群详情</h3><ul><li>Kubernetes 1.9.1</li><li>Docker-17.03.1-ce</li><li>Etcd-v3.2.14</li><li>Flanneld-v0.10.0 vxlan</li><li>TLS 认证通信</li><li>RBAC 授权</li><li>Kublet TLS BootStrapping</li><li>Coredns:1.0.4</li><li>Registry-2.6</li></ul><a id="more"></a><h3 id="网络环境说明"><a href="#网络环境说明" class="headerlink" title="网络环境说明"></a>网络环境说明</h3><ul><li>服务器网络（10.173.36.214/21）</li><li>Clutser网络（10.253.0.0/16)</li><li>Flannel网络（10.254.0.0/16）</li></ul><h3 id="集群拓扑图"><a href="#集群拓扑图" class="headerlink" title="集群拓扑图"></a>集群拓扑图</h3><p><img src="https://s1.ax1x.com/2018/04/03/CpAs9s.png" alt="集群拓扑图"></p><h2 id="集群环境初始化"><a href="#集群环境初始化" class="headerlink" title="集群环境初始化"></a>集群环境初始化</h2><table><tr><td bgcolor="#008000"> master和node </td></tr></table><h3 id="设置主机名-永久生效）"><a href="#设置主机名-永久生效）" class="headerlink" title="设置主机名(永久生效）"></a>设置主机名(永久生效）</h3><pre><code>$ hostnamectl --static set-hostname k8s-master01$ hostnamectl --static set-hostname k8s-node01$ hostnamectl --static set-hostname k8s-node02</code></pre><h3 id="配置epel7-yum源"><a href="#配置epel7-yum源" class="headerlink" title="配置epel7 yum源"></a>配置epel7 yum源</h3><pre><code>$ yum install  epel-release</code></pre><h3 id="配置ntp时间同步"><a href="#配置ntp时间同步" class="headerlink" title="配置ntp时间同步"></a>配置ntp时间同步</h3><pre><code>$ yum -y install ntp$ vim /etc/ntp.confserver time.pool.aliyun.com        # 向阿里云的ntp服务器进行校准$ systemctl start ntpd$ systemctl enable ntpd</code></pre><h3 id="配置密钥对"><a href="#配置密钥对" class="headerlink" title="配置密钥对"></a>配置密钥对</h3><pre><code>$ ssh-keygen -t rsa -P &quot;&quot; -f /root/.ssh/id_rsa #  把生成的公钥拷贝到其他节点的 authorized_keys 即可</code></pre><h3 id="修改-etc-hosts"><a href="#修改-etc-hosts" class="headerlink" title="修改/etc/hosts"></a>修改/etc/hosts</h3><pre><code>$ vim /etc/hosts 10.173.36.214 k8s-master01 10.173.36.215 k8s-node02 10.173.36.216 k8s-node01$ scp /etc/hosts root@10.173.36.216:/etc$ scp /etc/hosts root@10.173.36.215:/etc</code></pre><h3 id="打开路由转发"><a href="#打开路由转发" class="headerlink" title="打开路由转发"></a>打开路由转发</h3><pre><code>$ echo &quot;net.ipv4.ip_forward = 1&quot; &gt;&gt;/etc/sysctl.conf$ sysctl -p</code></pre><h3 id="关闭NetworkManager"><a href="#关闭NetworkManager" class="headerlink" title="关闭NetworkManager"></a>关闭NetworkManager</h3><pre><code>$ systemctl stop NetworkManager$ systemctl disable NetworkManager # 此服务会接管nameserver,导致修改不成功</code></pre><p><strong><em>这是网易云平台特有的配置，其他云平台可以忽略！</em></strong></p><h3 id="关闭-firewall"><a href="#关闭-firewall" class="headerlink" title="关闭 firewall"></a>关闭 firewall</h3><pre><code>$ systemctl stop firewalld$ systemctl disable firewalld</code></pre><h2 id="安装并配置Docker"><a href="#安装并配置Docker" class="headerlink" title="安装并配置Docker"></a>安装并配置Docker</h2><table><tr><td bgcolor="#008000"> master和node </td></tr></table><h3 id="安装yum管理工具并添加Docker官方源"><a href="#安装yum管理工具并添加Docker官方源" class="headerlink" title="安装yum管理工具并添加Docker官方源"></a>安装yum管理工具并添加Docker官方源</h3><pre><code>$ yum install -y yum-utils$ yum-config-manager  --add-repo  https://download.docker.com/linux/centos/docker-ce.repo$ yum makecache</code></pre><h3 id="查看yum版本"><a href="#查看yum版本" class="headerlink" title="查看yum版本"></a>查看yum版本</h3><pre><code>$ yum list docker-ce.x86_64  --showduplicates |sort -r</code></pre><h3 id="安装docker-ce的依赖-docker-ce-selinux"><a href="#安装docker-ce的依赖-docker-ce-selinux" class="headerlink" title="安装docker-ce的依赖 docker-ce-selinux"></a>安装docker-ce的依赖 docker-ce-selinux</h3><p>安装这个docker-ce-selinux，需要保持selinux的enforcing状态，安装完记得关闭。</p><pre><code>$ wget https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-selinux-17.03.1.ce-1.el7.centos.noarch.rpm$ rpm -ivh docker-ce-selinux-17.03.1.ce-1.el7.centos.noarch.rpm</code></pre><h3 id="关闭开启的selinux，并安装docker-ce-17-03-1-ce"><a href="#关闭开启的selinux，并安装docker-ce-17-03-1-ce" class="headerlink" title="关闭开启的selinux，并安装docker-ce-17.03.1.ce"></a>关闭开启的selinux，并安装docker-ce-17.03.1.ce</h3><pre><code>$ yum -y install docker-ce-17.03.1.ce$ docker version   # 查看docker版本信息</code></pre><h3 id="Docker使用overlay2"><a href="#Docker使用overlay2" class="headerlink" title="Docker使用overlay2"></a>Docker使用overlay2</h3><pre><code>$ lsmod |grep overlay   # 检查overlay是否存在$ modprobe overlay     #  加载overlay模块$ mkdir /etc/docker$ vi /etc/docker/daemon.json  # 修改存储引擎为overlay{  &quot;storage-driver&quot;: &quot;overlay2&quot;,  &quot;storage-opts&quot;: [    &quot;overlay2.override_kernel_check=true&quot;  ]}$ systemctl start docker$ docker info # 查看docker使用的引擎</code></pre><h3 id="增加docker-配置"><a href="#增加docker-配置" class="headerlink" title="增加docker 配置"></a>增加docker 配置</h3><pre><code>$ vim  /etc/systemd/system/docker.service[Unit]Description=Docker Application Container EngineDocumentation=http://docs.docker.comAfter=network.target docker-storage-setup.serviceWants=docker-storage-setup.service[Service]Type=notifyEnvironment=GOTRACEBACK=crashExecReload=/bin/kill -s HUP $MAINPIDDelegate=yesKillMode=processExecStart=/usr/bin/dockerd \          $DOCKER_OPTS \          $DOCKER_STORAGE_OPTIONS \          $DOCKER_NETWORK_OPTIONS \          $DOCKER_DNS_OPTIONS \          $INSECURE_REGISTRYLimitNOFILE=1048576LimitNPROC=1048576LimitCORE=infinityTimeoutStartSec=1minRestart=on-abnormal[Install]WantedBy=multi-user.target$ mkdir -p /etc/systemd/system/docker.service.d   # 后续还需要增加的配置放置目录$ vi /etc/systemd/system/docker.service.d/docker-dns.conf  # 增加docker的dns配置,后续配置好dns再增加$ vi /etc/systemd/system/docker.service.d/docker-options.conf  # 后续再这个配置文件中加入私有仓库信息配置[Service]Environment=&quot;DOCKER_OPTS=  --graph=/opt/docker --log-opt max-size=50m --log-opt max-file=5&quot;</code></pre><h3 id="重新读取配置，启动-docker"><a href="#重新读取配置，启动-docker" class="headerlink" title="重新读取配置，启动 docker"></a>重新读取配置，启动 docker</h3><pre><code>$ systemctl daemon-reload$ systemctl start docker$ systemctl enable docker$ journalctl -f -t docker  和 journalctl -u docker # 定位问题日志</code></pre><h2 id="安装私有仓库-Registry"><a href="#安装私有仓库-Registry" class="headerlink" title="安装私有仓库 Registry"></a>安装私有仓库 Registry</h2><table><tr><td bgcolor="#008000"> master </td></tr></table><h3 id="运行Registry容器"><a href="#运行Registry容器" class="headerlink" title="运行Registry容器"></a>运行Registry容器</h3><pre><code>$ mkdir -p /opt/docker-data/repos     # 创建registry的挂载目录$ docker run -d -p 8001:5000 --restart=always --privileged --name registry -v /opt/docker-data/repos:/var/lib/registry registry:2.6    # 运行registry最新容器</code></pre><p><strong>参数说明：</strong></p><ul><li>-d表示守护进程，-p表示本地的8001端口映射到容器的5000端口， restart表示容器挂了是否自启， -v表示本地的目录映射到容器的目录</li><li>–privileged 使用该参数，container内的root拥有真正的root权限。否则container内的root只是外部的一个普通用户权限。privileged启动的容器，可以看到很多host上的设备，并且可以执行mount。甚至允许你在docker容器中启动docker容器。</li></ul><h3 id="测试可用性"><a href="#测试可用性" class="headerlink" title="测试可用性"></a>测试可用性</h3><pre><code>$ docker pull  index.tenxcloud.com/google_containers/pause:3.0  # 拉取一个镜像做测试$ docker tag index.tenxcloud.com/google_containers/pause:3.0  k8s-master01:8001/google_containers/pause:3.0  # 改为本地镜像的存储名(镜像仓库地址:/项目地址/镜像名:版本号)$ docker push k8s-master01:8001/google_containers/pause:3.0 # 推送到本地镜像仓库</code></pre><h3 id="master和node-都需要修改的docker关于registry的配置"><a href="#master和node-都需要修改的docker关于registry的配置" class="headerlink" title="master和node 都需要修改的docker关于registry的配置"></a>master和node 都需要修改的docker关于registry的配置</h3><pre><code>$ vi /etc/systemd/system/docker.service.d/docker-options.conf  # 增加私有仓库地址的配置[Service]Environment=&quot;DOCKER_OPTS=--insecure-registry=k8s-master01:8001 \--graph=/opt/docker --log-opt max-size=50m --log-opt max-file=5&quot;$ systemctl daemon-reload   # 重启加载配置$ systemctl restart docker$ k8s-master01:8001/google_containers/pause:3.0    # node 节点测试一下是否可以拉取镜像</code></pre><h2 id="安装cfssl并创建CA"><a href="#安装cfssl并创建CA" class="headerlink" title="安装cfssl并创建CA"></a>安装cfssl并创建CA</h2><table><tr><td bgcolor="#008000"> master </td></tr></table><h3 id="安装-cfssl"><a href="#安装-cfssl" class="headerlink" title="安装 cfssl"></a>安装 cfssl</h3><pre><code>$ mkdir /opt/tools/cfssl -p$ cd /opt/tools/cfssl$ wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64$ wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64$ wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64$ mv cfssl_linux-amd64 cfssl$ mv cfssljson_linux-amd64 cfssljson$ mv cfssl-certinfo_linux-amd64 cfssl-certinfo$ chmod +x *$ mv cfssl/* /usr/local/bin</code></pre><h3 id="创建-CA-证书配置"><a href="#创建-CA-证书配置" class="headerlink" title="创建 CA 证书配置"></a>创建 CA 证书配置</h3><pre><code>$ mkdir /opt/ssl$ cd /opt/ssl$  vi csr.json{  &quot;CN&quot;: &quot;kubernetes&quot;,  &quot;key&quot;: {    &quot;algo&quot;: &quot;rsa&quot;,    &quot;size&quot;: 2048  },  &quot;names&quot;: [    {      &quot;C&quot;: &quot;CN&quot;,      &quot;ST&quot;: &quot;GuangZhou&quot;,      &quot;L&quot;: &quot;GuangZhou&quot;,      &quot;O&quot;: &quot;k8s&quot;,      &quot;OU&quot;: &quot;System&quot;    }  ],  &quot;ca&quot;: {      &quot;expiry&quot;: &quot;262880h&quot;  }}</code></pre><p><strong><em>这里的CA证书期限很多教程都是一个炕，应该如上配置才是正确的，不然都是5年期限！</em></strong></p><h3 id="生成-CA-证书和私钥"><a href="#生成-CA-证书和私钥" class="headerlink" title="生成 CA 证书和私钥"></a>生成 CA 证书和私钥</h3><pre><code>$ cd /opt/ssl/$ cfssl  gencert -initca csr.json | cfssljson -bare ca$ ls -lca.csr          # 证书请求文件ca-key.pem  # ca私钥ca.pem    # ca证书csr.jsonconfig.json</code></pre><p><strong><em>注意： 将会生成 ca-key.pem，ca.csr，ca.pem 这三个文件，请务必保证 ca-key.pem 文件的安全，</em>.csr 文件在整个过程中不会使用。*</strong></p><h3 id="分发证书"><a href="#分发证书" class="headerlink" title="分发证书"></a>分发证书</h3><table><tr><td bgcolor="#008000"> master和node </td></tr></table><pre><code>$ mkdir -p /etc/kubernetes/ssl  # 创建证书目录$ cp *.pem /etc/kubernetes/ssl  # 拷贝所有文件到目录下$ cp ca.csr /etc/kubernetes/ssl$  ls /etc/kubernetes/sslca.csr  ca-key.pem  ca.pem$ scp -a /etc/kubernetes/ssl/*  root@k8s-node01: /etc/kubernetes/ssl$ scp -a /etc/kubernetes/ssl/*  root@k8s-node02: /etc/kubernetes/ssl</code></pre><h2 id="etcd-集群"><a href="#etcd-集群" class="headerlink" title="etcd 集群"></a>etcd 集群</h2><blockquote><p>etcd是k8s非常重要的组件，因此这里采用etcd集群，三个节点都安装etcd，etcd开选举模式。</p></blockquote><h3 id="安装-etcd"><a href="#安装-etcd" class="headerlink" title="安装 etcd"></a>安装 etcd</h3><pre><code>$ cd /opt/tools$ wget https://github.com/coreos/etcd/releases/download/v3.2.14/etcd-v3.2.14-linux-amd64.tar.gz$ tar zxvf etcd-v3.2.14-linux-amd64.tar.gz$ cd etcd-v3.2.14-linux-amd64$ mv etcd  etcdctl /usr/bin/$ scp /usr/bin/etcd*  root@k8s-node01:/usr/bin/$ scp /usr/bin/etcd* root@k8s-node02:/usr/bin/</code></pre><h3 id="创建-etcd-证书"><a href="#创建-etcd-证书" class="headerlink" title="创建 etcd 证书"></a>创建 etcd 证书</h3><pre><code>$ cd /opt/ssl/$ vi etcd-csr.json  # 创建etcd的证书请求配置{  &quot;CN&quot;: &quot;etcd&quot;,  &quot;hosts&quot;: [    &quot;127.0.0.1&quot;,    &quot;10.173.36.214&quot;,    &quot;10.173.36.215&quot;,    &quot;10.173.36.216&quot;  ],  &quot;key&quot;: {    &quot;algo&quot;: &quot;rsa&quot;,    &quot;size&quot;: 2048  },  &quot;names&quot;: [    {      &quot;C&quot;: &quot;CN&quot;,      &quot;ST&quot;: &quot;GuangZhou&quot;,      &quot;L&quot;: &quot;GuangZhou&quot;,      &quot;O&quot;: &quot;k8s&quot;,      &quot;OU&quot;: &quot;System&quot;    }  ]}$ vim config.json{  &quot;signing&quot;: {       &quot;default&quot;: {        &quot;expiry&quot;: &quot;87600h&quot;    },    &quot;profiles&quot;: {      &quot;kubernetes&quot;: {        &quot;usages&quot;: [            &quot;signing&quot;,            &quot;key encipherment&quot;,            &quot;server auth&quot;,            &quot;client auth&quot;        ],        &quot;expiry&quot;: &quot;87600h&quot;       }     }   }}</code></pre><p><strong><em>注意：上面的证书请求配置，不能使用hostname,要使用ip,建议多预留几个IP。</em></strong></p><pre><code>$ cfssl gencert -ca=/opt/ssl/ca.pem \  -ca-key=/opt/ssl/ca-key.pem \  -config=/opt/ssl/config.json \  -profile=kubernetes etcd-csr.json | cfssljson -bare etcd$ ls etcd*.pem # 生成etcd的证书和私钥etcd-key.pem  # etcd私钥etcd.pem       # etcd证书</code></pre><h3 id="etcd证书分发-三个节点均为etcd"><a href="#etcd证书分发-三个节点均为etcd" class="headerlink" title="etcd证书分发(三个节点均为etcd)"></a>etcd证书分发(三个节点均为etcd)</h3><pre><code>$ cp -a etcd*.pem /etc/kubernetes/ssl          # etcd1$ scp -p etcd*.pem root@k8s-node01:/etc/kubernetes/ssl    # etcd2$ scp -p etcd*.pem root@k8s-node02:/etc/kubernetes/ssl    # etcd3</code></pre><h3 id="增加etcd-配置"><a href="#增加etcd-配置" class="headerlink" title="增加etcd 配置"></a>增加etcd 配置</h3><table><tr><td bgcolor="#008000"> master和node </td></tr></table><pre><code>$ mkdir /opt/etcd$ vi /etc/systemd/system/etcd.service     # etcd1[Unit]Description=Etcd ServerAfter=network.targetAfter=network-online.targetWants=network-online.target[Service]Type=notifyWorkingDirectory=/opt/etcd/User=rootExecStart=/usr/bin/etcd \  --name=etcd1 \  --cert-file=/etc/kubernetes/ssl/etcd.pem \  --key-file=/etc/kubernetes/ssl/etcd-key.pem \  --peer-cert-file=/etc/kubernetes/ssl/etcd.pem \  --peer-key-file=/etc/kubernetes/ssl/etcd-key.pem \  --trusted-ca-file=/etc/kubernetes/ssl/ca.pem \  --peer-trusted-ca-file=/etc/kubernetes/ssl/ca.pem \  --initial-advertise-peer-urls=https://10.173.36.214:2380 \  --listen-peer-urls=https://10.173.36.214:2380 \  --listen-client-urls=https://10.173.36.214:2379,http://127.0.0.1:2379 \  --advertise-client-urls=https://10.173.36.214:2379 \  --initial-cluster-token=k8s-etcd-cluster \  --initial-cluster=etcd1=https://10.173.36.214:2380,etcd2=https://10.173.36.216:2380,etcd3=https://10.173.36.215:2380 \  --initial-cluster-state=new \  --data-dir=/opt/etcd/Restart=on-failureRestartSec=5LimitNOFILE=65536[Install]WantedBy=multi-user.target$ mkdir /opt/etcd$ vi /etc/systemd/system/etcd.service  # etcd2[Unit]Description=Etcd ServerAfter=network.targetAfter=network-online.targetWants=network-online.target[Service]Type=notifyWorkingDirectory=/opt/etcd/User=rootExecStart=/usr/bin/etcd \  --name=etcd2 \  --cert-file=/etc/kubernetes/ssl/etcd.pem \  --key-file=/etc/kubernetes/ssl/etcd-key.pem \  --peer-cert-file=/etc/kubernetes/ssl/etcd.pem \  --peer-key-file=/etc/kubernetes/ssl/etcd-key.pem \  --trusted-ca-file=/etc/kubernetes/ssl/ca.pem \  --peer-trusted-ca-file=/etc/kubernetes/ssl/ca.pem \  --initial-advertise-peer-urls=https://10.173.36.216:2380 \  --listen-peer-urls=https://10.173.36.216:2380 \  --listen-client-urls=https://10.173.36.216:2379,http://127.0.0.1:2379 \  --advertise-client-urls=https://10.173.36.216:2379 \  --initial-cluster-token=k8s-etcd-cluster \  --initial-cluster=etcd1=https://10.173.36.214:2380,etcd2=https://10.173.36.216:2380,etcd3=https://10.173.36.215:2380 \  --initial-cluster-state=new \  --data-dir=/opt/etcd/Restart=on-failureRestartSec=5LimitNOFILE=65536[Install]WantedBy=multi-user.target$ mkdir /opt/etcd$ vi /etc/systemd/system/etcd.service   # etcd3[Unit]Description=Etcd ServerAfter=network.targetAfter=network-online.targetWants=network-online.target[Service]Type=notifyWorkingDirectory=/opt/etcd/User=rootExecStart=/usr/bin/etcd \  --name=etcd3 \  --cert-file=/etc/kubernetes/ssl/etcd.pem \  --key-file=/etc/kubernetes/ssl/etcd-key.pem \  --peer-cert-file=/etc/kubernetes/ssl/etcd.pem \  --peer-key-file=/etc/kubernetes/ssl/etcd-key.pem \  --trusted-ca-file=/etc/kubernetes/ssl/ca.pem \  --peer-trusted-ca-file=/etc/kubernetes/ssl/ca.pem \  --initial-advertise-peer-urls=https://10.173.36.215:2380 \  --listen-peer-urls=https://10.173.36.215:2380 \  --listen-client-urls=https://10.173.36.215:2379,http://127.0.0.1:2379 \  --advertise-client-urls=https://10.173.36.215:2379 \  --initial-cluster-token=k8s-etcd-cluster \  --initial-cluster=etcd1=https://10.173.36.214:2380,etcd2=https://10.173.36.216:2380,etcd3=https://10.173.36.215:2380 \  --initial-cluster-state=new \  --data-dir=/opt/etcd/Restart=on-failureRestartSec=5LimitNOFILE=65536[Install]WantedBy=multi-user.target</code></pre><h3 id="启动etcd"><a href="#启动etcd" class="headerlink" title="启动etcd"></a>启动etcd</h3><pre><code>$ systemctl daemon-reload$ systemctl enable etcd$ systemctl start etcd$ systemctl status etcd</code></pre><h3 id="验证-etcd-集群状态"><a href="#验证-etcd-集群状态" class="headerlink" title="验证 etcd 集群状态"></a>验证 etcd 集群状态</h3><p><strong>查看集群状态：</strong></p><pre><code>$ etcdctl --endpoints=https://10.173.36.214:2379,https://10.173.36.215:2379,https://10.173.36.216:2379\        --cert-file=/etc/kubernetes/ssl/etcd.pem \        --ca-file=/etc/kubernetes/ssl/ca.pem \        --key-file=/etc/kubernetes/ssl/etcd-key.pem \        cluster-healthmember 3f2cd58f2041fd0c is healthy: got healthy result from https://10.173.36.215:2379member 81779624411cd53c is healthy: got healthy result from https://10.173.36.216:2379member 87fb8e044eab3dee is healthy: got healthy result from https://10.173.36.214:2379</code></pre><p><strong>查看集群成员:</strong><br>可以看到集群节点的选举情况</p><pre><code>$ etcdctl --endpoints=https://10.173.36.214:2379,https://10.173.36.215:2379,https://10.173.36.216:2379\        --cert-file=/etc/kubernetes/ssl/etcd.pem \        --ca-file=/etc/kubernetes/ssl/ca.pem \        --key-file=/etc/kubernetes/ssl/etcd-key.pem \        member list3f2cd58f2041fd0c: name=etcd3 peerURLs=https://10.173.36.215:2380 clientURLs=https://10.173.36.215:2379 isLeader=false81779624411cd53c: name=etcd2 peerURLs=https://10.173.36.216:2380 clientURLs=https://10.173.36.216:2379 isLeader=true   // 被选中87fb8e044eab3dee: name=etcd1 peerURLs=https://10.173.36.214:2380 clientURLs=https://10.173.36.214:2379 isLeader=false</code></pre><p><strong>etcd查看报错:</strong></p><pre><code>$ journalctl -f -t etcd</code></pre><h2 id="Kubernetes-集群（Master）"><a href="#Kubernetes-集群（Master）" class="headerlink" title="Kubernetes 集群（Master）"></a>Kubernetes 集群（Master）</h2><blockquote><p>kubectl 安装在所有需要进行操作的机器上,一般放在master节点上；Master 需要部署 kube-apiserver , kube-scheduler , kube-controller-manager 这三个组件。Node需要部署kubelet,kubeproxy这两个组件。</p></blockquote><table><tr><td bgcolor="#008000"> master </td></tr></table><h3 id="安装kubernetes组件"><a href="#安装kubernetes组件" class="headerlink" title="安装kubernetes组件"></a>安装kubernetes组件</h3><pre><code>$ cd /opt/tools$ wget https://dl.k8s.io/v1.9.1/kubernetes-server-linux-amd64.tar.gz$ tar -xzvf kubernetes-server-linux-amd64.tar.gz$ cd kubernetes$ cp -r server/bin/{kube-apiserver,kube-controller-manager,kube-scheduler,kubectl} /usr/local/bin$ scp -r server/bin/{kube-apiserver,kube-controller-manager,kube-scheduler,kubectl,kube-proxy,kubelet} k8s-node01:/usr/local/bin$ scp -r server/bin/{kubelet,kube-proxy} k8s-node02:/usr/local/bin</code></pre><h3 id="kubeclt"><a href="#kubeclt" class="headerlink" title="kubeclt"></a>kubeclt</h3><h4 id="创建-admin-证书-client证书"><a href="#创建-admin-证书-client证书" class="headerlink" title="创建 admin 证书(client证书)"></a>创建 admin 证书(client证书)</h4><blockquote><p>kubectl的客户端证书，用于kubectl 与 kube-apiserver 的安全端口通信，需要为安全通信提供 TLS 证书和秘钥。</p></blockquote><pre><code>$ cd /opt/ssl/$ vim  admin-csr.json #  证书请求配置{  &quot;CN&quot;: &quot;admin&quot;,  &quot;hosts&quot;: [],  &quot;key&quot;: {    &quot;algo&quot;: &quot;rsa&quot;,    &quot;size&quot;: 2048  },  &quot;names&quot;: [    {      &quot;C&quot;: &quot;CN&quot;,      &quot;ST&quot;: &quot;GuangZhou&quot;,      &quot;L&quot;: &quot;GuangZhou&quot;,      &quot;O&quot;: &quot;system:masters&quot;,      &quot;OU&quot;: &quot;System&quot;    }  ]}$ cfssl gencert -ca=/etc/kubernetes/ssl/ca.pem -ca-key=/etc/kubernetes/ssl/ca-key.pem -config=/opt/ssl/config.json -profile=kubernetes admin-csr.json | cfssljson -bare admin  # 生成admin证书$ ls admin* # 查看证书和私钥的生成admin.csr  admin-csr.json  admin-key.pem  admin.pem$ cp admin*.pem /etc/kubernetes/ssl/$ scp -r admin*.pem  k8s-node01:/etc/kubernetes/ssl/  # 实际上这一步可以不做,拷贝后续的 kubectl kubeconfig文件即可！！</code></pre><h4 id="配置-kubectl-kubeconfig-文件"><a href="#配置-kubectl-kubeconfig-文件" class="headerlink" title="配置 kubectl kubeconfig 文件"></a>配置 kubectl kubeconfig 文件</h4><blockquote><p>生成证书相关的配置文件存储与 /root/.kube 目录中,这里的kubectl与apiserver通信，都是nginx-proxy将通过本地的16443转发到集群apiserver的6443端口。</p></blockquote><pre><code>$ kubectl config set-cluster kubernetes   \   --certificate-authority=/etc/kubernetes/ssl/ca.pem   --embed-certs=true   --server=https://127.0.0.1:16443$ kubectl config set-credentials admin   \   --client-certificate=/etc/kubernetes/ssl/admin.pem   --embed-certs=true   --client-key=/etc/kubernetes/ssl/admin-key.pem$ kubectl config set-context kubernetes  \ --cluster=kubernetes   --user=admin$ kubectl config use-context kubernetes$ scp -a /root/.kube/config root@k8s-node01:/root/.kube # 要保证k8s-node01上存在/root/.kube目录</code></pre><p><strong><em>注意：上面的步骤会生成在/root/.kube/下生成一个config文件,将这个config文件拷贝到安装kubectl节点上即可！！！</em></strong></p><h3 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h3><h4 id="创建-kubernetes-证书（server端"><a href="#创建-kubernetes-证书（server端" class="headerlink" title="创建 kubernetes 证书（server端)"></a>创建 kubernetes 证书（server端)</h4><blockquote><p>kube-apiserver的服务端证书，无论是kubectl,kubelet,kube-proxy的客户端证书，都需要跟此证书进行双向的TLS通信！</p></blockquote><pre><code>$ cd /opt/ssl$ vi kubernetes-csr.json # 生成证书请求配置{  &quot;CN&quot;: &quot;kubernetes&quot;,  &quot;hosts&quot;: [    &quot;127.0.0.1&quot;,    &quot;10.173.36.214&quot;,    &quot;10.173.36.216&quot;,    &quot;10.254.0.1&quot;,    &quot;kubernetes&quot;,    &quot;kubernetes.default&quot;,    &quot;kubernetes.default.svc&quot;,    &quot;kubernetes.default.svc.cluster&quot;,    &quot;kubernetes.default.svc.cluster.local&quot;  ],  &quot;key&quot;: {    &quot;algo&quot;: &quot;rsa&quot;,    &quot;size&quot;: 2048  },  &quot;names&quot;: [    {      &quot;C&quot;: &quot;CN&quot;,      &quot;ST&quot;: &quot;GuangZhou&quot;,      &quot;L&quot;: &quot;GuangZhou&quot;,      &quot;O&quot;: &quot;k8s&quot;,      &quot;OU&quot;: &quot;System&quot;    }  ]}</code></pre><p><strong><em>注意： 由于本集群采用HA apiserver方式，所以客户端组件在跟apiserver通信的时候，都是通过nginx-proxy将本地的16443转发到集群的apiserver的6443端口，所以这里的证书请求hosts配置，实际上配置成127.0.0.1即可，加kube-apiserver的ip是为了使连接更灵活，可以不适用nginx-proxy转发。</em></strong></p><h4 id="生成-kubernetes-证书和私钥"><a href="#生成-kubernetes-证书和私钥" class="headerlink" title="生成 kubernetes 证书和私钥"></a>生成 kubernetes 证书和私钥</h4><pre><code>$ cfssl gencert -ca=/etc/kubernetes/ssl/ca.pem \   -ca-key=/etc/kubernetes/ssl/ca-key.pem \   config=/opt/ssl/config.json \   -profile=kubernetes kubernetes-csr.json | cfssljson -bare kubernetes $ ls -lt kubernetes* kubernetes.csr kubernetes-key.pem kubernetes.pem kubernetes-csr.json $ cp kubernetes*.pem /etc/kubernetes/ssl/ $ scp -p  kubernetes*.pem root@k8s-node01:/etc/kubernetes/ssl/ # 拷贝到所有的master节点</code></pre><h4 id="配置-kube-apiserver"><a href="#配置-kube-apiserver" class="headerlink" title="配置 kube-apiserver"></a>配置 kube-apiserver</h4><blockquote><p>kubelet 首次启动时向 kube-apiserver 发送 TLS Bootstrapping 请求，kube-apiserver 验证 kubelet 请求中的 token 是否与它配置的 token 一致，如果一致则自动为 kubelet生成证书和秘钥。TLS bootstrapping 功能就是让 kubelet 先使用一个预定的低权限用户连接到 apiserver，然后向 apiserver 申请证书，kubelet 的证书由 apiserver 动态签署；RBAC判定是否有权限创建CSR请求。</p></blockquote><pre><code>$ head -c 16 /dev/urandom | od -An -t x | tr -d &apos; &apos;  # 生成 tokena0a5d162e00fff4420406defaae32e17$ cd /opt/ssl    # 创建 token.csv 文件a0a5d162e00fff4420406defaae32e17,kubelet-bootstrap,10001,&quot;system:kubelet-bootstrap&quot;$ cd /etc/kubernetes$ cat &gt;&gt; audit-policy.yaml &lt;&lt;EOF# Log all requests at the Metadata levelapiVersion: audit.k8s.io/v1beta1kind: Policyrules:- level: MetadataEOF$ cp token.csv /etc/kubernetes$ scp token.csv root@k8s-node01:/etc/kubernetes/$ scp audit-policy.yaml root@k8s-node01:/etc/kubernetes   # 拷贝token和审核文件到另外的apiserver上</code></pre><h4 id="配置-kube-apiserver并启动"><a href="#配置-kube-apiserver并启动" class="headerlink" title="配置 kube-apiserver并启动"></a>配置 kube-apiserver并启动</h4><blockquote><p>自定义 系统 service 文件一般存于 /etc/systemd/system/ 下</p></blockquote><pre><code>$ vim /etc/systemd/system/kube-apiserver.service[Unit]Description=Kubernetes API ServerDocumentation=https://github.com/GoogleCloudPlatform/kubernetesAfter=network.target[Service]User=rootExecStart=/usr/local/bin/kube-apiserver \  --admission-control=NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,ResourceQuota,NodeRestriction \  --advertise-address=10.173.36.214 \  --allow-privileged=true \  --apiserver-count=3 \  --audit-policy-file=/etc/kubernetes/audit-policy.yaml \  --audit-log-maxage=30 \  --audit-log-maxbackup=3 \  --audit-log-maxsize=100 \  --audit-log-path=/var/log/kubernetes/audit.log \  --authorization-mode=Node,RBAC \  --bind-address=0.0.0.0 \  --secure-port=6443 \  --client-ca-file=/etc/kubernetes/ssl/ca.pem \  --enable-swagger-ui=true \  --etcd-cafile=/etc/kubernetes/ssl/ca.pem \  --etcd-certfile=/etc/kubernetes/ssl/etcd.pem \  --etcd-keyfile=/etc/kubernetes/ssl/etcd-key.pem \  --etcd-servers=https://10.173.36.214:2379,https://10.173.36.215:2379,https://10.173.36.216:2379 \  --event-ttl=1h \  --kubelet-https=true \  --insecure-bind-address=127.0.0.1 \  --insecure-port=8080 \  --service-account-key-file=/etc/kubernetes/ssl/ca-key.pem \  --service-cluster-ip-range=10.254.0.0/16 \  --service-node-port-range=30000-32000 \  --tls-cert-file=/etc/kubernetes/ssl/kubernetes.pem \  --tls-private-key-file=/etc/kubernetes/ssl/kubernetes-key.pem \  --enable-bootstrap-token-auth \  --token-auth-file=/etc/kubernetes/token.csv \  --v=1Restart=on-failureRestartSec=5Type=notifyLimitNOFILE=65536[Install]WantedBy=multi-user.target$ systemctl daemon-reload$ systemctl enable kube-apiserver$ systemctl start kube-apiserver$ systemctl status kube-apiserver</code></pre><h3 id="kube-controller-manager"><a href="#kube-controller-manager" class="headerlink" title="kube-controller-manager"></a>kube-controller-manager</h3><h4 id="配置-kube-controller-manager"><a href="#配置-kube-controller-manager" class="headerlink" title="配置 kube-controller-manager"></a>配置 kube-controller-manager</h4><pre><code>$ vi /etc/systemd/system/kube-controller-manager.service[Unit]Description=Kubernetes Controller ManagerDocumentation=https://github.com/GoogleCloudPlatform/kubernetes[Service]ExecStart=/usr/local/bin/kube-controller-manager \  --address=0.0.0.0 \  --master=http://127.0.0.1:8080 \  --allocate-node-cidrs=true \  --service-cluster-ip-range=10.254.0.0/16 \  --cluster-cidr=10.253.0.0/16 \  --cluster-name=kubernetes \  --cluster-signing-cert-file=/etc/kubernetes/ssl/ca.pem \  --cluster-signing-key-file=/etc/kubernetes/ssl/ca-key.pem \  --service-account-private-key-file=/etc/kubernetes/ssl/ca-key.pem \  --root-ca-file=/etc/kubernetes/ssl/ca.pem \  --leader-elect=true \  --v=1Restart=on-failureRestartSec=5[Install]WantedBy=multi-user.target</code></pre><h4 id="启动kube-controller-manager"><a href="#启动kube-controller-manager" class="headerlink" title="启动kube-controller-manager"></a>启动kube-controller-manager</h4><pre><code>$ systemctl daemon-reload$ systemctl enable kube-controller-manager$ systemctl start kube-controller-manager$ systemctl status kube-controller-manager</code></pre><h3 id="kube-scheduler"><a href="#kube-scheduler" class="headerlink" title="kube-scheduler"></a>kube-scheduler</h3><h4 id="配置-kube-scheduler"><a href="#配置-kube-scheduler" class="headerlink" title="配置 kube-scheduler"></a>配置 kube-scheduler</h4><pre><code>$ vi /etc/systemd/system/kube-scheduler.service[Unit]Description=Kubernetes SchedulerDocumentation=https://github.com/GoogleCloudPlatform/kubernetes[Service]ExecStart=/usr/local/bin/kube-scheduler \  --address=0.0.0.0 \  --master=http://127.0.0.1:8080 \  --leader-elect=true \  --v=1Restart=on-failureRestartSec=5[Install]WantedBy=multi-user.target</code></pre><h4 id="启动kube-scheduler"><a href="#启动kube-scheduler" class="headerlink" title="启动kube-scheduler"></a>启动kube-scheduler</h4><pre><code>$ systemctl daemon-reload$ systemctl enable kube-scheduler$ systemctl start kube-scheduler$ systemctl status kube-scheduler</code></pre><p><strong><em>注意： kube-controller-manager和 kube-scheduler 跟 apiserver 通信都是采用的非安全端口127.0.0.1:8080</em></strong></p><h3 id="配置nginx-proxy"><a href="#配置nginx-proxy" class="headerlink" title="配置nginx-proxy"></a>配置nginx-proxy</h3><blockquote><p>根据具体需要配置nginx-proxy,我这里所有节点都配置了。</p></blockquote><table><tr><td bgcolor="#008000"> master和node </td></tr></table><h4 id="生成nginx配置文件"><a href="#生成nginx配置文件" class="headerlink" title="生成nginx配置文件"></a>生成nginx配置文件</h4><pre><code>$ docker pull nginx:1.13.7-alpine$ mkdir -p /etc/nginx$ cat &lt;&lt; EOF &gt;&gt; /etc/nginx/nginx.conferror_log stderr notice;worker_processes auto;events {  multi_accept on;  use epoll;  worker_connections 1024;}stream {    upstream kube_apiserver {        least_conn;        server 10.173.36.214:6443;        server 10.173.36.216:6443;    }    server {        listen        0.0.0.0:16443;        proxy_pass    kube_apiserver;        proxy_timeout 10m;        proxy_connect_timeout 1s;    }}EOF$ chmod +r /etc/nginx/nginx.conf</code></pre><h4 id="启动nginx-proxy"><a href="#启动nginx-proxy" class="headerlink" title="启动nginx-proxy"></a>启动nginx-proxy</h4><pre><code>$ cat &lt;&lt; EOF &gt;&gt; /etc/systemd/system/nginx-proxy.service # 配置 Nginx 基于 docker 进程，然后配置 systemd 来启动[Unit]Description=kubernetes apiserver docker wrapperWants=docker.socketAfter=docker.service[Service]User=rootPermissionsStartOnly=trueExecStart=/usr/bin/docker run -p 127.0.0.1:16443:16443 \\                              -v /etc/nginx:/etc/nginx \\                              --name nginx-proxy \\                              --net=host \\                              --restart=on-failure:5 \\                              --memory=512M \\                              nginx:1.13.7-alpineExecStartPre=-/usr/bin/docker rm -f nginx-proxyExecStop=/usr/bin/docker stop nginx-proxyRestart=alwaysRestartSec=15sTimeoutStartSec=30s[Install]WantedBy=multi-user.targetEOF$ systemctl daemon-reload$ systemctl start nginx-proxy$ systemctl enable nginx-proxy$ systemctl status nginx-proxy</code></pre><h3 id="查看集群信息"><a href="#查看集群信息" class="headerlink" title="查看集群信息"></a>查看集群信息</h3><h4 id="查看各组件信息"><a href="#查看各组件信息" class="headerlink" title="查看各组件信息"></a>查看各组件信息</h4><pre><code>$ kubectl get componentstatuses  # 查看各组件信息NAME                 STATUS    MESSAGE              ERRORcontroller-manager   Healthy   okscheduler            Healthy   oketcd-2               Healthy   {&quot;health&quot;: &quot;true&quot;}etcd-1               Healthy   {&quot;health&quot;: &quot;true&quot;}etcd-0               Healthy   {&quot;health&quot;: &quot;true&quot;}</code></pre><h4 id="查看集群状态信息"><a href="#查看集群状态信息" class="headerlink" title="查看集群状态信息"></a>查看集群状态信息</h4><pre><code>$ kubectl cluster-info # 查看集群信息Kubernetes master is running at https://127.0.0.1:16443CoreDNS is running at https://127.0.0.1:16443/api/v1/namespaces/kube-system/services/coredns:dns/proxykubernetes-dashboard is running at https://127.0.0.1:16443/api/v1/namespaces/kube-system/services/kubernetes-dashboard/proxy</code></pre><h2 id="Kubernetes-集群（Node）"><a href="#Kubernetes-集群（Node）" class="headerlink" title="Kubernetes 集群（Node）"></a>Kubernetes 集群（Node）</h2><blockquote><p>k8s的工作节点只需要运行kubelet及kube-proxy即可，kubelet的证书由Master端自动生成。</p><table><tr><td bgcolor="#008000"> master </td></tr></table></blockquote><h3 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h3><blockquote><p>kubelet 启动时向 kube-apiserver 发送 TLS bootstrapping 请求，需要先将 bootstrap token 文件中的 kubelet-bootstrap 用户赋予 system:node-bootstrapper 角色，然后 kubelet 才有权限创建认证请求(certificatesigningrequests)。</p></blockquote><h4 id="RBAC授权"><a href="#RBAC授权" class="headerlink" title="RBAC授权"></a>RBAC授权</h4><pre><code>$ kubectl create clusterrolebinding kubelet-bootstrap -- \clusterrole=system:node-bootstrapper --user=kubelet-bootstrap</code></pre><p><strong><em>注意：创建一个集群授权用户 kubelet-bootstrap，用户首次与apiserver通信使用！定义了kubelet进程的权限RBAC中用户和资源之间的连接权限。</em></strong></p><h4 id="生成bootstrap-kubeconfig配置"><a href="#生成bootstrap-kubeconfig配置" class="headerlink" title="生成bootstrap.kubeconfig配置"></a>生成bootstrap.kubeconfig配置</h4><pre><code>$ kubectl config set-cluster kubernetes \  --certificate-authority=/etc/kubernetes/ssl/ca.pem \  --embed-certs=true \  --server=https://127.0.0.1:16443 \  --kubeconfig=bootstrap.kubeconfig # 配置集群$ kubectl config set-credentials kubelet-bootstrap \  --token=a0a5d162e00fff4420406defaae32e17 \  --kubeconfig=bootstrap.kubeconfig # 客户端认证$ kubectl config set-context default \  --cluster=kubernetes \  --user=kubelet-bootstrap \  --kubeconfig=bootstrap.kubeconfig # 配置关联$ kubectl config use-context default --kubeconfig=bootstrap.kubeconfig # 配置默认关联mv bootstrap.kubeconfig /etc/kubernetes/scp -p  /etc/kubernetes/bootstrap.kubeconfig  root@k8s-node02:/etc/kubernetes</code></pre><p><strong><em>注意：这里生成的bootstrap.kubeconfig非常重要,在 apiserver 配置中指定了一个 token.csv 文件，该文件中是一个预设的用户配置；同时该用户的 Token 和 apiserver 的 CA 证书被写入了 kubelet 所使用的 bootstrap.kubeconfig 配置文件中；这样在首次请求时，kubelet 使用 bootstrap.kubeconfig 中的 apiserver CA 证书来与 apiserver 建立 TLS 通讯，使用 bootstrap.kubeconfig 中的用户 Token 来向 apiserver 声明自己的 RBAC 授权身份</em></strong></p><h4 id="创建-kubelet-service-文件"><a href="#创建-kubelet-service-文件" class="headerlink" title="创建 kubelet.service 文件"></a>创建 kubelet.service 文件</h4><table><tr><td bgcolor="#008000"> node </td></tr></table><pre><code>$ mkdir /var/lib/kubelet$ vi /etc/systemd/system/kubelet.serviceAfter=docker.serviceRequires=docker.service[Service]WorkingDirectory=/var/lib/kubeletExecStart=/usr/local/bin/kubelet \  --cgroup-driver=cgroupfs \  --hostname-override=k8s-node01 \  --pod-infra-container-image=k8s-master01:8001/google_containers/pause:3.0 \  --experimental-bootstrap-kubeconfig=/etc/kubernetes/bootstrap.kubeconfig \  --kubeconfig=/etc/kubernetes/kubelet.kubeconfig \  --cert-dir=/etc/kubernetes/ssl \  --cluster_dns=10.254.0.2 \  --cluster_domain=cluster.local. \  --hairpin-mode promiscuous-bridge \  --allow-privileged=true \  --fail-swap-on=false \  --serialize-image-pulls=false \  --logtostderr=true \  --max-pods=512 \  --v=1[Install]WantedBy=multi-user.target</code></pre><h4 id="启动kubelet服务"><a href="#启动kubelet服务" class="headerlink" title="启动kubelet服务"></a>启动kubelet服务</h4><pre><code>$ systemctl daemon-reload$ systemctl enable kubelet$ systemctl start kubelet # 启动kubelet$ systemctl status kube$ journalctl -f -t kubelet  和 journalctl -u kubelet # 定位问题</code></pre><h4 id="配置-TLS-认证"><a href="#配置-TLS-认证" class="headerlink" title="配置 TLS 认证"></a>配置 TLS 认证</h4><pre><code>$ kubectl get csr # 查看 csr 的名称$ kubectl get csr | grep Pending | awk &apos;{print $1}&apos; | xargs kubectl certificate approve # 增加 认证</code></pre><h4 id="验证-nodes"><a href="#验证-nodes" class="headerlink" title="验证 nodes"></a>验证 nodes</h4><pre><code>$ kubectl get nodesNAME         STATUS    ROLES     AGE       VERSIONk8s-node01   Ready     &lt;none&gt;    6d        v1.9.1k8s-node02   Ready     &lt;none&gt;    5d        v1.9.1</code></pre><p><strong><em>注意：成功以后会自动生成配置文件与密钥</em></strong></p><pre><code>$ ls /etc/kubernetes/kubelet.kubeconfig/etc/kubernetes/kubelet.kubeconfig$ ls /etc/kubernetes/ssl/kubelet* -l/etc/kubernetes/ssl/kubelet-client.crt/etc/kubernetes/ssl/kubelet-client.key/etc/kubernetes/ssl/kubelet.crt/etc/kubernetes/ssl/kubelet.key</code></pre><h3 id="配置-kube-proxy"><a href="#配置-kube-proxy" class="headerlink" title="配置 kube-proxy"></a>配置 kube-proxy</h3><blockquote><p>证书的生成都是在master节点上完成，然后拷贝到相应的node上</p><table><tr><td bgcolor="#008000"> master </td></tr></table></blockquote><h4 id="生成请求文件"><a href="#生成请求文件" class="headerlink" title="生成请求文件"></a>生成请求文件</h4><pre><code>$ cd /opt/ssl$ vi kube-proxy-csr.json{  &quot;CN&quot;: &quot;system:kube-proxy&quot;,  &quot;hosts&quot;: [],  &quot;key&quot;: {    &quot;algo&quot;: &quot;rsa&quot;,    &quot;size&quot;: 2048  },  &quot;names&quot;: [    {      &quot;C&quot;: &quot;CN&quot;,      &quot;ST&quot;: &quot;GuangZhou&quot;,      &quot;L&quot;: &quot;GuangZhou&quot;,      &quot;O&quot;: &quot;k8s&quot;,      &quot;OU&quot;: &quot;System&quot;    }  ]}</code></pre><h4 id="生成-kube-proxy-证书和私钥"><a href="#生成-kube-proxy-证书和私钥" class="headerlink" title="生成 kube-proxy 证书和私钥"></a>生成 kube-proxy 证书和私钥</h4><pre><code>$ cfssl gencert -ca=/etc/kubernetes/ssl/ca.pem \-ca-key=/etc/kubernetes/ssl/ca-key.pem \-config=/opt/ssl/config.json \-profile=kubernetes  kube-proxy-csr.json | cfssljson -bare kube-proxy # 生成证书$ ls kube-proxy*  // 查看生成证书和私钥kube-proxy.csr  kube-proxy-csr.json  kube-proxy-key.pem  kube-proxy.pem$ cp kube-proxy* /etc/kubernetes/ssl/ 分发证书及私钥$ scp kube-proxy* k8s-node01:/etc/kubernetes/ssl/$ scp kube-proxy* k8s-node02:/etc/kubernetes/ssl/</code></pre><h4 id="创建-kube-proxy-kubeconfig-文件"><a href="#创建-kube-proxy-kubeconfig-文件" class="headerlink" title="创建 kube-proxy kubeconfig 文件"></a>创建 kube-proxy kubeconfig 文件</h4><pre><code>$ kubectl config set-cluster kubernetes \   --certificate-authority=/etc/kubernetes/ssl/ca.pem \   --embed-certs=true \  --server=https://127.0.0.1:16443 \   --kubeconfig=kube-proxy.kubeconfig  # 配置集群$ kubectl config set-credentials kube-proxy \  --client-certificate=/etc/kubernetes/ssl/kube-proxy.pem \  --client-key=/etc/kubernetes/ssl/kube-proxy-key.pem \  --embed-certs=true \  --kubeconfig=kube-proxy.kubeconfig # 配置客户端认证$ kubectl config set-context default \  --cluster=kubernetes \  --user=kube-proxy \  --kubeconfig=kube-proxy.kubeconfig$ kubectl config use-context default --kubeconfig=kube-proxy.kubeconfig$ scp kube-proxy.kubeconfig k8s-node01:/etc/kubernetes/ # 分发到node节点$ scp kube-proxy.kubeconfig k8s-node02:/etc/kubernetes/</code></pre><h4 id="创建-kube-proxy-service-文件"><a href="#创建-kube-proxy-service-文件" class="headerlink" title="创建 kube-proxy.service 文件"></a>创建 kube-proxy.service 文件</h4><blockquote><p>打开 ipvs 需要安装 ipvsadm 软件</p></blockquote><table><tr><td bgcolor="#008000"> node </td></tr></table><pre><code>$ yum install ipvsadm -y$ yum install ipset -y$ yum install conntrack -y$ mkdir -p /var/lib/kube-proxy$ vi /etc/systemd/system/kube-proxy.service[Unit]Description=Kubernetes Kube-Proxy ServerDocumentation=https://github.com/GoogleCloudPlatform/kubernetesAfter=network.target[Service]WorkingDirectory=/var/lib/kube-proxyExecStart=/usr/local/bin/kube-proxy \  --bind-address=10.173.36.216 \  --hostname-override=k8s-node01 \  --cluster-cidr=10.253.0.0/16 \  --masquerade-all \  --feature-gates=SupportIPVSProxyMode=true \  --proxy-mode=ipvs \  --ipvs-min-sync-period=5s \  --ipvs-sync-period=5s \  --ipvs-scheduler=rr \  --kubeconfig=/etc/kubernetes/kube-proxy.kubeconfig \  --logtostderr=true \  --v=1Restart=on-failureRestartSec=5LimitNOFILE=65536[Install]WantedBy=multi-user.target</code></pre><h4 id="启动kube-proxy"><a href="#启动kube-proxy" class="headerlink" title="启动kube-proxy"></a>启动kube-proxy</h4><pre><code>$ systemctl daemon-reload$ systemctl enable kube-proxy$ systemctl start kube-proxy # 启动kube-proxy$ systemctl status kube-proxy$ journalctl -f -t kube-proxy  和 journalctl -u kube-proxy # 定位问题</code></pre><h4 id="检查ipvs"><a href="#检查ipvs" class="headerlink" title="检查ipvs"></a>检查ipvs</h4><pre><code>$ ipvsadm -L -nIP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConnTCP  10.254.0.1:443 rr persistent 10800  -&gt; 10.173.36.214:6443           Masq    1      1          0  -&gt; 10.173.36.216:6443           Masq    1      0          0</code></pre><h2 id="配置-Flannel-网络"><a href="#配置-Flannel-网络" class="headerlink" title="配置 Flannel 网络"></a>配置 Flannel 网络</h2><blockquote><p>配置完Flannel网络，会覆盖原来docker0的配置，k8s中所有pods将使用这个网段！</p></blockquote><table><tr><td bgcolor="#008000"> node 和master</td></tr></table><h3 id="下载Flannel包"><a href="#下载Flannel包" class="headerlink" title="下载Flannel包"></a>下载Flannel包</h3><pre><code>$ cd /opt/tools$ wget https://github.com/coreos/flannel/releases/download/v0.10.0/flannel-v0.10.0-linux-amd64.tar.gz # 拷贝包里面的flanneld 和 mk-docker-opts.sh$ tar xf  flannel-v0.10.0-linux-amd64.tar.gz$ cp flanneld  mk-docker-opts.sh /usr/local/bin$ scp -p mk-docker-opts.sh  mk-docker-opts.sh root@k8s-node02:/usr/local/bin</code></pre><h3 id="设置集群的网络范围"><a href="#设置集群的网络范围" class="headerlink" title="设置集群的网络范围"></a>设置集群的网络范围</h3><pre><code>$ etcdctl --endpoints=https://10.173.36.214:2379,https://10.173.36.215:2379,\https://10.173.36.216:2379   --ca-file=/etc/kubernetes/ssl/ca.pem  \ --cert-file=/etc/kubernetes/ssl/etcd.pem \ --key-file=/etc/kubernetes/ssl/etcd-key.pem  mkdir /kubernetes/network$ etcdctl --endpoints=https://10.173.36.214:2379,https://10.173.36.215:2379,\https://10.173.36.216:2379  --ca-file=/etc/kubernetes/ssl/ca.pem \  --cert-file=/etc/kubernetes/ssl/etcd.pem  \  --key-file=/etc/kubernetes/ssl/etcd-key.pem  \ mk /kubernetes/network/config &apos;{ &quot;Network&quot;: &quot;10.253.0.0/16&quot;, &quot;Backend&quot;: { &quot;Type&quot;: &quot;vxlan&quot;, &quot;VNI&quot;: 1 }}&apos;</code></pre><h3 id="创建flanneld-service文件"><a href="#创建flanneld-service文件" class="headerlink" title="创建flanneld service文件"></a>创建flanneld service文件</h3><pre><code>$ vim /etc/systemd/system/flanneld.service[Unit]Description=Flanneld overlay address etcd agentAfter=network.targetAfter=network-online.targetWants=network-online.targetAfter=etcd.serviceBefore=docker.service[Service]Type=notifyExecStart=/usr/local/bin/flanneld \-etcd-cafile=/etc/kubernetes/ssl/ca.pem \-etcd-certfile=/etc/kubernetes/ssl/etcd.pem  \-etcd-keyfile=/etc/kubernetes/ssl/etcd-key.pem\-etcd-endpoints=https://10.173.36.216:2379,https://0.173.36.214:2379,https://0.173.36.215:2379 \-etcd-prefix=/kubernetes/network \-iface=eth0ExecStartPost=/usr/local/bin/mk-docker-opts.sh -k DOCKER_NETWORK_OPTIONS -d /run/flannel/dockerRestart=on-failure[Install]WantedBy=multi-user.targetRequiredBy=docker.service</code></pre><h3 id="修改dokcer-service文件"><a href="#修改dokcer-service文件" class="headerlink" title="修改dokcer service文件"></a>修改dokcer service文件</h3><blockquote><p>还需要关联docker和flanneld配置,并重启机器。</p></blockquote><pre><code>$ vim /etc/systemd/system/docker.serviceEnvironmentFile=/run/flannel/docker # 增加这个参数$ reboot</code></pre><p><strong>重启前操作：</strong></p><ul><li>master01:<br>systemctl  enable etcd  flanneld  kube-apiserver kube-controller-manager kube-scheduler   docker</li></ul><ul><li><p>node01:<br>systemctl enable  kube-apiserver kube-controller-manager kube-scheduler docker etcd flanneld kubelet kube-proxy</p></li><li><p>node02:<br>systemctl  enable docker  etcd flanneld kubelet kube-proxy   nginx-proxy</p></li></ul><h3 id="验证网络"><a href="#验证网络" class="headerlink" title="验证网络"></a>验证网络</h3><blockquote><p>ifconfig  查看  docker0 网络 是否已经更改为配置IP网段</p></blockquote><pre><code>$ mkdir /opt/build$ vim nginx.yamlapiVersion: extensions/v1beta1kind: Deploymentmetadata:  name: nginx-dmspec:  replicas: 2  template:    metadata:      labels:        name: nginx    spec:      containers:        - name: nginx          image: nginx:alpine          imagePullPolicy: IfNotPresent          ports:            - containerPort: 80---apiVersion: v1kind: Servicemetadata:  name: nginx-svcspec:  ports:    - port: 80      targetPort: 80      protocol: TCP  selector:    name: nginx$ kubectl create -f nginx.yaml$ kubectl get pods  -o wideNAME                        READY     STATUS    RESTARTS   AGE       IP            NODEnginx-dm-84f8f49555-ddn7x   1/1       Running   0          3d        10.253.76.2   k8s-node02nginx-dm-84f8f49555-sjvbj   1/1       Running   0          3d        10.253.76.5   k8s-node02$ kubectl get svc  -o wideNAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE       SELECTORkubernetes   ClusterIP   10.254.0.1      &lt;none&gt;        443/TCP   6d        &lt;none&gt;nginx-svc    ClusterIP   10.254.173.38   &lt;none&gt;        80/TCP    4d        name=nginx[root@k8s-node01 ~]# curl 10.254.173.38 # 在安装kube-proxy的节点使用&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt;    body {        width: 35em;        margin: 0 auto;        font-family: Tahoma, Verdana, Arial, sans-serif;    }&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer to&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;Commercial support is available at&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="配置-CoreDNS"><a href="#配置-CoreDNS" class="headerlink" title="配置 CoreDNS"></a>配置 <a href="https://coredns.io" target="_blank" rel="noopener">CoreDNS</a></h2><h3 id="下载并启动coreDNS-svc"><a href="#下载并启动coreDNS-svc" class="headerlink" title="下载并启动coreDNS svc"></a>下载并启动coreDNS svc</h3><ul><li>官方镜像<br>coredns/coredns:1.0.4</li><li>我的镜像<br>k8s-master01:8001/coredns:1.0.4</li></ul><table><tr><td bgcolor="#008000"> master</td></tr></table><pre><code>$ docker pull coredns/coredns:1.0.4$ docker tag coredns/coredns:1.0.4  k8s-master01:8001/coredns:1.0.4$ docker push  k8s-master01:8001/coredns:1.0.4$ cd /opt/build$ vim coredns.yamlapiVersion: v1kind: ServiceAccountmetadata:  name: coredns  namespace: kube-system  labels:      kubernetes.io/cluster-service: &quot;true&quot;      addonmanager.kubernetes.io/mode: Reconcile---apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRolemetadata:  labels:    kubernetes.io/bootstrapping: rbac-defaults    addonmanager.kubernetes.io/mode: Reconcile  name: system:corednsrules:- apiGroups:  - &quot;&quot;  resources:  - endpoints  - services  - pods  - namespaces  verbs:  - list  - watch---apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRoleBindingmetadata:  annotations:    rbac.authorization.kubernetes.io/autoupdate: &quot;true&quot;  labels:    kubernetes.io/bootstrapping: rbac-defaults    addonmanager.kubernetes.io/mode: EnsureExists  name: system:corednsroleRef:  apiGroup: rbac.authorization.k8s.io  kind: ClusterRole  name: system:corednssubjects:- kind: ServiceAccount  name: coredns  namespace: kube-system---apiVersion: v1kind: ConfigMapmetadata:  name: coredns  namespace: kube-system  labels:      addonmanager.kubernetes.io/mode: EnsureExistsdata:  Corefile: |    .:53 {        errors        log stdout        health        kubernetes cluster.local 10.254.0.0/16        prometheus        proxy . /etc/resolv.conf        cache 30    }---apiVersion: extensions/v1beta1kind: Deploymentmetadata:  name: coredns  namespace: kube-system  labels:    k8s-app: coredns    kubernetes.io/cluster-service: &quot;true&quot;    addonmanager.kubernetes.io/mode: Reconcile    kubernetes.io/name: &quot;CoreDNS&quot;spec:  replicas: 1  selector:    matchLabels:      k8s-app: coredns  template:    metadata:      labels:        k8s-app: coredns    spec:      serviceAccountName: coredns      tolerations:        - key: node-role.kubernetes.io/master          effect: NoSchedule        - key: &quot;CriticalAddonsOnly&quot;          operator: &quot;Exists&quot;      containers:      - name: coredns        image: k8s-master01:8001/coredns:1.0.4        imagePullPolicy: IfNotPresent        resources:          limits:            memory: 170Mi          requests:            cpu: 100m            memory: 70Mi        args: [ &quot;-conf&quot;, &quot;/etc/coredns/Corefile&quot; ]        volumeMounts:        - name: config-volume          mountPath: /etc/coredns        ports:        - containerPort: 53          name: dns          protocol: UDP        - containerPort: 53          name: dns-tcp          protocol: TCP        - containerPort: 9153          name: metrics          protocol: TCP        livenessProbe:          httpGet:            path: /health            port: 8080            scheme: HTTP          initialDelaySeconds: 60          timeoutSeconds: 5          successThreshold: 1          failureThreshold: 5      dnsPolicy: Default      volumes:        - name: config-volume          configMap:            name: coredns            items:            - key: Corefile              path: Corefile---apiVersion: v1kind: Servicemetadata:  name: coredns  namespace: kube-system  labels:    k8s-app: coredns    kubernetes.io/cluster-service: &quot;true&quot;    addonmanager.kubernetes.io/mode: Reconcile    kubernetes.io/name: &quot;CoreDNS&quot;spec:  selector:    k8s-app: coredns  clusterIP: 10.254.0.2  ports:  - name: dns    port: 53    protocol: UDP  - name: dns-tcp    port: 53    protocol: TCP  - name: metrics    port: 9153    protocol: TCP$ kubectl create -f coredns.yaml</code></pre><p><strong>配置说明:</strong></p><ul><li><p>这里 kubernetes cluster.local 为 创建 svc 的 IP 段10.254.0.0/16</p></li><li><p>clusterIP  为 指定 DNS 的 IP clusterIP: 10.254.0.2</p></li></ul><h3 id="验证-dns-服务"><a href="#验证-dns-服务" class="headerlink" title="验证 dns 服务"></a>验证 dns 服务</h3><p>创建一个 pods 来测试一下 dns</p><pre><code>$ vim /opt/build/alpine.yamlapiVersion: v1kind: Podmetadata:  name: alpinespec:  containers:  - name: alpine    image: alpine    command:    - sh    - -c    - while true; do sleep 1; done$ kubectl exec -it alpine nslookup nginx-svc # 测试解析nslookup: can&apos;t resolve &apos;(null)&apos;: Name does not resolveName:      nginx-svcAddress 1: 10.254.173.38 nginx-svc.default.svc.cluster.local</code></pre><h2 id="部署-Dashboard和Heapster"><a href="#部署-Dashboard和Heapster" class="headerlink" title="部署  Dashboard和Heapster"></a>部署  Dashboard和Heapster</h2><ul><li><a href="gcr.io">官方 google_container地址</a></li><li><a href="https://hub.tenxcloud.com/search?q=google_containers&amp;source=tenxcloud" target="_blank" rel="noopener">时速云 google_container 镜像地址</a>   # 当然使用国内镜像更快</li></ul><h3 id="下载-dashboard和heapster镜像"><a href="#下载-dashboard和heapster镜像" class="headerlink" title="下载 dashboard和heapster镜像"></a>下载 dashboard和heapster镜像</h3><pre><code>$ docker pull index.tenxcloud.com/google_containers/kubernetes-dashboard-amd64:v1.4.0$ docker pull index.tenxcloud.com/google_containers/heapster:v1.2.0$ docker tag index.tenxcloud.com/google_containers/kubernetes-dashboard-amd64:v1.4.0 k8s-master01:8001/google_containers/kubernetes-dashboard-amd64:v1.4.0$ docker tag index.tenxcloud.com/google_containers/heapster:v1.2.0   k8s-master01:8001/google_containers/google_containers/heapster:v1.2.0$ docker push k8s-master01:8001/google_containers/kubernetes-dashboard-amd64:v1.4.0$ docker push  k8s-master01:8001/google_containers/google_containers/heapster:v1.2.0</code></pre><h3 id="启动dashboard应用"><a href="#启动dashboard应用" class="headerlink" title="启动dashboard应用"></a>启动dashboard应用</h3><pre><code>$ vim  dashboard.yamlapiVersion: v1kind: ServiceAccountmetadata:  name: kubernetes-dashboard  namespace: kube-system---apiVersion: rbac.authorization.k8s.io/v1beta1kind: ClusterRoleBindingmetadata:  name: kubernetes-dashboard  labels:    k8s-app: kubernetes-dashboardroleRef:  apiGroup: rbac.authorization.k8s.io  kind: ClusterRole  name: cluster-adminsubjects:- kind: ServiceAccount  name: kubernetes-dashboard  namespace: kube-system---apiVersion: extensions/v1beta1kind: Deploymentmetadata:  name: kubernetes-dashboard  namespace: kube-system  labels:    k8s-app: kubernetes-dashboard    kubernetes.io/cluster-service: &quot;true&quot;    addonmanager.kubernetes.io/mode: Reconcilespec:  selector:    matchLabels:      k8s-app: kubernetes-dashboard  template:    metadata:      labels:        k8s-app: kubernetes-dashboard      annotations:        scheduler.alpha.kubernetes.io/critical-pod: &apos;&apos;    spec:      serviceAccountName: kubernetes-dashboard      containers:      - name: kubernetes-dashboard        image: k8s-master01:8001/google_containers/kubernetes-dashboard-amd64:v1.4.0        resources:          limits:            cpu: 100m            memory: 300Mi          requests:            cpu: 100m            memory: 100Mi        ports:        - containerPort: 9090        livenessProbe:          httpGet:            path: /            port: 9090          initialDelaySeconds: 30          timeoutSeconds: 30      tolerations:      - key: &quot;CriticalAddonsOnly&quot;        operator: &quot;Exists&quot;$ vim dashboard-svc.yamlapiVersion: v1kind: Servicemetadata:  name: kubernetes-dashboard  namespace: kube-system  labels:    k8s-app: kubernetes-dashboard    kubernetes.io/cluster-service: &quot;true&quot;    addonmanager.kubernetes.io/mode: Reconcilespec:  selector:    k8s-app: kubernetes-dashboard  type: NodePort  ports:  - port: 9090    targetPort: 9090    nodePort: 30001$ kubectl create -f dashboard.yaml$ kubectl create -f dashboard-svc.yaml # 转发到node节点的30001</code></pre><h3 id="启动heapster应用"><a href="#启动heapster应用" class="headerlink" title="启动heapster应用"></a>启动heapster应用</h3><pre><code>$ vim heapster.yamlapiVersion: v1kind: ServiceAccountmetadata:  name: heapster  namespace: kube-system---kind: ClusterRoleBindingapiVersion: rbac.authorization.k8s.io/v1beta1metadata:  name: heapstersubjects:  - kind: ServiceAccount    name: heapster    namespace: kube-systemroleRef:  kind: ClusterRole  name: cluster-admin  apiGroup: rbac.authorization.k8s.io---apiVersion: extensions/v1beta1kind: Deploymentmetadata:  name: heapster  namespace: kube-systemspec:  replicas: 1  template:    metadata:      labels:        task: monitoring        k8s-app: heapster    spec:      serviceAccountName: heapster      containers:      - name: heapster        image: k8s-master01:8001/google_containers/google_containers/heapster:v1.2.0        imagePullPolicy: IfNotPresent        command:        - /heapster        - --source=kubernetes:kubernetes:https://kubernetes.default---apiVersion: v1kind: Servicemetadata:  labels:    task: monitoring    kubernetes.io/cluster-service: &apos;true&apos;    kubernetes.io/name: Heapster  name: heapster  namespace: kube-systemspec:  ports:  - port: 80    targetPort: 8082  selector:    k8s-app: heapster$ kubectl create -f heapster.yaml$ kubectl get pods -o wide -n=kube-systemNAME                                   READY     STATUS    RESTARTS   AGE       IP            NODEcoredns-6b59c4cb6d-lt7st               1/1       Running   0          4d        10.253.76.4   k8s-node02heapster-77dd748d7d-h2g9l              1/1       Running   0          2h        10.253.76.3   k8s-node02kubernetes-dashboard-654448b8b-78hgh   1/1       Running   0          3h        10.253.14.2   k8s-node01</code></pre><p>Dashboard 访问地址: <a href="http://10.173.36.216:30001" target="_blank" rel="noopener">http://10.173.36.216:30001</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;集群环境说明&quot;&gt;&lt;a href=&quot;#集群环境说明&quot; class=&quot;headerlink&quot; title=&quot;集群环境说明&quot;&gt;&lt;/a&gt;集群环境说明&lt;/h2&gt;&lt;h3 id=&quot;服务器信息&quot;&gt;&lt;a href=&quot;#服务器信息&quot; class=&quot;headerlink&quot; title=&quot;服务器信息&quot;&gt;&lt;/a&gt;服务器信息&lt;/h3&gt;&lt;p&gt;这里配置2Master 2个node, k8s-master01只做 Master, k8s-node01即是Master也是Node, k8s-node02单纯做Node。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/04/02/9z62xH.png&quot; alt=&quot;服务器信息&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;集群详情&quot;&gt;&lt;a href=&quot;#集群详情&quot; class=&quot;headerlink&quot; title=&quot;集群详情&quot;&gt;&lt;/a&gt;集群详情&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Kubernetes 1.9.1&lt;/li&gt;
&lt;li&gt;Docker-17.03.1-ce&lt;/li&gt;
&lt;li&gt;Etcd-v3.2.14&lt;/li&gt;
&lt;li&gt;Flanneld-v0.10.0 vxlan&lt;/li&gt;
&lt;li&gt;TLS 认证通信&lt;/li&gt;
&lt;li&gt;RBAC 授权&lt;/li&gt;
&lt;li&gt;Kublet TLS BootStrapping&lt;/li&gt;
&lt;li&gt;Coredns:1.0.4&lt;/li&gt;
&lt;li&gt;Registry-2.6&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="k8s" scheme="http://www.chenfanlinux.org/categories/k8s/"/>
    
    
      <category term="k8s" scheme="http://www.chenfanlinux.org/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Python实战之简单爬虫</title>
    <link href="http://www.chenfanlinux.org/2018/03/14/Python%E5%AE%9E%E6%88%98%E4%B9%8B%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/"/>
    <id>http://www.chenfanlinux.org/2018/03/14/Python实战之简单爬虫/</id>
    <published>2018-03-14T02:59:43.000Z</published>
    <updated>2018-03-14T03:01:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码：爬豆瓣电影Top100"><a href="#代码：爬豆瓣电影Top100" class="headerlink" title="代码：爬豆瓣电影Top100"></a>代码：爬豆瓣电影Top100</h2><h3 id="方式一：-re-urllib"><a href="#方式一：-re-urllib" class="headerlink" title="方式一： re   +  urllib"></a>方式一： <a href="https://www.cnblogs.com/huxi/archive/2010/07/04/1771073.html" target="_blank" rel="noopener">re</a>   +  urllib</h3><pre><code># _*_ coding:utf-8 _*_&apos;&apos;&apos;&lt;span class=&quot;title&quot;&gt;肖申克的救赎&lt;/span&gt;&lt;em class=&quot;&quot;&gt;1&lt;/em&gt;&apos;&apos;&apos;import ioimport sysimport refrom urllib.request import urlopensys.stdout = io.TextIOWrapper(sys.stdout.buffer,encoding=&apos;gb18030&apos;)top_num = 1url_base = &apos;https://movie.douban.com/top250?start=&apos;urls = [url_base + str(i*25) for i in range(0,4)]for url in urls:    html = urlopen(url).read().decode(&apos;utf-8&apos;)    top_tag = re.compile(r&apos;&lt;span class=&quot;title&quot;&gt;(.*)&lt;/span&gt;&apos;)    title = re.findall(top_tag, html)    for i in title:        if i.find(&apos;/&apos;) == -1:            print(&apos;Top&apos; + str(top_num) + &apos; &apos; + i)            top_num += 1</code></pre><a id="more"></a><h3 id="方式二：-requests-BeautifulSoup"><a href="#方式二：-requests-BeautifulSoup" class="headerlink" title="方式二： requests + BeautifulSoup"></a>方式二： <a href="https://requests-docs-cn.readthedocs.io/zh_CN/latest/index.html" target="_blank" rel="noopener">requests</a> + <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/#id5" target="_blank" rel="noopener">BeautifulSoup</a></h3><pre><code># _*_ coding:utf-8 _*_&apos;&apos;&apos;&lt;span class=&quot;title&quot;&gt;肖申克的救赎&lt;/span&gt;pip install requestspip install BeautifulSoup&apos;&apos;&apos;import requestsfrom  bs4 import  BeautifulSouptop_num = 1url = &apos;https://movie.douban.com/top250?start=&apos;urls = [url + str(i*25) for i in range(0,4)]for url in urls:    r = requests.get(url)    html = r.text    # 实例化    soup = BeautifulSoup(html,&apos;html.parser&apos;)    movies = soup.find_all(&apos;span&apos;, class_=&apos;title&apos;)    for i in movies:        if i.text.find(&apos;/&apos;) == -1:            print(&apos;Top&apos; + str(top_num) + &apos; &apos; + i.text )            top_num += 1</code></pre><h3 id="运行结果展示"><a href="#运行结果展示" class="headerlink" title="运行结果展示"></a>运行结果展示</h3><pre><code>$ python .\豆瓣Top100.pyTop1 肖申克的救赎Top2 霸王别姬Top3 这个杀手不太冷Top4 阿甘正传Top5 美丽人生Top6 千与千寻Top7 泰坦尼克号Top8 辛德勒的名单Top9 盗梦空间Top10 机器人总动员Top11 海上钢琴师Top12 三傻大闹宝莱坞Top13 忠犬八公的故事Top14 放牛班的春天Top15 大话西游之大圣娶亲Top16 楚门的世界Top17 教父Top18 龙猫Top19 熔炉Top20 乱世佳人Top21 星际穿越Top22 触不可及Top23 无间道Top24 当幸福来敲门Top25 天堂电影院Top26 怦然心动Top27 十二怒汉Top28 搏击俱乐部Top29 少年派的奇幻漂流Top30 鬼子来了Top31 指环王3：王者无敌Top32 蝙蝠侠：黑暗骑士Top33 活着Top34 天空之城Top35 罗马假日Top36 大话西游之月光宝盒Top37 飞屋环游记Top38 疯狂动物城Top39 窃听风暴Top40 两杆大烟枪Top41 飞越疯人院Top42 控方证人Top43 闻香识女人Top44 海豚湾Top45 哈尔的移动城堡Top46 V字仇杀队Top47 辩护人Top48 死亡诗社Top49 教父2Top50 美丽心灵Top51 指环王2：双塔奇兵Top52 指环王1：魔戒再现Top53 情书Top54 饮食男女Top55 美国往事Top56 狮子王Top57 钢琴家Top58 天使爱美丽Top59 七宗罪Top60 摔跤吧！爸爸Top61 被嫌弃的松子的一生Top62 素媛Top63 小鞋子Top64 致命魔术Top65 勇敢的心Top66 音乐之声Top67 剪刀手爱德华Top68 本杰明·巴顿奇事Top69 低俗小说Top70 看不见的客人Top71 西西里的美丽传说Top72 黑客帝国Top73 拯救大兵瑞恩Top74 沉默的羔羊Top75 入殓师Top76 蝴蝶效应Top77 玛丽和马克思Top78 让子弹飞Top79 春光乍泄Top80 大闹天宫Top81 心灵捕手Top82 阳光灿烂的日子Top83 幽灵公主Top84 第六感Top85 末代皇帝Top86 重庆森林Top87 禁闭岛Top88 大鱼Top89 狩猎Top90 布达佩斯大饭店Top91 射雕英雄传之东成西就Top92 哈利·波特与魔法石Top93 甜蜜蜜Top94 致命IDTop95 一一Top96 阳光姐妹淘Top97 断背山Top98 告白Top99 猫鼠游戏Top100 上帝之城</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;代码：爬豆瓣电影Top100&quot;&gt;&lt;a href=&quot;#代码：爬豆瓣电影Top100&quot; class=&quot;headerlink&quot; title=&quot;代码：爬豆瓣电影Top100&quot;&gt;&lt;/a&gt;代码：爬豆瓣电影Top100&lt;/h2&gt;&lt;h3 id=&quot;方式一：-re-urllib&quot;&gt;&lt;a href=&quot;#方式一：-re-urllib&quot; class=&quot;headerlink&quot; title=&quot;方式一： re   +  urllib&quot;&gt;&lt;/a&gt;方式一： &lt;a href=&quot;https://www.cnblogs.com/huxi/archive/2010/07/04/1771073.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;re&lt;/a&gt;   +  urllib&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;# _*_ coding:utf-8 _*_


&amp;apos;&amp;apos;&amp;apos;
&amp;lt;span class=&amp;quot;title&amp;quot;&amp;gt;肖申克的救赎&amp;lt;/span&amp;gt;
&amp;lt;em class=&amp;quot;&amp;quot;&amp;gt;1&amp;lt;/em&amp;gt;
&amp;apos;&amp;apos;&amp;apos;
import io
import sys
import re
from urllib.request import urlopen
sys.stdout = io.TextIOWrapper(sys.stdout.buffer,encoding=&amp;apos;gb18030&amp;apos;)
top_num = 1
url_base = &amp;apos;https://movie.douban.com/top250?start=&amp;apos;
urls = [url_base + str(i*25) for i in range(0,4)]
for url in urls:
    html = urlopen(url).read().decode(&amp;apos;utf-8&amp;apos;)
    top_tag = re.compile(r&amp;apos;&amp;lt;span class=&amp;quot;title&amp;quot;&amp;gt;(.*)&amp;lt;/span&amp;gt;&amp;apos;)
    title = re.findall(top_tag, html)
    for i in title:
        if i.find(&amp;apos;/&amp;apos;) == -1:
            print(&amp;apos;Top&amp;apos; + str(top_num) + &amp;apos; &amp;apos; + i)
            top_num += 1
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="python项目实战" scheme="http://www.chenfanlinux.org/categories/python%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="Python" scheme="http://www.chenfanlinux.org/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python项目实战之密码管理器</title>
    <link href="http://www.chenfanlinux.org/2018/03/13/Python%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B9%8B%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    <id>http://www.chenfanlinux.org/2018/03/13/Python项目实战之密码管理器/</id>
    <published>2018-03-13T07:34:52.000Z</published>
    <updated>2018-03-13T07:41:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h2><h3 id="写入密码"><a href="#写入密码" class="headerlink" title="写入密码"></a>写入密码</h3><pre><code>$  python .\zpass4.py -m w1 web, 2 server, 0 退出 1title:chenfanlinuxuser:chenfanpasswd:123456url:chenfanlinux.org{&apos;web&apos;: {&apos;chenfanlinux&apos;: {&apos;passwd&apos;: &apos;123456&apos;,                          &apos;url&apos;: &apos;chenfanlinux.org&apos;,                          &apos;user&apos;: &apos;chenfan&apos;}}}保存成功!$  python .\zpass4.py -m w1 web, 2 server, 0 退出 2title:tomcat01user:rootpasswd:123hostname:tomcat01-serverip:127.0.0.1{&apos;server&apos;: {&apos;tomcat01&apos;: {&apos;hostname&apos;: &apos;tomcat01-server&apos;,                         &apos;ip&apos;: &apos;127.0.0.1&apos;,                         &apos;passwd&apos;: &apos;123&apos;,                         &apos;user&apos;: &apos;root&apos;}}, &apos;web&apos;: {&apos;chenfanlinux&apos;: {&apos;passwd&apos;: &apos;123456&apos;,                          &apos;url&apos;: &apos;chenfanlinux.org&apos;,                          &apos;user&apos;: &apos;chenfan&apos;}}}保存成功!</code></pre><h3 id="查找密码"><a href="#查找密码" class="headerlink" title="查找密码"></a>查找密码</h3><pre><code>$ python .\zpass4.py -m r -c web -i chenfanlinux{&apos;passwd&apos;: &apos;123456&apos;, &apos;url&apos;: &apos;chenfanlinux.org&apos;, &apos;user&apos;: &apos;chenfan&apos;}</code></pre><h3 id="生成密码"><a href="#生成密码" class="headerlink" title="生成密码"></a>生成密码</h3><pre><code>$ python .\zpass4.py -m g -l 10CCrkoMjbhA</code></pre><a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># _*_ coding:utf8 _*_&apos;&apos;&apos;密码管理器:* 保存密码* 取密码密码数据保存格式:{ category: { title : value1} }{  &apos;web&apos; : {&quot;chenfanlinux&quot;: {&quot;user&quot;:&quot;chenfan&quot;,&quot;passwd&quot;:&quot;123456&quot;,&quot;url&quot;: &quot;www.chenfanlinux.org&quot;},           &quot;zhihu&quot;: {&quot;user&quot;: &quot;chenfan&quot;,&quot;passwd&quot;: &quot;123456&quot;,&quot;url&quot; : &quot;www.zhihu.com&quot;}          }, &apos;server&apos; :          { &quot;nginx&quot;:{ &quot;user&quot;: &quot;root&quot;,&quot;passwd&quot;: &quot;123456&quot;,&quot;hostname&quot;: &quot;localhost&quot;,&quot;ip&quot;: &quot;127.0.0.1&quot;},            &quot;tomcat&quot;:{&quot;user&quot;: &quot;chenfan&quot;,&quot;passwd&quot;: &quot;123&quot; ,&quot;hostname&quot;: &quot;tomcat01&quot;,&quot;ip&quot; : &quot;192.168.0.1&quot;}          }}* 密码存取方式:    * 写密码      python zpass.py w               user_choise ---&gt; 1(web),2(server),0(退出)      python zpass.py r category title&apos;&apos;&apos;import pickleimport sysimport pprintimport argparseimport stringimport randomparser = argparse.ArgumentParser()parser.add_argument(&apos;-m&apos;, action=&apos;store&apos;, dest=&apos;method&apos;,                    help=&apos;操作方式 w:写密码, r查找密码, g: 生成密码&apos;)parser.add_argument(&apos;-c&apos;, action=&apos;store&apos;, dest=&apos;category&apos;,                    help=&apos;类别&apos;)parser.add_argument(&apos;-i&apos;, action=&apos;store&apos;, dest=&apos;title&apos;,                    help=&apos;查找的名称&apos;)parser.add_argument(&apos;-l&apos;, type = int, action=&apos;store&apos;, dest=&apos;length&apos;,                    help=&apos;密码长度&apos;)args = parser.parse_args()def select_db():    try:        with open (&apos;passwd.zpass&apos;,&apos;rb&apos;) as f:            return pickle.load(f)    except IOError:        return False    except Exception as e:        raise edef insert_db(user_data):    try:        with open(&apos;passwd.zpass&apos;, &apos;wb&apos;) as f:            pickle.dump(user_data, f)    except IOError:        return False    except Exception as e:        raise e    return Trueclass Password(dict):    def __init__(self, category, title, user, passwd):        super().__init__()        self.title = title        self.category = category        self[title] = {&apos;user&apos;: user, &apos;passwd&apos;: passwd}    @staticmethod    def get_passwd():        passwd_data = select_db() if select_db()  else {}        return passwd_data.get(args.category).get(args.title)    def save_passwd(self):        passwd_data = select_db() if select_db()  else {}        if not passwd_data or self.category not in passwd_data:            passwd_data[self.category] = {}        passwd_data[self.category][self.title] = self[self.title]        pprint.pprint(passwd_data)        insert_status = insert_db(passwd_data)        if not insert_status:            print(&quot;保存失败&quot;)        return True    @classmethod    def get_item(cls):        cls.item = [&apos;title&apos;, &apos;user&apos;, &apos;passwd&apos;]        return cls.itemclass WebPassword(Password):    def __init__(self, category, title, user, passwd,url):        super().__init__(category, title, user, passwd)        self[title][&apos;url&apos;] = url    @classmethod    def get_item(cls):        super().get_item()        cls.item.append(&apos;url&apos;)        return cls.itemclass ServerPassWord(Password):    def __init__(self, category, title, user, passwd, hostname, ip):        super().__init__(category, title, user, passwd)        self[title][&apos;hostname&apos;] = hostname        self[title][&apos;ip&apos;] = ip    @classmethod    def get_item(cls):        super().get_item()        cls.item.append(&apos;hostname&apos;)        cls.item.append(&apos;ip&apos;)        return cls.itemdef handle_passwd():    passwd_args = {}    user_choice = input(&quot;1 web, 2 server, 0 退出 &quot;)    pwd_class =  {    &apos;1&apos; : (&apos;web&apos;, WebPassword),    &apos;2&apos; : (&apos;server&apos;, ServerPassWord)    }    category = pwd_class[user_choice][0]    handle_class = pwd_class[user_choice][1]    for i in handle_class.get_item():        passwd_args[i] = input(i + &quot;:&quot;)    pwd = handle_class(category=category, **passwd_args)    stat = pwd.save_passwd()    if stat is False:        print(&apos;保存失败!&apos;)    print(&apos;保存成功!&apos;)def gen_passwd(length):    chars = string.ascii_letters + string.digits + &quot;!@#$%^&amp;*():&quot;    return &apos;&apos;.join([random.choice(chars) for  i in range(length)])def main():    if args.method == &apos;r&apos;:        print(Password.get_passwd())    elif args.method == &apos;w&apos;:        handle_passwd()    elif args.method == &apos;g&apos;:        print(gen_passwd(args.length))    else:        print(&apos;退出&apos;)if __name__ == &apos;__main__&apos;:    main()</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;使用介绍&quot;&gt;&lt;a href=&quot;#使用介绍&quot; class=&quot;headerlink&quot; title=&quot;使用介绍&quot;&gt;&lt;/a&gt;使用介绍&lt;/h2&gt;&lt;h3 id=&quot;写入密码&quot;&gt;&lt;a href=&quot;#写入密码&quot; class=&quot;headerlink&quot; title=&quot;写入密码&quot;&gt;&lt;/a&gt;写入密码&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;$  python .\zpass4.py -m w
1 web, 2 server, 0 退出 1
title:chenfanlinux
user:chenfan
passwd:123456
url:chenfanlinux.org
{&amp;apos;web&amp;apos;: {&amp;apos;chenfanlinux&amp;apos;: {&amp;apos;passwd&amp;apos;: &amp;apos;123456&amp;apos;,
                          &amp;apos;url&amp;apos;: &amp;apos;chenfanlinux.org&amp;apos;,
                          &amp;apos;user&amp;apos;: &amp;apos;chenfan&amp;apos;}}}
保存成功!


$  python .\zpass4.py -m w
1 web, 2 server, 0 退出 2
title:tomcat01
user:root
passwd:123
hostname:tomcat01-server
ip:127.0.0.1
{&amp;apos;server&amp;apos;: {&amp;apos;tomcat01&amp;apos;: {&amp;apos;hostname&amp;apos;: &amp;apos;tomcat01-server&amp;apos;,
                         &amp;apos;ip&amp;apos;: &amp;apos;127.0.0.1&amp;apos;,
                         &amp;apos;passwd&amp;apos;: &amp;apos;123&amp;apos;,
                         &amp;apos;user&amp;apos;: &amp;apos;root&amp;apos;}},
 &amp;apos;web&amp;apos;: {&amp;apos;chenfanlinux&amp;apos;: {&amp;apos;passwd&amp;apos;: &amp;apos;123456&amp;apos;,
                          &amp;apos;url&amp;apos;: &amp;apos;chenfanlinux.org&amp;apos;,
                          &amp;apos;user&amp;apos;: &amp;apos;chenfan&amp;apos;}}}
保存成功!
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;查找密码&quot;&gt;&lt;a href=&quot;#查找密码&quot; class=&quot;headerlink&quot; title=&quot;查找密码&quot;&gt;&lt;/a&gt;查找密码&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;$ python .\zpass4.py -m r -c web -i chenfanlinux
{&amp;apos;passwd&amp;apos;: &amp;apos;123456&amp;apos;, &amp;apos;url&amp;apos;: &amp;apos;chenfanlinux.org&amp;apos;, &amp;apos;user&amp;apos;: &amp;apos;chenfan&amp;apos;}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;生成密码&quot;&gt;&lt;a href=&quot;#生成密码&quot; class=&quot;headerlink&quot; title=&quot;生成密码&quot;&gt;&lt;/a&gt;生成密码&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;$ python .\zpass4.py -m g -l 10
CCrkoMjbhA
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="python项目实战" scheme="http://www.chenfanlinux.org/categories/python%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="Python" scheme="http://www.chenfanlinux.org/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python进阶之函数式编程</title>
    <link href="http://www.chenfanlinux.org/2018/03/12/Python%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://www.chenfanlinux.org/2018/03/12/Python进阶之函数式编程/</id>
    <published>2018-03-12T15:00:58.000Z</published>
    <updated>2018-03-12T15:02:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>在函数式编程中，我们可以将函数当作变量一样自由使用。一个函数接收另一个函数作为参数，这种函数称之为<strong>高阶函数（Higher-order Functions）</strong>。</p><p>看一个简单的例子：</p><pre><code>def func(g, arr):    return [g(x) for x in arr]</code></pre><p>上面的代码中，func 是一个高阶函数，它接收两个参数，第 1 个参数是函数，第 2 个参数是数组，func 的功能是将函数 g 逐个作用于数组 arr 上，并返回一个新的数组，比如，我们可以这样用：</p><pre><code>def double(x):    return 2 * xdef square(x):    return x * xarr1 = func(double, [1, 2, 3, 4])arr2 = func(square, [1, 2, 3, 4])</code></pre><p>不难判断出，arr1 是 [2, 4, 6, 8]，arr2 是 [1, 4, 9, 16]。<br>可接收其他函数作为参数的函数称为高阶函数。</p><a id="more"></a><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>在 Python 中，我们使用 def 语句来定义函数，比如：</p><pre><code>&gt;&gt;&gt; def double(x):    return 2 * x</code></pre><p>除了用上面的方式定义函数，Python 还提供了一个关键字 lambda，让我们可以创建一个匿名函数，也就是没有名称的函数。它的形式如下：</p><pre><code>lambda 参数: 表达式</code></pre><p>关键字 lambda 说明它是一个匿名函数，冒号 : 前面的变量是该匿名函数的参数，冒号后面是函数的返回值，注意这里不需使用 return 关键字。</p><p>我们将上面的 double 函数改写成一个匿名函数，如下：</p><pre><code>lambda x: 2 * x</code></pre><p>那怎么调用匿名函数呢？可以直接这样使用：</p><pre><code>&gt;&gt;&gt; (lambda x: 2 * x)(8)16</code></pre><p>由于匿名函数本质上是一个函数对象，也可以将其赋值给另一个变量，再由该变量来调用函数，如下：</p><pre><code>&gt;&gt;&gt; f = lambda x: 2 * x   # 将匿名函数赋给变量 f&gt;&gt;&gt; f&lt;function &lt;lambda&gt; at 0x7f835a696578&gt;&gt;&gt;&gt; f(8)16</code></pre><p>lambda 函数一般适用于创建一些临时性的，小巧的函数。比如上面的 double 函数，我们当然可以使用 def 来定义，但使用 lambda 来创建会显得很简洁，尤其是在高阶函数的使用中。</p><ul><li>匿名函数本质上是一个函数，没有函数名称，因此使用匿名函数不用担心函数名冲突；</li><li>匿名函数一般适用于创建一些临时性的，小巧的函数。</li></ul><h2 id="map-reduce-filter"><a href="#map-reduce-filter" class="headerlink" title="map/reduce/filter"></a>map/reduce/filter</h2><p>map/reduce/filter 是 Python 中较为常用的内建高阶函数，它们为函数式编程提供了不少便利。</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map 函数的使用形式如下：</p><pre><code>map(function, sequence)</code></pre><p>解释：对 sequence 中的 item 依次执行 function(item)，并将结果组成一个 List 返回，也就是：</p><pre><code>[function(item1), function(item2), function(item3), ...]</code></pre><p>看一些简单的例子：</p><pre><code>&gt;&gt;&gt; def square(x):    return x * x&gt;&gt;&gt; list(map(square, [1, 2, 3, 4]))[1, 4, 9, 16]&gt;&gt;&gt; list(map(lambda x: x*x , [1, 2, 3, 4]))[1, 4, 9, 16]&gt;&gt;&gt; list(map(str, [1, 2, 3, 4]))[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;]&gt;&gt;&gt; list(map(int, [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;]))[1, 2, 3, 4]</code></pre><p>再看一个例子：</p><pre><code>&gt;&gt;&gt; def double(x):    return 2 * x&gt;&gt;&gt; def triple(x):    return 3 *x&gt;&gt;&gt; def square(x):    return x * x&gt;&gt;&gt; funcs = [double, triple, square]  # 列表元素是函数对象&gt;&gt;&gt;&gt;&gt;&gt; # 相当于 [double(4), triple(4), square(4)]value = list(map(lambda f: f(4), funcs))&gt;&gt;&gt;&gt;&gt;&gt; print(value)[8, 12, 16]&gt;&gt;&gt;</code></pre><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>reduce 函数的使用形式如下：</p><pre><code>reduce(function, sequence[, initial])</code></pre><p><strong>解释</strong>：先将 sequence 的前两个 item 传给 function，即 function(item1, item2)，函数的返回值和 sequence 的下一个 item 再传给 function，即 function(function(item1, item2), item3)，如此迭代，直到 sequence 没有元素，如果有 initial，则作为初始值调用。</p><p>也就是说：</p><pre><code>reduece(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</code></pre><p>看一些例子，就能很快理解了。</p><pre><code>&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; reduce(lambda x, y: x * y, [1, 2, 3, 4])  # 相当于 ((1 * 2) * 3) * 424&gt;&gt;&gt; reduce(lambda x, y: x * y, [1, 2, 3, 4], 5) # ((((5 * 1) * 2) * 3)) * 4120&gt;&gt;&gt; f = lambda a, b: a if (a &gt; b) else b   # 两两比较，取最大值&gt;&gt;&gt; reduce(f, [5, 8, 1, 10])10</code></pre><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>filter 函数用于过滤元素，它的使用形式如下：</p><pre><code>filter(function, sequnce)</code></pre><p><strong>解释</strong>：将 function 依次作用于 sequnce 的每个 item，即 function(item)，将返回值为 True 的 item 组成一个 List/String/Tuple (取决于 sequnce 的类型，python3 统一返回迭代器) 返回</p><pre><code>&gt;&gt;&gt; even_num = list(filter(lambda x: x % 2 == 0, [1, 2, 3, 4, 5, 6]))&gt;&gt;&gt; even_num[2, 4, 6]&gt;&gt;&gt; odd_num = list(filter(lambda x: x % 2, [1, 2, 3, 4, 5, 6]))&gt;&gt;&gt; odd_num[1, 3, 5]</code></pre><h2 id="携带状态的闭包"><a href="#携带状态的闭包" class="headerlink" title="携带状态的闭包"></a>携带状态的闭包</h2><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>在 Python 中，函数也是一个对象。因此，我们在定义函数时，可以再嵌套定义一个函数，并将该嵌套函数返回，比如：</p><pre><code>&gt;&gt;&gt; from math import pow&gt;&gt;&gt; def make_pow(n):        def inner_func(x): # 嵌套定义了 inner_func            return pow(x, n) # 注意这里引用了外部函数的n        return inner_func # 返回 inner_func</code></pre><p>上面的代码中，函数 make_pow 里面又定义了一个内部函数 inner_func，然后将该函数返回。因此，我们可以使用 make_pow 来生成另一个函数。</p><pre><code>&gt;&gt;&gt; pow2 = make_pow(2) # pow2 是一个函数,参数2是自由变量&gt;&gt;&gt; pow2&lt;function make_pow.&lt;locals&gt;.inner_func at 0x0000000003556488&gt;&gt;&gt;&gt; pow2(6)36.0</code></pre><p>我们还注意到，内部函数 inner_func 引用了外部函数 make_pow 的自由变量 n，这也就意味着，当函数 make_pow 的生命周期结束之后，n 这个变量依然会保存在 inner_func 中，它被 inner_func 所引用。</p><pre><code>&gt;&gt;&gt; del make_pow         # 删除 make_pow&gt;&gt;&gt; pow3 = make_pow(3)Traceback (most recent call last):  File &quot;&lt;pyshell#13&gt;&quot;, line 1, in &lt;module&gt;    pow3 = make_pow(3)NameError: name &apos;make_pow&apos; is not defined&gt;&gt;&gt; pow2(9)     # pow2 仍可正常调用，自由变量 2 仍保存在 pow2 中81.0</code></pre><p>像上面这种情况，一个函数返回了一个内部函数，该内部函数引用了外部函数的相关参数和变量，我们把该返回的内部函数称为闭包（Closure）。在上面的例子中，inner_func 就是一个闭包，它引用了自由变量 n。</p><h3 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h3><ul><li>闭包的最大特点就是引用了自由变量，即使生成闭包的环境已经释放，闭包仍然存在。</li><li>闭包在运行时可以有多个实例，即使传入的参数相同。</li></ul><p>实例：</p><pre><code>&gt;&gt;&gt; pow_a = make_pow(2)&gt;&gt;&gt; pow_b = make_pow(2)&gt;&gt;&gt; pow_a == pow_bFalse</code></pre><ul><li>利用闭包，我们还可以模拟类的实例。</li></ul><p>这里构造一个类，用于求一个点到另一个点的距离：</p><pre><code>from math import sqrtclass Point(object):    def __init__(self, x, y):        self.x, self.y = x, y    def get_distance(self, u, v):        distance = sqrt((self.x - u) ** 2 + (self.y - v) ** 2)        return distance&gt;&gt;&gt; pt = Point(7, 2)        # 创建一个点&gt;&gt;&gt; pt.get_distance(10, 6)  # 求到另一个点的距离5.0</code></pre><p>用闭包来实现：</p><pre><code>&gt;&gt;&gt; def point(x, y):    def get_distance(u, v):        return sqrt((x - u) ** 2 + (y - v) ** 2)    return get_distance&gt;&gt;&gt; pt = point(7, 2) # 自由变量 7,2&gt;&gt;&gt; pt(10, 6)5.0</code></pre><p>可以看到，结果是一样的，但使用闭包实现比使用类更加简洁。</p><h3 id="常见误区"><a href="#常见误区" class="headerlink" title="常见误区"></a>常见误区</h3><p>闭包的概念很简单，但实现起来却容易出现一些误区，比如下面的例子：</p><pre><code>def count():    funcs = []    for i in [1, 2, 3]:        def f():            return i        funcs.append(f)    return funcs</code></pre><p>在该例子中，我们在每次 for 循环中创建了一个函数，并将它存到 funcs 中。现在，调用上面的函数，你可能认为返回结果是 1, 2, 3，事实上却不是：</p><pre><code>&gt;&gt;&gt; f1, f2, f3 = count()&gt;&gt;&gt; f1()3&gt;&gt;&gt; f2()3&gt;&gt;&gt; f3()3</code></pre><p>为什么呢？原因在于上面的函数 f 引用了变量 i，但函数 f 并非立刻执行，当 for 循环结束时，此时变量 i 的值是3，funcs 里面的函数引用的变量都是 3，最终结果也就全为 3。</p><p>因此，我们应尽量避免在闭包中引用循环变量，或者后续会发生变化的变量。</p><p>那上面这种情况应该怎么解决呢？我们可以再创建一个函数，并将循环变量的值传给该函数，如下：</p><pre><code>def count():funcs = []for i in [1, 2, 3]:    def g(param):        f = lambda : param    # 这里创建了一个匿名函数        return f    funcs.append(g(i))        # 将循环变量的值传给 greturn funcs&gt;&gt;&gt; f1, f2, f3 = count()&gt;&gt;&gt; f1()1&gt;&gt;&gt; f2()2&gt;&gt;&gt; f3()3</code></pre><ul><li>闭包是携带自由变量的函数，即使创建闭包的外部函数的生命周期结束了，闭包所引用的自由变量仍会存在。</li><li>闭包在运行可以有多个实例。</li><li>尽量不要在闭包中引用循环变量，或者后续会发生变化的变量。</li></ul><h2 id="会打扮的装饰器"><a href="#会打扮的装饰器" class="headerlink" title="会打扮的装饰器"></a>会打扮的装饰器</h2><p>我们知道，在 Python 中，我们可以像使用变量一样使用函数：</p><ul><li>函数可以被赋值给其他变量</li><li>函数可以被删除</li><li>可以在函数里面再定义函数</li><li>函数可以作为参数传递给另外一个函数</li><li>函数可以作为另一个函数的返回</li></ul><p><strong>简而言之，函数就是一个对象。</strong></p><h3 id="对一个简单的函数进行装饰"><a href="#对一个简单的函数进行装饰" class="headerlink" title="对一个简单的函数进行装饰"></a>对一个简单的函数进行装饰</h3><p>为了更好地理解装饰器，我们先从一个简单的例子开始，假设有下面的函数：</p><pre><code>&gt;&gt;&gt; def hello():    return &apos;hello world&apos;</code></pre><p>现在我们想增强 hello() 函数的功能，希望给返回加上 HTML 标签，比如 <i>hello world</i>，但是有一个要求，不改变原来 hello() 函数的定义。这里当然有很多种方法，下面给出一种跟本文相关的方法：</p><pre><code>def makeitalic(func):    def wrapped():        return &quot;&lt;i&gt;&quot; + func() + &quot;&lt;/i&gt;&quot;    return wrapped</code></pre><p>在上面的代码中，我们定义了一个函数 makeitalic，该函数有一个参数 func，它是一个函数；在 makeitalic 函数里面我们又定义了一个内部函数 wrapped，并将该函数作为返回。</p><p>现在，我们就可以不改变 hello() 函数的定义，给返回加上 HTML 标签了：</p><pre><code>&gt;&gt;&gt; hello = makeitalic(hello)  # 将 hello 函数传给 makeitalic&gt;&gt;&gt; hello()&apos;&lt;i&gt;&lt;i&gt;hello world&lt;/i&gt;&lt;/i&gt;&apos;</code></pre><p>在上面，我们将 hello 函数传给 makeitalic，再将返回新功能函数 wrapped 赋给 hello，此时调用 hello() 就得到了我们想要的结果。</p><p>不过要注意的是，由于我们将 makeitalic 的返回赋给了 hello，此时 hello() 函数仍然存在，但是它的函数名不再是 hello 了，而是 wrapped，正是 makeitalic 返回函数的名称，可以验证一下：</p><pre><code>&gt;&gt;&gt; hello.__name__&apos;wrapped&apos;</code></pre><p>现在，我们梳理一下上面的例子，为了增强原函数 hello 的功能，我们定义了一个函数，它接收原函数作为参数，并返回一个新的函数，完整的代码如下：</p><pre><code>def makeitalic(func):    def wrapped():        return &quot;&lt;i&gt;&quot; + func() + &quot;&lt;/i&gt;&quot;    return wrappeddef hello():    return &apos;hello world&apos;hello = makeitalic(hello)</code></pre><p>事实上，makeitalic 就是一个装饰器（decorator），它『装饰』了函数 hello，并返回一个函数，将其赋给 hello。</p><p>一般情况下，我们使用装饰器提供的 @ 语法糖（Syntactic Sugar），来简化上面的写法：</p><pre><code>&gt;&gt;&gt; def makeitalic(func):    def wrapped():        return &quot;&lt;i&gt;&quot; + func() + &quot;&lt;/i&gt;&quot;    return wrapped&gt;&gt;&gt; @makeitalicdef hello():    return &apos;hello world&apos;</code></pre><p>像上面的情况，可以动态修改函数（或类）功能的函数就是装饰器。本质上，它是一个高阶函数，以被装饰的函数（比如上面的 hello）为参数，并返回一个包装后的函数（比如上面的 wrapped）给被装饰函数（hello）。</p><h3 id="装饰器的使用形式"><a href="#装饰器的使用形式" class="headerlink" title="装饰器的使用形式"></a>装饰器的使用形式</h3><p>1.装饰器的一般使用形式如下：</p><pre><code>@decoratordef func():    pass</code></pre><p>等价于下面的形式：</p><pre><code>def func():    passfunc = decorator(func)</code></pre><p>2.装饰器可以定义多个，离函数定义最近的装饰器先被调用，比如：</p><pre><code>@decorator_one@decorator_twodef func():    pass</code></pre><p>等价于：</p><pre><code>def func():    passfunc = decorator_one(decorator_two(func))</code></pre><p>3.装饰器还可以带参数，比如：</p><pre><code>@decorator(arg1, arg2)def func():    pass</code></pre><p>等价于：</p><pre><code>def func():    passfunc = decorator(arg1, arg2)(func)</code></pre><p>下面我们再看一些具体的例子，以加深对它的理解。</p><h3 id="对带参数的函数进行装饰"><a href="#对带参数的函数进行装饰" class="headerlink" title="对带参数的函数进行装饰"></a>对带参数的函数进行装饰</h3><p>前面的例子中，被装饰的函数 hello() 是没有带参数的，我们看看被装饰函数带参数的情况。对前面例子中的 hello() 函数进行改写，使其带参数，如下：</p><pre><code>&gt;&gt;&gt; def makeitalic(func):    def wrapped(*args, **kwargs):        ret = func(*args,**kwargs)        return &apos;&lt;i&gt;&apos; + ret + &apos;&lt;/i&gt;&apos;    return wrapped&gt;&gt;&gt; @makeitalicdef hello(name):    return &apos;hello %s&apos; % name&gt;&gt;&gt; @makeitalicdef hello2(name1, name2):    return &apos;hello %s, %s&apos; %(name1, name2)</code></pre><p>由于函数 hello 带参数，因此内嵌包装函数 wrapped 也做了一点改变：</p><ul><li>内嵌包装函数的参数传给了 func，即被装饰函数，也就是说内嵌包装函数的参数跟被装饰函数的参数对应，这里使用了 (<em>args, *</em>kwargs)，是为了适应可变参数。</li></ul><p>看看使用：</p><pre><code>&gt;&gt;&gt; hello(&apos;python&apos;)&apos;&lt;i&gt;hello python&lt;/i&gt;&apos;&gt;&gt;&gt; hello2(&apos;python&apos;, &apos;java&apos;)&apos;&lt;i&gt;hello python, java&lt;/i&gt;&apos;</code></pre><h3 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h3><p>上面的例子，我们增强了函数 hello 的功能，给它的返回加上了标签 <i></i>，现在，我们想改用标签 <b\></b\> 或 <p\></p\>。是不是要像前面一样，再定义一个类似 makeitalic 的装饰器呢？其实，我们可以定义一个函数，将标签作为参数，返回一个装饰器，比如：</p><pre><code>&gt;&gt;&gt; def wrap_in_tag(tag):    def decorator(func):        def wrapped(*args, **kwargs):            ret = func(*args, **kwargs)            return &apos;&lt;/&apos; + tag + &apos;&gt;&apos; + ret + &apos;&lt;/&apos; + tag + &apos;&gt;&apos;        return wrapped    return decorator</code></pre><p>现在，我们可以根据需要生成想要的装饰器了：</p><pre><code>&gt;&gt;&gt; makebold = wrap_in_tag(&apos;b&apos;)  # 根据 &apos;b&apos; 返回 makebold 生成器&gt;&gt;&gt; def hello(name):    return &apos;hello %s&apos; % name&gt;&gt;&gt; hello(&apos;world&apos;)&apos;hello world&apos;</code></pre><p>上面的形式也可以写得更加简洁：</p><pre><code>&gt;&gt;&gt; @wrap_in_tag(&apos;b&apos;)def hello(name):    return &apos;hello %s&apos; % name&gt;&gt;&gt; hello(&apos;world&apos;)&apos;&lt;/b&gt;hello world&lt;/b&gt;&apos;</code></pre><p>这就是带参数的装饰器，其实就是在装饰器外面多了一层包装，根据不同的参数返回不同的装饰器。</p><h3 id="多个装饰器"><a href="#多个装饰器" class="headerlink" title="多个装饰器"></a>多个装饰器</h3><p>现在，让我们来看看多个装饰器的例子，为了简单起见，下面的例子就不使用带参数的装饰器。</p><pre><code>&gt;&gt;&gt; def makebold(func):    def wrapped():        return &apos;&lt;b&gt;&apos; + func() + &apos;&lt;/b&gt;&apos;    return wrapped&gt;&gt;&gt;&gt;&gt;&gt; def makeitalic(func):    def wrapped():        return &apos;&lt;i&gt;&apos; + func() + &apos;&lt;/i&gt;&apos;    return wrapped&gt;&gt;&gt; @makebold@makeitalicdef hello():    return &apos;hello world&apos;&gt;&gt;&gt; hello()&apos;&lt;b&gt;&lt;i&gt;hello world&lt;/i&gt;&lt;/b&gt;&apos;</code></pre><p>上面定义了两个装饰器，对 hello 进行装饰，上面的最后几行代码相当于：</p><pre><code>def hello():    return &apos;hello world&apos;hello = makebold(makeitalic(hello))</code></pre><p>调用函数 hello：</p><pre><code>&gt;&gt;&gt; hello()&apos;&lt;b&gt;&lt;i&gt;hello world&lt;/i&gt;&lt;/b&gt;&apos;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;高阶函数&quot;&gt;&lt;a href=&quot;#高阶函数&quot; class=&quot;headerlink&quot; title=&quot;高阶函数&quot;&gt;&lt;/a&gt;高阶函数&lt;/h2&gt;&lt;p&gt;在函数式编程中，我们可以将函数当作变量一样自由使用。一个函数接收另一个函数作为参数，这种函数称之为&lt;strong&gt;高阶函数（Higher-order Functions）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;看一个简单的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def func(g, arr):
    return [g(x) for x in arr]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的代码中，func 是一个高阶函数，它接收两个参数，第 1 个参数是函数，第 2 个参数是数组，func 的功能是将函数 g 逐个作用于数组 arr 上，并返回一个新的数组，比如，我们可以这样用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def double(x):
    return 2 * x

def square(x):
    return x * x

arr1 = func(double, [1, 2, 3, 4])
arr2 = func(square, [1, 2, 3, 4])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不难判断出，arr1 是 [2, 4, 6, 8]，arr2 是 [1, 4, 9, 16]。&lt;br&gt;可接收其他函数作为参数的函数称为高阶函数。&lt;/p&gt;
    
    </summary>
    
      <category term="python进阶知识" scheme="http://www.chenfanlinux.org/categories/python%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Python" scheme="http://www.chenfanlinux.org/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python进阶之面向对象</title>
    <link href="http://www.chenfanlinux.org/2018/03/12/Python%E8%BF%9B%E9%98%B6%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://www.chenfanlinux.org/2018/03/12/Python进阶之面向对象/</id>
    <published>2018-03-12T08:30:27.000Z</published>
    <updated>2018-03-12T08:31:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类与实例"><a href="#类与实例" class="headerlink" title="类与实例"></a>类与实例</h2><ul><li>Python里的所有数据都是以对象形式存在的，无论是的简单的数字类型还是复杂的代码模块。然而，Python特殊的语法形式巧妙地将实现对象机制的大量细节隐藏起来。</li><li>对象既包含数据（变量，更习惯称之为特性，attribute），也包含代码（函数，也成为方法）。它是某一类具体事务的特殊实例。</li><li>当你想要创建一个别人从来没有创建过的新对象时，首先必须定义一个类，用以指明该类的对象所包含的内容（特性和方法）。</li><li>对象就是像是包含了代码的超级数据结构。</li></ul><h3 id="使用-class-定义类"><a href="#使用-class-定义类" class="headerlink" title="使用 class 定义类"></a>使用 class 定义类</h3><p>类是一个抽象的概念，我们可以把它理解为具有相同属性和方法的一组对象的集合，而实例则是一个具体的对象。</p><p>首先需要定义 Person 类作为生产对象的模具。在接下来的几个例子中，我们会不停更新这个类的内容，从最简单的开始，知道它成为一个可实际使用的类。</p><p>首先创建的是最简单的类，即一个没有任何内容的空类：</p><pre><code>&gt;&gt;&gt; class Person(object):    pass</code></pre><h3 id="类的实例化"><a href="#类的实例化" class="headerlink" title="类的实例化"></a>类的实例化</h3><p>同函数一样，用 pass 表示这个类是一个空类。上面这种定义类的方法已经是最简形式，无法再忽略。你可以通过类名来创建对象，同调用函数一样：</p><pre><code>&gt;&gt;&gt; someone = Person()  # 类实例化&gt;&gt;&gt;</code></pre><p>在这个例子中，Person()创建了一个Person类的对象，并给它赋值 someone 这个名字。但是，由于我们的Person类是空的，所以由它创建的对象 someone 实际上什么也做不了。实际编程中，你永远也不会创建这样一个没用的类，我在这里只是为了从零开始引出后面每一步的内容。</p><p>我们来试着重新定义一下 Person 类。这一次，将 Python 中特殊的对象初始化方法放入其中：</p><pre><code>&gt;&gt;&gt; class Person(object):    def __init__(self):        pass</code></pre><a id="more"></a><p>我承认 init() 和 self 看起来很奇怪，但这就是实际的Python类的定义形式。init() 是 Python 中一个特殊的函数名，用于根据类的定义创建实例对象。self参数指向了这个正在被创建的对象本身。</p><p>当你在类生命定义 init() 方法时，第一个参数必须为 self。尽管 self 并不是一个 Python 保留字，但它很常用。</p><p>尽管我们添加了初始化方法，但用这个 Person 类创建的对象仍然什么也做不了。接着我们在初始化方法中添加 name 参数：</p><pre><code>&gt;&gt;&gt; class Person(object):    def __init__(self, name):        self.name = name</code></pre><p>用 Person 类创建一个对象，为 name 特性传递一个字符串参数：</p><pre><code>hunter = Person(&quot;xiao ming&quot;)</code></pre><blockquote><p>python执行： Person.init(huter, “xiao ming”)<br>self 其实就是代表要实例化的对象，这个例子里是 hunter。</p></blockquote><p>上面这短短的一行代码实际做了以下工作：</p><ul><li>查看 Person 类的定义</li><li>在内存中实例化（创建）一个新的对象</li><li>调用对象的 init 方法， 将这个新创建的对象作为 self 传入，并将另一个参数（’xiao ming’）作为 name 传入</li><li>将 name 的值存入对象</li><li>返回这个新的对象</li><li>将名字 hunter 与这个对象关联</li></ul><p>这个新对象与任何其他的python对象一样。 你可以把它当作列表、元组、字典或集合中的元素，也可以把它当作参数传递给函数，或者把它作为函数的返回结果。</p><p>我们传入的 name 参数 作为对象的特性存储在了对象里。可以直接对它进行读写操作：</p><pre><code>&gt;&gt;&gt; print(&apos;The mighty hunter: &apos;, hunter.name)The mighty hunter:  xiao ming</code></pre><p>记住，在 Person 类定义的内部， 你可以直接通过 self.name 访问 name 特性。 而当创建了一个实际的对象后，例如这里的 hunter，需要通过 hunter.name 来访问他。</p><p>在类的定义中， init 并不是必需的。只有当需要区分由该类创建的不同对象时，才需要指定 init 方法。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>在你编写代码解决实际问题时，经常能找到一些已有的类，它们能够实现你所需的大部分功能，但不是全部。这时该怎么办？当然，你可以对这个已有的类进行修改，但这么做很容易让代码变得更加复杂，一不留神就可能会破坏原来可以正常工作的功能,应该遵循 <strong><em>多继承类，少修改类原则。</em></strong></p><p>当然，也可以另起炉灶重新编写一个类：复制粘贴原来的代码再融入自己的新代码。但这意味着你需要维护更多的代码。同时，新类和旧类中实现同样功能的代码被分隔在了不同的地方（日后修改时需要改动多处）。</p><p>更好的解决方法是利用类的继承：从已有类中衍生出新的类，添加和修改部分功能。这是代码复用的一个绝佳的例子。使用继承得到的新类会自动获得旧类中的多有方法，而不需要进行任何复制。</p><p>你只需要在新类里面定义自己额外需要的方法，或者按照需求对继承的方法进行修改即可。修改得到的新方法会覆盖原有的方法。我们习惯将原始的类称为父类、超类或基类，将新的类称作孩子类、子类或衍生类。这些术语在面向对象的编程中不加以区分。</p><p>现在，我们来试试继承。首先，定义一个空类 Car。然后，定义一个 Car 的子类 Tesla。定义子类使用的也是 class 关键字，不过需要把父类的名字放在子类名字后面的括号里：</p><pre><code>&gt;&gt;&gt; class Car(object):    pass&gt;&gt;&gt; class Tesla(Car):    pass</code></pre><p>接着，为每个类创建一个实例对象:</p><pre><code>&gt;&gt;&gt; give_me_a_car = Car()&gt;&gt;&gt; give_me_a_tesla = Tesla()</code></pre><p>子类是父类的一种特殊情况，它属于父类。在面向对象的术语里，我们经常将 Tesla 看作是一个 Car。 对象 give_me_a_tesla 是 Tesla 类的一个实例，但它同时集成了 Car 能做到的所有事情。当然，上面的例子中 Car 和 Tesla 就像潜艇上的甲板水手一样起不到任何实际作用。我们来更新一下类的定义，让它们发挥点儿作用。</p><pre><code>&gt;&gt;&gt; class Car():    def exclaim(self):        print(&quot;I&apos;m a Car!&quot;)&gt;&gt;&gt; class Tesla(Car):    pass</code></pre><p>最后，为每一个类各创建一个对象，并调用刚刚声明的 exclaim 方法：</p><pre><code>&gt;&gt;&gt; give_me_a_car.exclaim()I&apos;m a Car!&gt;&gt;&gt; give_me_a_tesla.exclaim()I&apos;m a Car!&gt;&gt;&gt; isinstance(give_me_a_tesla,Car) # give_True&gt;&gt;&gt; isinstance(give_me_a_tesla,Tesla)True</code></pre><p>我们不需要进行任何特殊的操作，Tesla 就自动从 Car 那里继承了 exclaim() 方法。但事实上，我们并不希望 Tesla 在 exclaim() 方法里面宣称它是一个 Car，这可能会造成无法区分 Car 和 Tesla。让我们来看看怎么解决这个问题。</p><h3 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h3><p>新创建的子类会自动继承父类的所有信息。接下来我们来看子类如何替代——覆盖（override）父类的方法。</p><pre><code>&gt;&gt;&gt; class Car():    def exclaim(self):        print(&quot;I&apos;m a Car!&quot;)&gt;&gt;&gt; class Tesla(Car):    def exclaim(self):        print(&quot;I&apos;m a Tesla!&quot;)</code></pre><p>为每个类创建一个对象：</p><pre><code>&gt;&gt;&gt; give_me_a_car = Car()&gt;&gt;&gt; give_me_a_tesla = Tesla()</code></pre><p>执行看下结果：</p><pre><code>&gt;&gt;&gt; give_me_a_car.exclaim()I&apos;m a Car!&gt;&gt;&gt; give_me_a_tesla.exclaim()I&apos;m a Tesla!</code></pre><p>我们覆盖了父类的 exclaim() 方法。 在子类中，可以覆盖任何父类的方法，包括 <strong>init()</strong>。下面我们使用之前的 Person 类。我们来创建两个子类，分别代表医生(MDPerson)和律师（JDPerson）。</p><pre><code>&gt;&gt;&gt; class Person():    def __init__(self, name):        self.name = name&gt;&gt;&gt; class MDPerson(Person):    def __init__(self, name):        self.name = &quot;Doctor&quot; + name&gt;&gt;&gt; class JDPerson(Person):    def __init__(self, name):        self.name = name + &quot;, Esquire&quot;</code></pre><p>在上面的例子中，子类的初始化方法 init() 接受的参数和父类 Person 一样，但存储到对象内部 name 特性的值却不尽相同：</p><pre><code>&gt;&gt;&gt; print(person.name)Fudd&gt;&gt;&gt; print(doctor.name)DoctorFudd&gt;&gt;&gt; print(lawyer.name)Fudd, Esquire</code></pre><h3 id="添加新方法"><a href="#添加新方法" class="headerlink" title="添加新方法"></a>添加新方法</h3><p>子类还可以添加父类中没有的方法。回到 Car 类 和 Tesla 类，我们给 Tesla 类添加一个新的方法 need_a_push()</p><pre><code>&gt;&gt;&gt; class Car():    def exclaim(self):        print(&quot;I&apos;m a Car!&quot;)&gt;&gt;&gt; class Tesla(Car):    def exclaim(self):        print(&quot;I&apos;m a Tesla!&quot;)    def need_a_push(self):        print(&quot;A little help here?&quot;)</code></pre><p>接着创建一个 Car 和一个 Tesla 对象：</p><pre><code>&gt;&gt;&gt; give_me_a_car = Car()&gt;&gt;&gt; give_me_a_tesla = Tesla()</code></pre><p>Tesla 类的对象可以响应 need_a_push()方法：</p><pre><code>&gt;&gt;&gt; give_me_a_tesla.need_a_push()A little help here?</code></pre><p>但父类 Car 无法使用该方法：</p><pre><code>&gt;&gt;&gt; give_me_a_car.need_a_push()Traceback (most recent call last):  File &quot;&lt;pyshell#17&gt;&quot;, line 1, in &lt;module&gt;    give_me_a_car.need_a_push()AttributeError: &apos;Car&apos; object has no attribute &apos;need_a_push&apos;</code></pre><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>我们已经知道如何在子类中覆盖父类的方法，但如果想要调用父类的方法就要使用 super()。下面的例子将新定义一个新的类 EmailPerson，用于表示有电子邮箱的 Person。首先，来定义熟悉的Person类。</p><pre><code>&gt;&gt;&gt; class Person():    def __init__(self, name):        self.name = name</code></pre><p>下面是子类的定义。注意，子类的初始化方法 init() 中添加了一个额外的 email 参数：</p><pre><code>&gt;&gt;&gt; class EmailPerson(Person):    def __init__(self, name, email):        super().__init__(name)        self.email = email</code></pre><p>在子类中定义 init() 方法时，父类的 init() 方法会被覆盖。<strong><em>因此在子类中父类的初始化方法并不会被自动调用，我们必须显式调用它。</em></strong>以上代码实际上做了这样几件事情：</p><ul><li>通过 super() 方法获取了父类 Person 的定义。</li><li>子类的 init() 调用了 Person.init() 方法。它会自动将 self 参数传递给父类。因此，你只需传入其余参数即可。在上面的例子中，Person() 能接受的其余参数指的是 name。</li><li>self.email = email 这行新的代码才真正起到了将 EmailPerson 与 Person 区分开的作用。</li></ul><p>接下来，创建一个 EmailPerson 类的对象：</p><pre><code>&gt;&gt;&gt; bob = EmailPerson(&apos;Bob Frapples&apos;, &apos;bob@frapples.com&apos;)</code></pre><p>我们既可以访问 name 特性，也可访问 email 特性：</p><pre><code>&gt;&gt;&gt; bob.name&apos;Bob Frapples&apos;&gt;&gt;&gt; bob.email&apos;bob@frapples.com&apos;</code></pre><p>为什么不像下面这样定义 EmailPerson 类呢？</p><pre><code>class EmailPerson(Person):     def __init__(self, name, email):         self.name = name        self.email = email</code></pre><p>确实可以这么做，但这有悖我么使用继承的初衷。我们应该使用 super() 来让 Person 完成他应该做的事情，就像任何一个单纯的 Person 对象一样。除此之外，不这么写还有另一个好处，如果 Person 类的定义在未来发生改变，使用 super() 可以保证这些改变会自动体现在 EmailPersion类上，而不需要手动修改。</p><p>子类可以按照自己的方式处理问题，但如果人需要借助父类的帮助，使用 super() 是最佳的选择。</p><h2 id="特性访问限制"><a href="#特性访问限制" class="headerlink" title="特性访问限制"></a>特性访问限制</h2><h3 id="使用名称重整保护私有特性"><a href="#使用名称重整保护私有特性" class="headerlink" title="使用名称重整保护私有特性"></a>使用名称重整保护私有特性</h3><p>Python 对那些需要刻意隐藏在类内部的特性有自己的命名规范：由连续的两个下划线开头（_）。</p><pre><code>&gt;&gt;&gt; class Duck():    def __init__(self, input_name):        self.__name = input_name    @property    def name(self):        print(&apos;inside the getter&apos;)        return self.__name    @name.setter    def name(self, input_name):        print(&apos;inside the setter&apos;)        self.__name = input_name</code></pre><p>看看代码是否还能正常工作：</p><pre><code>&gt;&gt;&gt; fowl = Duck(&apos;Howard&apos;)&gt;&gt;&gt; fowl.nameinside the getter&apos;Howard&apos;&gt;&gt;&gt; fowl.name = &apos;Donald&apos;inside the setter&gt;&gt;&gt; fowl.nameinside the getter&apos;Donald&apos;</code></pre><p>看起来没问题，现在，你无法在外部访问 __name 特性了：</p><pre><code>&gt;&gt;&gt; fowl.__nameTraceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &apos;Duck&apos; object has no attribute &apos;__name&apos;</code></pre><p>这种命名规范本质上并没有把特性变成私有，但Python确实将它的名字重整了。让外部的代码无法使用。如果你是在好奇名称重整是怎么实现的。我可以偷偷告诉你其中的奥秘：</p><pre><code>&gt;&gt;&gt; fowl._Duck__name&apos;Howard&apos;</code></pre><p>发现了么？我们并没有得到 inside the getter，成功绕过了 getter 方法。尽管如我们所见，这种保护特性的方式并不完美，但它确实能在一定程度上避免我们无意或有意地对特性进行直接访问。</p><h3 id="使用-property"><a href="#使用-property" class="headerlink" title="使用 @property"></a>使用 @property</h3><p>@property 把方法『变成』了属性。在使用 @property 之前，让我们先来看一个简单的例子：</p><pre><code>&gt;&gt;&gt; e = Exam(60)&gt;&gt;&gt; e._score60&gt;&gt;&gt; e.set_score(70)&gt;&gt;&gt; e.get_score()70</code></pre><p>在上面，我们定义了一个 Exam 类，为了避免直接对 _score 特性操作，我们提供了 get_score 和 set_score 方法，这样起到了封装的作用，把一些不想对外公开的属性隐蔽起来，而只是提供方法给用户操作，在方法里面，我们可以检查参数的合理性等。</p><p>这样做没什么问题，但是我们有更简单的方式来做这件事，Python 提供了 property 装饰器，被装饰的方法，我们可以将其『当作』属性来用，看下面的例子:</p><pre><code>&gt;&gt;&gt; class Exam():    def __init__(self, score):        self.score = score    @property    def score(self):        return self._score    @score.setter    def score(self,var):        if var &lt; 0:            self._score = 0        elif var &gt; 100:            self._score = 100        else:            self._score = var&gt;&gt;&gt; e = Exam(60)&gt;&gt;&gt; e.score60&gt;&gt;&gt; e.score = 90&gt;&gt;&gt; e.score90&gt;&gt;&gt; e.score = 200&gt;&gt;&gt; e.score100</code></pre><p>在上面，我们给方法 score 加上了 @property，于是我们可以把 score 当成一个属性来用，此时，又会创建一个新的装饰器 score.setter，它可以把被装饰的方法变成属性来赋值。</p><p>另外，我们也不一定要使用 score.setter 这个装饰器，这时 score 就变成一个只读属性了：</p><pre><code>class Exam(object):    def __init__(self, score):        self._score = score    @property    def score(self):        return self._score&gt;&gt;&gt; e = Exam(60)&gt;&gt;&gt;&gt;&gt;&gt; e.score60&gt;&gt;&gt; e.score = 200Traceback (most recent call last):  File &quot;&lt;pyshell#31&gt;&quot;, line 1, in &lt;module&gt;    e.score = 200AttributeError: can&apos;t set attribute</code></pre><h2 id="方法的类型"><a href="#方法的类型" class="headerlink" title="方法的类型"></a>方法的类型</h2><p>有些数据（特性）和函数（方法）是类本身的一部分，还有一些是由类创建的实例的一部分。</p><p>在类的定义中，以 self 作为第一个参数的方法都是实例方法（instance method）。它们在创建自定义类时最常用。实例方法的首个参数是 self，当它被调用时，Python 会把调用该方法的对象作为 self 参数传入。</p><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p>与之相对，类方法（class method）会作用于整个类，对类作出的任何改变会对它的所有实例对象产生影响。在类定义内部，用前缀修饰符 @classmethod 指定的方法都是类方法。与实例方法相似，类方法的第一个参数是类本身。在Python中，这个采纳数常被写作 cls，因为全称 class 是保留字，在这里我们无法使用。下面的例子中，我们为A定义一个类方法来记录一共有多少个类A的对象被创建：</p><pre><code>&gt;&gt;&gt; class A():    count = 0 # 类属性    def __init__(self):        A.count += 1    def exclaim(self):        print(&quot;I&apos;m an A!&quot;)    @classmethod # 类方法    def kids(cls):        print(&quot;A has&quot;, cls.count, &quot;little objects.&quot;)&gt;&gt;&gt; easy_a = A()&gt;&gt;&gt; breezy_a = A()&gt;&gt;&gt; wheezy_a = A()&gt;&gt;&gt; A.kids()A has 3 little objects.</code></pre><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>类定义中的方法还存在着第三种类型，它既不会影响类也不会影响类的对象。他们出现在类的定义中仅仅是为了方便，否则他们只能孤零零地出现在代码的其他地方，这会影响代码的逻辑性。这种类型的方法被称作静态方法（static method），用 @staticmethod 修饰， 它既不需要 self 参数 也不需要 class 参数。 下面列子中的静态方法是一则 CoyoteWeapon的广告：</p><pre><code>&gt;&gt;&gt; class CoyoteWeapop():    @staticmethod    def commercial():        print(&apos;This CoyoteWeapon has been brought to you by Acme&apos;)&gt;&gt;&gt; CoyoteWeapop.commercial()This CoyoteWeapon has been brought to you by Acme</code></pre><p><strong><em>注意,在这个例子中,我们甚至都不用创建任何 CoyoteWeapon 类的对象就可以调用这个方法,语法优雅不失风格！</em></strong></p><h2 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h2><p>Python 对实现多态（polymorphism）要求得十分宽松，这意味着我们可以对不同对象调用同名的操作，甚至与用管这些对象的类型是什么。</p><p>我们来为上那个 Quote 类设定同样的初始化方法 init()，然后再添加两个新函数：</p><ul><li>who() 返回保存的 person 字符串的值</li><li>says() 返回保存的 words 字符串的内容，并添上指定的表点符号</li></ul><p>例子如下:</p><pre><code>&gt;&gt;&gt; class Quote():    def __init__(self, person, words):        self.person = person        self.words = words    def who(self):        return self.person    def says(self):        return self.words + &apos;.&apos;&gt;&gt;&gt; class QuestionQuote(Quote):    def says(self):        return self.words + &apos;?&apos;&gt;&gt;&gt; class ExclamationQuote(Quote):    def says(self):        return self.words + &apos;!&apos;</code></pre><p>我们不需要改变 QuestionQuote 或者 ExclamQuote 的初始化方式，因此没有覆盖它们的 init()方法。Python 会自动调用父类 Quote 的初始化函数 init() 来存储实例变量 person 和 words，这就是我们可以在子类 QuestionQuote 和 ExclamationQuote 的对象里访问 self.words 的原因。</p><p>接下来创建一些对象：</p><pre><code>&gt;&gt;&gt; hunter = Quote(&apos;Elmer Fudd&apos;, &quot;I&apos;m hunting rabbits&quot;)&gt;&gt;&gt; print(hunter.who(), &apos;says:&apos;, hunter.says())Elmer Fudd says: I&apos;m hunting rabbits.&gt;&gt;&gt; hunted1 = QuestionQuote(&apos;Bugs Bunny&apos;, &quot;What&apos;s up, doc&quot;)&gt;&gt;&gt; print(hunted1.who(), &apos;says:&apos;, hunted1.says())Bugs Bunny says: What&apos;s up, doc?&gt;&gt;&gt; print(hunted2.who(), &apos;says:&apos;, hunted2.says())Daffy Duck says: It&apos;s rabbit season!</code></pre><p>三个不同版本的 says() 为上面三种类型提供了不同的相应方式，这是面向对象的语言中多态的传统形式。Python 在这方面走的更远一些，无论对象的种类是什么，只要包含 who() 和 says()，你便可以调用它。我们再来定义一个 BabblingBrook 类，他与我们之前的猎人猎物（Quote 类的后代）什么的没有任何关系：</p><pre><code>&gt;&gt;&gt; class BabblingBrook():    def who(self):        return &apos;Brook&apos;    def says(self):        return &apos;Babble&apos;</code></pre><p>现在，对不同对象执行 who() 和 says() 方法，其中有一个（brook） 与其他类型的对象毫无关联：</p><pre><code>&gt;&gt;&gt; who_says(hunter)Elmer Fudd says I&apos;m hunting rabbits.&gt;&gt;&gt; who_says(hunted1)Bugs Bunny says What&apos;s up, doc?&gt;&gt;&gt; who_says(hunted2)Daffy Duck says It&apos;s rabbit season!&gt;&gt;&gt; who_says(brook)Brook says Babble</code></pre><p>这种方式有事被称作鸭子类型（duck typing），这个命名源自一句名言：</p><pre><code>如果它想鸭子一样走路，像样子一样叫，那么它就是一直鸭子。</code></pre><h2 id="特殊方法-方法重构"><a href="#特殊方法-方法重构" class="headerlink" title="特殊方法 (方法重构)"></a>特殊方法 (方法重构)</h2><p>到目前为止，你已经能创建并使用基本对象了。现在再往深钻研一些。</p><p>当我们输入像 a = 3 + 8 这样的表达式时，整数 3 和 8 怎么知道如何实现 + 的？ 同样， a 又是怎么知道如何使用 = 来获取计算结果的？ 你可以使用 Python 的特殊方法（special method），有时魔术方法（magic method）， 来实现这些操作符的功能。别担心，它们一点也不复杂。</p><p>这些特殊的方法的名称以双下划线()开头和结束。没错，你已经见过其中一个：<br><code>__init__</code>，它根据类的定义以及传入的参数对新创建的对象进行初始化。</p><p>假设你有一个简单的 Word 类，现在想要添加一个 equals() 方法来比较两个词是否一致，忽略大小写。也就是说，一个包含值 ‘ha’ 的 Word 对象与包含 ‘HA’ 的是相同的。</p><p>下面的代码是第一次尝试，创建一个普通方法 equals()。self.text 是当前 Word 对象所包含的字符串文本，equals() 方法将该字符串与 words （另一个 Word 对象）所包含的字符串做比较：</p><pre><code>&gt;&gt;&gt; class Word():    def __init__(self, text):        self.text = text    def equals(self, word2):        return self.text.lower() == word2.text.lower()</code></pre><p>接着创建三个包含不通字符串的 Word 对象：</p><pre><code>&gt;&gt;&gt; first = Word(&apos;ha&apos;)&gt;&gt;&gt; second = Word(&apos;HA&apos;)&gt;&gt;&gt; third = Word(&apos;eh&apos;)</code></pre><p>当字符串 ‘ha’ 和 ‘HA’ 被转换为小写形式再进行比较时（我们就是这么做的），他们应该是相等的：</p><pre><code>&gt;&gt;&gt; first.equals(second)True</code></pre><p>但字符串 ‘eh’ 无论如何与 ‘ha’也不会相等：</p><pre><code>&gt;&gt;&gt; first.equals(third)False</code></pre><p>我们成功定义了 equals() 方法进行小写转换并比较。但试想一下，如果能通过 first == second 进行比较的话岂不更妙？这样类会更自然，表现得更像一个 Python 内置的类。 好的，我们来试一下，把前面例子中的 equals() 方法的名称改为 eq() ：</p><pre><code>&gt;&gt;&gt; class Word():    def __init__(self,text):        self.text = text    def __eq__(self,word2):        return self.text.lower() == word2.text.lower()</code></pre><p>修改就此结束，来看看新的版本能否正常工作：</p><pre><code>&gt;&gt;&gt; first == secondTrue&gt;&gt;&gt; first == thirdFalse</code></pre><p>太神奇了！是不是如同魔术一般？仅需将方法名改为 Python 里进行相等比较的特殊方法名 eq() 即可。下面列出一些常用的魔术方法：</p><p>和比较相关的魔术方法</p><p><img src="https://s1.ax1x.com/2018/03/12/9fn3He.png" alt="比较相关的魔术方法"></p><p>和数学相关的魔术方法</p><p><img src="https://s1.ax1x.com/2018/03/12/9fnY4A.png" alt="数学相关的魔术方法"></p><p>不仅数字类型可以使用像 + （魔术方法 add()）和 - （魔术方法 sub()）的数学运算符，一些其他的类型也可以使用。例如，Python 的字符类型使用 + 进行拼接，使用 * 进行复制。</p><p>字符串常见的魔术方法如下：</p><p><img src="https://s1.ax1x.com/2018/03/12/9fndjf.png" alt="字符串模式方法"></p><p>除了 init() 外，你会发现在编写类方法时最常用到的是 str()，他用于定义如何打印对象信息。print() 方法，str() 方法以及一些字符串格式化的相关方法都会用到 str()。交互式解释器则用 repr() 方法输出变量。如果在你的类既没有定义 str() 也没有定义 repr(), Python会输出类似下面这样的默认字符串：</p><pre><code>&gt;&gt;&gt; first = Word(&apos;ha&apos;)&gt;&gt;&gt; first&lt;__main__.Word object at 0x0000000003561EB8&gt;&gt;&gt;&gt; print(first)&lt;__main__.Word object at 0x0000000003561EB8&gt;</code></pre><p>我们将 str() 和 repr() 方法都添加到 Word 类里，让输出的对象信息变得更好看些：</p><pre><code>&gt;&gt;&gt; class Word():    def __init__(self, text):        self.text = text    def __eq__(self, word2):        return self.text.lower() == word2.text.lower()    def __str__(self):        return self.text    def __repr__(self):        return &apos;Word(&apos; + self.text + &apos;)&apos;&gt;&gt;&gt; first = Word(&apos;ha&apos;)&gt;&gt;&gt; firstWord(ha)&gt;&gt;&gt; print(first)ha</code></pre><p>更多关于 <a href="(https://docs.python.org/3/reference/datamodel.html#special-method-names">魔术方法</a>) 的内容请查看 Python 文档</p><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>如果你想要创建的子类在大多数情况下的行为都和父类相似的话，使用继承是非常不错的选择，建立复杂的继承关系确实很吸引人，但有些时候使用组合（composition）或者聚合（aggregation）更加符合现实的逻辑。一只鸭子是鸟的一种，它有一条尾巴。尾巴并不是鸭子的一种，它是鸭子的组成部分。</p><pre><code>&gt;&gt;&gt; class Tail():    def __init__(self, length):        self.length = length&gt;&gt;&gt; class Bill():    def __init__(self, description):        self.description = description&gt;&gt;&gt; class Duck():    def __init__(self, bill, tail):        self.bill = bill        self.tail = tail    def about(self):        print(&apos;This duck has a&apos;, bill.description, &apos;bill and a&apos;, tail.length, &apos;tail&apos;)tail = Tail(&apos;long&apos;)bill = Bill(&apos;wide orange&apos;)duck = Duck(bill, tail)duck.about()</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类与实例&quot;&gt;&lt;a href=&quot;#类与实例&quot; class=&quot;headerlink&quot; title=&quot;类与实例&quot;&gt;&lt;/a&gt;类与实例&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Python里的所有数据都是以对象形式存在的，无论是的简单的数字类型还是复杂的代码模块。然而，Python特殊的语法形式巧妙地将实现对象机制的大量细节隐藏起来。&lt;/li&gt;
&lt;li&gt;对象既包含数据（变量，更习惯称之为特性，attribute），也包含代码（函数，也成为方法）。它是某一类具体事务的特殊实例。&lt;/li&gt;
&lt;li&gt;当你想要创建一个别人从来没有创建过的新对象时，首先必须定义一个类，用以指明该类的对象所包含的内容（特性和方法）。&lt;/li&gt;
&lt;li&gt;对象就是像是包含了代码的超级数据结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;使用-class-定义类&quot;&gt;&lt;a href=&quot;#使用-class-定义类&quot; class=&quot;headerlink&quot; title=&quot;使用 class 定义类&quot;&gt;&lt;/a&gt;使用 class 定义类&lt;/h3&gt;&lt;p&gt;类是一个抽象的概念，我们可以把它理解为具有相同属性和方法的一组对象的集合，而实例则是一个具体的对象。&lt;/p&gt;
&lt;p&gt;首先需要定义 Person 类作为生产对象的模具。在接下来的几个例子中，我们会不停更新这个类的内容，从最简单的开始，知道它成为一个可实际使用的类。&lt;/p&gt;
&lt;p&gt;首先创建的是最简单的类，即一个没有任何内容的空类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class Person(object):
    pass
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;类的实例化&quot;&gt;&lt;a href=&quot;#类的实例化&quot; class=&quot;headerlink&quot; title=&quot;类的实例化&quot;&gt;&lt;/a&gt;类的实例化&lt;/h3&gt;&lt;p&gt;同函数一样，用 pass 表示这个类是一个空类。上面这种定义类的方法已经是最简形式，无法再忽略。你可以通过类名来创建对象，同调用函数一样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; someone = Person()  # 类实例化
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在这个例子中，Person()创建了一个Person类的对象，并给它赋值 someone 这个名字。但是，由于我们的Person类是空的，所以由它创建的对象 someone 实际上什么也做不了。实际编程中，你永远也不会创建这样一个没用的类，我在这里只是为了从零开始引出后面每一步的内容。&lt;/p&gt;
&lt;p&gt;我们来试着重新定义一下 Person 类。这一次，将 Python 中特殊的对象初始化方法放入其中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class Person(object):
    def __init__(self):
        pass
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="python进阶知识" scheme="http://www.chenfanlinux.org/categories/python%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Python" scheme="http://www.chenfanlinux.org/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python基础之推导式</title>
    <link href="http://www.chenfanlinux.org/2018/02/28/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%A8%E5%AF%BC%E5%BC%8F/"/>
    <id>http://www.chenfanlinux.org/2018/02/28/Python基础之推导式/</id>
    <published>2018-02-28T04:19:12.000Z</published>
    <updated>2018-02-28T04:20:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h2><blockquote><p>推导式是从一个或者多个迭代器快速简洁地创建数据结构的一种方法。它可以加循环和条件判断结合，从而避免语法冗长的代码。会使用推导式有时可以说明你已经超过 Python初学者的水平。也就是说，使用推导式更像 Python 风格。</p></blockquote><h3 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h3><p>你可以从1到5创建一个整数列表，每次增加一项：</p><pre><code>&gt;&gt;&gt; number_list = []&gt;&gt;&gt; number_list.append(1)&gt;&gt;&gt; number_list.append(2)&gt;&gt;&gt; number_list.append(3)&gt;&gt;&gt; number_list.append(4)&gt;&gt;&gt; number_list.append(5)&gt;&gt;&gt; number_list[1, 2, 3, 4, 5]</code></pre><p>或者，可以结合 range() 函数使用一个迭代器：</p><pre><code>&gt;&gt;&gt; number_list = []&gt;&gt;&gt; for number in range(1, 6):    number_list.append(number)&gt;&gt;&gt; number_list[1, 2, 3, 4, 5]</code></pre><p>上面这些方法都是可行的Python代码，会得到相同的结果。然而，更像 Python 风格的创建列表方法是列表推导。语法如下：</p><pre><code>[ expression for item in iterable ]</code></pre><p>将通过列表推导创建一个整数列表：</p><pre><code>&gt;&gt;&gt; number_list = [number for number in range(1,6)]&gt;&gt;&gt; number_list[1, 2, 3, 4, 5]</code></pre><p>在第一行中，第一个 number 变量为列表生成值，也就是说，把循环的结果放在列表 number_list 中。 第二个 number 可以为表达式， 看下下面的例子：</p><pre><code>&gt;&gt;&gt; number_list = [number-1 for number in range(1, 6)]&gt;&gt;&gt; number_list[0, 1, 2, 3, 4]</code></pre><p>列表推到把循环放在方括号内部。这种例子和之前碰到的不大一样，但却是更为常见的方式。同样，列表推导也可以像下面的例子加上条件表达式：</p><pre><code>[expression for item in iterable if condition]</code></pre><p>现在，通过推导创建一个在1到5之间的偶数列表（当 number % 2 == 1 为真时，代表奇数；为假时代表偶数）</p><pre><code>&gt;&gt;&gt; a_list = [number for number in range(1,6) if number %2 ==1]&gt;&gt;&gt; a_list[1, 3, 5]</code></pre><p>使用一次推导，将结果赋值给变量 cells，使 row，col 成为元组：</p><pre><code>&gt;&gt;&gt; rows = range(1,4)&gt;&gt;&gt; cols = range(1,3)&gt;&gt;&gt; cells = [(row,col) for row in rows for col in cols]&gt;&gt;&gt; for cell in cells:    print(cell)(1, 1)(1, 2)(2, 1)(2, 2)(3, 1)(3, 2)</code></pre><a id="more"></a><p>另外，在对 cells 列表进行迭代时可以通过元组拆封将变量 row 和 col 的值分别取出：</p><pre><code>&gt;&gt;&gt; for row,col in cells:    print(row,col)1 11 22 12 23 13 2</code></pre><h3 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h3><p>集合也不例外，同样有推导式。最简单的版本和之前的列表、字典推导类似：</p><pre><code>{expression for expression in iterable }</code></pre><p>也可以使用条件判断：</p><pre><code>&gt;&gt;&gt; a_set = {number for number in range(6) if number % 3 == 1}&gt;&gt;&gt; a_set{1, 4}</code></pre><h3 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h3><pre><code>&gt;&gt;&gt; letter_counts = {letter: word.count(letter) for letter in word}        &gt;&gt;&gt; letter_counts        {&apos;t&apos;: 2, &apos;e&apos;: 2, &apos;l&apos;: 1, &apos;r&apos;: 1, &apos;s&apos;: 1}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;推导式&quot;&gt;&lt;a href=&quot;#推导式&quot; class=&quot;headerlink&quot; title=&quot;推导式&quot;&gt;&lt;/a&gt;推导式&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;推导式是从一个或者多个迭代器快速简洁地创建数据结构的一种方法。它可以加循环和条件判断结合，从而避免语法冗长的代码。会使用推导式有时可以说明你已经超过 Python初学者的水平。也就是说，使用推导式更像 Python 风格。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;列表推导式&quot;&gt;&lt;a href=&quot;#列表推导式&quot; class=&quot;headerlink&quot; title=&quot;列表推导式&quot;&gt;&lt;/a&gt;列表推导式&lt;/h3&gt;&lt;p&gt;你可以从1到5创建一个整数列表，每次增加一项：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; number_list = []
&amp;gt;&amp;gt;&amp;gt; number_list.append(1)
&amp;gt;&amp;gt;&amp;gt; number_list.append(2)
&amp;gt;&amp;gt;&amp;gt; number_list.append(3)
&amp;gt;&amp;gt;&amp;gt; number_list.append(4)
&amp;gt;&amp;gt;&amp;gt; number_list.append(5)
&amp;gt;&amp;gt;&amp;gt; number_list
[1, 2, 3, 4, 5]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或者，可以结合 range() 函数使用一个迭代器：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; number_list = []
&amp;gt;&amp;gt;&amp;gt; for number in range(1, 6):
    number_list.append(number)


&amp;gt;&amp;gt;&amp;gt; number_list
[1, 2, 3, 4, 5]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面这些方法都是可行的Python代码，会得到相同的结果。然而，更像 Python 风格的创建列表方法是列表推导。语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[ expression for item in iterable ]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将通过列表推导创建一个整数列表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; number_list = [number for number in range(1,6)]
&amp;gt;&amp;gt;&amp;gt; number_list
[1, 2, 3, 4, 5]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在第一行中，第一个 number 变量为列表生成值，也就是说，把循环的结果放在列表 number_list 中。 第二个 number 可以为表达式， 看下下面的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; number_list = [number-1 for number in range(1, 6)]
&amp;gt;&amp;gt;&amp;gt; number_list
[0, 1, 2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;列表推到把循环放在方括号内部。这种例子和之前碰到的不大一样，但却是更为常见的方式。同样，列表推导也可以像下面的例子加上条件表达式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[expression for item in iterable if condition]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在，通过推导创建一个在1到5之间的偶数列表（当 number % 2 == 1 为真时，代表奇数；为假时代表偶数）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a_list = [number for number in range(1,6) if number %2 ==1]
&amp;gt;&amp;gt;&amp;gt; a_list
[1, 3, 5]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用一次推导，将结果赋值给变量 cells，使 row，col 成为元组：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; rows = range(1,4)
&amp;gt;&amp;gt;&amp;gt; cols = range(1,3)
&amp;gt;&amp;gt;&amp;gt; cells = [(row,col) for row in rows for col in cols]
&amp;gt;&amp;gt;&amp;gt; for cell in cells:
    print(cell)


(1, 1)
(1, 2)
(2, 1)
(2, 2)
(3, 1)
(3, 2)
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="python基础知识" scheme="http://www.chenfanlinux.org/categories/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Python" scheme="http://www.chenfanlinux.org/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python基础之迭代器和生成器</title>
    <link href="http://www.chenfanlinux.org/2018/02/23/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://www.chenfanlinux.org/2018/02/23/Python基础之迭代器和生成器/</id>
    <published>2018-02-23T08:49:36.000Z</published>
    <updated>2018-02-23T08:51:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><blockquote><p>迭代器是一个可以记住遍历的位置的对象。迭代器对象要求支持迭代器协议的对象，在Python中，支持迭代器协议就是实现对象的iter()和next()方法。其中iter()方法返回迭代器对象本身；next()方法返回容器的下一个元素，在结尾时引发StopIteration异常。</p></blockquote><h3 id="可迭代对象-Iterable"><a href="#可迭代对象-Iterable" class="headerlink" title="可迭代对象: Iterable"></a>可迭代对象: Iterable</h3><p>在Python中，很多对象都是可以通过for语句来直接遍历的数据类型有以下几种:</p><ul><li>一类是集合数据类型，如list、tuple、dict、set、str等；</li><li>一类是generator，包括生成器和带yield的generator function 。</li></ul><p>这些可以直接作用于for循环的对象统称为可迭代对象：Iterable，可以使用isinstance()判断一个对象是否是Iterable对象:</p><pre><code>&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance([], Iterable)True&gt;&gt;&gt; isinstance({}, Iterable)True&gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterable)True&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable)True&gt;&gt;&gt; isinstance(100, Iterable)False</code></pre><a id="more"></a><h3 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器: Iterator"></a>迭代器: Iterator</h3><blockquote><p>可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。迭代器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。</p></blockquote><p>迭代器有两个基本的方法：</p><pre><code>__iter__()和next()方法</code></pre><p>可以使用isinstance()判断一个对象是否是Iterator对象：</p><pre><code>&gt;&gt;&gt; from collections import Iterator&gt;&gt;&gt;&gt;&gt;&gt; isinstance((x for x in range(10)), Iterator)True&gt;&gt;&gt; isinstance([], Iterator)False&gt;&gt;&gt; isinstance({}, Iterator)False&gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterator)False&gt;&gt;&gt;</code></pre><p><strong><em>生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。</em></strong></p><p>把list、dict、str等Iterable变成Iterator可以使用iter()函数：</p><pre><code>&gt;&gt;&gt; isinstance(iter([]), Iterator)True&gt;&gt;&gt; isinstance(iter(&apos;abc&apos;), Iterator)True</code></pre><p>你可能会问，为什么list、dict、str等数据类型不是Iterator？</p><p>这是因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。</p><p>Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。</p><h3 id="迭代器小结"><a href="#迭代器小结" class="headerlink" title="迭代器小结"></a>迭代器小结</h3><ul><li>凡是可作用于for循环的对象都是Iterable类型；</li><li>凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；</li><li>集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。</li><li>Python的for语句就会自动的通过iter()方法来获得迭代器对象，并且通过next()方法来获取下一个元素。</li></ul><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><blockquote><p>生成器是用来创建 Python 序列的一个对象。使用它可以迭代庞大的序列，且不需要再内存中创建和存储整个序列，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。</p></blockquote><h3 id="创建生成器"><a href="#创建生成器" class="headerlink" title="创建生成器"></a>创建生成器</h3><p>要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：</p><pre><code>&gt;&gt;&gt; L = [ x * x for x in range(10)]&gt;&gt;&gt; L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x0000000003541BA0&gt;</code></pre><p>如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值：</p><pre><code>&gt;&gt;&gt; next(g)0&gt;&gt;&gt; next(g)1&gt;&gt;&gt; next(g)4&gt;&gt;&gt; next(g)9&gt;&gt;&gt; next(g)16&gt;&gt;&gt; next(g)25&gt;&gt;&gt; next(g)36&gt;&gt;&gt; next(g)49&gt;&gt;&gt; next(g)64&gt;&gt;&gt; next(g)81&gt;&gt;&gt; next(g)Traceback (most recent call last):  File &quot;&lt;pyshell#27&gt;&quot;, line 1, in &lt;module&gt;    next(g)StopIteration</code></pre><p>generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。</p><p>当然，上面这种不断调用next(g)实在是太变态了，正确的方法是使用for循环，因为generator也是可迭代对象：</p><pre><code>&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; for n in g:    print(n)0149162536496481</code></pre><p>所以，我们创建了一个generator后，基本上永远不会调用next()，而是通过for循环来迭代它，并且不需要关心StopIteration的错误。</p><h3 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h3><blockquote><p>每次迭代生成器，它会记录上一次调用的位置，并且返回下一个值。这一点和普通的函数是不一样的，一般函数都不记录之前一次调用，而且都会在函数的第一行开始执行。</p></blockquote><p>如果你想创建一个比较大的序列，使用生成器推导的代码会很长，这是可以尝试写一个生成器函数。生成器函数和普通函数类似，但是它的返回值使用 yield 语句声明, 不是 return。下面编写我们自己的 range() 函数版本：</p><pre><code>&gt;&gt;&gt; def my_range(first=0, last=10, step=1):    number = first    while number &lt; last:        yield number        number += step</code></pre><p>这是一个普通的函数：</p><pre><code>&gt;&gt;&gt; my_range&lt;function my_range at 0x00000000035FC158&gt;</code></pre><p>并且它返回的是一个生成器对象:</p><pre><code>&gt;&gt;&gt; ranger = my_range(1, 5)&gt;&gt;&gt; ranger&lt;generator object my_range at 0x00000000035F1C50&gt;</code></pre><p>可以对这个生成器对象进行迭代：</p><pre><code>&gt;&gt;&gt; for x in ranger:    print(x)1234</code></pre><p><strong><em>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回yield的值。并在下一次执行 next()方法时从当前位置继续运行。</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;迭代器&quot;&gt;&lt;a href=&quot;#迭代器&quot; class=&quot;headerlink&quot; title=&quot;迭代器&quot;&gt;&lt;/a&gt;迭代器&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;迭代器是一个可以记住遍历的位置的对象。迭代器对象要求支持迭代器协议的对象，在Python中，支持迭代器协议就是实现对象的iter()和next()方法。其中iter()方法返回迭代器对象本身；next()方法返回容器的下一个元素，在结尾时引发StopIteration异常。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;可迭代对象-Iterable&quot;&gt;&lt;a href=&quot;#可迭代对象-Iterable&quot; class=&quot;headerlink&quot; title=&quot;可迭代对象: Iterable&quot;&gt;&lt;/a&gt;可迭代对象: Iterable&lt;/h3&gt;&lt;p&gt;在Python中，很多对象都是可以通过for语句来直接遍历的数据类型有以下几种:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一类是集合数据类型，如list、tuple、dict、set、str等；&lt;/li&gt;
&lt;li&gt;一类是generator，包括生成器和带yield的generator function 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些可以直接作用于for循环的对象统称为可迭代对象：Iterable，可以使用isinstance()判断一个对象是否是Iterable对象:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from collections import Iterable
&amp;gt;&amp;gt;&amp;gt; isinstance([], Iterable)
True
&amp;gt;&amp;gt;&amp;gt; isinstance({}, Iterable)
True
&amp;gt;&amp;gt;&amp;gt; isinstance(&amp;apos;abc&amp;apos;, Iterable)
True

&amp;gt;&amp;gt;&amp;gt; isinstance((x for x in range(10)), Iterable)
True
&amp;gt;&amp;gt;&amp;gt; isinstance(100, Iterable)
False
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="python基础知识" scheme="http://www.chenfanlinux.org/categories/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Python" scheme="http://www.chenfanlinux.org/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python基础之函数与模块</title>
    <link href="http://www.chenfanlinux.org/2018/02/23/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0%E4%B8%8E%E6%A8%A1%E5%9D%97/"/>
    <id>http://www.chenfanlinux.org/2018/02/23/Python基础之函数与模块/</id>
    <published>2018-02-23T04:15:11.000Z</published>
    <updated>2018-02-23T04:20:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><blockquote><p>代码复用的第一步是使用函数，它是命名的用于区分的代码段。函数可以接受任何数字或者其他类型的输入作为参数，并且返回数字或者其他类型的结果。函数是Python为了代码最大程度的重用和最小化代码冗余而提供的最基本的程序结构。</p></blockquote><h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><p>在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:；然后在缩进块中编写函数体，函数的返回值用return语句返回。</p><pre><code>def 函数名(参数):    ...    函数体    ...    返回值</code></pre><h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><p>函数的返回值需要使用到return这个关键字，返回值主要是用来接受函数的执行结果。</p><pre><code>&gt;&gt;&gt; def re():    if 1 == 1:        return True    else:        return False&gt;&gt;&gt; re()True</code></pre><p>函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕；如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。</p><a id="more"></a><h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><blockquote><p>定义函数的时候，我们把参数的名字和位置确定下来，函数的接口定义就完成了。对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值就够了，函数内部的复杂逻辑被封装起来，调用者无需了解。</p></blockquote><h4 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h4><p>Python 处理参数的方式要比其他语言更加灵活。其中，最熟悉的参数类型是位置参数，传入参数的值必须按照顺序依次复制过去的。</p><pre><code>// n1, n2, n3是形参&gt;&gt;&gt; def name (n1, n2, n3):    print(&apos;1&apos;, n1)    print(&apos;2&apos;, n2)    print(&apos;3&apos;, n3)// 老大, 老二, 老三是实参&gt;&gt;&gt; name(&apos;老大&apos;, &apos;老二&apos;, &apos;老三&apos;)1 老大2 老二3 老三</code></pre><p>尽管这种方式很常见，但是位置参数的一个弊端是必须熟记没个位置的参数的含义。在调用函数name() 时误把最后一个参数当做第一个参数，会得到完全不同的结果：</p><pre><code>&gt;&gt;&gt; name(&apos;老三&apos;,&apos;老大&apos;,&apos;老二&apos;)1 老三2 老大3 老二</code></pre><h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>为了避免位置参数带来的混乱，调用参数时可以指定对应的名字，甚至可以采用与函数定义不同的顺序调用，<strong><em>关键字参数需要在位置参数之后。</em></strong></p><pre><code>&gt;&gt;&gt; name(n2=&apos;老二&apos;, n1=&apos;老大&apos;, n3=&apos;老三&apos;)1 老大2 老二3 老三</code></pre><p>你也可以把位置参数和关键字参数混合起来:</p><pre><code>&gt;&gt;&gt; name(&apos;老大&apos;, n2=&apos;老二&apos;, n3=&apos;老三&apos;)1 老大2 老二3 老三</code></pre><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p><strong>当调用方没有提供对应的参数值时，你可以指定默认参数值。</strong></p><pre><code>&gt;&gt;&gt; def name(n2, n3, n1=&apos;老大&apos;):    print(&apos;1&apos;, n1)    print(&apos;2&apos;, n2)    print(&apos;3&apos;, n3)&gt;&gt;&gt; name(&apos;老二&apos;, &apos;老三&apos;)1 老大2 老二3 老三</code></pre><p><strong><em>默认参数可以简化函数的调用,设置默认参数时,有几点要注意:</em></strong></p><ul><li>一是必选参数在前，默认参数在后，否则Python的解释器会报错。</li><li>当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。</li><li>定义默认参数要牢记一点：默认参数必须指向不变对象！</li></ul><p>默认参数值在函数被定义时已经计算出来，而不是在程序运行时。Python程序员经常犯的一个错误是把可变的数据类型（例如列表或者字典）当做默认参数值。Python函数在定义的时候，默认参数result的值就被计算出来了，即[]，因为默认参数result也是一个变量，它指向对象[]，每次调用该函数，如果改变了result的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。</p><pre><code>&gt;&gt;&gt; def box(arg, result=[]):    result.append(arg)    print(result)&gt;&gt;&gt; box(&apos;a&apos;)[&apos;a&apos;]&gt;&gt;&gt; box(&apos;b&apos;)[&apos;a&apos;, &apos;b&apos;]</code></pre><p>如果写成下面的样子就会解决刚才的问题：</p><pre><code>&gt;&gt;&gt; def box(arg):    result = []    result.append(arg)    return result&gt;&gt;&gt; box(&apos;a&apos;)[&apos;a&apos;]&gt;&gt;&gt; box(&apos;b&apos;)[&apos;b&apos;]</code></pre><p>这样的修改也是为了表明第一次调用跳过一些操作：</p><pre><code>&gt;&gt;&gt; def box(arg, result=None):    if result is None:        result = []    result.append(arg)    print(result)&gt;&gt;&gt; box(&apos;a&apos;)[&apos;a&apos;]&gt;&gt;&gt; box(&apos;b&apos;)[&apos;b&apos;]</code></pre><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p><strong>若你的函数在定义时不确定用户想传入多少个参数，就可以使用可变参数。</strong></p><pre><code>&gt;&gt;&gt; def stu_register(name, age, *args): # *args 会把多传入的参数变成一个元组形式    print(name, age , args)&gt;&gt;&gt; stu_register(&quot;chenfanlinux&quot;, 23)chenfanlinux 23 () # 后面这个()就是args,只是因为没传值,所以为空&gt;&gt;&gt; stu_register(&quot;chenfanlinux&quot;, 30, &quot;CN&quot;, &quot;Python&quot;)chenfanlinux 30 (&apos;CN&apos;, &apos;Python&apos;)  # 后面传入的参数会被当做一个元组</code></pre><p>还可以有一个 **kwargs</p><pre><code>&gt;&gt;&gt; def stu_register(name, age, *args, **kwargs):    print(name, age, args, kwargs)&gt;&gt;&gt; stu_register(&quot;chenfan&quot;, 22)chenfan 22 () {}    # 后面这个{}就是kwargs,只是因为没传值,所以为空&gt;&gt;&gt; stu_register(&quot;chenfan&quot;, 22, &quot;CN&quot;, &quot;Python&quot;, sex=&quot;Male&quot;, province=&quot;guangzhou&quot;)chenfan 22 (&apos;CN&apos;, &apos;Python&apos;) {&apos;province&apos;: &apos;guangzhou&apos;, &apos;sex&apos;: &apos;Male&apos;}</code></pre><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a><a href="http://www.cnblogs.com/wupeiqi/articles/4963027.html" target="_blank" rel="noopener">模块</a></h2><p>在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。<br>为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。<strong><em>在Python中，一个.py文件就称之为一个模块（Module）。</em></strong></p><h3 id="使用模块的好处"><a href="#使用模块的好处" class="headerlink" title="使用模块的好处"></a>使用模块的好处</h3><ul><li>最大的好处是大大提高了代码的可维护性。</li><li>编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。</li><li>相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。</li><li>如果不同的人编写的模块名相同怎么办？为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package）。</li></ul><h3 id="模块与包"><a href="#模块与包" class="headerlink" title="模块与包"></a>模块与包</h3><p>举个例子，一个 <strong><em>abc.py</em></strong> 的文件就是一个名字叫 <strong><em>abc</em></strong> 的模块，一个 <strong><em>xyz.py</em></strong> 的文件就一个名字叫 <strong><em>xyz</em></strong> 的模块。</p><p>现在，假设我们的 <strong><em>abc</em></strong> 和 <strong><em>xyz</em></strong> 这两个模块名字与其他模块冲突了，于是我们可以通过包来组织模块，避免冲突。方法是选择一个顶层包名，比如<strong><em>mycompany</em></strong>，按照如下目录存放：</p><pre><code>mycompany # 包名├─ __init__.py├─ abc.py # 模块名└─ xyz.py</code></pre><p>引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。现在，<strong><em>abc.py</em></strong> 模块的名字就变成了 <strong><em>mycompany.abc</em></strong>，<strong><em>xyz.py</em></strong> 的模块名变成了 <strong><em>mycompany.xyz</em></strong>。</p><p>请注意，每一个包目录下面都会有一个 __init__.py 的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。__init__.py可以是空文件，也可以有Python代码，因为__init__.py本身就是一个模块，而它的模块名就是文件夹名mycompany。</p><p>类似的，可以有多级目录，组成多级层次的包结构。比如如下的目录结构：</p><pre><code>mycompany ├─ web │  ├─ __init__.py │  ├─ utils.py │  └─ www.py ├─ __init__.py ├─ abc.py └─ xyz.py</code></pre><p>文件www.py的模块名就是mycompany.web.www 。</p><blockquote><p>自己创建模块时要注意命名，不能和Python自带的模块名称冲突。例如，系统自带了sys模块，自己的模块就不可命名为sys.py，否则将无法导入系统自带的sys模块。</p></blockquote><h3 id="模块的导入"><a href="#模块的导入" class="headerlink" title="模块的导入"></a>模块的导入</h3><p>导入模块有一下几种方法：</p><ul><li>import module</li><li>from module.xx.xx import xx</li><li>from module.xx.xx import xx as rename</li><li>from module.xx.xx import *</li></ul><p>导入模块其实就是告诉Python解释器去解释那个py文件</p><ul><li>导入一个py文件，解释器解释该py文件</li><li>导入一个包，解释器解释该包下的 __init__.py 文件</li></ul><p>那么问题来了，导入模块时是根据那个路径作为基准来进行的呢？即：sys.path</p><pre><code>&gt;&gt;&gt; import sys&gt;&gt;&gt; print(sys.path)[&apos;&apos;, &apos;F:\\Python35\\Lib\\idlelib&apos;, &apos;F:\\Python35\\python35.zip&apos;, &apos;F:\\Python35\\DLLs&apos;, &apos;F:\\Python35\\lib&apos;, &apos;F:\\Python35&apos;, &apos;F:\\Python35\\lib\\site-packages&apos;]</code></pre><p>如果sys.path路径列表没有你想要的路径，可以通过 sys.path.append(‘路径’) 添加。</p><pre><code>import sysimport ospre_path = os.path.abspath(&apos;../&apos;)sys.path.append(pre_path)</code></pre><h3 id="模块总结"><a href="#模块总结" class="headerlink" title="模块总结"></a>模块总结</h3><p>模块是一组Python代码的集合，可以使用其他模块，也可以被其他模块使用。</p><p>创建自己的模块时，要注意：</p><ul><li>模块名要遵循Python变量命名规范，不要使用中文、特殊字符；</li><li>模块名不要和系统模块名冲突，最好先查看系统是否已存在该模块，检查方法是在Python交互环境执行import abc，若成功则说明系统存在此模块。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;代码复用的第一步是使用函数，它是命名的用于区分的代码段。函数可以接受任何数字或者其他类型的输入作为参数，并且返回数字或者其他类型的结果。函数是Python为了代码最大程度的重用和最小化代码冗余而提供的最基本的程序结构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;函数的定义&quot;&gt;&lt;a href=&quot;#函数的定义&quot; class=&quot;headerlink&quot; title=&quot;函数的定义&quot;&gt;&lt;/a&gt;函数的定义&lt;/h3&gt;&lt;p&gt;在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:；然后在缩进块中编写函数体，函数的返回值用return语句返回。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def 函数名(参数):
    ...
    函数体
    ...
    返回值
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;函数的返回值&quot;&gt;&lt;a href=&quot;#函数的返回值&quot; class=&quot;headerlink&quot; title=&quot;函数的返回值&quot;&gt;&lt;/a&gt;函数的返回值&lt;/h3&gt;&lt;p&gt;函数的返回值需要使用到return这个关键字，返回值主要是用来接受函数的执行结果。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def re():
    if 1 == 1:
        return True
    else:
        return False


&amp;gt;&amp;gt;&amp;gt; re()
True
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕；如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。&lt;/p&gt;
    
    </summary>
    
      <category term="python基础知识" scheme="http://www.chenfanlinux.org/categories/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Python" scheme="http://www.chenfanlinux.org/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python基础之文件与异常</title>
    <link href="http://www.chenfanlinux.org/2018/02/22/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BC%82%E5%B8%B8/"/>
    <id>http://www.chenfanlinux.org/2018/02/22/Python基础之文件与异常/</id>
    <published>2018-02-22T08:41:24.000Z</published>
    <updated>2018-02-22T08:42:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><blockquote><p>数据持久化最简单的类型是普通文件,它仅仅是在一个文件名下的字节流，把数据从一个文件读入内存，然后从内存写入文件。</p></blockquote><h3 id="文件操作模型"><a href="#文件操作模型" class="headerlink" title="文件操作模型"></a>文件操作模型</h3><pre><code>data = open(filename, mode)</code></pre><p>下面是对该 open() 调用的简单解释：</p><ul><li>data 是 open() 返回的文件对象</li><li>filename 是该文件的字符串名</li><li>mode 是指明文件类型和操作的字符串</li></ul><p>mode 的第一个字母表明对其的操作：</p><ul><li>r 以只读方式打开文件。文件的指针将会放在文件的开头，这是默认模式。</li><li>r+ 可读可写，不会创建不存在的文件。如果直接写文件，则从顶部开始写，覆盖之前此位置的内容，如果先读后写，则会在文件最后追加内容。</li><li>w 表示写模式。若果文件不存在则新创建，如果该文件已存在则将其覆盖。</li><li>w+ 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</li><li>x 表示在文件不存在的情况下新创建并写文件，如果文件存在就会报错。</li><li>a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</li><li>a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</li></ul><p>mode 的第二个字母是文件类型：</p><ul><li>t（或者省略） 代表文本类型</li><li>b 代表二进制文件</li></ul><p><strong><em>注意: 打开文件之后就可以调用函数来读写数据，最后需要关闭文件。</em></strong></p><a id="more"></a><h3 id="使用-write-写文本文件"><a href="#使用-write-写文本文件" class="headerlink" title="使用 write() 写文本文件"></a>使用 write() 写文本文件</h3><pre><code>&gt;&gt;&gt; poem = &quot;日照香炉生紫烟，遥看瀑布挂前川。飞流直下三千尺，疑是银河落九天。&quot;&gt;&gt;&gt;&gt;&gt;&gt; len(poem)32</code></pre><p>将整首诗写到libai.txt中：</p><pre><code>&gt;&gt;&gt; fout = open(&apos;libai.txt&apos;,&apos;wt&apos;)&gt;&gt;&gt; fout.write(poem)32&gt;&gt;&gt; fout.close&lt;built-in method close of _io.TextIOWrapper object at 0x00000000034E1120&gt;</code></pre><p>函数 write() 返回写入文件的字节数。和 print() 一样， 他没有增加空格或者换行符。同样，你也可以在一个文本文件中使用 print()。</p><pre><code>&gt;&gt;&gt; fout = open(&apos;libai.txt&apos;,&apos;wt&apos;)&gt;&gt;&gt; print(poem, file=fout)&gt;&gt;&gt; fout.close()</code></pre><p>这就产生了一个问题：到底是用是 write() 还是 print()？ print() 默认会在每个参数后面添加空格，在每行结束处添加换行。在之前的例子中， libai.txt 中默认添加了一个换行。为了使 print() 与 write() 有同样的输出，传入下面两个参数：</p><ul><li>sep 分隔符：默认是一个空格‘’</li><li>end 结束字符：默认是一个换行符 ‘\n’</li></ul><p>除非自定义参数，否则 print() 会使用默认参数。在这里，我们通过空字符串替换 print() 添加的所有多余输出：</p><pre><code>&gt;&gt;&gt; print(poem, file=fout, sep=&apos;&apos;, end=&apos;&apos;)&gt;&gt;&gt; fout.close()</code></pre><p>如果字符串非常大，可以将数据分块，直到所有字符被写入：</p><pre><code>&gt;&gt;&gt; size = len(poem)&gt;&gt;&gt;&gt;&gt;&gt; fout = open(&apos;libai.txt&apos;, &apos;w&apos;)&gt;&gt;&gt; offset = 0&gt;&gt;&gt; chunk = 10&gt;&gt;&gt; while True:    if offset &gt; size:        break    fout.write(poem[offset:offset+chunk])    offset += chunk1010102&gt;&gt;&gt;&gt;&gt;&gt; fout.close()</code></pre><p>如果 libai.txt 文件已经存在，使用模式 x 可以避免重写文件：</p><pre><code>&gt;&gt;&gt; fount = open(&apos;libai.txt&apos;,&apos;xt&apos;)Traceback (most recent call last):  File &quot;&lt;pyshell#0&gt;&quot;, line 1, in &lt;module&gt;    fount = open(&apos;libai.txt&apos;,&apos;xt&apos;)FileExistsError: [Errno 17] File exists: &apos;libai.txt&apos;</code></pre><h3 id="使用-read-、readline-或者-readlines-读取文本文件"><a href="#使用-read-、readline-或者-readlines-读取文本文件" class="headerlink" title="使用 read()、readline() 或者 readlines() 读取文本文件"></a>使用 read()、readline() 或者 readlines() 读取文本文件</h3><p>使用不带参数的 read() 函数一次读入文件的所有内容。但在读入文件时要格外注意，1GB的文件会用到相同大小的内存，如果文件大小太大的话，需要防止内存爆掉。</p><pre><code>&gt;&gt;&gt; fin = open(&apos;libai.txt&apos;, &apos;rt&apos;)&gt;&gt;&gt; poem = fin.read()&gt;&gt;&gt; poem&apos;日照香炉生紫烟，遥看瀑布挂前川。飞流直下三千尺，疑是银河落九天。&apos;&gt;&gt;&gt; fin.close()&gt;&gt;&gt; len(poem)32</code></pre><p>同样也可以设置最大的读入字符数限制 read() 函数一次返回的大小。下面一次读入10个字符，然后把每一快拼接成原来的字符串 poem。</p><pre><code>&gt;&gt;&gt; poem = &apos;&apos;&gt;&gt;&gt; fin = open(&apos;libai.txt&apos;, &apos;rt&apos;)&gt;&gt;&gt; chunk = 10&gt;&gt;&gt; while True:    fragment = fin.read(chunk)    if not fragment:        break    poem += fragment&gt;&gt;&gt; fin.close()&gt;&gt;&gt; len(poem)32&gt;&gt;&gt; poem&apos;日照香炉生紫烟，遥看瀑布挂前川。飞流直下三千尺，疑是银河落九天。&apos;</code></pre><p>读到结尾之后，再次调用 read() 会返回空字符串(‘’)， if not fragment 条件被判断为 False。此时会跳出 while True 的循环。 当然， 你也能使用 readline() 每次读入文件的一行。 在下面的例子中，通过追加每一行拼接成原来的字符串 poem。</p><pre><code>&gt;&gt;&gt; poem = &apos;&apos;&gt;&gt;&gt; fin = open(&apos;libai.txt&apos;, &apos;rt&apos;)&gt;&gt;&gt; while True:    line = fin.readline()    if not line:        break    poem += line&gt;&gt;&gt; fin.close()&gt;&gt;&gt; len(poem)32&gt;&gt;&gt; poem&apos;日照香炉生紫烟，遥看瀑布挂前川。飞流直下三千尺，疑是银河落九天。&apos;</code></pre><p>读取文本文件最简单的方式是使用一个迭代器（iterator），它会每次返回一行。这和之前的例子类似，但代码会更短：</p><pre><code>&gt;&gt;&gt; poem = &apos;&apos;&gt;&gt;&gt; fin = open(&apos;libai.txt&apos;, &apos;rt&apos;)&gt;&gt;&gt; for line in fin:    poem += line&gt;&gt;&gt; fin.close()&gt;&gt;&gt; len(poem)32&gt;&gt;&gt; poem&apos;日照香炉生紫烟，遥看瀑布挂前川。飞流直下三千尺，疑是银河落九天。&apos;</code></pre><p>前面所有的示例最终都返回单个字符串 poem。 函数 readlines() 调用时每次读取一行，并返回单行字符串的列表：</p><pre><code>&gt;&gt;&gt; poem = &apos;&apos;&apos;日照香炉生紫烟，遥看瀑布挂前川。飞流直下三千尺,疑是银河落九天。&apos;&apos;&apos;&gt;&gt;&gt; fin = open(&apos;libai.txt&apos;,&apos;wt&apos;)&gt;&gt;&gt; fin.write(poem)36&gt;&gt;&gt; fin.close()&gt;&gt;&gt; fin = open(&apos;libai.txt&apos;, &apos;rt&apos;)&gt;&gt;&gt; lines = fin.readlines()&gt;&gt;&gt; fin.close()&gt;&gt;&gt; lines[&apos;日照香炉生紫烟，\n&apos;, &apos;遥看瀑布挂前川。\n&apos;, &apos;飞流直下三千尺,\n&apos;, &apos;疑是银河落九天。\n&apos;]&gt;&gt;&gt; for line in lines:print(line,end=&apos;&apos;)日照香炉生紫烟，遥看瀑布挂前川。飞流直下三千尺,疑是银河落九天。</code></pre><h3 id="使用-with-自动关闭文件"><a href="#使用-with-自动关闭文件" class="headerlink" title="使用 with 自动关闭文件"></a>使用 with 自动关闭文件</h3><p>Python的上下文管理器（context manager）会清理一些资源，例如打开的文件。<br>它的形式<br><code>with expression as variable：</code></p><pre><code>&gt;&gt;&gt; opem = &apos;&apos;&apos;welcome to chenfanlinux.org&apos;&apos;&apos;// 利用这种方式就可以不必用close()函数关闭文件&gt;&gt;&gt; with open(&apos;libai.txt&apos;, &apos;wt&apos;) as fout:    print(opem,file=fout,end=&apos;&apos;)&gt;&gt;&gt; with open(&apos;libai.txt&apos;, &apos;rt&apos;) as fin:    for line in fin:        print(line,end=&apos;&apos;)welcome to chenfanlinux.org</code></pre><p>完成上下文管理器的代码后，文件会自动关闭。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><blockquote><p>Python使用被称为异常的特殊对象来管理程序执行期间发生的错误。每当发生让Python不知 所措的错误时，它都会创建一个异常对象。如果你编写了处理该异常的代码，程序将继续运行; 如果你未对异常进行处理，程序将停止，并显示一个traceback，其中包含有关异常的报告。<br>异常是使用try-except代码块处理的。try-except代码块让Python执行指定的操作，同时告 诉Python发生异常时怎么办。使用了try-except代码块时，即便出现异常，程序也将继续运行: 显示你编写的友好的错误消息，而不是令用户迷惑的traceback。</p></blockquote><h3 id="使用-try-except-代码块"><a href="#使用-try-except-代码块" class="headerlink" title="使用 try-except 代码块"></a>使用 try-except 代码块</h3><blockquote><p>try 语句有两种主要形式: try-except 和 try-finally . 这两个语句是互斥的, 也就是说你 只能使用其中的一种. 一个 try 语句可以对应一个或多个 except 子句, 但只能对应一个 finally 子句, 或是一个 try-except-finally 复合语句。</p></blockquote><p>处理ZeroDivisionError异常的try-except代码 类似于下面这样：</p><pre><code>&gt;&gt;&gt; try:    print(5/0)except ZeroDivisionError:    print(&quot;You can&apos;t divide by zero!&quot;)You can&apos;t divide by zero!</code></pre><p>我们将导致错误的代码行print(5/0)放在了一个try代码中。如果try代码中的代码运行起来没有问题，Python将跳过except代码; 如果try代码中的代码导致了错误，Python将查找这样的except代码块，并运行其中的代码，即其中指定的错误与引发的错误相同。<br>在这个示例中，try代码中的代码引发了ZeroDivisionError异常，因此Python指出了该如何解决问题的except代码块，并运行其中的代码。这样，用户看到的是一条 好的错误消息，而不是traceback:</p><pre><code>You can&apos;t divide by zero!</code></pre><p>如果try-except代码后面还有其他代码，程序将接着运行，因为已经告诉了Python如何处理这种错误。</p><h3 id="使用异常避免崩溃"><a href="#使用异常避免崩溃" class="headerlink" title="使用异常避免崩溃"></a>使用异常避免崩溃</h3><p>发生错误时，如果程序还有工作没有完成，妥善地处理错误就尤其重要。这种情况经常会出现在要求用户提供输入的程序中;如果程序能够妥善地处理无效输入，就能再提示用户提供有效输入，而不至于崩溃。</p><pre><code>#__author: Administrator#date: 2018/2/11print(&quot;Give me two numbers, and I&apos;ll divide them.&quot;)print(&quot;Enter &apos;q&apos; to quit.&quot;)while True:    first_number = input(&quot;\n First number: &quot;)    if first_number == &apos;q&apos;:        break    second_number = input(&quot;\n Second number: &quot;)    if second_number == &apos;q&apos;:        break    answer = int(first_number) / int(second_number)    print(answer)</code></pre><p>这个程序没有采取任何处理错误的措施，因此让它执行除数为0的除法运算时，它将崩溃:</p><pre><code>Give me two numbers, and I&apos;ll divide them.Enter &apos;q&apos; to quit.First number: 5Second number: 0Traceback (most recent call last):  File &quot;&lt;ipython-input-208-1e61f850d337&gt;&quot;, line 11, in &lt;module&gt;    answer = int(first_number) / int(second_number)ZeroDivisionError: division by zero&gt;&gt;&gt;</code></pre><p>程序崩溃可不好，但让用户看到 traceback 也不是好主意。不懂技术的用户会被它们搞糊涂， 而且如果用户 怀有恶意，他会通过traceback获悉你不希望他知道的信息。例如，他将知道你的程序文件的名称，还将看到部分不能正确运行的代码。有时候，训练有素的攻击者可根据这些信息判断出可对你的代码发起什么样的攻击。</p><h3 id="else-代码块"><a href="#else-代码块" class="headerlink" title="else 代码块"></a>else 代码块</h3><p>通过将可能引发错误的代码放在try-except代码中，可提高这个程序抵御错误的能力。错误是执行除法运算的代码行导致的，因此我们需要将它放到try-except代码块中。这个示例还包含一个else代码块; 依赖于try代码块成功执行的代码都应放到else代码中:</p><pre><code>#__author: Administrator#date: 2018/2/11print(&quot;Give me two numbers, and I&apos;ll divide them.&quot;)print(&quot;Enter &apos;q&apos; to quit.&quot;)while True:    first_number = input(&quot;\n First number: &quot;)    if first_number == &apos;q&apos;:        break    second_number = input(&quot;\n Second number: &quot;)    if second_number == &apos;q&apos;:        break    try:        answer = int(first_number) / int(second_number)    except ZeroDivisionError:        print(&quot;You can&apos;t divide by 0!&quot;)    else:        print(answer)</code></pre><p>我们让Python尝试执行try代码块中的除法运算，这个代码块只包含可能导致错误的代码。依赖于try代码块成功执行的代码都放在else代码中; 在这个示例中，如果除法运算成功，我们就使用else代码块来打印结果。<br>except代码块告诉Python，出现ZeroDivisionError异常时该怎么办。如果try代码因除零错误而失败，我们就打印一条友好的消息，告诉用户如何避免这种错误。程序将继续运行，用户根本看不到traceback。</p><pre><code>Give me two numbers, and I&apos;ll divide them.Enter &apos;q&apos; to quit.First number: 5Second number: 0You can&apos;t divide by 0!First number: 5Second number: 22.5First number: q&gt;&gt;&gt;</code></pre><p>try-except-else代码块的工作原理大致如下: Python尝试执行try代码块中的代码; 只有可能引发异常的代码才需要放在try语句中。有时候，有一些仅在try代码块成功执行时才需要运行的的代码; 这些代码应放在else代码中。except代码块告诉Python，如果它尝试运行try代码块中的代码时引发了指定的异常，该怎么办。通过预测可能发生错误的代码，可编写健壮的程序，它们即便面临无效数据或缺少资源，也能继续运行，从而能够抵御无意的用户错误和恶意的攻击。</p><h3 id="finally子句"><a href="#finally子句" class="headerlink" title="finally子句"></a>finally子句</h3><p>finally 子句是无论异常是否发生,是否捕捉都会执行的一段代码. 你可以将 finally 仅仅配合 try 一起使用,也可以和 try-except(else 也是可选的)一起使用。你可以用 finally 子句 与 try-except 或 try-except-else 一起使用。</p><p>下面是 try-except-else-finally 语法的示例:</p><pre><code>try:    Aexcept MyException1:    B1except MyException2:    B2else:    Cfinally:    D</code></pre><p>当然,无论如何,你都可以有不止一个的 except 子句,但最少有一个 except 语句,而 else 和 finally 都是可选的. A,B,C 和 D 是程序(代码块). 程序会按预期的顺序执行.(注意:可能的顺序是 A-C-D[正常]或 A-B-D[异常])，无论异常发生都将执行 finally 块。</p><h3 id="常见的异常"><a href="#常见的异常" class="headerlink" title="常见的异常"></a>常见的异常</h3><p><img src="https://s1.ax1x.com/2018/02/22/9UQn74.png" alt="常见的异常"></p><h3 id="决定报告那些错误"><a href="#决定报告那些错误" class="headerlink" title="决定报告那些错误"></a>决定报告那些错误</h3><ul><li>编写得很好且经过详尽测试的代码不容易出现内部错误，如语法或逻辑错误。</li><li>但只要程序依赖于外部因素，如用户输入、存在指定的文件、有网络连接，就有可能出现异常。凭借经验可判断该在程序的什么地方包含异常处理 ，以及出现错误时该向用户提供多少相关的信息。</li><li>向用户显示他不想看到的信息可能会降低程序的可用性。Python的错误处理结构让你能够细致地控制与用户分享错误信息的程度，要分享多少信息由你决定。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文件&quot;&gt;&lt;a href=&quot;#文件&quot; class=&quot;headerlink&quot; title=&quot;文件&quot;&gt;&lt;/a&gt;文件&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;数据持久化最简单的类型是普通文件,它仅仅是在一个文件名下的字节流，把数据从一个文件读入内存，然后从内存写入文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;文件操作模型&quot;&gt;&lt;a href=&quot;#文件操作模型&quot; class=&quot;headerlink&quot; title=&quot;文件操作模型&quot;&gt;&lt;/a&gt;文件操作模型&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;data = open(filename, mode)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面是对该 open() 调用的简单解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;data 是 open() 返回的文件对象&lt;/li&gt;
&lt;li&gt;filename 是该文件的字符串名&lt;/li&gt;
&lt;li&gt;mode 是指明文件类型和操作的字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;mode 的第一个字母表明对其的操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;r 以只读方式打开文件。文件的指针将会放在文件的开头，这是默认模式。&lt;/li&gt;
&lt;li&gt;r+ 可读可写，不会创建不存在的文件。如果直接写文件，则从顶部开始写，覆盖之前此位置的内容，如果先读后写，则会在文件最后追加内容。&lt;/li&gt;
&lt;li&gt;w 表示写模式。若果文件不存在则新创建，如果该文件已存在则将其覆盖。&lt;/li&gt;
&lt;li&gt;w+ 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。&lt;/li&gt;
&lt;li&gt;x 表示在文件不存在的情况下新创建并写文件，如果文件存在就会报错。&lt;/li&gt;
&lt;li&gt;a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。&lt;/li&gt;
&lt;li&gt;a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;mode 的第二个字母是文件类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;t（或者省略） 代表文本类型&lt;/li&gt;
&lt;li&gt;b 代表二进制文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意: 打开文件之后就可以调用函数来读写数据，最后需要关闭文件。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python基础知识" scheme="http://www.chenfanlinux.org/categories/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Python" scheme="http://www.chenfanlinux.org/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python基础之变量与运算符</title>
    <link href="http://www.chenfanlinux.org/2018/02/17/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://www.chenfanlinux.org/2018/02/17/Python基础之变量与运算符/</id>
    <published>2018-02-16T22:44:59.000Z</published>
    <updated>2018-02-16T22:48:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><blockquote><p>在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。所谓变量就是在程序中为了方便地引用内存中的值而为它取的名称。在 Python 中，我们用 = 来给一个变量赋值。</p></blockquote><h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><p>Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</p><pre><code>&gt;&gt;&gt; a = 123  # a是整数&gt;&gt;&gt; id(a)1647579408&gt;&gt;&gt; a = &apos;ABC&apos; # a变为字符串&gt;&gt;&gt; id(a)10190496</code></pre><p><strong><em>Python 中的变量有一个非常重要的性质:它仅仅是一个名字。赋值操作并不会实际 复制值，它只是为数据对象取个相关的名字。名字是对对象的引用而不是对象本身。你可以把名字想象成贴在盒子上的标签</em></strong></p><a id="more"></a><h3 id="变量在内存中表示"><a href="#变量在内存中表示" class="headerlink" title="变量在内存中表示"></a>变量在内存中表示</h3><p>理解变量在计算机内存中的表示也非常重要。当我们写:</p><pre><code>a =  &apos;ABC&apos;</code></pre><p>Python解释器干了两件事情：</p><ul><li>在内存中创建了一个’ABC’的字符串；</li><li>在内存中创建了一个名为a的变量，并把它指向’ABC’。</li></ul><p>也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据，例如下面的代码：</p><pre><code>&gt;&gt;&gt; a =  &apos;ABC&apos;&gt;&gt;&gt; a = &apos;ABC&apos;&gt;&gt;&gt; b = a&gt;&gt;&gt; a = &apos;XYZ&apos;&gt;&gt;&gt; print(b)ABC</code></pre><p>上面的代码执行步骤如下:</p><ul><li>执行a = ‘ABC’，解释器创建了字符串’ABC’和变量a，并把a指向’ABC’</li><li>执行b = a，解释器创建了变量b，并把b指向a指向的字符串’ABC’</li><li>执行a = ‘XYZ’，解释器创建了字符串’XYZ’，并把a的指向改为’XYZ’，但b并没有更改,所以，最后打印变量b的结果自然是’ABC’了</li></ul><h3 id="变量的命名"><a href="#变量的命名" class="headerlink" title="变量的命名"></a>变量的命名</h3><p>在Python中使用变量时，需要遵守一些规则和指南。违反这些规则将引发错误，而指南旨在 让你编写的代码更容易阅读和理解， 请务必牢记下述有关变量的规则。</p><ul><li>变量名只能包含字母、数字和下划线。变量名可以字母或下划线打头，但不能以数字打 头，例如，可将变量命名为message_1，不能命名为1_message</li><li>变量名不能包含空格，但可使用下划线来分隔其中的单词。例如，变量名greeting_message 可行，但变量名greeting message会引发错误。</li><li>不要将Python关键字和函数名用作变量名，即不要使用Python保留用于特殊用途的单词。</li></ul><h4 id="Python-关键字"><a href="#Python-关键字" class="headerlink" title="Python 关键字"></a>Python 关键字</h4><p>下面的关键字都有特殊含义，如果你将它们用作变量名，将引发错误:<br><img src="https://s1.ax1x.com/2018/02/18/9tDAZn.md.png" alt="Python关键字"></p><h4 id="Python-内置函数"><a href="#Python-内置函数" class="headerlink" title="Python 内置函数"></a>Python 内置函数</h4><p>将内置函数名用作变量名时，不会导致错误，但将覆盖这些函数的行为:<br><img src="https://s1.ax1x.com/2018/02/18/9tDEaq.md.png" alt="Python内置函数"></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><blockquote><p>你所编写的大多数语句(逻辑行)都包含了表达式(Expressions)。一个表达式的简单例子<br>便是 2+3 。表达式可以拆分成运算符（ Operators） 与操作数（ Operands),运算符（ Operators） 是进行某些操作，并且可以用诸如 + 等符号或特殊关键词加以表达的<br>功能。运算符需要一些数据来进行操作，这些数据就被称作操作数（ Operands)。</p></blockquote><p>Python语言支持以下类型的运算符:</p><ul><li>算术运算符</li><li>比较（关系）运算符</li><li>赋值运算符</li><li>逻辑运算符</li><li>位运算符</li><li>成员运算符</li><li>身份运算符</li><li>运算符优先级</li></ul><h3 id="Python算术运算符"><a href="#Python算术运算符" class="headerlink" title="Python算术运算符"></a>Python算术运算符</h3><p><img src="https://s1.ax1x.com/2018/02/18/9tDtJK.png" alt="Python算术运算符"></p><h3 id="Python比较运算符"><a href="#Python比较运算符" class="headerlink" title="Python比较运算符"></a>Python比较运算符</h3><p><img src="https://s1.ax1x.com/2018/02/18/9tDsot.png" alt="Python比较运算符"></p><h3 id="Python赋值运算符"><a href="#Python赋值运算符" class="headerlink" title="Python赋值运算符"></a>Python赋值运算符</h3><p><img src="https://s1.ax1x.com/2018/02/18/9tDRSS.png" alt="Python赋值运算符"></p><h3 id="Python位运算符"><a href="#Python位运算符" class="headerlink" title="Python位运算符"></a>Python位运算符</h3><blockquote><p>按位运算符是把数字看作二进制来进行计算的。</p></blockquote><p><img src="https://s1.ax1x.com/2018/02/18/9tDIwn.png" alt="Python位运算符"></p><h3 id="Python逻辑运算符"><a href="#Python逻辑运算符" class="headerlink" title="Python逻辑运算符"></a>Python逻辑运算符</h3><p><img src="https://s1.ax1x.com/2018/02/18/9tDHYV.png" alt="Python逻辑运算符"></p><h3 id="Python成员运算符"><a href="#Python成员运算符" class="headerlink" title="Python成员运算符"></a>Python成员运算符</h3><blockquote><p>除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。</p></blockquote><p><img src="https://s1.ax1x.com/2018/02/18/9tDLSU.png" alt="Python成员运算符"></p><h3 id="Python身份运算符"><a href="#Python身份运算符" class="headerlink" title="Python身份运算符"></a>Python身份运算符</h3><blockquote><p>身份运算符用于比较两个对象的存储单元。</p></blockquote><p><img src="https://s1.ax1x.com/2018/02/18/9tDXy4.md.png" alt="Python身份运算符"></p><p><strong>is 与 == 区别：</strong></p><p>is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。</p><pre><code>&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; b = a&gt;&gt;&gt; b is aTrue&gt;&gt;&gt; b == aTrue&gt;&gt;&gt; b = a[:]&gt;&gt;&gt; b is aFalse&gt;&gt;&gt; b == aTrue</code></pre><h3 id="Python运算符优先级"><a href="#Python运算符优先级" class="headerlink" title="Python运算符优先级"></a>Python运算符优先级</h3><p>以下表格列出了从最高到最低优先级的所有运算符:</p><p><img src="https://s1.ax1x.com/2018/02/18/9trklD.png" alt="运算符优先级"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。所谓变量就是在程序中为了方便地引用内存中的值而为它取的名称。在 Python 中，我们用 = 来给一个变量赋值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;变量赋值&quot;&gt;&lt;a href=&quot;#变量赋值&quot; class=&quot;headerlink&quot; title=&quot;变量赋值&quot;&gt;&lt;/a&gt;变量赋值&lt;/h3&gt;&lt;p&gt;Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = 123  # a是整数
&amp;gt;&amp;gt;&amp;gt; id(a)
1647579408
&amp;gt;&amp;gt;&amp;gt; a = &amp;apos;ABC&amp;apos; # a变为字符串
&amp;gt;&amp;gt;&amp;gt; id(a)
10190496
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Python 中的变量有一个非常重要的性质:它仅仅是一个名字。赋值操作并不会实际 复制值，它只是为数据对象取个相关的名字。名字是对对象的引用而不是对象本身。你可以把名字想象成贴在盒子上的标签&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python基础知识" scheme="http://www.chenfanlinux.org/categories/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Python" scheme="http://www.chenfanlinux.org/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Pytho基础之内置数据类型(二)</title>
    <link href="http://www.chenfanlinux.org/2018/02/14/Pytho%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%BA%8C/"/>
    <id>http://www.chenfanlinux.org/2018/02/14/Pytho基础之内置数据类型-二/</id>
    <published>2018-02-14T04:17:34.000Z</published>
    <updated>2018-02-14T04:25:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><blockquote><p>列表由一系列按特定顺序排列的元素组成，可以将任何东西加入列表中，其中的元素之间可以没有任何关系。列表非常适合利用顺序和位置定位某一元素，尤其是当元素的顺序或内容经常发生改变时。与字符串不同，列表是可变的。你可以直接对原始列表进行修改:添加新元素、删除 或覆盖已有元素。在列表中，具有相同值的元素允许出现多次。</p></blockquote><h3 id="常用列表方法"><a href="#常用列表方法" class="headerlink" title="常用列表方法"></a>常用列表方法</h3><pre><code>&gt;&gt;&gt; dir(list)[&apos;__add__&apos;, &apos;__class__&apos;, &apos;__contains__&apos;,&apos;__delattr__&apos;, &apos;__delitem__&apos;, &apos;__dir__&apos;,&apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;,&apos;__getattribute__&apos;, &apos;__getitem__&apos;, &apos;__gt__&apos;,&apos;__hash__&apos;, &apos;__iadd__&apos;, &apos;__imul__&apos;,&apos;__init__&apos;, &apos;__iter__&apos;, &apos;__le__&apos;, &apos;__len__&apos;, &apos;__lt__&apos;, &apos;__mul__&apos;,&apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__reversed__&apos;, &apos;__rmul__&apos;, &apos;__setattr__&apos;, &apos;__setitem__&apos;,&apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;append&apos;, &apos;clear&apos;, &apos;copy&apos;, &apos;count&apos;, &apos;extend&apos;, &apos;index&apos;, &apos;insert&apos;, &apos;pop&apos;, &apos;remove&apos;, &apos;reverse&apos;, &apos;sort&apos;]</code></pre><h3 id="列表切片"><a href="#列表切片" class="headerlink" title="列表切片"></a>列表切片</h3><p><strong>定义列表后，可从其中获取任何部分作为新列表。该技术称为对列表进行切片，对于有序序列，包括字符串，元组都可以切片。</strong></p><pre><code>&gt;&gt;&gt; lists = [&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;, &apos;Bob&apos;, &apos;Jack&apos;]&gt;&gt;&gt; lists[0]&apos;Michael&apos;&gt;&gt;&gt; lists[1:3] # 切片实际是索引尾部取开区间 [1:3)[&apos;Sarah&apos;, &apos;Tracy&apos;]&gt;&gt;&gt; lists[:3]  # 相当于索引lists[0:3][&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;]&gt;&gt;&gt; lists[0:3][&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;]&gt;&gt;&gt; lists[-2:] # 取列表最后两个元素[&apos;Bob&apos;, &apos;Jack&apos;]</code></pre><h3 id="append-向列表尾部追加一个元素"><a href="#append-向列表尾部追加一个元素" class="headerlink" title="append 向列表尾部追加一个元素"></a>append 向列表尾部追加一个元素</h3><pre><code>&gt;&gt;&gt; lists[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;, &apos;Bob&apos;, &apos;Jack&apos;]&gt;&gt;&gt; lists.append(&apos;chenfan&apos;)&gt;&gt;&gt; lists[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;, &apos;Bob&apos;, &apos;Jack&apos;, &apos;chenfan&apos;]</code></pre><h3 id="clear-清除列表中的所有元素"><a href="#clear-清除列表中的所有元素" class="headerlink" title="clear 清除列表中的所有元素"></a>clear 清除列表中的所有元素</h3><pre><code>&gt;&gt;&gt; num = [1,2,3,4,5]&gt;&gt;&gt; num.clear()&gt;&gt;&gt; num[]</code></pre><a id="more"></a><h3 id="copy-复制一个列表"><a href="#copy-复制一个列表" class="headerlink" title="copy 复制一个列表"></a>copy 复制一个列表</h3><pre><code>&gt;&gt;&gt; lists[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;, &apos;Bob&apos;, &apos;Jack&apos;, &apos;chenfan&apos;]&gt;&gt;&gt; the_list = lists.copy()&gt;&gt;&gt; the_list[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;, &apos;Bob&apos;, &apos;Jack&apos;, &apos;chenfan&apos;]</code></pre><h3 id="count-计算某个元素在列表中出现的次数"><a href="#count-计算某个元素在列表中出现的次数" class="headerlink" title="count 计算某个元素在列表中出现的次数"></a>count 计算某个元素在列表中出现的次数</h3><pre><code>&gt;&gt;&gt; numbers = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]&gt;&gt;&gt; numbers.count(4)4&gt;&gt;&gt; numbers.count(2)2</code></pre><h3 id="extend-向列表末尾一次性追加另一个列表"><a href="#extend-向列表末尾一次性追加另一个列表" class="headerlink" title="extend 向列表末尾一次性追加另一个列表"></a>extend 向列表末尾一次性追加另一个列表</h3><pre><code>&gt;&gt;&gt; numbers[1, 2, 2, 3, 3, 3, 4, 4, 4, 4]&gt;&gt;&gt; a = [5, 5, 5, 5, 5]&gt;&gt;&gt; numbers.extend(a)&gt;&gt;&gt; numbers[1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]</code></pre><h3 id="index-从列表中找出某个值第一个匹配的索引位置"><a href="#index-从列表中找出某个值第一个匹配的索引位置" class="headerlink" title="index 从列表中找出某个值第一个匹配的索引位置"></a>index 从列表中找出某个值第一个匹配的索引位置</h3><pre><code>&gt;&gt;&gt; numbers[1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]&gt;&gt;&gt; numbers.index(5)10&gt;&gt;&gt; numbers.index(2)1</code></pre><h3 id="insert-将对象插入列表某个索引位置"><a href="#insert-将对象插入列表某个索引位置" class="headerlink" title="insert 将对象插入列表某个索引位置"></a>insert 将对象插入列表某个索引位置</h3><pre><code>&gt;&gt;&gt; numbers.insert(0,0)&gt;&gt;&gt; numbers[0, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5</code></pre><h3 id="pop-移除列表中的最后一个元素"><a href="#pop-移除列表中的最后一个元素" class="headerlink" title="pop 移除列表中的最后一个元素"></a>pop 移除列表中的最后一个元素</h3><pre><code>&gt;&gt;&gt; numbers[0, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]&gt;&gt;&gt; numbers.pop()5&gt;&gt;&gt; numbers[0, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5]</code></pre><h3 id="remove-移除列表中第一个匹配的元素"><a href="#remove-移除列表中第一个匹配的元素" class="headerlink" title="remove 移除列表中第一个匹配的元素"></a>remove 移除列表中第一个匹配的元素</h3><pre><code>&gt;&gt;&gt; num = [1, 2, 1, 3, 2]&gt;&gt;&gt; num.remove(1)&gt;&gt;&gt; num[2, 1, 3, 2]&gt;&gt;&gt; num.remove(2)&gt;&gt;&gt; num[1, 3, 2]</code></pre><h3 id="reverse-将列表中的元素反向存放"><a href="#reverse-将列表中的元素反向存放" class="headerlink" title="reverse 将列表中的元素反向存放"></a>reverse 将列表中的元素反向存放</h3><pre><code>&gt;&gt;&gt; numbers[0, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5]&gt;&gt;&gt; numbers.reverse()&gt;&gt;&gt; numbers[5, 5, 5, 5, 4, 4, 4, 4, 3, 3, 3, 2, 2, 1, 0]</code></pre><h3 id="sort-对列表排序"><a href="#sort-对列表排序" class="headerlink" title="sort 对列表排序"></a>sort 对列表排序</h3><h4 id="默认排序（升序）"><a href="#默认排序（升序）" class="headerlink" title="默认排序（升序）"></a>默认排序（升序）</h4><pre><code>&gt;&gt;&gt; L = [1,4,3,2]&gt;&gt;&gt; L.sort()&gt;&gt;&gt; L[1, 2, 3, 4]</code></pre><h4 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h4><p><strong>看sort的使用方法</strong></p><pre><code>&gt;&gt;&gt; L.sort.__doc__&apos;L.sort(key=None, reverse=False) -&gt; None -- stable sort *IN PLACE*&apos;</code></pre><p><strong>根据提供的key函数为元素产生一个键，列表的元素按照这个键值来排序</strong></p><pre><code>&gt;&gt;&gt; x = [&apos;abc&apos;,&apos;a&apos;,&apos;bc&apos;,&apos;abcd&apos;]&gt;&gt;&gt; x.sort(key=len)&gt;&gt;&gt; x[&apos;a&apos;, &apos;bc&apos;, &apos;abc&apos;, &apos;abcd&apos;]</code></pre><p><strong>反向排序</strong></p><pre><code>&gt;&gt;&gt; n = [3, 1, 2, 5]&gt;&gt;&gt; n.sort(reverse=True)&gt;&gt;&gt; n[5, 3, 2, 1]</code></pre><h3 id="使用-in-判断值是否存在"><a href="#使用-in-判断值是否存在" class="headerlink" title="使用 in 判断值是否存在"></a>使用 in 判断值是否存在</h3><pre><code>&gt;&gt;&gt; num = [1, 2, 3]&gt;&gt;&gt; 1 in numTrue&gt;&gt;&gt; 4 in numFalse</code></pre><h3 id="使用-len-获取长度"><a href="#使用-len-获取长度" class="headerlink" title="使用 len() 获取长度"></a>使用 len() 获取长度</h3><pre><code>&gt;&gt;&gt; num[1, 2, 3]&gt;&gt;&gt; len(num)3</code></pre><h3 id="使用-赋值，使用copy-复制"><a href="#使用-赋值，使用copy-复制" class="headerlink" title="使用=赋值，使用copy()复制"></a>使用=赋值，使用copy()复制</h3><p><strong>如果将一个列表赋值给了多个变量，改变其中的任何一处造成其他变量对应的值也被修改</strong></p><pre><code>&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; a[1, 2, 3]&gt;&gt;&gt; b = a&gt;&gt;&gt; a[0] = &apos;surpise&apos;&gt;&gt;&gt; a[&apos;surpise&apos;, 2, 3]&gt;&gt;&gt; b[&apos;surpise&apos;, 2, 3]</code></pre><p>b与a实际上指向的是同一个对象，因此，无论我们是通过a还是b来修改列表的内容，其结果都会作用于双方。</p><pre><code>&gt;&gt;&gt; b[&apos;surpise&apos;, 2, 3]&gt;&gt;&gt; b[0] = &apos;I love surprises&apos;&gt;&gt;&gt; b[&apos;I love surprises&apos;, 2, 3]&gt;&gt;&gt; a[&apos;I love surprises&apos;, 2, 3]&gt;&gt;&gt;</code></pre><p><strong>通过下面任意一种方法，都可以将一个列表的值复制到另一个新的列表中</strong></p><pre><code>&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; b = a.copy()&gt;&gt;&gt; c = list(a)&gt;&gt;&gt; d = a[:]&gt;&gt;&gt; a[0] = &apos;one&apos;&gt;&gt;&gt; b[1, 2, 3]&gt;&gt;&gt; c[1, 2, 3]&gt;&gt;&gt; d[1, 2, 3]</code></pre><ul><li>列表 copy() 函数</li><li>list() 转换函数</li><li>列表分片 [:]</li></ul><p>b、c、d 都是a的复制：它们是自身带有值的新对象，与原始的a所指向的列表对象[1, 2, 3]没有任何关联。所以改变a不影响b、c、d的复制。</p><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><blockquote><p>与列表类似，元组也是由任意类型元素组成的有序序列。与列表不同的是，元组是不可改变的，这意味着一但元组被定义，将无法再进行增加、删除或者修改元素等操作。因此元组就像一个常量列表。元组的只读性使其拥有更好的内存效率和性能。除无法修改外，其普通特征和列表类似。 在需要传递 “不可变” 参数时，应鼓励用元组替代列表。</p></blockquote><h3 id="使用-创建元组"><a href="#使用-创建元组" class="headerlink" title="使用()创建元组"></a>使用()创建元组</h3><p>可以用()创建一个空元组：</p><pre><code>&gt;&gt;&gt; empty_tuple = () # 创建空元组&gt;&gt;&gt; empty_tuple()&gt;&gt;&gt; type(empty_tuple)&lt;class &apos;tuple&apos;&gt;</code></pre><p>创建包含一个或多个元素的元组时，每一个元素后面需要跟着一个逗号：</p><pre><code>&gt;&gt;&gt; num = (1)&gt;&gt;&gt; type(num)&lt;class &apos;int&apos;&gt;&gt;&gt;&gt; num = (1,)&gt;&gt;&gt; type(num)&lt;class &apos;tuple&apos;&gt;</code></pre><p>创建多个元素的元组，可以用括号将所有元素包裹起来，这会使得程序更加清晰：</p><pre><code>&gt;&gt;&gt; num = 1,2,3&gt;&gt;&gt; num1 = (1,2,3)&gt;&gt;&gt; num(1, 2, 3)&gt;&gt;&gt; num1(1, 2, 3)</code></pre><h3 id="元组解包"><a href="#元组解包" class="headerlink" title="元组解包"></a>元组解包</h3><p><strong>可以一口气将元组赋值给多个变量</strong></p><pre><code>&gt;&gt;&gt; num(1, 2, 3)&gt;&gt;&gt; a, b, c = num&gt;&gt;&gt; a1&gt;&gt;&gt; b2&gt;&gt;&gt; c3</code></pre><p><strong>可以利用元组在一条语句中对多个变量的值进行交换，而不需借助临时变量</strong></p><pre><code>&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = 2&gt;&gt;&gt; a, b = b, a&gt;&gt;&gt; a2&gt;&gt;&gt; b1</code></pre><h3 id="元组与列表对比"><a href="#元组与列表对比" class="headerlink" title="元组与列表对比"></a>元组与列表对比</h3><p>在许多地方都可以用元组代替列表，但元组的方法函数与类表相比要少一些，元组没有append()、insert()等等。因为一但创建元组变无法修改，既然列表更加灵活那为什么不在所有地方都是用列表呢？原因如下：</p><ul><li>元组占用的空间小</li><li>你不会意外修改元组的值</li><li>可以将元组用作字典的键（详细的后面会介绍）</li><li>命名元组可以作为对象的代替</li><li>函数的参数是以元组形式是传递的</li></ul><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><blockquote><p>字典 是键值对的无序集合。向字典添加一个键的同时，必须为该键增添一个值。（之后可随时修改该值。） Python 的字典为通过键获取值进行了优化，而不是反过来。比如字典的键必须为不可变对象，因此列表、字典和集合都不能作为字典的键，但元组可以作为字典的键。</p></blockquote><h3 id="使用-创建字典"><a href="#使用-创建字典" class="headerlink" title="使用 {} 创建字典"></a>使用 {} 创建字典</h3><pre><code>&gt;&gt;&gt; empty_dict = {}&gt;&gt;&gt; empty_dict{}&gt;&gt;&gt; type(empty_dict)&lt;class &apos;dict&apos;&gt;</code></pre><h3 id="字典的键也不允许重复"><a href="#字典的键也不允许重复" class="headerlink" title="字典的键也不允许重复"></a>字典的键也不允许重复</h3><pre><code>&gt;&gt;&gt; c = {&quot;1&quot;:2, &quot;1&quot;:3, &quot;1&quot;:4}&gt;&gt;&gt; c{&apos;1&apos;: 4}</code></pre><h3 id="使用-dict-转换为字典"><a href="#使用-dict-转换为字典" class="headerlink" title="使用 dict() 转换为字典"></a>使用 dict() 转换为字典</h3><p><strong>记住，字典是无序的，字典中元素的顺序是无关紧要的，实际存储顺序可能取决于你添加元素的顺序。</strong></p><p>双值子序列的序列转换成字典：</p><pre><code>&gt;&gt;&gt; type(empty_dict)&lt;class &apos;dict&apos;&gt;&gt;&gt;&gt; lol = [ [&apos;a&apos;, &apos;b&apos;], [&apos;c&apos;, &apos;d&apos;], [&apos;e&apos;, &apos;f&apos;] ]&gt;&gt;&gt; dict(lol){&apos;c&apos;: &apos;d&apos;, &apos;a&apos;: &apos;b&apos;, &apos;e&apos;: &apos;f&apos;}</code></pre><p>双值元组列表：</p><pre><code>&gt;&gt;&gt; lot = [ (&apos;a&apos;, &apos;b&apos;), (&apos;c&apos;, &apos;d&apos;), (&apos;e&apos;, &apos;f&apos;) ]&gt;&gt;&gt; dict(lot){&apos;c&apos;: &apos;d&apos;, &apos;a&apos;: &apos;b&apos;, &apos;e&apos;: &apos;f&apos;}</code></pre><p>双字符串的字符串组成的列表：</p><pre><code>&gt;&gt;&gt; los = [ &apos;ab&apos;, &apos;cd&apos;, &apos;ef&apos; ]&gt;&gt;&gt; dict(los){&apos;c&apos;: &apos;d&apos;, &apos;a&apos;: &apos;b&apos;, &apos;e&apos;: &apos;f&apos;}</code></pre><p>双字符的字符串组成的元组：</p><pre><code>&gt;&gt;&gt; tos = ( &apos;ab&apos;, &apos;cd&apos;, &apos;ef&apos;)&gt;&gt;&gt; dict(tos){&apos;c&apos;: &apos;d&apos;, &apos;a&apos;: &apos;b&apos;, &apos;e&apos;: &apos;f&apos;}</code></pre><h3 id="使用-key-添加或修改元素"><a href="#使用-key-添加或修改元素" class="headerlink" title="使用 [key] 添加或修改元素"></a>使用 [key] 添加或修改元素</h3><pre><code>&gt;&gt;&gt; d = {&quot;11&quot;:1, &quot;12&quot;:2, &quot;13&quot;:3}&gt;&gt;&gt; d[&quot;14&quot;] = 4&gt;&gt;&gt; d{&apos;13&apos;: 3, &apos;14&apos;: 4, &apos;11&apos;: 1, &apos;12&apos;: 2}</code></pre><h3 id="使用-update-合并字典"><a href="#使用-update-合并字典" class="headerlink" title="使用 update() 合并字典"></a>使用 update() 合并字典</h3><pre><code>&gt;&gt;&gt; d = {&quot;l1&quot;:1, &quot;l2&quot;:2, &quot;l3&quot;:3}&gt;&gt;&gt; e = {&quot;14&quot;:4, &quot;15&quot;:5}&gt;&gt;&gt; d.update(e)&gt;&gt;&gt; d{&apos;14&apos;: 4, &apos;l1&apos;: 1, &apos;l2&apos;: 2, &apos;l3&apos;: 3, &apos;15&apos;: 5}</code></pre><h3 id="使用-del-删除具有指定键的元素"><a href="#使用-del-删除具有指定键的元素" class="headerlink" title="使用 del 删除具有指定键的元素"></a>使用 del 删除具有指定键的元素</h3><pre><code>&gt;&gt;&gt; d{&apos;14&apos;: 4, &apos;l1&apos;: 1, &apos;l2&apos;: 2, &apos;l3&apos;: 3, &apos;15&apos;: 5}&gt;&gt;&gt; del d[&quot;14&quot;]&gt;&gt;&gt; d{&apos;l1&apos;: 1, &apos;l2&apos;: 2, &apos;l3&apos;: 3, &apos;15&apos;: 5}</code></pre><h3 id="使用-clear-删除所有元素"><a href="#使用-clear-删除所有元素" class="headerlink" title="使用 clear() 删除所有元素"></a>使用 clear() 删除所有元素</h3><pre><code>&gt;&gt;&gt; d{&apos;l1&apos;: 1, &apos;l2&apos;: 2, &apos;l3&apos;: 3, &apos;15&apos;: 5}&gt;&gt;&gt; d{&apos;l1&apos;: 1, &apos;l2&apos;: 2, &apos;l3&apos;: 3, &apos;15&apos;: 5}&gt;&gt;&gt; d.clear()&gt;&gt;&gt; d{}</code></pre><h3 id="使用-in-判断是否存在"><a href="#使用-in-判断是否存在" class="headerlink" title="使用 in 判断是否存在"></a>使用 in 判断是否存在</h3><p>如果你希望判断某一个键是否存在于一个字典中，可以使用 in。</p><pre><code>&gt;&gt;&gt; d = {&quot;l1&quot;:1, &quot;l2&quot;:2, &quot;l3&quot;:3}&gt;&gt;&gt; d{&apos;l1&apos;: 1, &apos;l3&apos;: 3, &apos;l2&apos;: 2}&gt;&gt;&gt; 1 in dFalse&gt;&gt;&gt; &quot;l1&quot; in dTrue&gt;&gt;&gt; &quot;l4&quot; in dFalse</code></pre><h3 id="使用-keys-获取元素"><a href="#使用-keys-获取元素" class="headerlink" title="使用 keys() 获取元素"></a>使用 keys() 获取元素</h3><pre><code>&gt;&gt;&gt; d = {&quot;l1&quot;:1, &quot;l2&quot;:2, &quot;l3&quot;:3}&gt;&gt;&gt; d.keys()dict_keys([&apos;l1&apos;, &apos;l3&apos;, &apos;l2&apos;])</code></pre><h3 id="使用-values-获取所有值"><a href="#使用-values-获取所有值" class="headerlink" title="使用 values() 获取所有值"></a>使用 values() 获取所有值</h3><pre><code>&gt;&gt;&gt; d.values()dict_values([1, 3, 2])</code></pre><h3 id="使用-赋值，使用copy-复制-1"><a href="#使用-赋值，使用copy-复制-1" class="headerlink" title="使用=赋值，使用copy()复制"></a>使用=赋值，使用copy()复制</h3><p>与列表一样，对字典内容进行修改会反应到所有与之相关联的变量名上：</p><pre><code>&gt;&gt;&gt; d = {&quot;l1&quot;:1, &quot;l2&quot;:2, &quot;l3&quot;:3}&gt;&gt;&gt; d2 = d&gt;&gt;&gt; d.update({&quot;14&quot;:4})&gt;&gt;&gt; d{&apos;l1&apos;: 1, &apos;l3&apos;: 3, &apos;14&apos;: 4, &apos;l2&apos;: 2}&gt;&gt;&gt; d2{&apos;l1&apos;: 1, &apos;l3&apos;: 3, &apos;14&apos;: 4, &apos;l2&apos;: 2}</code></pre><p>若想避免这种情况，可以使用 copy() 将字典复制到一个新的字典中：</p><pre><code>&gt;&gt;&gt; d = {&quot;l1&quot;:1, &quot;l2&quot;:2, &quot;l3&quot;:3}&gt;&gt;&gt; d2 = d.copy()&gt;&gt;&gt; d2.update({&quot;14&quot;:5})&gt;&gt;&gt; d{&apos;l3&apos;: 3, &apos;l2&apos;: 2, &apos;l1&apos;: 1}&gt;&gt;&gt; d2{&apos;14&apos;: 5, &apos;l3&apos;: 3, &apos;l1&apos;: 1, &apos;l2&apos;: 2}</code></pre><h3 id="两个列表转换为字典"><a href="#两个列表转换为字典" class="headerlink" title="两个列表转换为字典"></a>两个列表转换为字典</h3><pre><code>&gt;&gt;&gt; l1 = [1,2,3]&gt;&gt;&gt; l2 = [&quot;one&quot;, &quot;two&quot;, &quot;there&quot;]&gt;&gt;&gt; zip(l1,l2)&lt;zip object at 0x0000000003569E08&gt;&gt;&gt;&gt; dict(zip(l1,l2)){1: &apos;one&apos;, 2: &apos;two&apos;, 3: &apos;there&apos;}</code></pre><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><blockquote><p>集合就像舍弃了值，仅剩下键的字典一样。键与键之间也不允许重复。如果你仅仅想知道某一个元素是否存在而不关心其他的，使用集合是个非常好的选择。如果需要为键附加其他信息的话建议使用字典。</p></blockquote><h3 id="使用-set-创建集合"><a href="#使用-set-创建集合" class="headerlink" title="使用 set() 创建集合"></a>使用 set() 创建集合</h3><pre><code>&gt;&gt;&gt; empty_set = set()&gt;&gt;&gt; empty_setset()&gt;&gt;&gt; type(empty_set)&lt;class &apos;set&apos;&gt;</code></pre><blockquote><p>与字典一样，集合是无序的。{} 创建的是一个空字典，这仅仅是因为字典出现的比较早抢占了花括号；因此创建空的集合，使用set()。</p></blockquote><h3 id="使用set-将其他类型转换为集合"><a href="#使用set-将其他类型转换为集合" class="headerlink" title="使用set()将其他类型转换为集合"></a>使用set()将其他类型转换为集合</h3><p><strong>你可以利用已有的列表、字符串、元组或字典的内容来创建集合，其中重复的值会被丢弃。</strong></p><pre><code>&gt;&gt;&gt; set(&apos;letters&apos;){&apos;t&apos;, &apos;s&apos;, &apos;l&apos;, &apos;e&apos;, &apos;r&apos;}</code></pre><p>再试试用列表建立集合：</p><pre><code>&gt;&gt;&gt; set([&apos;one&apos;, &apos;two&apos;, &apos;three&apos;]){&apos;one&apos;, &apos;three&apos;, &apos;two&apos;}</code></pre><p>再看下元组：</p><pre><code>&gt;&gt;&gt; set((&apos;one&apos;, &apos;two&apos;, &apos;three&apos;)){&apos;one&apos;, &apos;three&apos;, &apos;two&apos;}</code></pre><p>当字典作为参数传入set()函数时，只有键会被使用：</p><pre><code>&gt;&gt;&gt; set( {&apos;apple&apos;: &apos;red&apos;, &apos;orange&apos;: &apos;orange&apos;, &apos;cherry&apos;: &apos;red&apos;} ){&apos;apple&apos;, &apos;orange&apos;, &apos;cherry&apos;}</code></pre><h3 id="使用in测试值是否存在"><a href="#使用in测试值是否存在" class="headerlink" title="使用in测试值是否存在"></a>使用in测试值是否存在</h3><pre><code>&gt;&gt;&gt; num_set = {&apos;one&apos;, &apos;two&apos;, &apos;three&apos;}&gt;&gt;&gt; &quot;one&quot; in num_setTrue&gt;&gt;&gt; &quot;four&quot; in num_setFalse</code></pre><h3 id="添加删除数据"><a href="#添加删除数据" class="headerlink" title="添加删除数据"></a>添加删除数据</h3><pre><code>&gt;&gt;&gt; num_set = {&apos;one&apos;, &apos;two&apos;, &apos;three&apos;}&gt;&gt;&gt; num_set.add(&quot;four&quot;) # 增加数据&gt;&gt;&gt; num_set{&apos;four&apos;, &apos;one&apos;, &apos;three&apos;, &apos;two&apos;}&gt;&gt;&gt; num_set{&apos;four&apos;, &apos;one&apos;, &apos;three&apos;, &apos;two&apos;}&gt;&gt;&gt; num_set.remove(&quot;three&quot;) # 删除数据&gt;&gt;&gt; num_set{&apos;four&apos;, &apos;one&apos;, &apos;two&apos;}</code></pre><h3 id="交集和并集"><a href="#交集和并集" class="headerlink" title="交集和并集"></a>交集和并集</h3><pre><code>&gt;&gt;&gt; s1 = set([1, 2, 3])&gt;&gt;&gt; s2 = set([2, 3, 4])&gt;&gt;&gt; s1 &amp; s2{2, 3}&gt;&gt;&gt; s1 | s2{1, 2, 3, 4}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;列表&quot;&gt;&lt;a href=&quot;#列表&quot; class=&quot;headerlink&quot; title=&quot;列表&quot;&gt;&lt;/a&gt;列表&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;列表由一系列按特定顺序排列的元素组成，可以将任何东西加入列表中，其中的元素之间可以没有任何关系。列表非常适合利用顺序和位置定位某一元素，尤其是当元素的顺序或内容经常发生改变时。与字符串不同，列表是可变的。你可以直接对原始列表进行修改:添加新元素、删除 或覆盖已有元素。在列表中，具有相同值的元素允许出现多次。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;常用列表方法&quot;&gt;&lt;a href=&quot;#常用列表方法&quot; class=&quot;headerlink&quot; title=&quot;常用列表方法&quot;&gt;&lt;/a&gt;常用列表方法&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; dir(list)
[&amp;apos;__add__&amp;apos;, &amp;apos;__class__&amp;apos;, &amp;apos;__contains__&amp;apos;,
&amp;apos;__delattr__&amp;apos;, &amp;apos;__delitem__&amp;apos;, &amp;apos;__dir__&amp;apos;,
&amp;apos;__doc__&amp;apos;, &amp;apos;__eq__&amp;apos;, &amp;apos;__format__&amp;apos;, &amp;apos;__ge__&amp;apos;,
&amp;apos;__getattribute__&amp;apos;, &amp;apos;__getitem__&amp;apos;, &amp;apos;__gt__&amp;apos;,
&amp;apos;__hash__&amp;apos;, &amp;apos;__iadd__&amp;apos;, &amp;apos;__imul__&amp;apos;,
&amp;apos;__init__&amp;apos;, &amp;apos;__iter__&amp;apos;, &amp;apos;__le__&amp;apos;,
 &amp;apos;__len__&amp;apos;, &amp;apos;__lt__&amp;apos;, &amp;apos;__mul__&amp;apos;,
&amp;apos;__ne__&amp;apos;, &amp;apos;__new__&amp;apos;, &amp;apos;__reduce__&amp;apos;,
 &amp;apos;__reduce_ex__&amp;apos;, &amp;apos;__repr__&amp;apos;, &amp;apos;__reversed__&amp;apos;
, &amp;apos;__rmul__&amp;apos;, &amp;apos;__setattr__&amp;apos;, &amp;apos;__setitem__&amp;apos;,
&amp;apos;__sizeof__&amp;apos;, &amp;apos;__str__&amp;apos;, &amp;apos;__subclasshook__&amp;apos;,
 &amp;apos;append&amp;apos;, &amp;apos;clear&amp;apos;, &amp;apos;copy&amp;apos;, &amp;apos;count&amp;apos;, &amp;apos;extend&amp;apos;, &amp;apos;index&amp;apos;, &amp;apos;insert&amp;apos;, &amp;apos;pop&amp;apos;, &amp;apos;remove&amp;apos;, &amp;apos;reverse&amp;apos;, &amp;apos;sort&amp;apos;]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;列表切片&quot;&gt;&lt;a href=&quot;#列表切片&quot; class=&quot;headerlink&quot; title=&quot;列表切片&quot;&gt;&lt;/a&gt;列表切片&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;定义列表后，可从其中获取任何部分作为新列表。该技术称为对列表进行切片，对于有序序列，包括字符串，元组都可以切片。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; lists = [&amp;apos;Michael&amp;apos;, &amp;apos;Sarah&amp;apos;, &amp;apos;Tracy&amp;apos;, &amp;apos;Bob&amp;apos;, &amp;apos;Jack&amp;apos;]
&amp;gt;&amp;gt;&amp;gt; lists[0]
&amp;apos;Michael&amp;apos;
&amp;gt;&amp;gt;&amp;gt; lists[1:3] # 切片实际是索引尾部取开区间 [1:3)
[&amp;apos;Sarah&amp;apos;, &amp;apos;Tracy&amp;apos;]
&amp;gt;&amp;gt;&amp;gt; lists[:3]  # 相当于索引lists[0:3]
[&amp;apos;Michael&amp;apos;, &amp;apos;Sarah&amp;apos;, &amp;apos;Tracy&amp;apos;]
&amp;gt;&amp;gt;&amp;gt; lists[0:3]
[&amp;apos;Michael&amp;apos;, &amp;apos;Sarah&amp;apos;, &amp;apos;Tracy&amp;apos;]
&amp;gt;&amp;gt;&amp;gt; lists[-2:] # 取列表最后两个元素
[&amp;apos;Bob&amp;apos;, &amp;apos;Jack&amp;apos;]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;append-向列表尾部追加一个元素&quot;&gt;&lt;a href=&quot;#append-向列表尾部追加一个元素&quot; class=&quot;headerlink&quot; title=&quot;append 向列表尾部追加一个元素&quot;&gt;&lt;/a&gt;append 向列表尾部追加一个元素&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; lists
[&amp;apos;Michael&amp;apos;, &amp;apos;Sarah&amp;apos;, &amp;apos;Tracy&amp;apos;, &amp;apos;Bob&amp;apos;, &amp;apos;Jack&amp;apos;]
&amp;gt;&amp;gt;&amp;gt; lists.append(&amp;apos;chenfan&amp;apos;)
&amp;gt;&amp;gt;&amp;gt; lists
[&amp;apos;Michael&amp;apos;, &amp;apos;Sarah&amp;apos;, &amp;apos;Tracy&amp;apos;, &amp;apos;Bob&amp;apos;, &amp;apos;Jack&amp;apos;, &amp;apos;chenfan&amp;apos;]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;clear-清除列表中的所有元素&quot;&gt;&lt;a href=&quot;#clear-清除列表中的所有元素&quot; class=&quot;headerlink&quot; title=&quot;clear 清除列表中的所有元素&quot;&gt;&lt;/a&gt;clear 清除列表中的所有元素&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; num = [1,2,3,4,5]
&amp;gt;&amp;gt;&amp;gt; num.clear()
&amp;gt;&amp;gt;&amp;gt; num
[]
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="python基础知识" scheme="http://www.chenfanlinux.org/categories/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Python" scheme="http://www.chenfanlinux.org/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python基础之内置数据类型(一)</title>
    <link href="http://www.chenfanlinux.org/2018/02/13/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%80/"/>
    <id>http://www.chenfanlinux.org/2018/02/13/Python基础之内置数据类型-一/</id>
    <published>2018-02-13T14:14:07.000Z</published>
    <updated>2018-02-14T04:20:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在 Python 中， 每个值都有一种数据类型，但您并不需要声明变量的数据类型。那该方式是如何运作的呢？Python 根据每个变量的初始赋值情况分析其类型，并在内部对其进行跟踪。</p></blockquote><h3 id="内置数据类型分类"><a href="#内置数据类型分类" class="headerlink" title="内置数据类型分类"></a>内置数据类型分类</h3><ul><li>Booleans［布尔型］ 或为 True［真］ 或为 False［假］</li><li>Numbers［数值型］ 可以是 Integers［整数］（1 和 2）、Floats［浮点数］（1.1 和 1.2）、Fractions［分数］（1/2 和 2/3）；甚至是 Complex Number［复数］</li><li>Strings［字符串型］ 是 Unicode 字符序列，例如： 一份 html 文档</li><li>Bytes［字节］ 和 Byte Arrays［字节数组］， 例如: 一份 jpeg 图像文件</li><li>Lists［列表］ 是值的有序序列</li><li>Tuples［元组］ 是有序而不可变的值序列</li><li>Sets［集合］ 是装满无序值的包裹</li><li>Dictionaries［字典］ 是键值对的无序包裹</li></ul><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><p><strong>布尔类型或为真或为假。Python 有两个被巧妙地命名为 True 和 False 的常量，可用于对布尔类型的直接赋值。表达式也可以计算为布尔类型的值。数字 0、None、以及元素为空的容器类对象都可视作 bool False，反之为 True。</strong></p><pre><code>&gt;&gt;&gt; bool(0)False&gt;&gt;&gt; bool(None)False&gt;&gt;&gt; bool([])False&gt;&gt;&gt; bool({})False&gt;&gt;&gt; bool(1)True&gt;&gt;&gt; bool([1,2])True</code></pre><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><p>python本身支持整数以及浮点数。你可以对这些数字进行下表中的计算。</p><p><img src="https://s1.ax1x.com/2018/02/13/9YZkc9.png" alt="数字类型"></p><a id="more"></a><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>任何仅含数字的序列在 Python 中都被认为是整数</p><pre><code>&gt;&gt;&gt; 55</code></pre><p>Python还支持运算次序，因此你可在同一个表达式中使用多种运算。你还可以使用括号来修 改运算次序，让Python按你指定的次序执行运算，如下所示:</p><pre><code>&gt;&gt;&gt; 2 + 3 * 414&gt;&gt;&gt; (2 + 3) * 420</code></pre><p>在这些示例中，空格不影响Python计算表达式的方式，它们的存在旨在让你阅读代码时，能迅速确定先执行哪些运算。</p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p><strong>Python将带小数点的数字都称为浮点数。大多数编程语言都使用了这个术语，它指出了这样一个事实:小数点可出现在数字的任何位置。</strong></p><pre><code>&gt;&gt;&gt; 0.1 + 0.10.2&gt;&gt;&gt; 2 * 0.10.2</code></pre><p>但需要注意的是，结果包含的小数位数可能是不确定的:</p><pre><code>&gt;&gt;&gt; 3 * 0.10.30000000000000004&gt;&gt;&gt; 0.2 + 0.10.30000000000000004&gt;&gt;&gt; 4 * 0.10.4</code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是由多个字符组成的序列。在Python中，用引号括起的都是字符串，字符串定义简单自由，可以是单引号、双引号或者三引号。字符串是不可变序列（immutable, sequence）类型，默认存储 Unicode 文本。</p><h3 id="字符串使用"><a href="#字符串使用" class="headerlink" title="字符串使用"></a>字符串使用</h3><pre><code>&gt;&gt;&gt; s = &quot;chenfanlinux博客&quot;&gt;&gt;&gt; len(s)14&gt;&gt;&gt; print(ascii(s))&apos;chenfanlinux\u535a\u5ba2&apos;</code></pre><p>内置函数 ascii 将目标转换为可打印 ASCII 字符组成的字符串。</p><p><strong>构建字符串很容易，单引号、双引号，以及跨行的三个引号。</strong></p><pre><code>&gt;&gt;&gt; &quot;ab&apos;c&quot;  #双引号&quot;ab&apos;c&quot;&gt;&gt;&gt; &apos;ab&quot;c&quot;&apos; #单引号&apos;ab&quot;c&quot;&gt;&gt;&gt; &quot;&quot;&quot; abc #多行efdhij&quot;&quot;&quot;&apos; abc\nefd\nhij\n&apos;&gt;&gt;&gt; &apos;ab\&apos;c&apos; #引号转义&quot;ab&apos;c&quot;</code></pre><p><strong>可在字面量前添加特殊指示符。</strong></p><pre><code>&gt;&gt;&gt; print(r&quot;abc\nd&quot;)  # raw string，禁用转义。abc\nd&gt;&gt;&gt; type(b&quot;ab&quot;)&lt;class &apos;bytes&apos;&gt;&gt;&gt;&gt; type(u&quot;ab&quot;)&lt;class &apos;str&apos;&gt;</code></pre><h3 id="str-类型转换"><a href="#str-类型转换" class="headerlink" title="str() 类型转换"></a>str() 类型转换</h3><pre><code>&gt;&gt;&gt; &quot;abc&quot; + str(2.2)&apos;abc2.2&apos;</code></pre><h3 id="合并字符串"><a href="#合并字符串" class="headerlink" title="合并字符串"></a>合并字符串</h3><h4 id="format格式化输出-推荐使用"><a href="#format格式化输出-推荐使用" class="headerlink" title="format格式化输出(推荐使用)"></a>format格式化输出(推荐使用)</h4><pre><code>&gt;&gt;&gt; &quot;谁的博客很酷: {}&quot;.format(&quot;陈凡&quot;)&apos;谁的博客很酷: 陈凡&apos;&gt;&gt;&gt; s =&quot;&quot;&quot;你的名字是: {};你的工资是多少: {};你是做什么工作的: {}&quot;&quot;&quot;.format(&quot;陈凡&quot;,&quot;不告诉你&quot;,&quot;运维&quot;)&gt;&gt;&gt; print(s)你的名字是: 陈凡;你的工资是多少: 不告诉你;你是做什么工作的: 运维&gt;&gt;&gt; &quot;你喜欢什么音乐:{0} 你的偶像是谁:{1}&quot;.format(&quot;戒指&quot;,&quot;你猜&quot;)&apos;你喜欢什么音乐:戒指 你的偶像是谁:你猜&apos;</code></pre><h4 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="% 字符串格式化"></a>% 字符串格式化</h4><pre><code>&gt;&gt;&gt; msg = &quot;my name is %s and weight is %d kg!&quot; %(&quot;chenfan&quot;,120)&gt;&gt;&gt; print(msg)my name is chenfan and weight is 120 kg!</code></pre><h4 id=""><a href="#" class="headerlink" title="+"></a>+</h4><pre><code>&gt;&gt;&gt; &quot;欢迎来到:&quot; + &quot;www.chenfanlinux.org&quot;&apos;欢迎来到:www.chenfanlinux.org&apos;</code></pre><h3 id="split-分割"><a href="#split-分割" class="headerlink" title="split() 分割"></a>split() 分割</h3><pre><code>&gt;&gt;&gt; (man,said) = &quot;chenfan : welcome to my bolg:www.chenfanlinu.org&quot;.split(&apos;:&apos;,1)&gt;&gt;&gt; print(man)chenfan&gt;&gt;&gt; print(said) welcome to my bolg:www.chenfanlinu.org</code></pre><h3 id="strip-移除头尾的字符串"><a href="#strip-移除头尾的字符串" class="headerlink" title="strip() 移除头尾的字符串"></a>strip() 移除头尾的字符串</h3><pre><code>&gt;&gt;&gt; &quot; www.chenfanlinux.org &quot;.strip()  # 注意只能移除头部和尾部字符串&apos;www.chenfanlinux.org&apos;&gt;&gt; &quot;www.chenfanlinux. org&quot;.strip() # 这种空格无法移除www.chenfanlinux. org&apos;&gt;&gt;&gt; &quot;www.chenfanlinux.org&quot;.strip(&quot;www.&quot;)&apos;chenfanlinux.org&apos;</code></pre><h3 id="join-合并列表"><a href="#join-合并列表" class="headerlink" title="join() 合并列表"></a>join() 合并列表</h3><pre><code>&gt;&gt;&gt; path = [&quot;/etc&quot;, &quot;nginx&quot;, &quot;nginx.conf&quot; ]&gt;&gt;&gt; &apos;/&apos;.join(path)&apos;/etc/nginx/nginx.conf&apos;</code></pre><h3 id="find-查找子串"><a href="#find-查找子串" class="headerlink" title="find 查找子串"></a>find 查找子串</h3><p><strong>查找到返回该子串在原字符串中的索引位置，如果无法找到，find方法会返回值-1</strong></p><pre><code>&gt;&gt;&gt; s = &quot;www.chenfanlinux.org&quot;&gt;&gt;&gt; s.find(&quot;chenfan&quot;)  #访问索引位置4&gt;&gt;&gt; s.find(&quot;chenfanfan&quot;) # 未找到返回-1-1</code></pre><h3 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h3><p><strong>存在索引的数据类型，包括字符串,列表和元组都可以做切片操作</strong></p><pre><code>&gt;&gt;&gt; s = &quot;www.chenfanlinux.org&quot;&gt;&gt;&gt; s[0]&apos;w&apos;&gt;&gt;&gt; s[0:5]&apos;www.c&apos;&gt;&gt;&gt; s[-1]&apos;g&apos;</code></pre><h3 id="字符串运算符总结"><a href="#字符串运算符总结" class="headerlink" title="字符串运算符总结"></a>字符串运算符总结</h3><p>下表实例变量 a 值为字符串 “Hello”，b 变量值为 “Python”<br><img src="https://s1.ax1x.com/2018/02/13/9YVUSJ.png" alt="字符串运算符"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在 Python 中， 每个值都有一种数据类型，但您并不需要声明变量的数据类型。那该方式是如何运作的呢？Python 根据每个变量的初始赋值情况分析其类型，并在内部对其进行跟踪。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;内置数据类型分类&quot;&gt;&lt;a href=&quot;#内置数据类型分类&quot; class=&quot;headerlink&quot; title=&quot;内置数据类型分类&quot;&gt;&lt;/a&gt;内置数据类型分类&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Booleans［布尔型］ 或为 True［真］ 或为 False［假］&lt;/li&gt;
&lt;li&gt;Numbers［数值型］ 可以是 Integers［整数］（1 和 2）、Floats［浮点数］（1.1 和 1.2）、Fractions［分数］（1/2 和 2/3）；甚至是 Complex Number［复数］&lt;/li&gt;
&lt;li&gt;Strings［字符串型］ 是 Unicode 字符序列，例如： 一份 html 文档&lt;/li&gt;
&lt;li&gt;Bytes［字节］ 和 Byte Arrays［字节数组］， 例如: 一份 jpeg 图像文件&lt;/li&gt;
&lt;li&gt;Lists［列表］ 是值的有序序列&lt;/li&gt;
&lt;li&gt;Tuples［元组］ 是有序而不可变的值序列&lt;/li&gt;
&lt;li&gt;Sets［集合］ 是装满无序值的包裹&lt;/li&gt;
&lt;li&gt;Dictionaries［字典］ 是键值对的无序包裹&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;布尔类型&quot;&gt;&lt;a href=&quot;#布尔类型&quot; class=&quot;headerlink&quot; title=&quot;布尔类型&quot;&gt;&lt;/a&gt;布尔类型&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;布尔类型或为真或为假。Python 有两个被巧妙地命名为 True 和 False 的常量，可用于对布尔类型的直接赋值。表达式也可以计算为布尔类型的值。数字 0、None、以及元素为空的容器类对象都可视作 bool False，反之为 True。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; bool(0)
False
&amp;gt;&amp;gt;&amp;gt; bool(None)
False
&amp;gt;&amp;gt;&amp;gt; bool([])
False
&amp;gt;&amp;gt;&amp;gt; bool({})
False
&amp;gt;&amp;gt;&amp;gt; bool(1)
True
&amp;gt;&amp;gt;&amp;gt; bool([1,2])
True
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;数字类型&quot;&gt;&lt;a href=&quot;#数字类型&quot; class=&quot;headerlink&quot; title=&quot;数字类型&quot;&gt;&lt;/a&gt;数字类型&lt;/h2&gt;&lt;p&gt;python本身支持整数以及浮点数。你可以对这些数字进行下表中的计算。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/02/13/9YZkc9.png&quot; alt=&quot;数字类型&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python基础知识" scheme="http://www.chenfanlinux.org/categories/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Python" scheme="http://www.chenfanlinux.org/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>SQL查询语句及视图(三)</title>
    <link href="http://www.chenfanlinux.org/2018/02/05/SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E5%8F%8A%E8%A7%86%E5%9B%BE-%E4%B8%89/"/>
    <id>http://www.chenfanlinux.org/2018/02/05/SQL查询语句及视图-三/</id>
    <published>2018-02-05T06:57:20.000Z</published>
    <updated>2018-02-05T06:59:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a><a href="http://dev.mysql.com/doc/refman/5.7/en/subqueries.html" target="_blank" rel="noopener">SELECT</a></h2><h3 id="SELECT语法格式"><a href="#SELECT语法格式" class="headerlink" title="SELECT语法格式"></a>SELECT语法格式</h3><pre><code>SELECT values_to_display    FROM table_name    WHERE expression    GROUP BY how_to_group    HAVING expression    ORDER BY how_to_sort    LIMIT row_count;</code></pre><ul><li>SELECT子句：指定要显示的属性列</li><li>FROM子句：指定查询的对象(基本表或视图)</li><li>WHERE子句：指定查询的条件</li><li>GROUP BY子句：对查询的结果按指定列的值分组,该属性列值相等的记录为一组。通常会在每组中作用聚集函数</li><li>HAVING短语：只有满足指定条件的组才予以输出，对聚集计算的结果做过滤</li><li>ORDER BY子句：对查询结果按指定的列升序（ASC）或者降序（DESC）排序</li><li>LIMIT num ： 限制操作的行</li><li>执行过程： FROM –&gt; WHERE –&gt; GROUP BY –&gt; HAVING –&gt; ORDER BY –&gt; SELECT –&gt; LIMIT</li></ul><p><strong>WHERE expression: 比较表达式，内置函数；</strong></p><p><img src="https://s1.ax1x.com/2018/02/02/9EvdV1.png" alt=""></p><ul><li><p>特殊的比较操作符：</p><ul><li>BETWEEN… AND …:</li><li>IN：指定范围内值的存在性测试</li><li>IN(list): 指定的字段取的取值在此list中，则表示符合条件；</li><li>IS NULL</li><li>IS NOT NULL</li><li>LIKE：可使用通配符，%, _</li><li>RLIKE或REGEXP：可使用正则表达式的模式</li></ul></li><li><p>逻辑操作符：</p><ul><li>AND</li><li>OR</li><li>NOT</li></ul></li></ul><a id="more"></a><h3 id="创建用于查询的表"><a href="#创建用于查询的表" class="headerlink" title="创建用于查询的表"></a>创建用于查询的表</h3><h4 id="学生表"><a href="#学生表" class="headerlink" title="学生表"></a>学生表</h4><p><strong>Student(Sno,Sname,Ssex,Sage,Sdept)</strong></p><pre><code>mysql&gt; CREATE TABLE Student    -&gt; (Sno CHAR(9) PRIMARY KEY,    -&gt; Sname CHAR(20)   UNIQUE,    -&gt; Ssex CHAR(2),    -&gt; Sage SMALLINT,    -&gt; Sdept CHAR(20)    -&gt; );Query OK, 0 rows affected (0.07 sec)mysql&gt; DESC student;+-------+-------------+------+-----+---------+-------+| Field | Type        | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| Sno   | char(9)     | NO   | PRI | NULL    |       || Sname | char(20)    | YES  | UNI | NULL    |       || Ssex  | char(2)     | YES  |     | NULL    |       || Sage  | smallint(6) | YES  |     | NULL    |       || Sdept | char(20)    | YES  |     | NULL    |       |+-------+-------------+------+-----+---------+-------+mysql&gt; INSERT INTO Student VALUES  (&apos;201215121&apos;,&apos;李勇&apos;,&apos;男&apos;,19,&apos;CS&apos;), (&apos;201215122&apos;,&apos;刘晨&apos;,&apos;女&apos;,19,&apos;CS&apos;),(&apos;201215123&apos;,&apos;王敏&apos;,&apos;女&apos;,18,&apos;MA&apos;),(&apos;201215125&apos;,&apos;张立&apos;,&apos;男&apos;,19,&apos;IS&apos;);mysql&gt; SELECT * FROM Student;+-----------+-------+------+------+-------+| Sno       | Sname | Ssex | Sage | Sdept |+-----------+-------+------+------+-------+| 201215121 | 李勇  | 男   |   20 | CS    || 201215122 | 刘晨  | 女   |   19 | CS    || 201215123 | 王敏  | 女   |   18 | MA    || 201215125 | 张立  | 男   |   19 | IS    |+-----------+-------+------+------+-------+4 rows in set (0.00 sec)</code></pre><h4 id="课程表"><a href="#课程表" class="headerlink" title="课程表"></a>课程表</h4><p><strong>Course(Cno,Cname,Cpno,Ccredit)</strong></p><pre><code>mysql&gt; CREATE TABLE Course    -&gt; (Cno CHAR(4) PRIMARY KEY,    -&gt; Cname CHAR(40),    -&gt; Cpno CHAR(4),    -&gt; Ccredit SMALLINT,    -&gt; FOREIGN KEY(Cpno) REFERENCES Course(Cno)    -&gt; ); // Cpno是外码,被参照表的Course,被参照列是Cnomysql&gt; INSERT INTO Course (Cno,Cname,Ccredit) VALUES (&apos;1&apos;,&apos;数据库&apos;,4),    -&gt; (&apos;2&apos;,&apos;数学&apos;,2),(&apos;3&apos;,&apos;信息系统&apos;,4),(&apos;4&apos;,&apos;操作系统&apos;,3),(&apos;5&apos;,&apos;数据结构&apos;,4),    -&gt; (&apos;6&apos;,&apos;数据处理&apos;,2),(&apos;7&apos;,&apos;PASCAL语言&apos;,4);Query OK, 7 rows affected (0.18 sec)Records: 7  Duplicates: 0  Warnings: 0mysql&gt; UPDATE course SET cpno=&apos;5&apos; WHERE Cno=&apos;1&apos;;mysql&gt; UPDATE course SET cpno=&apos;1&apos; WHERE Cno=&apos;3&apos;;mysql&gt; UPDATE course SET cpno=&apos;6&apos; WHERE Cno=&apos;4&apos;;mysql&gt; UPDATE course SET cpno=&apos;7&apos; WHERE Cno=&apos;5&apos;;mysql&gt; UPDATE course SET cpno=&apos;6&apos; WHERE Cno=&apos;7&apos;;mysql&gt; SELECT * FROM Course;+-----+------------+------+---------+| Cno | Cname      | Cpno | Ccredit |+-----+------------+------+---------+| 1   | 数据库     | 5    |       4 || 2   | 数学       | NULL |       2 || 3   | 信息系统   | 1    |       4 || 4   | 操作系统   | 6    |       3 || 5   | 数据结构   | 7    |       4 || 6   | 数据处理   | NULL |       2 || 7   | PASCAL语言 | 6    |       4 |+-----+------------+------+---------+7 rows in set (0.00 sec)</code></pre><h4 id="选课表"><a href="#选课表" class="headerlink" title="选课表"></a>选课表</h4><p><strong>SC(Sno,Cno,Grade)</strong></p><pre><code>mysql&gt; CREATE TABLE SC    -&gt; (Sno CHAR(9),    -&gt; Cno CHAR(4),    -&gt; Grade SMALLINT,    -&gt; PRIMARY KEY(Sno,Cno),     /* 主码由两个属性构成，必须作为表级完整性进行定义*/    -&gt; FOREIGN KEY(Sno) REFERENCES Student(Sno),     /* 表级完整性约束条件， Sno是外码，被参照表是Student */    -&gt; FOREIGN KEY(Cno) REFERENCES Course(Cno)     /* 表级完整性约束条件， Cno是外码，被参照表是Course*/    -&gt; );mysql&gt; INSERT INTO sc VALUES (&apos;201215121&apos;,&apos;1&apos;,92),(&apos;201215121&apos;,&apos;2&apos;,85),(&apos;201215121&apos;,&apos;3&apos;,88),(&apos;201215122&apos;,&apos;2&apos;,90),(&apos;201215122&apos;,&apos;3&apos;,80);mysql&gt; SELECT * FROM sc;+-----------+-----+-------+| Sno       | Cno | Grade |+-----------+-----+-------+| 201215121 | 1   |    92 || 201215121 | 2   |    85 || 201215121 | 3   |    88 || 201215122 | 2   |    90 || 201215122 | 3   |    80 |+-----------+-----+-------+</code></pre><h2 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h2><h3 id="查询表中的若干列"><a href="#查询表中的若干列" class="headerlink" title="查询表中的若干列"></a>查询表中的若干列</h3><p><strong>查询指定的列</strong><br>查询全体学生的学号与姓名：</p><pre><code>mysql&gt; SELECT Sno,Sname FROM Student;+-----------+-------+| Sno       | Sname |+-----------+-------+| 201215122 | 刘晨  || 201215125 | 张立  || 201215121 | 李勇  || 201215123 | 王敏  |+-----------+-------+4 rows in set (0.00 sec)</code></pre><p><strong>查询全部的列</strong><br>查询全体学生的详细记录：</p><pre><code>mysql&gt; SELECT * FROM Student;+-----------+-------+------+------+-------+| Sno       | Sname | Ssex | Sage | Sdept |+-----------+-------+------+------+-------+| 201215121 | 李勇  | 男   |   20 | CS    || 201215122 | 刘晨  | 女   |   19 | CS    || 201215123 | 王敏  | 女   |   18 | MA    || 201215125 | 张立  | 男   |   19 | IS    |+-----------+-------+------+------+-------+4 rows in set (0.00 sec)</code></pre><p><strong>查询经过计算的值</strong></p><blockquote><p>SELECT子句的&lt;目标列表达式&gt;不仅可以为表中的属性列， 也可以是表达式</p></blockquote><p>查全体学生的姓名及其出生年份：</p><pre><code>mysql&gt; SELECT Sname,2017-Sage FROM Student;+-------+-----------+| Sname | 2017-Sage |+-------+-----------+| 李勇  |      1997 || 刘晨  |      1998 || 王敏  |      1999 || 张立  |      1998 |+-------+-----------+</code></pre><p>查询全体学生的姓名、 出生年份和所在的院系， 要<br>求用小写字母表示系名：</p><pre><code>mysql&gt; SELECT Sname,&apos;出生年份:&apos;,2017-Sage,LOWER(Sdept) FROM Student;+-------+-----------+-----------+--------------+| Sname | 出生年份: | 2017-Sage | LOWER(Sdept) |+-------+-----------+-----------+--------------+| 李勇  | 出生年份: |      1997 | cs           || 刘晨  | 出生年份: |      1998 | cs           || 王敏  | 出生年份: |      1999 | ma           || 张立  | 出生年份: |      1998 | is           |+-------+-----------+-----------+--------------+</code></pre><p>使用列别名改变查询结果的列标题:</p><pre><code>mysql&gt; SELECT Sname NAME,&apos;出生年份:&apos; BIRTH,2017-Sage BIRTHDAY,LOWER(Sdept) DEPARTMENTFROM Student;+------+-----------+----------+------------+| NAME | BIRTH     | BIRTHDAY | DEPARTMENT |+------+-----------+----------+------------+| 李勇 | 出生年份: |     1997 | cs         || 刘晨 | 出生年份: |     1998 | cs         || 王敏 | 出生年份: |     1999 | ma         || 张立 | 出生年份: |     1998 | is         |+------+-----------+----------+------------+</code></pre><h3 id="选择表中的若干元组"><a href="#选择表中的若干元组" class="headerlink" title="选择表中的若干元组"></a>选择表中的若干元组</h3><p><strong>消除取值重复的行</strong></p><blockquote><p>指定DISTINCT关键词，去掉表中重复的行,如果没有指定DISTINCT关键词，则缺省为ALL</p></blockquote><pre><code>mysql&gt; SELECT  Sno FROM Sc;+-----------+| Sno       |+-----------+| 201215121 || 201215121 || 201215122 || 201215121 || 201215122 |+-----------+5 rows in set (0.00 sec)mysql&gt; SELECT  DISTINCT Sno FROM Sc;+-----------+| Sno       |+-----------+| 201215121 || 201215122 |+-----------+2 rows in set (0.18 sec)</code></pre><p><strong>查询符合条件的行</strong></p><p>（1）比较大小</p><pre><code>// 查询计算机科学系全体学生的名单：mysql&gt; SELECT Sname FROM student WHERE Sdept=&apos;CS&apos;;+-------+| Sname |+-------+| 李勇  || 刘晨  |+-------+// 查询所有年龄在20岁以下的学生姓名及其年龄:mysql&gt; SELECT Sname,Sage FROM student WHERE Sage&lt;20;+-------+------+| Sname | Sage |+-------+------+| 刘晨  |   19 || 王敏  |   18 || 张立  |   19 |+-------+------+// 查询考试成绩及格的学生的学号:mysql&gt; SELECT DISTINCT Sno FROM sc WHERE Grade&gt;60;+-----------+| Sno       |+-----------+| 201215121 || 201215122 |+-----------+</code></pre><p>  (2) 确定范围  BETWEEN … AND …  NOT BETWEEN … AND …</p><pre><code>// 查询年龄在20~23岁（包括20岁和23岁）之间的学生的姓名、系别和年龄:mysql&gt; SELECT Sname,Sdept,Sage FROM student WHERE Sage BETWEEN 20 AND 23;+-------+-------+------+| Sname | Sdept | Sage |+-------+-------+------+| 李勇  | CS    |   20 |+-------+-------+------+// 查询年龄不在20~23岁之间的学生姓名、 系别和年龄:mysql&gt; SELECT Sname,Sdept,Sage FROM student WHERE Sage NOT  BETWEEN 20 AND 23;+-------+-------+------+| Sname | Sdept | Sage |+-------+-------+------+| 刘晨  | CS    |   19 || 王敏  | MA    |   18 || 张立  | IS    |   19 |+-------+-------+------+</code></pre><p>  (3) 确定集合  IN &lt;值表&gt;, NOT IN &lt;值表&gt;</p><pre><code>// 查询计算机科学系（ CS）、数学系（ MA）和信息系（ IS）学生的姓名和性别:mysql&gt; SELECT Sname Ssex FROM student WHERE Sdept in (&apos;CS&apos;,&apos;MA&apos;,&apos;IS&apos;);+------+| Ssex |+------+| 李勇 || 刘晨 || 王敏 || 张立 |+------+// 查询既不是计算机科学系、 也不是数学系的学生的姓名和性别:mysql&gt; SELECT Sname Ssex FROM student WHERE Sdept not in (&apos;CS&apos;,&apos;MA&apos;);+------+| Ssex |+------+| 张立 |+------+</code></pre><p> （4）字符匹配 [NOT] LIKE ‘&lt;匹配串&gt;’ [ESCAPE ‘ &lt;换码字符&gt;’]</p><pre><code>// &lt;匹配串&gt;可以是一个完整的字符串， 也可以含有通配符%和 _// 查询所有姓刘学生的姓名、学号和性别mysql&gt; SELECT Sname,Sno,Ssex FROM student WHERE Sname LIKE &apos;刘%&apos;;+-------+-----------+------+| Sname | Sno       | Ssex |+-------+-----------+------+| 刘晨  | 201215122 | 女   |+-------+-----------+------+// 查询所有不姓刘的学生姓名、学号和性别:mysql&gt; SELECT Sname,Sno,Ssex FROM student WHERE Sname NOT LIKE &apos;刘_&apos;;+-------+-----------+------+| Sname | Sno       | Ssex |+-------+-----------+------+| 李勇  | 201215121 | 男   || 王敏  | 201215123 | 女   || 张立  | 201215125 | 男   |+-------+-----------+------+</code></pre><p>   (5) 涉及空值的查询 IS NULL 或 IS NOT NULL ,“IS” 不能用 “ =” 代替</p><pre><code>// 查询缺少成绩的学生的学号和相应的课程号:mysql&gt; INSERT INTO sc (Sno,Cno) VALUES(&apos;201215125&apos;,&apos;2&apos;);mysql&gt; SELECT Sno,Cno FROM sc WHERE Grade IS NULL;    +-----------+-----+| Sno       | Cno |+-----------+-----+| 201215125 | 2   |+-----------+-----+</code></pre><p>  (6) 逻辑运算符： AND和 OR来连接多个查询条件</p><pre><code> // 查询计算机系年龄在20岁以下的学生姓名: mysql&gt; SELECT Sname FROM student WHERE Sdept=&apos;CS&apos; AND Sage &lt;20;+-------+| Sname |+-------+| 刘晨  |+-------+// 查询计算机科学系（ CS）和数学系（ MA））学生的姓名和性别:mysql&gt; SELECT Sname,Ssex FROM student WHERE Sdept=&apos;CS&apos; or Sdept=&apos;MA&apos; ;+-------+------+| Sname | Ssex |+-------+------+| 李勇  | 男   || 刘晨  | 女   || 王敏  | 女   |+-------+------+mysql&gt; SELECT Sname,Ssex FROM student WHERE Sdept IN (&apos;CS&apos;,&apos;MA&apos;);+-------+------+| Sname | Ssex |+-------+------+| 李勇  | 男   || 刘晨  | 女   || 王敏  | 女   |+-------+------+</code></pre><h3 id="ORDER-BY子句"><a href="#ORDER-BY子句" class="headerlink" title="ORDER BY子句"></a>ORDER BY子句</h3><blockquote><p>可以按一个或多个属性列排序,升序： ASC;降序： DESC;缺省值为升序</p></blockquote><pre><code>// 查询选修了3号课程的学生的学号及其成绩， 查询结果按分数降序排列:mysql&gt; SELECT Sno,Grade FROM SC WHERE Cno=&apos;3&apos; ORDER BY Grade DESC;+-----------+-------+| Sno       | Grade |+-----------+-------+| 201215121 |    88 || 201215122 |    80 |+-----------+-------+// 查询全体学生情况，查询结果按所在系的系号升序排列，同一系中的学生按年龄降序排列。mysql&gt; SELECT * FROM student ORDER BY Sdept,Sage DESC;+-----------+-------+------+------+-------+| Sno       | Sname | Ssex | Sage | Sdept |+-----------+-------+------+------+-------+| 201215121 | 李勇  | 男   |   20 | CS    || 201215122 | 刘晨  | 女   |   19 | CS    || 201215125 | 张立  | 男   |   19 | IS    || 201215123 | 王敏  | 女   |   18 | MA    |+-----------+-------+------+------+-------+</code></pre><h3 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h3><ul><li>统计记录个数<ul><li>COUNT(*)</li></ul></li><li>统计一列中值的个数<ul><li>COUNT([DISTINCT|ALL] &lt;列名&gt;)</li></ul></li><li>计算一列值的总和（ 此列必须为数值型）<ul><li>SUM([DISTINCT|ALL] &lt;列名&gt;)</li></ul></li><li>计算一列值的平均值（ 此列必须为数值型）<ul><li>AVG([DISTINCT|ALL] &lt;列名&gt;)</li></ul></li><li>求一列中的最大值和最小值<ul><li>MAX([DISTINCT|ALL] &lt;列名&gt;)</li><li>MIN([DISTINCT|ALL] &lt;列名&gt;)</li></ul></li></ul><p><strong>范例：</strong></p><pre><code>// 查询学生总人数mysql&gt; SELECT COUNT(*) FROM Student;+----------+| COUNT(*) |+----------+|        4 |+----------+// 查询选修了课程的学生人数mysql&gt; SELECT COUNT(DISTINCT Sno) FROM SC;+---------------------+| COUNT(DISTINCT Sno) |+---------------------+|                   3 |+---------------------+// 计算1号课程的学生平均成绩mysql&gt; SELECT AVG(Grade) FROM SC WHERE Cno=&apos;1&apos;;+------------+| AVG(Grade) |+------------+|    92.0000 |+------------+// 查询选修2号课程的学生最高分数mysql&gt; SELECT MAX(Grade) FROM SC WHERE Cno=&apos;2&apos;;+------------+| MAX(Grade) |+------------+|         90 |+------------+</code></pre><h3 id="GROUP-BY子句"><a href="#GROUP-BY子句" class="headerlink" title="GROUP BY子句"></a>GROUP BY子句</h3><blockquote><p>细化聚集函数的作用对象</p></blockquote><ul><li>如果未对查询结果分组， 聚集函数将作用于整个查询结果</li><li>对查询结果分组后，聚集函数将分别作用于每个组</li><li>按指定的一列或多列值分组，值相等的为一组</li></ul><p><strong>范例：</strong></p><pre><code>// 求各个课程号及相应的选课人数mysql&gt; SELECT Cno,COUNT(Sno) FROM SC GROUP BY Cno;+-----+------------+| Cno | COUNT(Sno) |+-----+------------+| 1   |          1 || 2   |          3 || 3   |          2 |+-----+------------+// 查询选修了2门以上课程的学生学号mysql&gt; SELECT Sno FROM SC GROUP BY Sno HAVING COUNT(*)&gt;2;+-----------+| Sno       |+-----------+| 201215121 |+-----------+// 查询平均成绩大于等于80分的学生学号和平均成绩mysql&gt; SELECT Sno,AVG(Grade) FROM SC GROUP BY Sno HAVING AVG(Grade)&gt;=80;+-----------+------------+| Sno       | AVG(Grade) |+-----------+------------+| 201215121 |    88.3333 || 201215122 |    85.0000 |+-----------+------------+</code></pre><p><strong><em>注意：WHERE子句中是不能用聚集函数作为条件表达式，使用HAVING子句做过滤。</em></strong></p><p><strong>HAVING短语与WHERE子句的区别：</strong></p><ul><li>作用对象不同</li><li>WHERE子句作用于基表或视图， 从中选择满足条件的元组</li><li>HAVING短语作用于组， 从中选择满足条件的组。</li></ul><h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><blockquote><p>同时涉及两个以上的表的查询,使用连接条件同时将两个表连接起来。</p></blockquote><p><strong>连接条件的格式：</strong></p><ul><li>[&lt;表名1&gt;.]&lt;列名1&gt;  &lt;比较运算符&gt;  [&lt;表名2&gt;.]&lt;列名2&gt;</li><li>[&lt;表名1&gt;.]&lt;列名1&gt;  BETWEEN   [&lt;表名2&gt;.]&lt;列名2&gt; AND [&lt;表名2&gt;.]&lt;列名3&gt;</li></ul><p><strong><em>连接条件中的各连接字段类型必须是可比的， 但名字不必相同。</em></strong></p><h3 id="等值与非等值连接查询-内连接"><a href="#等值与非等值连接查询-内连接" class="headerlink" title="等值与非等值连接查询(内连接)"></a>等值与非等值连接查询(内连接)</h3><p><strong>等值连接：连接运算符为=</strong></p><pre><code>// 查询每个学生及其选修课程的情况mysql&gt; SELECT Student.*,SC.* FROM Student,SC WHERE Student.Sno=sc.Sno;+-----------+-------+------+------+-------+-----------+-----+-------+| Sno       | Sname | Ssex | Sage | Sdept | Sno       | Cno | Grade |+-----------+-------+------+------+-------+-----------+-----+-------+| 201215121 | 李勇  | 男   |   20 | CS    | 201215121 | 1   |    92 || 201215121 | 李勇  | 男   |   20 | CS    | 201215121 | 2   |    85 || 201215121 | 李勇  | 男   |   20 | CS    | 201215121 | 3   |    88 || 201215122 | 刘晨  | 女   |   19 | CS    | 201215122 | 2   |    90 || 201215122 | 刘晨  | 女   |   19 | CS    | 201215122 | 3   |    80 || 201215125 | 张立  | 男   |   19 | IS    | 201215125 | 2   |  NULL |+-----------+-------+------+------+-------+-----------+-----+-------+</code></pre><p><strong>连接操作的执行过程:</strong></p><ul><li><a href="https://www.chinadb.org/home/nav/5/sub/25/third/110" target="_blank" rel="noopener">嵌套循环法</a>（ NESTED-LOOP）</li><li><a href="https://www.chinadb.org/home/nav/5/sub/25/third/111" target="_blank" rel="noopener">排序合并法</a>（ SORT-MERGE）</li><li><a href="https://www.chinadb.org/home/nav/5/sub/25/third/112" target="_blank" rel="noopener">散列连接</a> (HASH-JOIN)</li><li><a href="https://www.chinadb.org/home/nav/5/sub/25/third/113" target="_blank" rel="noopener">索引连接</a>（ INDEX-JOIN）</li></ul><h4 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h4><pre><code>// 使用自然连接,查询每个学生及其选修课程的情况:mysql&gt; SELECT Student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade FROM Student,SC WHERE Student.Sno=Sc.Sno;+-----------+-------+------+------+-------+-----+-------+| Sno       | Sname | Ssex | Sage | Sdept | Cno | Grade |+-----------+-------+------+------+-------+-----+-------+| 201215121 | 李勇  | 男   |   20 | CS    | 1   |    92 || 201215121 | 李勇  | 男   |   20 | CS    | 2   |    85 || 201215121 | 李勇  | 男   |   20 | CS    | 3   |    88 || 201215122 | 刘晨  | 女   |   19 | CS    | 2   |    90 || 201215122 | 刘晨  | 女   |   19 | CS    | 3   |    80 || 201215125 | 张立  | 男   |   19 | IS    | 2   |  NULL |+-----------+-------+------+------+-------+-----+-------+</code></pre><h4 id="复合查询"><a href="#复合查询" class="headerlink" title="复合查询"></a>复合查询</h4><blockquote><p>一条SQL语句可以同时完成选择和连接查询，这时WHERE子句是由连接谓词和选择谓词组成的复合条件。</p></blockquote><pre><code>// 查询选修2号课程且成绩在85分以上的所有学生的学号和姓名。mysql&gt; SELECT Student.Sno,Sname FROM Student,Sc WHERE Student.Sno=Sc.Sno AND SC.Cno=&apos;2&apos; AND SC.Grade&gt;85;+-----------+-------+| Sno       | Sname |+-----------+-------+| 201215122 | 刘晨  |+-----------+-------+</code></pre><p><strong><em>执行过程：</em></strong></p><ul><li>先执行选择语句，然后再执行连接语句</li><li>先从SC中挑选出Cno=’2’并且Grade&gt;90的元组形成一个中间关系</li><li>再和Student中满足连接条件的元组进行连接得到最终的结果关系</li></ul><h3 id="自身连接"><a href="#自身连接" class="headerlink" title="自身连接"></a>自身连接</h3><ul><li>一个表与其自己进行连接</li><li>需要给表起别名以示区别</li><li>由于所有属性名都是同名属性，因此必须使用别名前缀</li></ul><p><strong>范例：</strong></p><pre><code>// 查询每一门课的间接先修课（即先修课的先修课）SELECT FIRST.Cno,SECOND.Cpno FROM course FIRST,course SECOND WHERE FIRST.Cpno=SECOND.Cno;    +-----+------+| Cno | Cpno |+-----+------+| 3   | 5    || 1   | 7    || 4   | NULL || 7   | NULL || 5   | 6    |+-----+------+</code></pre><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p><strong>外连接与普通连接的区别</strong></p><ul><li>普通连接操作只输出满足连接条件的元组</li><li>外连接操作以指定表为连接主体，将主体表中不满足连接条件的元组一并输出</li><li>左外连接<ul><li>列出左边关系中所有的元组</li></ul></li><li>右外连接<ul><li>列出右边关系中所有的元组</li></ul></li></ul><p><strong>范例：</strong></p><pre><code>// 查询每个学生及其选修课程的情况mysql&gt; SELECT Student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade FROM Student LEFT  JOIN SC ON (Student.Sno=SC.Sno);+-----------+-------+------+------+-------+------+-------+| Sno       | Sname | Ssex | Sage | Sdept | Cno  | Grade |+-----------+-------+------+------+-------+------+-------+| 201215121 | 李勇  | 男   |   20 | CS    | 1    |    92 || 201215121 | 李勇  | 男   |   20 | CS    | 2    |    85 || 201215121 | 李勇  | 男   |   20 | CS    | 3    |    88 || 201215122 | 刘晨  | 女   |   19 | CS    | 2    |    90 || 201215122 | 刘晨  | 女   |   19 | CS    | 3    |    80 || 201215125 | 张立  | 男   |   19 | IS    | 2    |  NULL || 201215123 | 王敏  | 女   |   18 | MA    | NULL |  NULL |+-----------+-------+------+------+-------+------+-------+</code></pre><h3 id="多表连接"><a href="#多表连接" class="headerlink" title="多表连接"></a>多表连接</h3><blockquote><p>两个以上的表进行连接</p></blockquote><p><strong>范例：</strong></p><pre><code>//查询每个学生的学号、 姓名、 选修的课程名及成绩mysql&gt; SELECT Student.Sno,Sname,Cname,Grade FROM Student,SC,Course WHERE Student.Sno=SC.Sno AND SC.Cno=Course.Cno;+-----------+-------+----------+-------+| Sno       | Sname | Cname    | Grade |+-----------+-------+----------+-------+| 201215121 | 李勇  | 数据库   |    92 || 201215121 | 李勇  | 数学     |    85 || 201215121 | 李勇  | 信息系统 |    88 || 201215122 | 刘晨  | 数学     |    90 || 201215122 | 刘晨  | 信息系统 |    80 || 201215125 | 张立  | 数学     |  NULL |+-----------+-------+----------+-------+</code></pre><h2 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h2><blockquote><p>一个SELECT-FROM-WHERE语句称为一个查询块,将一个查询块嵌套在另一个查询块的WHERE子句<br>或HAVING短语的条件中的查询称为嵌套查询。</p></blockquote><ul><li>上层的查询块称为外层查询或父查询</li><li>下层查询块称为内层查询或子查询</li><li>SQL语言允许多层嵌套查询：即一个子查询中还可以嵌套其他子查询</li><li>子查询的限制：不能使用ORDER BY子句</li></ul><p><strong>嵌套查询求解方法</strong></p><ul><li>不相关子查询：子查询的查询条件不依赖于父查询<ul><li>由里向外 逐层处理。即每个子查询在上一级查询处理之前求解，子查询的结果用于建立其父查询的查找条<br>件。</li></ul></li><li>相关子查询：子查询的查询条件依赖于父查询<ul><li>首先取外层查询中表的第一个元组，根据它与内层查询相关的属性值处理内层查询，若WHERE子句返回值为真，则取此元组放入结果表</li><li>然后再取外层表的下一个元组</li><li>重复这一过程，直至外层表全部检查完为止</li></ul></li></ul><h3 id="带有IN谓词的子查询"><a href="#带有IN谓词的子查询" class="headerlink" title="带有IN谓词的子查询"></a>带有IN谓词的子查询</h3><pre><code>// 查询与“刘晨”在同一个系学习的学生:(1) 确定刘晨所在的系    mysql&gt; SELECT Sdept FROM Student WHERE Sname=&apos;刘晨&apos;;    +-------+    | Sdept |    +-------+    | CS    |    +-------+（2）查找所有在CS系学习的学生    mysql&gt; SELECT Sno,Sname,Sdept FROM Student WHERE Sdept=&apos;CS&apos;;    +-----------+-------+-------+    | Sno       | Sname | Sdept |    +-----------+-------+-------+    | 201215121 | 李勇  | CS    |    | 201215122 | 刘晨  | CS    |    +-----------+-------+-------+ (3) 将第一步查询嵌入到第二步查询的条件中    mysql&gt; SELECT Sno,Sname,Sdept FROM Student WHERE Sdept IN (SELECT Sdept FROM Student WHERE Sname=&apos;刘晨&apos;);    +-----------+-------+-------+    | Sno       | Sname | Sdept |    +-----------+-------+-------+    | 201215121 | 李勇  | CS    |    | 201215122 | 刘晨  | CS    |    +-----------+-------+-------+ // 使用自身连接也可以完成操作    mysql&gt; SELECT S1.Sno,S1.Sname,S1.Sdept FROM Student S1,Student S2 WHERE S1.Sdept=S2.Sdept AND S2.Sname=&apos;刘晨&apos;;    +-----------+-------+-------+    | Sno       | Sname | Sdept |    +-----------+-------+-------+    | 201215121 | 李勇  | CS    |    | 201215122 | 刘晨  | CS    |    +-----------+-------+-------+</code></pre><h3 id="带有比较运算符的子查询"><a href="#带有比较运算符的子查询" class="headerlink" title="带有比较运算符的子查询"></a>带有比较运算符的子查询</h3><blockquote><p>当能确切知道内层查询返回单值时，可用比较运<br>算符（ &gt;， &lt;， =， &gt;=， &lt;=， !=或&lt; &gt;）</p></blockquote><pre><code>// 找出每个学生超过他选修课程平均成绩的课程号:mysql&gt; SELECT Sno,Cno FROM SC x WHERE Grade&gt;=(SELECT AVG(Grade) FROM SC y WHERE y.Sno=x.Sno);+-----------+-----+| Sno       | Cno |+-----------+-----+| 201215121 | 1   || 201215122 | 2   |+-----------+-----+</code></pre><p><strong>可能的执行过程:</strong></p><ul><li><p>从外层查询中取出SC的一个元组x，将元组x的Sno值（ 201215121）传送给内层查询</p><p>  SELECT AVG(Grade)<br>  FROM SC y<br>  WHERE y.Sno=’201215121’;</p></li><li><p>执行内层查询，得到值88（近似值），用该值代替内层查询，得到外层查询</p><p>   SELECT Sno,Cno<br>  FROM SC x<br>  WHERE Grade &gt;=88;</p></li><li><p>执行这个查询，得到</p><p>  （ 201215121,1）<br>  （ 201215121,3）</p></li><li><p>然后外层查询取出下一个元组重复做上述上面的步骤，直到外层的SC元组全部处理完毕。</p></li></ul><h3 id="带有ANY（-SOME）或ALL谓词的子查询"><a href="#带有ANY（-SOME）或ALL谓词的子查询" class="headerlink" title="带有ANY（ SOME）或ALL谓词的子查询"></a>带有ANY（ SOME）或ALL谓词的子查询</h3><p><strong>语法：</strong></p><ul><li><blockquote><p>ANY 大于子查询结果中的某个值</p></blockquote></li><li><blockquote><p>ALL 大于子查询结果中的所有值</p></blockquote></li><li>（&gt;,&gt;=,&lt;,&lt;=,!= 或者&lt;&gt;）<br>使用ANY或ALL谓词时必须同时使用比较运算</li></ul><p><strong>范例：</strong></p><pre><code>// 查询非计算机科学系中比计算机科学系任意一个，学生年龄小的学生姓名和年龄。mysql&gt; SELECT Sname,Sage FROM Student WHERE Sage &lt; ANY (SELECT Sage FROM Student WHERE Sdept=&apos;CS&apos;) AND Sdept &lt;&gt; &apos;CS&apos; ;+-------+------+| Sname | Sage |+-------+------+| 王敏  |   18 || 张立  |   19 |+-------+------+</code></pre><h3 id="带有EXISTS谓词的子查询"><a href="#带有EXISTS谓词的子查询" class="headerlink" title="带有EXISTS谓词的子查询"></a>带有EXISTS谓词的子查询</h3><p><strong>EXISTS谓词</strong></p><ul><li>带有EXISTS谓词的子查询不返回任何数据，只产生逻辑<br>真值“ true”或逻辑假值“ false”。<ul><li>若内层查询结果非空，则外层的WHERE子句返回真值</li><li>若内层查询结果为空，则外层的WHERE子句返回假值</li></ul></li><li>由EXISTS引出的子查询，其目标列表达式通常都用 * ，<br>因为带EXISTS的子查询只返回真值或假值，给出列名无<br>实际意义。</li></ul><p><strong>NOT EXISTS谓词</strong></p><ul><li>若内层查询结果非空，则外层的WHERE子句返回假值</li><li>若内层查询结果为空，则外层的WHERE子句返回真值</li></ul><p><strong>范例：</strong></p><pre><code>// 查询所有选修了1号课程的学生姓名:// 1.本查询涉及Student和SC关系// 2.在Student中依次取每个元组的Sno值，用此值去检查SC表// 3.若SC中存在这样的元组，其Sno值等于此Student.Sno值，并且其Cno= ‘1’，则取此Student.Sname送入结果表mysql&gt; SELECT Sname FROM Student WHERE EXISTS (SELECT * FROM SC WHERE Sno=Student.Sno AND Cno=&apos;1&apos;);+-------+| Sname |+-------+| 李勇  |+-------+// 查询没有选修1号课程的学生姓名:mysql&gt; SELECT Sname FROM Student WHERE NOT EXISTS (SELECT * FROM SC WHERE Sno=Student.Sno AND Cno=&apos;1&apos;);+-------+| Sname |+-------+| 刘晨  || 张立  || 王敏  |+-------+// 查询与“刘晨”在同一个系学习的学生mysql&gt; SELECT Sno,Sname,Sdept FROM Student S1 WHERE EXISTS (SELECT * FROM Student S2 WHERE S2.Sdept = S1.Sdept AND S2.Sname=&apos;刘晨&apos;);+-----------+-------+-------+| Sno       | Sname | Sdept |+-----------+-------+-------+| 201215121 | 李勇  | CS    || 201215122 | 刘晨  | CS    |+-----------+-------+-------+</code></pre><h2 id="集合查询"><a href="#集合查询" class="headerlink" title="集合查询"></a>集合查询</h2><p><strong>集合操作的种类:</strong></p><ul><li>并操作UNION</li><li>交操作INTERSECT</li><li>差操作EXCEPT</li></ul><p><strong><em>1.MySQL并不支持交与差运算，考虑用子查询（差）或多表连接查询（交）代替！</em></strong></p><p><strong><em>2.参加集合操作的各查询结果的列数必须相同;对应项的数据类型也必须相同</em></strong></p><p>UNION：将多个查询结果合并起来时，系统自动去掉重复元组<br>UNION ALL：将多个查询结果合并起来时，保留重复元组</p><p><strong>范例：</strong></p><pre><code>// 查询计算机科学系的学生及年龄不大于19岁的学生。(UNION)mysql&gt; SELECT * FROM Student WHERE Sdept=&apos;CS&apos; UNION SELECT * FROM Student WHERE Sage&lt;=19;+-----------+-------+------+------+-------+| Sno       | Sname | Ssex | Sage | Sdept |+-----------+-------+------+------+-------+| 201215121 | 李勇  | 男   |   20 | CS    || 201215122 | 刘晨  | 女   |   19 | CS    || 201215123 | 王敏  | 女   |   18 | MA    || 201215125 | 张立  | 男   |   19 | IS    |+-----------+-------+------+------+-------+// 查询计算机科学系的学生与年龄不大于19岁的学生的交集。</code></pre><h2 id="SELECT语句的一般格式"><a href="#SELECT语句的一般格式" class="headerlink" title="SELECT语句的一般格式"></a>SELECT语句的一般格式</h2><pre><code>SELECT [ALL|DISTINCT]&lt;目标列表达式&gt; [别名] [ ,&lt;目标列表达式&gt; [别名]] …FROM &lt;表名或视图名&gt; [别名][ ,&lt;表名或视图名&gt; [别名]] …|(&lt;SELECT语句&gt;)[AS]&lt;别名&gt;[WHERE &lt;条件表达式&gt;][GROUP BY &lt;列名1&gt;[HAVING&lt;条件表达式&gt;]][ORDER BY &lt;列名2&gt; [ASC|DESC]];</code></pre><h3 id="目标列表达式格式"><a href="#目标列表达式格式" class="headerlink" title="目标列表达式格式"></a>目标列表达式格式</h3><ul><li>*</li><li>&lt;表名&gt;.*</li><li>COUNT([DISTINCT|ALL]* )</li><li>[&lt;表名&gt;.]&lt;属性列名表达式&gt;[,&lt;表名&gt;.]&lt;属性列名<br>表达式&gt;]…</li></ul><p>其中&lt;属性列名表达式&gt;可以是由属性列、作用于属性列的聚集函数和常量的任意算术运算（ +， -， *， /）组成的运算公式</p><h3 id="聚集函数的一般格式"><a href="#聚集函数的一般格式" class="headerlink" title="聚集函数的一般格式"></a>聚集函数的一般格式</h3><p>{COUNT SUM  AVG MAX MIN}（ [DISTINCT|ALL] &lt;列名&gt;）</p><h3 id="WHERE子句的条件表达式的可选格式"><a href="#WHERE子句的条件表达式的可选格式" class="headerlink" title="WHERE子句的条件表达式的可选格式"></a>WHERE子句的条件表达式的可选格式</h3><p><img src="https://s1.ax1x.com/2018/02/05/9ubHII.png" alt="条件表达式"><br><img src="https://s1.ax1x.com/2018/02/05/9uqJyD.png" alt="条件表达式1"><br><img src="https://s1.ax1x.com/2018/02/05/9uq6Og.png" alt="条件表达式2"></p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="视图的特点"><a href="#视图的特点" class="headerlink" title="视图的特点"></a>视图的特点</h3><ul><li>虚表，是从一个或几个基本表（或视图）导出的表</li><li>只存放视图的定义，不存放视图对应的数据</li><li>基表中的数据发生变化，从视图中查询出的数据也随之改变</li><li>关系数据库管理系统执行CREATE VIEW语句时只是把视图定义存入数据字典，并不执行其中的<br>SELECT语句</li><li>在对视图查询时，按视图的定义从基本表中将数<br>据查出</li></ul><h3 id="建立视图"><a href="#建立视图" class="headerlink" title="建立视图"></a>建立视图</h3><h4 id="语句格式"><a href="#语句格式" class="headerlink" title="语句格式"></a>语句格式</h4><pre><code>CREATE VIEW&lt;视图名&gt; [(&lt;列名&gt; [,&lt;列名&gt;]…)]AS &lt;子查询&gt;[WITH CHECK OPTION];</code></pre><h4 id="WITH-CHECK-OPTION"><a href="#WITH-CHECK-OPTION" class="headerlink" title="WITH CHECK OPTION"></a>WITH CHECK OPTION</h4><blockquote><p>对视图进行UPDATE， INSERT和DELETE操作时要保<br>证更新、插入或删除的行满足视图定义中的谓词条件<br>（即子查询中的条件表达式）</p></blockquote><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><blockquote><p>可以是任意的SELECT语句，是否可以含<br>有ORDER BY子句和DISTINCT短语，则决定具<br>体系统的实现。</p></blockquote><h4 id="组成视图的属性列名"><a href="#组成视图的属性列名" class="headerlink" title="组成视图的属性列名"></a>组成视图的属性列名</h4><ul><li>全部省略:由子查询中SELECT目标列中的诸字段组成</li><li>明确指定视图的所有列名<ul><li>某个目标列是聚集函数或列表达式</li><li>多表连接时选出了几个同名列作为视图的字段</li><li>需要在视图中为某个列启用新的更合适的名字</li></ul></li></ul><h4 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h4><pre><code>//建立信息系学生的视图  CREATE VIEW IS_Student1 AS SELECT Sno,Sname,Sage FROM Student WHERE Sdept=&apos;IS&apos; WITH CHECK OPTION;// 定义一个反映学生出生年份的视图mysql&gt; CREATE VIEW BT_S(Sno,Sname,Sbirth) AS SELECT Sno,Sname,2014-Sage FROM Student; Query OK, 0 rows affected (0.10 sec)mysql&gt; SELECT * FROM BT_S;+-----------+-------+--------+| Sno       | Sname | Sbirth |+-----------+-------+--------+| 201215121 | 李勇  |   1994 || 201215122 | 刘晨  |   1995 || 201215123 | 王敏  |   1996 || 201215125 | 张立  |   1995 |+-----------+-------+--------+ // 将学生的学号及平均成绩定义为一个视图mysql&gt; CREATE  VIEW S_G(Sno,Gavg) AS SELECT Sno,AVG(Grade) FROM SC GROUP BY Sno;mysql&gt; SELECT * FROM S_G;+-----------+---------+| Sno       | Gavg    |+-----------+---------+| 201215121 | 88.3333 || 201215122 | 85.0000 || 201215125 |    NULL |+-----------+---------+</code></pre><p><strong><em>定义IS_Student视图时加上了WITH CHECK OPTION子句，对该视图进行插入、修改和删除操作<br>时,RDBMS会自动加上Sdept=’IS’的条件。</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SELECT&quot;&gt;&lt;a href=&quot;#SELECT&quot; class=&quot;headerlink&quot; title=&quot;SELECT&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/subqueries.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SELECT&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;SELECT语法格式&quot;&gt;&lt;a href=&quot;#SELECT语法格式&quot; class=&quot;headerlink&quot; title=&quot;SELECT语法格式&quot;&gt;&lt;/a&gt;SELECT语法格式&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;SELECT values_to_display
    FROM table_name
    WHERE expression
    GROUP BY how_to_group
    HAVING expression
    ORDER BY how_to_sort
    LIMIT row_count;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;SELECT子句：指定要显示的属性列&lt;/li&gt;
&lt;li&gt;FROM子句：指定查询的对象(基本表或视图)&lt;/li&gt;
&lt;li&gt;WHERE子句：指定查询的条件&lt;/li&gt;
&lt;li&gt;GROUP BY子句：对查询的结果按指定列的值分组,该属性列值相等的记录为一组。通常会在每组中作用聚集函数&lt;/li&gt;
&lt;li&gt;HAVING短语：只有满足指定条件的组才予以输出，对聚集计算的结果做过滤&lt;/li&gt;
&lt;li&gt;ORDER BY子句：对查询结果按指定的列升序（ASC）或者降序（DESC）排序&lt;/li&gt;
&lt;li&gt;LIMIT num ： 限制操作的行&lt;/li&gt;
&lt;li&gt;执行过程： FROM –&amp;gt; WHERE –&amp;gt; GROUP BY –&amp;gt; HAVING –&amp;gt; ORDER BY –&amp;gt; SELECT –&amp;gt; LIMIT&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;WHERE expression: 比较表达式，内置函数；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/02/02/9EvdV1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;特殊的比较操作符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BETWEEN… AND …:&lt;/li&gt;
&lt;li&gt;IN：指定范围内值的存在性测试&lt;/li&gt;
&lt;li&gt;IN(list): 指定的字段取的取值在此list中，则表示符合条件；&lt;/li&gt;
&lt;li&gt;IS NULL&lt;/li&gt;
&lt;li&gt;IS NOT NULL&lt;/li&gt;
&lt;li&gt;LIKE：可使用通配符，%, _&lt;/li&gt;
&lt;li&gt;RLIKE或REGEXP：可使用正则表达式的模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;逻辑操作符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AND&lt;/li&gt;
&lt;li&gt;OR&lt;/li&gt;
&lt;li&gt;NOT&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="MySQL基础入门" scheme="http://www.chenfanlinux.org/categories/MySQL%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="MySQL" scheme="http://www.chenfanlinux.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据类型及SQL语句(二)</title>
    <link href="http://www.chenfanlinux.org/2018/02/02/MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8ASQL%E8%AF%AD%E5%8F%A5-%E4%BA%8C/"/>
    <id>http://www.chenfanlinux.org/2018/02/02/MySQL数据类型及SQL语句-二/</id>
    <published>2018-02-02T03:22:50.000Z</published>
    <updated>2018-02-02T03:24:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL数据类型"><a href="#MySQL数据类型" class="headerlink" title="MySQL数据类型"></a>MySQL数据类型</h2><blockquote><p>MySQL中定义数据字段的类型对你数据库的优化是非常重要的。MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。</p></blockquote><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><ul><li>精确数值型<ul><li>整形: TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT</li><li>十进制: DECIMAL</li></ul></li><li>近似数值型(浮点型):<ul><li>FLOAT</li><li>DOUBLE</li></ul></li></ul><p><img src="https://s1.ax1x.com/2018/01/31/9PaLMF.png" alt="数值类型"></p><h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><blockquote><p>char使用固定长度的空间进行存储，char(4)存储4个字符，根据编码方式的不同占用不同的字节，gbk编码方式，不论是中文还是英文，每个字符占用2个字节的空间，utf8编码方式，每个字符占用3个字节的空间。如果需要存储的字符串的长度跟所有值的平均长度相差不大，适合用char，如MD5。</p></blockquote><ul><li>CHAR,BINARY: 定长数据类型(CHAR不区分字符大小写,BINARY区分字符大小写)</li><li>VARCHAR,VARBINARY: 变长数据类型,需要结束符</li><li>TEXT: TINYTEXT, TEXT, MEDIUMTEXT, LOGTEXT</li><li>BLOB: TINYBLOB, BLOB, MEDIUMBLOB, LONGBLOB</li><li>ENUM,SET</li></ul><p><strong><em>注意：binary保存二进制字符串，就是说它们包含字节字符串而不是字符字符串，没有字符集限制</em></strong></p><p><img src="https://s1.ax1x.com/2018/01/31/9PdYon.png" alt="字符类型"><br><strong><em>注意：CHAR,VARCHAR,TEXT 不区分字符大小写；BINARY,VARBINARY,BLOB 区分字符大小写</em></strong></p><h3 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h3><ul><li>DATE</li><li>TIME</li><li>DATETIME</li><li>TIMESTAMP</li><li>YEAR(2), YEAR(4)</li></ul><p><img src="https://s1.ax1x.com/2018/01/31/9PwwtI.png" alt="日期时间型"></p><h3 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h3><ul><li>ENUM:从给定的字符串中选择一个字串</li><li>SET:集合,从指定字符集合中选择多个组合成一种变化形式</li></ul><a id="more"></a><h3 id="MySQL中字符大小写"><a href="#MySQL中字符大小写" class="headerlink" title="MySQL中字符大小写"></a>MySQL中字符大小写</h3><ol><li>SQL关键字及函数名不区字符大小写；<ul><li>SELECT, Select, select</li><li>切记：遵循同一种风格</li></ul></li><li>数据库、表、索引及视图的名称是否区分大小写取决于低层的OS及FS；</li><li>存储过程、存储函数及事件调度器不区分字符大小写；但触发器区分；</li><li>表别名不区分大小写；</li><li>字段中字符数据，类型为binary、blog、varbinary时区分大小写；其它的不区分；</li></ol><h3 id="数据类型的修饰符"><a href="#数据类型的修饰符" class="headerlink" title="数据类型的修饰符"></a>数据类型的修饰符</h3><h4 id="整形修饰符"><a href="#整形修饰符" class="headerlink" title="整形修饰符"></a>整形修饰符</h4><ul><li>NOT NULL</li><li>NULL</li><li>DEFAULT NUMBER</li><li>AUTO_INCREMENT:自动增长,需要下面三个条件的支持。<ul><li>UNSIGNED: 无符号,必须放在仅放在字段类型后</li><li>PRIMARY KEY | UNIQUE KEY</li><li>NOT NULL</li></ul></li></ul><p>例如:<br><code>CREATE TABLE t1 (id INT UNSIGNED AUTO_INCREMNET PRIMAY KEY NOT NULL,name VARCHAR(5) NOT NULL);</code></p><h4 id="字符型修饰符"><a href="#字符型修饰符" class="headerlink" title="字符型修饰符"></a>字符型修饰符</h4><blockquote><p>字符类型的修饰符: 定义在字段类型之后</p></blockquote><ul><li>NOT NULL: 非空约束</li><li>NULL: 默认为空</li><li>DEFAULT ‘STRING’: 指明默认值</li><li>CHARACTE SET ‘’: 使用字符集</li><li>COLLATION: 使用的排序规则</li></ul><p>查看字符集和排序规则: 在数据库上定义后,表可以继承,一般无须定义</p><p><code>mysql&gt;SHOW CHARACTER SET;</code><br><code>mysql&gt;SHOW COLLATION;</code></p><p>字符有通配符：</p><ul><li>%: 匹配任意长度的任意字符</li><li>_: 匹配任意单个字符；</li></ul><h4 id="日期时间型的修饰符"><a href="#日期时间型的修饰符" class="headerlink" title="日期时间型的修饰符:"></a>日期时间型的修饰符:</h4><ul><li>NOUT NULL</li><li>NULL</li><li>DEFAULT</li></ul><h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><blockquote><p><a href="https://zh.wikipedia.org/wiki/SQL" target="_blank" rel="noopener">SQL</a>（Structured Query Language),结构化查询语言，是关系数据库的标准语言;集数据定义语言（ DDL),数据操纵语言（ DML),<br>数据控制语言（ DCL）功能于一体。</p></blockquote><h3 id="SQL动词"><a href="#SQL动词" class="headerlink" title="SQL动词"></a>SQL动词</h3><table><thead><tr><th>SQL功能</th><th style="text-align:center">动词</th></tr></thead><tbody><tr><td>数据定义</td><td style="text-align:center">CREATE, DROP, ALTER</td></tr><tr><td>数据操作</td><td style="text-align:center">SELECT, INSERT, DELETE, UPDATE</td></tr><tr><td>数据控制</td><td style="text-align:center">GRANT, REVOKE</td></tr></tbody></table><h3 id="MySQL三级模式"><a href="#MySQL三级模式" class="headerlink" title="MySQL三级模式"></a>MySQL三级模式</h3><p><img src="https://s1.ax1x.com/2018/02/01/9kw5Q0.png" alt=""></p><h3 id="DDL-数据定义语言"><a href="#DDL-数据定义语言" class="headerlink" title="DDL 数据定义语言"></a>DDL 数据定义语言</h3><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E5%AE%9A%E7%BE%A9%E8%AA%9E%E8%A8%80" target="_blank" rel="noopener">数据定义语言</a>（Data Definition Language，DDL）是SQL语言集中负责数据结构定义与数据库对象定义的语言，由CREATE、ALTER与DROP三个语法所组成，最早是由Codasyl（Conference on Data Systems Languages）数据模型开始，现在被纳入SQL指令中作为其中一个子集。</p></blockquote><h4 id="CREATE对象"><a href="#CREATE对象" class="headerlink" title="CREATE对象"></a>CREATE对象</h4><p>CREATE操作的对象包括: 数据库表，索引，视图，用户，存储过程，存储函数，触发器，时间调度器等</p><pre><code>MariaDB [(none)]&gt; help createMany help items for your request exist.To make a more specific request, please type &apos;help &lt;item&gt;&apos;,where &lt;item&gt; is one of the followingtopics:   CREATE DATABASE  //数据库   CREATE EVENT    //事件   CREATE FUNCTION //函数   CREATE FUNCTION UDF //自定义函数   CREATE INDEX    //索引   CREATE PROCEDURE  //存储函数   CREATE SERVER     //服务器   CREATE TABLE   //表   CREATE TABLESPACE   //表空间   CREATE TRIGGER      //触发器   CREATE USER         //用户   CREATE VIEW         //视图   SHOW                //看CREATE语句过程   SHOW CREATE DATABASE   SHOW CREATE EVENT   SHOW CREATE FUNCTION   SHOW CREATE PROCEDURE   SHOW CREATE TABLE   SPATIAL</code></pre><h4 id="CREATE-DATABASE"><a href="#CREATE-DATABASE" class="headerlink" title="CREATE DATABASE"></a><a href="http://dev.mysql.com/doc/refman/5.5/en/create-database.html" target="_blank" rel="noopener">CREATE DATABASE</a></h4><p><strong>语法:</strong></p><pre><code>MariaDB [(none)]&gt; help create databaseCREATE {DATABASE | SCHEMA} [IF NOT EXISTS] db_name    [create_specification] ...create_specification:    [DEFAULT] CHARACTER SET [=] charset_name  | [DEFAULT] COLLATE [=] collation_name</code></pre><p><strong>实例:</strong><br><code>CREATE DATABASE IF NOT EXISTS test_db DEFAULT CHARACTER SET  utf8 COLLATE utf8_general_ci;</code></p><h4 id="CREATE-TABLE"><a href="#CREATE-TABLE" class="headerlink" title="CREATE TABLE"></a><a href="https://dev.mysql.com/doc/refman/5.5/en/create-table.html" target="_blank" rel="noopener">CREATE TABLE</a></h4><p><strong>语法：</strong></p><pre><code>CREATE TABLE [IF NOT EXISTS] tb_name(col1_def, col2_def,PRIMARY KEY(col_name,...),UNIQUE (col1,...), INDEX (col1,...))[table_option]------------------------table_option:ENGINE [=] engine_nameCOMMENT [=] &apos;string&apos;ROW_FORMAT [=] {DEFAULT|DYNAMIC|FIXED|COMPRESSED|REDUNDANT|COMPACT}TABLESPACE tablespace_name [STORAGE {DISK|MEMORY|DEFAULT}]</code></pre><p>显示表上的索引：<br><code>SHOW INDEXES FROM tb_name;</code></p><p><strong><em>注意: Storage Engine是指的表类型,也即在表创建时指明其使用的存储引擎:同一个库中要使用同一种存储引擎类型</em></strong></p><p><strong>范例:</strong><br><code>CREATE TABLE tb1 (id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY NOT NULL,name CHAR(5) NOT NULL);</code></p><p><strong>查看表结构：</strong><br><code>DESCRIBE tb1_name</code></p><p><strong>查看表状态信息：</strong><br><code>SHOW [FULL] TABLE STATUS [{FROM|IN} db_name] [LIKE &#39;pattern&#39; | WHERE expr]</code></p><p><strong>查看存储引擎：</strong><br><code>SELECT @@SESSION.default_storage_engine;</code></p><h4 id="ALTER-TABLE"><a href="#ALTER-TABLE" class="headerlink" title="ALTER TABLE"></a><a href="https://dev.mysql.com/doc/refman/5.5/en/alter-table.html" target="_blank" rel="noopener">ALTER TABLE</a></h4><p><strong>语法：</strong></p><pre><code>ALTER [ONLINE | OFFLINE] [IGNORE] TABLE tbl_name    [alter_specification [, alter_specification] ...]    [partition_options]    alter_specification:    table_options  | ADD [COLUMN] col_name column_definition        [FIRST | AFTER col_name ]  | ADD [COLUMN] (col_name column_definition,...)  | ADD {INDEX|KEY} [index_name]        [index_type] (index_col_name,...) [index_option] ...  | ALTER [COLUMN] col_name {SET DEFAULT literal | DROP DEFAULT}  | CHANGE [COLUMN] old_col_name new_col_name column_definition    [FIRST|AFTER col_name]  | DROP [COLUMN] col_name  ......</code></pre><p><strong>添加单列：</strong><br><code>ALTER TABLE tb_name ADD [COLUMN] col_name column_definition [FIRST|AFTER col_name]</code></p><p>范例:</p><pre><code>MariaDB [db1]&gt; ALTER TABLE tb1 ADD COLUMN sex ENUM(&apos;man&apos;,&apos;woman&apos;) AFTER name;Query OK, 0 rows affected (0.10 sec)Records: 0  Duplicates: 0  Warnings: 0MariaDB [db1]&gt; DESC tb1;+-------+---------------------+------+-----+---------+----------------+| Field | Type                | Null | Key | Default | Extra          |+-------+---------------------+------+-----+---------+----------------+| id    | int(10) unsigned    | NO   | PRI | NULL    | auto_increment || name  | char(5)             | NO   |     | NULL    |                || sex   | enum(&apos;man&apos;,&apos;woman&apos;) | YES  |     | NULL    |                |+-------+---------------------+------+-----+---------+----------------+</code></pre><p><strong>删除列：</strong><br><code>ALTER TABLE tb_name DROP [column] col_name</code></p><p>范例：</p><pre><code>MariaDB [db1]&gt; ALTER TABLE tb1 DROP sex;Query OK, 0 rows affected (0.14 sec)Records: 0  Duplicates: 0  Warnings: 0MariaDB [db1]&gt; DESC tb1;+-------+------------------+------+-----+---------+----------------+| Field | Type             | Null | Key | Default | Extra          |+-------+------------------+------+-----+---------+----------------+| id    | int(10) unsigned | NO   | PRI | NULL    | auto_increment || name  | char(5)          | NO   |     | NULL    |                |+-------+------------------+------+-----+---------+----------------+2 rows in set (0.00 sec)</code></pre><p><strong>修改列的类型：</strong><br><code>ALTER TABLE tb_name MODIFY [COLUMN] col_name column_definition</code></p><pre><code>MariaDB [db1]&gt; ALTER TABLE tb1 MODIFY  name  CHAR(6);Query OK, 0 rows affected (0.09 sec)Records: 0  Duplicates: 0  Warnings: 0MariaDB [db1]&gt; DESC tb1;+-------+------------------+------+-----+---------+----------------+| Field | Type             | Null | Key | Default | Extra          |+-------+------------------+------+-----+---------+----------------+| id    | int(10) unsigned | NO   | PRI | NULL    | auto_increment || name  | char(6)          | YES  |     | NULL    |                |+-------+------------------+------+-----+---------+----------------+2 rows in set (0.01 sec)</code></pre><h4 id="DROP-TABLE"><a href="#DROP-TABLE" class="headerlink" title="DROP TABLE"></a><a href="https://dev.mysql.com/doc/refman/5.5/en/drop-table.html" target="_blank" rel="noopener">DROP TABLE</a></h4><p><strong>语法：</strong></p><pre><code>DROP [TEMPORARY] TABLE [IF EXISTS]    tbl_name [, tbl_name] ...    [RESTRICT | CASCADE]</code></pre><ul><li>RESTRICT：删除表是有限制的<ul><li>欲删除的基本表不能被其他表的约束所引用</li><li>如果存在依赖该表的对象，则此表不能被删除</li></ul></li><li>CASCADE: 在删除基本表的同时，相关的依赖对象一起删除</li></ul><h3 id="DML-数据操作语言"><a href="#DML-数据操作语言" class="headerlink" title="DML 数据操作语言"></a>DML 数据操作语言</h3><blockquote><p><a href="http://www.360doc.com/content/16/0309/09/31217954_540682216.shtml" target="_blank" rel="noopener">数据操作语言</a>(Data Manipulation Language, DML）包含了数据库数据的增删改查操作，也是我们经常会见到的’CRUD’操作，其主要包括INSERT、SELECT、UPDATE和DELETE四条命令。</p></blockquote><h4 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h4><p><strong>语法：</strong></p><pre><code>INSERT [INTO] tbl_name [(col_name [, col_name] ...)]{VALUES | VALUE} ( value [, value] ...) [, ( value [, value] ...)] ...//批量插入INSERT  [INTO] tbl_name [(col_name,...)] SELECT ...INSERT [INTO] tbl_name SET col_name={expr | DEFAULT}, ...</code></pre><p><strong>范例：</strong></p><p>单行插入：</p><pre><code>mysql&gt; INSERT INTO tb1 (name) VALUES (&apos;chenfan&apos;);ERROR 1406 (22001): Data too long for column &apos;name&apos; at row 1mysql&gt; INSERT INTO tb1 (name) VALUES (&apos;chen&apos;);Query OK, 1 row affected (0.06 sec)mysql&gt; SELECT * FROM tb1;+----+------+| id | name |+----+------+|  1 | chen |+----+------+1 row in set (0.00 sec)</code></pre><p>插入查询到的数据:</p><pre><code>mysql&gt; INSERT INTO tb1 (name) SELECT name FROM tb1;Query OK, 1 row affected (0.06 sec)Records: 1  Duplicates: 0  Warnings: 0mysql&gt; SELECT * FROM tb1;+----+------+| id | name |+----+------+|  1 | chen ||  2 | chen |+----+------+2 rows in set (0.00 sec)</code></pre><h4 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h4><p><strong>语法:</strong></p><pre><code>UPDATE [LOW_PRIORITY] [IGNORE] table_reference    SET assignment_list    [WHERE where_condition]    [ORDER BY col1[,...] {ASC|DESC}]    [LIMIT row_count]assignment: col_name = valueassignment_list: assignment [, assignment] ...判断某字段值为空：IS NULL          不空：IS NOT NULLASC：升序DESC：降序</code></pre><p><strong>范例：</strong></p><pre><code>mysql&gt; SELECT * FROM tb1;+----+------+| id | name |+----+------+|  1 | chen ||  2 | chen |+----+------+2 rows in set (0.00 sec)mysql&gt; UPDATE tb1 SET name=&apos;fan&apos; WHERE id=&apos;2&apos; ;Query OK, 1 row affected (0.10 sec)Rows matched: 1  Changed: 1  Warnings: 0mysql&gt; SELECT * FROM tb1;+----+------+| id | name |+----+------+|  1 | chen ||  2 | fan  |+----+------+2 rows in set (0.00 sec)</code></pre><h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><p><strong>语法：</strong></p><pre><code>DELETE FROM tbl_name [WHERE where_condition]    [ORDER BY ...] [LIMIT row_count]</code></pre><p><strong>范例：</strong></p><pre><code>mysql&gt; DELETE FROM tb1 WHERE name=&apos;fan&apos;;Query OK, 1 row affected (0.06 sec)mysql&gt; SELECT * FROM tb1;+----+------+| id | name |+----+------+|  1 | chen |+----+------+1 row in set (0.00 sec)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MySQL数据类型&quot;&gt;&lt;a href=&quot;#MySQL数据类型&quot; class=&quot;headerlink&quot; title=&quot;MySQL数据类型&quot;&gt;&lt;/a&gt;MySQL数据类型&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;MySQL中定义数据字段的类型对你数据库的优化是非常重要的。MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;数值类型&quot;&gt;&lt;a href=&quot;#数值类型&quot; class=&quot;headerlink&quot; title=&quot;数值类型&quot;&gt;&lt;/a&gt;数值类型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;精确数值型&lt;ul&gt;
&lt;li&gt;整形: TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT&lt;/li&gt;
&lt;li&gt;十进制: DECIMAL&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;近似数值型(浮点型):&lt;ul&gt;
&lt;li&gt;FLOAT&lt;/li&gt;
&lt;li&gt;DOUBLE&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/01/31/9PaLMF.png&quot; alt=&quot;数值类型&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;字符型&quot;&gt;&lt;a href=&quot;#字符型&quot; class=&quot;headerlink&quot; title=&quot;字符型&quot;&gt;&lt;/a&gt;字符型&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;char使用固定长度的空间进行存储，char(4)存储4个字符，根据编码方式的不同占用不同的字节，gbk编码方式，不论是中文还是英文，每个字符占用2个字节的空间，utf8编码方式，每个字符占用3个字节的空间。如果需要存储的字符串的长度跟所有值的平均长度相差不大，适合用char，如MD5。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;CHAR,BINARY: 定长数据类型(CHAR不区分字符大小写,BINARY区分字符大小写)&lt;/li&gt;
&lt;li&gt;VARCHAR,VARBINARY: 变长数据类型,需要结束符&lt;/li&gt;
&lt;li&gt;TEXT: TINYTEXT, TEXT, MEDIUMTEXT, LOGTEXT&lt;/li&gt;
&lt;li&gt;BLOB: TINYBLOB, BLOB, MEDIUMBLOB, LONGBLOB&lt;/li&gt;
&lt;li&gt;ENUM,SET&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意：binary保存二进制字符串，就是说它们包含字节字符串而不是字符字符串，没有字符集限制&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/01/31/9PdYon.png&quot; alt=&quot;字符类型&quot;&gt;&lt;br&gt;&lt;strong&gt;&lt;em&gt;注意：CHAR,VARCHAR,TEXT 不区分字符大小写；BINARY,VARBINARY,BLOB 区分字符大小写&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;日期和时间类型&quot;&gt;&lt;a href=&quot;#日期和时间类型&quot; class=&quot;headerlink&quot; title=&quot;日期和时间类型&quot;&gt;&lt;/a&gt;日期和时间类型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;DATE&lt;/li&gt;
&lt;li&gt;TIME&lt;/li&gt;
&lt;li&gt;DATETIME&lt;/li&gt;
&lt;li&gt;TIMESTAMP&lt;/li&gt;
&lt;li&gt;YEAR(2), YEAR(4)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/01/31/9PwwtI.png&quot; alt=&quot;日期时间型&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;特殊类型&quot;&gt;&lt;a href=&quot;#特殊类型&quot; class=&quot;headerlink&quot; title=&quot;特殊类型&quot;&gt;&lt;/a&gt;特殊类型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;ENUM:从给定的字符串中选择一个字串&lt;/li&gt;
&lt;li&gt;SET:集合,从指定字符集合中选择多个组合成一种变化形式&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="MySQL基础入门" scheme="http://www.chenfanlinux.org/categories/MySQL%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="MySQL" scheme="http://www.chenfanlinux.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL基础概念及安装(一)</title>
    <link href="http://www.chenfanlinux.org/2018/01/30/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%89%E8%A3%85-%E4%B8%80/"/>
    <id>http://www.chenfanlinux.org/2018/01/30/MySQL基础概念及安装-一/</id>
    <published>2018-01-30T04:22:21.000Z</published>
    <updated>2018-02-02T03:24:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库概念及相关术语"><a href="#数据库概念及相关术语" class="headerlink" title="数据库概念及相关术语"></a>数据库概念及相关术语</h2><h3 id="什么是数据库？"><a href="#什么是数据库？" class="headerlink" title="什么是数据库？"></a>什么是数据库？</h3><p><a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93" target="_blank" rel="noopener">数据库</a>（Database）是按照数据结构来组织、存储和管理数据的仓库，每个数据库都有一个或多个不同的API用于创建，访问，管理，搜索和复制所保存的数据。我们也可以将数据存储在文件中，但是在文件中读写数据速度相对较慢。所以，现在我们使用关系型数据库管理系统（RDBMS）来存储和管理的大数据量。所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。</p><h3 id="RDBMS的特点"><a href="#RDBMS的特点" class="headerlink" title="RDBMS的特点"></a>RDBMS的特点</h3><blockquote><p>RDBMS即关系数据库管理系统(Relational Database Management System)</p></blockquote><ul><li>数据库中的数据集合都放在数据表(table)中</li><li>数据表由数据行(row)和数据列(column)构成</li><li>一个数据行就是一个数据表中的一条记录(record)</li><li>记录中包含多个信息项，数据表中的每一个数据列都对应一个信息项</li></ul><h3 id="RDBMS-术语"><a href="#RDBMS-术语" class="headerlink" title="RDBMS 术语"></a>RDBMS 术语</h3><ul><li><p>数据库：数据库是一些关联表的集合。</p></li><li><p>数据表：表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。</p></li><li><p>列： 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。</p></li><li><p>行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。</p></li><li><p>冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。</p></li><li><p>主键：主键是唯一的。必须提供数据，即字段不为空（null）；字段不重复，即唯一标识本行；一张表只能有一个主键。</p></li><li><p>外键：一个表中的某字段可填入的数据取决于另一个表的主 键或唯一键已有的数据 ，键表示了两个表之间的相关联系。一个表的主键是另外一张表的外键（唯一键也可以做外键）。</p></li><li><p>复合键：表中一个属性无法唯一标识一条记录，用两条属性组才可以唯一标识一条记录，那么两条属性主就组成了符合主键。单独的每列的字段可重复，但是两个列组成主键后总字段是不重复的，一般用于复合索引。</p></li><li><p>唯一键：一个或多个字段的组合，填入的数据必须能在本表唯一标识本行。和主键不同之处：在表中可以有多个；允许为空值。</p></li><li><p>索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构，类似于书籍的目录。</p></li></ul><h3 id="MySQL核心组件"><a href="#MySQL核心组件" class="headerlink" title="MySQL核心组件"></a>MySQL核心组件</h3><ul><li>连接池：认证、线程重用、连接数限制、内存检查、缓存；</li><li>SQL接口：DDL, DML, 关系型数据库的基本抽象；</li><li>parser: 查询转换、对象权限检查；</li><li>优化器：访问路径，性能相关的统计数据；</li><li>caches和buffers：与存储引擎自身相关的I/O性能提升工具；</li><li>存储引擎：<ul><li>MyISAM、InnoDB(变种：XtraDB)、Memory、Merge、Federated、CSV、Archive、Blackholl、Aria、SphinxSE、TokuDB</li></ul></li></ul><h3 id="数据库设计规范化"><a href="#数据库设计规范化" class="headerlink" title="数据库设计规范化"></a>数据库设计规范化</h3><blockquote><p>仅有好的DBMS并不足以避免数据冗余，必须在数据库的设计中创建好的表结构，数据库规范化的三个级别，范式是具有最小冗余的表结构。</p></blockquote><ul><li><p>第一范式(1NF)<br>就是属性不可分割，这个字段只能是一个值，不能被拆分成多个字段。</p></li><li><p>第二范式(2NF)<br>就是要有主键，要求其他字段都依赖于主键。为什么要有主键？没有主键就没有唯一性，没有唯一性在集合中就定位不到这行记录，所以要主键。</p></li><li><p>第三范式(3NF)<br>关系模式R中的非主关键字不能依赖于其他非主关键，即非主关键字之间不能有函数(传递)依赖关系，要消除传递依赖，消除冗余应该比较好理解一些，就是各种信息只在一个地方存储，不出现在多张表中。</p></li></ul><h3 id="事务（transaction）"><a href="#事务（transaction）" class="headerlink" title="事务（transaction）"></a>事务（transaction）</h3><blockquote><p>事务(Transaction)，一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)，通常就是指数据库事务。一个支持事务（Transaction）的数据库系统，必需要具有ACID特性。</p></blockquote><ul><li>原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</li><li>一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。</li><li>隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li><li>持久性（Durability）：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。</li></ul><a id="more"></a><h3 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h3><ul><li>域的完整性: domain integrity 该类型主要限制了列中的值大小。</li><li>实体完整性：entity integrity 实体属性中的标识属性不能为空、不能重复，该约束通过制定的主键实现，其约束有系统强制实施。</li><li>参照完整性：referential integrity 实体中的外键可以为空，但不能是错的。主要管理表（table）之间的关系。</li></ul><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><blockquote><p>约束主要完成对数据的检验和限制，从而保证数据库的完整性。</p></blockquote><ul><li><p>主键约束(PRIMARY KEY)<br>主键约束列不允许重复，即任意两行的主键值都不相同；每行都具有一个主键值，也不允许出现空值；</p></li><li><p>联合主键<br>有时候一个列的字段可能有重复，可以联合多个列设为主键。</p></li><li><p>外键约束(FOREIGN KEY)<br>外键约束是保证一个或两个表之间的参照完整性,保持数据一致性。表的外键可以是另一表的主键, 外键可以有重复的, 可以是空值。实现一对一或一对多关系。</p></li><li><p>唯一约束(UNIQUE)<br>指定表中某一列或多个列不能有相同的两行或者两行以上的数据存在</p></li><li><p>非空约束(NOT NULL)<br>输入值必须是非空的，需要注意的是允许控制尽量不要太多，太多会更消耗数据库性能。</p></li><li><p>默认约束(DEFAULT)<br>定义的常量必须与该列的数据类型、精度等匹配;每个列只能定义一个DEFAULT约束;DEFAULT约束会在使用INSERT语句。</p></li></ul><h2 id="安装MariaDB"><a href="#安装MariaDB" class="headerlink" title="安装MariaDB"></a>安装MariaDB</h2><blockquote><p>MariaDB的安装方式大致分为三种，第一种是利用程序包管理器的程序包进行安装，简单说可以通过配置yum源来进行安装；第二种是通过对源码进行编译安装进行一些功能选择，以满足生产活动中对一些特殊功能的要求；第三种是利用官网提供的已经编译好的二进制格式程序包进行安装。下面我们主要介绍如何在CentOS7上利用第三种方式进行安装。</p></blockquote><h3 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h3><h4 id="准备用户"><a href="#准备用户" class="headerlink" title="准备用户"></a>准备用户</h4><blockquote><p>因为MariaDB是通过用户身份进行运行的，因此要提前为其准备好运行账户和组。</p></blockquote><pre><code>[root@test ~] groupadd -r -g 306 mysql[root@test ~] useradd -r -g 306 -u 306 -s /sbin/nologin –m –d /app/data mysql[root@test ~] chown mysql:mysql /app/data</code></pre><p>改变目录/app/data目录的所有者和属组，我们可以用其当做数据库的存放目录，这也是我们之所以指定为其创建家目录的原因所在。</p><h4 id="准备二进制程序包"><a href="#准备二进制程序包" class="headerlink" title="准备二进制程序包"></a>准备二进制程序包</h4><pre><code>[root@test ~] tar xf mariadb-VERSION-linux-x86_64.tar.gz -C /usr/local[root@test ~] cd /usr/local;ln -sv mariadb-VERSION mysql[root@test ~] chown -R root:mysql /usr/local/mysql/</code></pre><h4 id="为数据库准备配置文件"><a href="#为数据库准备配置文件" class="headerlink" title="为数据库准备配置文件"></a>为数据库准备配置文件</h4><blockquote><p>数据库已经为我们准备了配置文件模板，我们可以通过这条命令查询并进行选择。而且有”my-small.cnf my-medium.cnf my-large.cnf my-huge.cnf”适合多种类型数据库的配置文件模板供我们选择。这里我们选择huge模板。</p></blockquote><pre><code>[root@test ~] cp  /usr/local/mysql/support-files/my-large.cnf /etc/my.cnf    [root@test ~] vim /etc/mysql/my.cnf  datadir = /app/data 指定数据库位置,必须要指定到我们之前选定的数据库存放目录。    innodb_file_per_table = on 允许每个表格单独存放,方便管理，可省略。    skip_name_resolve = on 禁止主机名反向解析，加快登录速度，可省略。</code></pre><p>数据库会在启动时自动读取配置文件，读取的次序是:<br>/etc/my.cnf —-&gt;/etc/mysql/my.cnf —-&gt;$MYSQL_HOME/my.cnf —&gt;default-extra-file=/path/to/somedir/my.cnf —&gt;~/.my.cnf</p><p>集中式的配置文件，能够为mysql的下面各应用程序提供配置信息</p><ul><li>[mysqld]</li><li>[mysqld_safe]</li><li>[mysqld-multi]</li><li>[server]</li><li>[mysql]</li><li>[mysqldump]</li><li>[client]</li></ul><h3 id="开始配置启动mysql"><a href="#开始配置启动mysql" class="headerlink" title="开始配置启动mysql"></a>开始配置启动mysql</h3><h4 id="为数据库准备配置文件-1"><a href="#为数据库准备配置文件-1" class="headerlink" title="为数据库准备配置文件"></a>为数据库准备配置文件</h4><blockquote><p>创建数据库文件并不需要我们直接手动进行，数据库为我们准备了脚本，我们只需要执行脚本即可。注意必须在目录/usr/local/mysql中，我们才可以执行这个脚本。</p></blockquote><pre><code>[root@test ~] cd /usr/local/mysql/[root@test ~] ./scripts/mysql_install_db --datadir=/app/data --user=mysql</code></pre><h4 id="创建日志文件"><a href="#创建日志文件" class="headerlink" title="创建日志文件"></a>创建日志文件</h4><blockquote><p>为了方便对数据进行管理和排错，我们要自己手动创建数据库文件，并且要给予数据库的运行账户mysql以权限，让其可以写数据进去。</p></blockquote><pre><code>[root@test ~] touch /var/log/mysqld.log[root@test ~] chown mysql /var/log/mysqld.log</code></pre><h4 id="配置服务脚本及开机自启"><a href="#配置服务脚本及开机自启" class="headerlink" title="配置服务脚本及开机自启"></a>配置服务脚本及开机自启</h4><pre><code>[root@test ~] install /usr/local/mysql/support-files/mysql.server /etc/rc.d/init.d/mysqld[root@test ~] chkconfig --add mysqld[root@test ~] chkconfig mysqld on[root@test ~] service mysqld start;ss -ntl</code></pre><p>为了使服务脚本可以利用service命令进行管理，我们需要将服务脚本copy进固定目录中，用install命令是因为这个命令既可以复制又可以加权限。</p><h4 id="为客户端工具指明PATH路径"><a href="#为客户端工具指明PATH路径" class="headerlink" title="为客户端工具指明PATH路径"></a>为客户端工具指明PATH路径</h4><blockquote><p>我们在安装编译好的二进制程序包的时候，不仅安装了服务端程序，也安装了客户端程序。所以我们要为客户端程序指明PATH路径。</p></blockquote><pre><code>[root@test ~] vim /etc/profile.d/mysql.sh   export PATH=/usr/local/mysql/bin:$PATH[root@test ~] source /etc/profile.d/mysql.sh</code></pre><h4 id="执行安全初始化脚本"><a href="#执行安全初始化脚本" class="headerlink" title="执行安全初始化脚本"></a>执行安全初始化脚本</h4><blockquote><p>刚安装好的数据库是无论什么身份都可以登录的，所以需要进行安全初始化，为数据库的root用户创建密码，以及禁止非数据库目录登录数据库。</p></blockquote><pre><code>[root@test ~] mysql_secure_installation\\ 执行后按照提示一步步进行设置即可。</code></pre><h4 id="安装后的设定"><a href="#安装后的设定" class="headerlink" title="安装后的设定"></a>安装后的设定</h4><p><strong>为所有root用户设定密码：</strong></p><ul><li><code>mysql&gt; SET PASSWORD FOR &#39;username&#39;@&#39;host&#39; = PASSWORD(&#39;your_password&#39;);</code></li><li><code>mysql&gt; update mysql.user SET password=PASSWORD(&#39;your_pass&#39;) WHERE clase;</code></li><li><code>$ mysqladmin -uUSERNMAE -hHOSTNAME_OR_IP -p password &#39;new_password&#39;</code></li></ul><p><strong>删除所有的匿名用户:</strong></p><p><code>mysql&gt; DORP USER &#39;&#39;@&#39;localhost&#39;;</code><br>上述可用 mysql_secure_installation 完成</p><p><strong>建议关闭主机名反解功能</strong></p><h2 id="MySQL客户端和服务端特性"><a href="#MySQL客户端和服务端特性" class="headerlink" title="MySQL客户端和服务端特性"></a>MySQL客户端和服务端特性</h2><h3 id="mysql客户端程序"><a href="#mysql客户端程序" class="headerlink" title="mysql客户端程序"></a>mysql客户端程序</h3><h4 id="常见的客户端程序"><a href="#常见的客户端程序" class="headerlink" title="常见的客户端程序"></a>常见的客户端程序</h4><ul><li><p>mysql: 交互式的CLI工具</p></li><li><p>mysqldump: 备份工具,基础mysql协议向mysqld发起查询请求,并将查得的数据保存在文本文件中,转换成create,insert语句保存在文本文件中</p></li><li><p>mysqladmin: 基于mysql协议管理mysqld</p></li><li><p>mysqlimport:数据导入工具</p></li><li>非客户端类的管理工具： myisamchk,myisampak</li></ul><h4 id="客户端类应用程序的可用选项"><a href="#客户端类应用程序的可用选项" class="headerlink" title="客户端类应用程序的可用选项:"></a>客户端类应用程序的可用选项:</h4><ul><li>-u, –user=</li><li>-h, –host=</li><li>-p, –password=</li><li>-P, –port=</li><li>–protocol={tcp|sock}</li><li>-S, –socket= 客户端和服务端位于同一主机</li><li>-D, –database=</li><li>-C, –compress</li><li>-e, 执行sql语句</li></ul><h4 id="如何获取程序默认使用的配置？"><a href="#如何获取程序默认使用的配置？" class="headerlink" title="如何获取程序默认使用的配置？"></a>如何获取程序默认使用的配置？</h4><ul><li>$ mysql  –print-defaults  客户端</li><li>$ mysqld –print-defaults  服务端</li></ul><h4 id="mysql的使用模式"><a href="#mysql的使用模式" class="headerlink" title="mysql的使用模式:"></a>mysql的使用模式:</h4><ul><li>交互式模式:可运行命令有两类<ul><li>客户端命令:<br>\h,help</li><li>服务器端命令:<br>SQL,需要语句结束符’;’</li></ul></li><li>脚本模式:<ul><li>$ mysql -uUSERNAME -hHOST -pPASSWORD &lt;/path/from/somefile.sql</li><li>mysql&gt; source /path/from/somefile.sql</li></ul></li></ul><h3 id="mysql服务端程序-mysqld）"><a href="#mysql服务端程序-mysqld）" class="headerlink" title="mysql服务端程序(mysqld）"></a>mysql服务端程序(mysqld）</h3><h4 id="获取配置文件参数"><a href="#获取配置文件参数" class="headerlink" title="获取配置文件参数"></a>获取配置文件参数</h4><pre><code>[root@docker mysql]# mysqld --verbose --helpsync-frm                                          TRUEsync-master-info                                  0sync-relay-log                                    0sync-relay-log-info                               0sysdate-is-now                                    FALSEtable-cache                                       256table-definition-cache                            400table-open-cache                                  256tc-heuristic-recover                              COMMITtemp-pool                                         TRUEthread-cache-size                                 8thread-concurrency                                8thread-handling                                   one-thread-per-connectionthread-pool-idle-timeout                          60thread-pool-max-threads                           500thread-pool-oversubscribe                         3thread-pool-size                                  1thread-pool-stall-limit                           500thread-stack                                      294912time-format                                       %H:%i:%stimed-mutexes                                     FALSEtmp-table-size                                    16777216tmpdir                                            /tmptransaction-alloc-block-size                      8192transaction-isolation                             REPEATABLE-READtransaction-prealloc-size                         4096updatable-views-with-limit                        YESuserstat                                          FALSEverbose                                           TRUEwait-timeout                                      28800xtradb-admin-command                              ON</code></pre><h4 id="获取运行中的mysql进程使用各参数及其值"><a href="#获取运行中的mysql进程使用各参数及其值" class="headerlink" title="获取运行中的mysql进程使用各参数及其值"></a>获取运行中的mysql进程使用各参数及其值</h4><pre><code>mysql&gt; SHOW GLOBAL VARIABLES;  //全局参数mysql&gt; SHOW SESSION VARIABLES; //会话级别参数</code></pre><p><strong><em>注意: 其中有些参数支持运行时修改，会立即生效;有些参数不支持,且只能通过修改配置文件,并重启服务器程序生效.有些参数的作用域是全局的,且不可改变;有些可以为每个用户提供单独的配置.</em></strong></p><h4 id="MySQL的服务器及状态变量"><a href="#MySQL的服务器及状态变量" class="headerlink" title="MySQL的服务器及状态变量"></a>MySQL的服务器及状态变量</h4><pre><code>SHOW {GLOBAL|SESSION} VARIABLES [LIKE CLAUSE];  //服务器变量SHOW {GLOBAL|SESSION} STATUS [LIKE CLAUSE];     //状态变量</code></pre><p> 状态变量：用户保存mysqld运行中的统计数据变量</p><h4 id="修改服务器变量的值"><a href="#修改服务器变量的值" class="headerlink" title="修改服务器变量的值"></a>修改服务器变量的值</h4><p><code>mysql&gt; help SET</code>  // 查看设置帮助</p><ul><li>全局:<ul><li>mysql&gt; SET GLOBAL system_var_name=value;</li><li>mysql&gt; SET @@global.system_var_name=value;</li></ul></li><li>会话:<ul><li>mysql&gt; SET [SESSION] system_var_name=value;</li><li>mysql&gt; SET @@[session.]system_var_name=value;</li></ul></li></ul><h4 id="SQL-MODE"><a href="#SQL-MODE" class="headerlink" title="SQL MODE"></a>SQL MODE</h4><blockquote><p>定义mysqld对约束等的响应行为</p></blockquote><pre><code>mysql&gt; SHOW GLOBAL VARIABLES LIKE &apos;sql_mode&apos;;mysql&gt; SET GLOBAL sql_mode=&apos;MODE&apos;mysql&gt; SET @@global.sql_mode=&apos;MODE&apos;</code></pre><p>常用的MODE:</p><ul><li>TRADITIONAL</li><li>STRICT_TRANS_TABLES：对支持事务的表使用严格模式</li><li>STRICT_ALL_TABLES：对所有表使用严格模式</li></ul><p><strong><em>使用global修改的变量仅对修改后的新创建的会话有效,对于已经建立的会话无效,无论是SESSION级别或者GLOBAL级别的,重启后都会失效,永久生效需要修改配置文件并重启</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据库概念及相关术语&quot;&gt;&lt;a href=&quot;#数据库概念及相关术语&quot; class=&quot;headerlink&quot; title=&quot;数据库概念及相关术语&quot;&gt;&lt;/a&gt;数据库概念及相关术语&lt;/h2&gt;&lt;h3 id=&quot;什么是数据库？&quot;&gt;&lt;a href=&quot;#什么是数据库？&quot; class=&quot;headerlink&quot; title=&quot;什么是数据库？&quot;&gt;&lt;/a&gt;什么是数据库？&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数据库&lt;/a&gt;（Database）是按照数据结构来组织、存储和管理数据的仓库，每个数据库都有一个或多个不同的API用于创建，访问，管理，搜索和复制所保存的数据。我们也可以将数据存储在文件中，但是在文件中读写数据速度相对较慢。所以，现在我们使用关系型数据库管理系统（RDBMS）来存储和管理的大数据量。所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。&lt;/p&gt;
&lt;h3 id=&quot;RDBMS的特点&quot;&gt;&lt;a href=&quot;#RDBMS的特点&quot; class=&quot;headerlink&quot; title=&quot;RDBMS的特点&quot;&gt;&lt;/a&gt;RDBMS的特点&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;RDBMS即关系数据库管理系统(Relational Database Management System)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;数据库中的数据集合都放在数据表(table)中&lt;/li&gt;
&lt;li&gt;数据表由数据行(row)和数据列(column)构成&lt;/li&gt;
&lt;li&gt;一个数据行就是一个数据表中的一条记录(record)&lt;/li&gt;
&lt;li&gt;记录中包含多个信息项，数据表中的每一个数据列都对应一个信息项&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;RDBMS-术语&quot;&gt;&lt;a href=&quot;#RDBMS-术语&quot; class=&quot;headerlink&quot; title=&quot;RDBMS 术语&quot;&gt;&lt;/a&gt;RDBMS 术语&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;数据库：数据库是一些关联表的集合。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数据表：表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;列： 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;主键：主键是唯一的。必须提供数据，即字段不为空（null）；字段不重复，即唯一标识本行；一张表只能有一个主键。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;外键：一个表中的某字段可填入的数据取决于另一个表的主 键或唯一键已有的数据 ，键表示了两个表之间的相关联系。一个表的主键是另外一张表的外键（唯一键也可以做外键）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;复合键：表中一个属性无法唯一标识一条记录，用两条属性组才可以唯一标识一条记录，那么两条属性主就组成了符合主键。单独的每列的字段可重复，但是两个列组成主键后总字段是不重复的，一般用于复合索引。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;唯一键：一个或多个字段的组合，填入的数据必须能在本表唯一标识本行。和主键不同之处：在表中可以有多个；允许为空值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构，类似于书籍的目录。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;MySQL核心组件&quot;&gt;&lt;a href=&quot;#MySQL核心组件&quot; class=&quot;headerlink&quot; title=&quot;MySQL核心组件&quot;&gt;&lt;/a&gt;MySQL核心组件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;连接池：认证、线程重用、连接数限制、内存检查、缓存；&lt;/li&gt;
&lt;li&gt;SQL接口：DDL, DML, 关系型数据库的基本抽象；&lt;/li&gt;
&lt;li&gt;parser: 查询转换、对象权限检查；&lt;/li&gt;
&lt;li&gt;优化器：访问路径，性能相关的统计数据；&lt;/li&gt;
&lt;li&gt;caches和buffers：与存储引擎自身相关的I/O性能提升工具；&lt;/li&gt;
&lt;li&gt;存储引擎：&lt;ul&gt;
&lt;li&gt;MyISAM、InnoDB(变种：XtraDB)、Memory、Merge、Federated、CSV、Archive、Blackholl、Aria、SphinxSE、TokuDB&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;数据库设计规范化&quot;&gt;&lt;a href=&quot;#数据库设计规范化&quot; class=&quot;headerlink&quot; title=&quot;数据库设计规范化&quot;&gt;&lt;/a&gt;数据库设计规范化&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;仅有好的DBMS并不足以避免数据冗余，必须在数据库的设计中创建好的表结构，数据库规范化的三个级别，范式是具有最小冗余的表结构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一范式(1NF)&lt;br&gt;就是属性不可分割，这个字段只能是一个值，不能被拆分成多个字段。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二范式(2NF)&lt;br&gt;就是要有主键，要求其他字段都依赖于主键。为什么要有主键？没有主键就没有唯一性，没有唯一性在集合中就定位不到这行记录，所以要主键。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第三范式(3NF)&lt;br&gt;关系模式R中的非主关键字不能依赖于其他非主关键，即非主关键字之间不能有函数(传递)依赖关系，要消除传递依赖，消除冗余应该比较好理解一些，就是各种信息只在一个地方存储，不出现在多张表中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;事务（transaction）&quot;&gt;&lt;a href=&quot;#事务（transaction）&quot; class=&quot;headerlink&quot; title=&quot;事务（transaction）&quot;&gt;&lt;/a&gt;事务（transaction）&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;事务(Transaction)，一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)，通常就是指数据库事务。一个支持事务（Transaction）的数据库系统，必需要具有ACID特性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。&lt;/li&gt;
&lt;li&gt;一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。&lt;/li&gt;
&lt;li&gt;隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。&lt;/li&gt;
&lt;li&gt;持久性（Durability）：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="MySQL基础入门" scheme="http://www.chenfanlinux.org/categories/MySQL%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="MySQL" scheme="http://www.chenfanlinux.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础之进程管理</title>
    <link href="http://www.chenfanlinux.org/2018/01/29/Linux%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>http://www.chenfanlinux.org/2018/01/29/Linux基础之进程管理/</id>
    <published>2018-01-29T15:10:26.000Z</published>
    <updated>2018-01-29T15:14:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程?"></a>什么是进程?</h2><h3 id="进程的基本概念"><a href="#进程的基本概念" class="headerlink" title="进程的基本概念"></a>进程的基本概念</h3><blockquote><p>程序本身只是指令、数据及其组织形式的描述，<a href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B" target="_blank" rel="noopener">进程</a>才是程序（那些指令和数据）的真正运行实例。现代计算机系统可在同一段时间内以进程的形式将多个程序加载到内存中，并借由时间共享（或称时分复用），以在一个处理器上表现出同时（平行性）运行的感觉。同样的，使用多线程技术（多线程即每一个线程都代表一个内的一个独立执行上下文）的操作系统或计算机架构，同样程序的平行线程，可在多CPU主机或网络上真正同时运行（在不同的CPU上）。</p></blockquote><h3 id="进程包含的资源"><a href="#进程包含的资源" class="headerlink" title="进程包含的资源"></a>进程包含的资源</h3><p>一个计算机系统进程包括（或者说“拥有”）下列数据：</p><ul><li>那个程序的可执行机器码的一个在内存的映像。</li><li>分配到的内存（通常是虚拟的一个内存区域）。内存的内容包括可执行代码、特定于进程的数据（输入、输出）、调用堆栈、堆栈（用于保存运行时运输中途产生的数据）。</li><li>分配给该进程的资源的操作系统描述符，诸如文件描述符（Unix术语）或文件句柄（Windows）、数据源和数据终端。</li><li>安全特性，诸如进程拥有者和进程的权限集（可以容许的操作）。</li><li>处理器状态（内文），诸如寄存器内容、物理内存定址等。当进程正在运行时，状态通常存储在寄存器，其他情况在内存。</li></ul><h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><ul><li>运行态：running</li><li>就绪态：ready</li><li>睡眠态：又称阻塞态或等待态,可以分为中断睡眠、不可中断睡眠<ul><li>可中断：interruptable</li><li>不可中断：uninterruptable</li></ul></li><li>停止态：暂停于内存中，但不会被调度，除非手动启动之；stopped</li><li><a href="https://zh.wikipedia.org/wiki/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener">僵死态</a>：zombie</li><li>空闲状态（idle）</li></ul><a id="more"></a><p><strong>R (task_running) : 可执行状态</strong></p><blockquote><p>只有在该状态的进程才可能在CPU上运行。而同一时刻可能有多个进程处于可执行状态，这些进程的task_struct结构（进程控制块）被放入对应CPU的可执行队列中（一个进程最多只能出现在一个CPU的可执行队列中）。进程调度器的任务就是从各个CPU的可执行队列中分别选择一个进程在该CPU上运行。<br>很多操作系统教科书将正在CPU上执行的进程定义为RUNNING状态、而将可执行但是尚未被调度执行的进程定义为READY状态，这两种状态在linux下统一为 TASK_RUNNING状态。</p></blockquote><p><strong>S 可中断睡眠: interruptible</strong></p><blockquote><p>处于这个状态的进程因为等待某某事件的发生（比如等待socket连接、等待信号量），而被挂起。这些进程的task_struct结构被放入对应事件的等待队列中。当这些事件发生时（由外部中断触发、或由其他进程触发），对应的等待队列中的一个或多个进程将被唤醒。通过ps命令我们会看到，一般情况下，进程列表中的绝大多数进程都处于task_interruptible状态（除非机器的负载很高）。毕竟CPU就这么一两个，进程动辄几十上百个，如果不是绝大多数进程都在睡眠，CPU又怎么响应得过来。</p></blockquote><p><strong>D 不可中断的睡眠: uninterruptible</strong></p><blockquote><p>进程处于睡眠状态，但是此刻进程是不可中断的。不可中断，指的并不是CPU不响应外部硬件的中断，而是指进程不响应异步信号。绝大多数情况下，进程处在睡眠状态时，总是应该能够响应异步信号的。但是uninterruptible sleep 状态的进程不接受外来的任何信号，因此无法用kill杀掉这些处于D状态的进程，无论是”kill”, “kill -9″还是”kill -15″，这种情况下，一个可选的方法就是reboot。处于uninterruptible sleep状态的进程通常是在等待IO，比如磁盘IO，网络IO，其他外设IO，如果进程正在等待的IO在较长的时间内都没有响应，那么就被ps看到了，同时也就意味着很有可能有IO出了问题，可能是外设本身出了故障，也可能是比如挂载的远程文件系统已经不可访问了。而task_uninterruptible状态存在的意义就在于，内核的某些处理流程是不能被打断的。如果响应异步信号，程序的执行流程中就会被插入一段用于处理异步信号的流程（这个插入的流程可能只存在于内核态，也可能延伸到用户态），于是原有的流程就被中断了。 在进程对某些硬件进行操作时（比如进程调用read系统调用对某个设备文件进行读操作，而read系统调用最终执行到对应设备驱动的代码，并与对应的物理设备进行交互），可能需要使用task_uninterruptible状态对进程进行保护，以避免进程与设备交互的过程被打断，造成设备陷入不可控的状态。这种情况下的task_uninterruptible状态总是非常短暂的，通过ps命令基本上不可能捕捉到。</p></blockquote><p><strong>Z 僵尸进程：zombie</strong></p><blockquote><p>在Linux进程的状态中，僵尸进程是非常特殊的一种，它是已经结束了的进程，但是没有从进程表中删除。太多了会导致进程表里面条目满了，进而导致系统崩溃，倒是不占用其他系统资源。它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的退出状态等信息供其他进程收集，除此之外，僵尸进程不再占有任何内存空间。<br>进程在退出的过程中，处于TASK_DEAD状态。在这个退出过程中，进程占有的所有资源将被回收，除了task_struct结构（以及少数资源）以外。于是进程就只剩下task_struct这么个空壳，故称为僵尸。<br>子进程在退出的过程中，内核会给其父进程发送一个信号，通知父进程来“收尸”。 父进程可以通过wait系列的系统调用（如wait4、waitid）来等待某个或某些子进程的退出，并获取它的退出信息。然后wait系列的系统调用会顺便将子进程的尸体（task_struct）也释放掉。<br>这个信号默认是SIGCHLD，但是在通过clone系统调用创建子进程时，可以设置这个信号。<br>如果他的父进程没安装SIGCHLD信号处理函数调用wait或waitpid()等待子进程结束，又没有显式忽略该信号，那么它就一直保持僵尸状态，子进程的尸体（task_struct）也就无法释放掉。<br>如果这时父进程结束了，那么init进程自动会接手这个子进程，为它收尸，它还是能被清除的。但是如果如果父进程是一个循环，不会结束，那么子进程就会一直保持僵尸状态，这就是为什么系统中有时会有很多的僵尸进程。</p></blockquote><p><strong>Unix/Linux 处理僵尸进程的方法：</strong></p><p>找出父进程号，然后kill 父进程，之后子进程（僵尸进程）会被托管到其他进程，如init进程，然后由init进程将子进程的尸体（task_struct）释放掉。</p><p><strong>T：Stopped：停止状态</strong></p><blockquote><p>向进程发送一个sigstop信号，它就会因响应该信号而进入task_stopped状态（除非该进程本身处于task_uninterruptible状态而不响应信号）。（sigstop与sigkill信号一样，是非常强制的。不允许用户进程通过signal系列的系统调用重新设置对应的信号处理函数。）<br> 向进程发送一个sigcont信号，可以让其从task_stopped状态恢复到task_running状态。<br> 当进程正在被跟踪时，它处于task_traced这个特殊的状态。“正在被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。比如在gdb中对被跟踪的进程下一个断点，进程在断点处停下来的时候就处于task_traced状态。而在其他时候，被跟踪的进程还是处于前面提到的那些状态。<br> 对于进程本身来说，task_stopped和task_traced状态很类似，都是表示进程暂停下来。<br> 而task_traced状态相当于在task_stopped之上多了一层保护，处于task_traced状态的进程不能响应sigcont信号而被唤醒。只能等到调试进程通过ptrace系统调用执行ptrace_cont、ptrace_detach等操作（通过ptrace系统调用的参数指定操作），或调试进程退出，被调试的进程才能恢复task_running状态。</p></blockquote><h3 id="IPC进程间通信"><a href="#IPC进程间通信" class="headerlink" title="IPC进程间通信"></a>IPC进程间通信</h3><ul><li>同一主机上：signal信号、shm: shared memory共享内存、semerphor旗语手势</li><li>不同主机上：rpc: remote process  call远程过程调用、socket套接字</li></ul><h3 id="fork-amp-exec"><a href="#fork-amp-exec" class="headerlink" title="fork &amp; exec"></a>fork &amp; exec</h3><ul><li><p>当计算机开机的时候，内核（kernel）只建立了一个 init 进程。Linux kernel 并不提供直接建立新进程的系统调用。剩下的所有进程都是 init 进程通过 fork 机制建立的。</p></li><li><p>新的进程要通过老的进程复制自身得到，这就是 fork。fork 是一个系统调用。进程存活于内存中。每个进程都在内存中分配有属于自己的一片空间 (内存空间，包含栈、堆、全局静态区、文本常量区、程序代码区)。</p></li><li><p>当一个程序调用 fork 的时候，实际上就是将上面的内存空间，又复制出来一个，构成一个新的进程，并在内核中为该进程创建新的附加信息 (比如新的 PID，而 PPID 为原进程的 PID)。此后，两个进程分别地继续运行下去。新的进程和原有进程有相同的运行状态(相同的变量值，相同的指令…)。我们只能通过进程的附加信息来区分两者。</p></li><li><p>程序调用 exec 的时候，进程清空自身的内存空间，并根据新的程序文件重建程序代码、文本常量、全局静态、堆和栈(此时堆和栈大小都为 0)，并开始运行。</p></li></ul><h2 id="进程管理相关命令"><a href="#进程管理相关命令" class="headerlink" title="进程管理相关命令"></a>进程管理相关命令</h2><h3 id="ps-用于显示当前进程的状态（非动态）"><a href="#ps-用于显示当前进程的状态（非动态）" class="headerlink" title="ps 用于显示当前进程的状态（非动态）"></a>ps 用于显示当前进程的状态（非动态）</h3><p>选项有三种风格：</p><ul><li><p>UNIX风格，必须在选项前面加“-”</p></li><li><p>BSD风格，选项前不能加“-”</p></li><li><p>GNU风格，选项前为两个“-”</p></li></ul><p><strong>常用组合之一：aux</strong></p><ul><li>a：所有与终端相关的进程</li><li>x：所有与终端无关的进程</li><li>u：以用户为中心组织进程状态信息显示</li></ul><p><img src="https://s1.ax1x.com/2018/01/29/9STeaV.png" alt="ps aux"></p><ul><li>USER：用户名</li><li>PID：进程号</li><li>CPU%：cpu时间占用比率</li><li>MEM%：内存占用百分比</li><li>VSZ：virtual size虚拟内存集</li><li>RSS：Resident Size，常驻内存集</li><li>STAT: 进程状态<ul><li>R：running 运行</li><li>S：interruptable sleeping 可中断睡眠</li><li>D：uninterruptable sleeping 不可中断睡眠</li><li>T：Stopped 停止</li><li>Z：zombie 僵死态</li><li>+：前台进程</li><li>l：多线程进程</li><li>N：低优先级进程</li><li>&lt;：高优先级进程</li><li>s：session leader  进程领导者</li></ul></li></ul><p><strong>常用组合之二：-ef</strong></p><ul><li>-e：显示所有进程</li><li>-f：显示完整格式的进程信息</li></ul><p><img src="https://s1.ax1x.com/2018/01/29/9SLS1O.png" alt="ps -ef "></p><h3 id="top动态查看进程状态"><a href="#top动态查看进程状态" class="headerlink" title="top动态查看进程状态"></a>top动态查看进程状态</h3><blockquote><p>系统响应变慢，首先得定位大致的问题出在哪里，是IO瓶颈、CPU瓶颈、内存瓶颈还是程序导致的系统问题；使用top工具能够比较全面的查看我们关注的点。</p></blockquote><p><img src="https://s1.ax1x.com/2018/01/29/9SLAAI.png" alt="top"></p><p><strong>top命令个参数具体含义：</strong></p><p><strong><em>系统状态</em></strong><br>top - 22:08:50 up 16 days, 10:03,  1 user,  load average: 0.00, 0.01, 0.05</p><ul><li>14:58:34：当前时间</li><li>up  5:28：运行时长</li><li>1 user：登录当前系统上的用户数</li><li>load average: 0.00, 0.01, 0.05：<a href="http://blog.scoutapp.com/articles/2009/07/31/understanding-load-averages" target="_blank" rel="noopener">平均负载</a>（等待运行的队列长度的负载）</li></ul><p><strong><em>系统任务情况</em></strong><br>Tasks: 232 total,   1 running, 231 sleeping,   0 stopped,   0 zombie</p><ul><li>232 total：一共运行多少进程</li><li>1 running：几个处于运行</li><li>231 sleeping：多少个睡眠</li><li>0 stopped：多少个停止</li><li>0 zombie：多少个僵死</li></ul><p><strong><em>占用Cpu百分比</em></strong><br>%Cpu(s):  0.1 us,  0.2 sy,  0.0 ni, 99.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</p><ul><li>0.1 us：用户空间占用时间的百分比</li><li>0.2 sy：内核空间占用时间的百分比</li><li>0.0 ni：对nice调整占用的内存百分比</li><li>99.8 id：Cpu的空闲百分比</li><li>0.0 wa：等待IO完成所消耗的百分比</li><li>0.0 hi：处理硬件中断所占用的百分比</li><li>0.0 si：处理软件中断所占用的百分比</li><li>0.0 st：被偷走的百分比（虚拟化程序）</li></ul><p><strong><em>内存的使用情况</em></strong><br>KiB Mem :  8003404 total,   458404 free,  2139240 used,  5405760 buff/cache</p><ul><li>KiB Mem：内存空间占用，以KB为单位：</li><li>8003404 total：总内存空间</li><li>458404 free：剩余内存空间</li><li>2139240 used：已用内存空间</li><li>5405760 buff/cache：用于缓存和缓冲的内存空间<ul><li>A buffer is something that has yet to be “written” to disk</li><li>A cache is something that has been “read” from the disk and stored for later use</li></ul></li></ul><p>注意：系统实际可用的内存为free工具输出第二行的free+buffer+cached,<br>也就是说buffer是用于存放要输出到disk（块设备）的数据的，而cache是存放从disk上读出的数据。这二者是为了提高IO性能的，并由OS管理。</p><p><strong><em>交换分区信息</em></strong></p><ul><li>6881272k total：交换区总量</li><li>4010444k used：使用的交换区量</li><li>2870828k free：空闲的交换区量</li><li>4336992k cached：缓冲交换区总量</li></ul><p><strong><em>进程状态</em></strong></p><ul><li>PID:用户pid</li><li>USER:用户名称</li><li>PR:优先级</li><li>NI:nice值</li><li>VIRT:virtual size虚拟内存集</li><li>RES:常驻内存集</li><li>SHR:共享内存空间</li><li>S:当前状态</li><li>%CPU:占据CPU百分比</li><li>%MEM:占据MEM百分比</li><li>TIME+:运行时长</li><li>COMMAND:命令</li></ul><p><strong><em>top内排序</em></strong></p><ul><li>P：按%CPU使用率排行</li><li>T：按MITE+排行</li><li>M：按%MEM排行</li></ul><h3 id="vmstat-监视内存使用情况"><a href="#vmstat-监视内存使用情况" class="headerlink" title="vmstat 监视内存使用情况"></a>vmstat 监视内存使用情况</h3><blockquote><p>vmstat是Virtual Meomory Statistics（虚拟内存统计）的缩写，可实时动态监视操作系统的虚拟内存、进程、CPU活动。</p></blockquote><p>语法格式：<br><code>vmstat [-V] [-n] [delay [count]]</code></p><ul><li>-V表示打印出版本信息；</li><li>-n表示在周期性循环输出时，输出的头部信息仅显示一次；</li><li>delay是两次输出之间的延迟时间；</li><li>count是指按照这个时间间隔统计的次数。</li></ul><p><img src="https://s1.ax1x.com/2018/01/29/9pPwAU.png" alt="vmstat"></p><ul><li><p>Procs（进程）:</p><ul><li>r: 等待运行进程的个数</li><li>b: 等待IO的进程数量</li></ul></li><li><p>Memory（内存）:</p><ul><li>swpd: 使用虚拟内存大小</li><li>free: 可用内存大小</li><li>buff: 用作缓冲的内存大小</li><li>cache: 用作缓存的内存大小</li></ul></li><li>Swap:<ul><li>si: 每秒从交换区写到内存的大小</li><li>so: 每秒写入交换区的内存大小</li><li>IO：（现在的Linux版本块的大小为1024bytes）</li><li>bi: 每秒读取的块数</li><li>bo: 每秒写入的块数</li></ul></li><li>system：<ul><li>in: 每秒中断数，包括时钟中断</li><li>cs: 每秒上下文切换数</li></ul></li><li>CPU（以百分比表示）<ul><li>us: 用户进程执行时间(user time)</li><li>sy: 系统进程执行时间(system time)</li><li>id: 空闲时间(包括IO等待时间)</li><li>wa: 等待IO时间</li></ul></li></ul><h3 id="dstat系统资源统计命令（动态）"><a href="#dstat系统资源统计命令（动态）" class="headerlink" title="dstat系统资源统计命令（动态）"></a>dstat系统资源统计命令（动态）</h3><blockquote><p>dstat 是一个用来替换 vmstat, iostat, netstat, nfsstat 和 ifstat 这些命令的工具，是一个全能系统信息统计工具。</p></blockquote><p>语法格式：<br><code>dstat [-afv] [options..] [delay [count]]</code></p><p><img src="https://s1.ax1x.com/2018/01/29/9pFDyR.png" alt="dstat"></p><ul><li>-c: 显示cpu信息,默认显示cpu</li><li>-d: 显示disk相关信息</li><li>-D total,sda,sdb</li><li>-g: 显示页面换进换出</li><li>-m :显示内存信息</li><li>-n :显示网络相关信息</li><li>-p :显示process相关统计数据</li><li>-s :显示交互内存的统计数据</li><li>–ipc:进程间通信</li><li>-fs:打开的文件</li><li>–tcp</li><li>–upd</li><li>–socket:socker显示信息</li><li>–top-cpu:显示最消耗cpu的进程</li><li>–top-io:显示最消耗io的进程</li><li>–top-mem:显示最占用内存的进程</li><li>–top-lantency: 显示延迟最大的进程</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是进程&quot;&gt;&lt;a href=&quot;#什么是进程&quot; class=&quot;headerlink&quot; title=&quot;什么是进程?&quot;&gt;&lt;/a&gt;什么是进程?&lt;/h2&gt;&lt;h3 id=&quot;进程的基本概念&quot;&gt;&lt;a href=&quot;#进程的基本概念&quot; class=&quot;headerlink&quot; title=&quot;进程的基本概念&quot;&gt;&lt;/a&gt;进程的基本概念&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;程序本身只是指令、数据及其组织形式的描述，&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;进程&lt;/a&gt;才是程序（那些指令和数据）的真正运行实例。现代计算机系统可在同一段时间内以进程的形式将多个程序加载到内存中，并借由时间共享（或称时分复用），以在一个处理器上表现出同时（平行性）运行的感觉。同样的，使用多线程技术（多线程即每一个线程都代表一个内的一个独立执行上下文）的操作系统或计算机架构，同样程序的平行线程，可在多CPU主机或网络上真正同时运行（在不同的CPU上）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;进程包含的资源&quot;&gt;&lt;a href=&quot;#进程包含的资源&quot; class=&quot;headerlink&quot; title=&quot;进程包含的资源&quot;&gt;&lt;/a&gt;进程包含的资源&lt;/h3&gt;&lt;p&gt;一个计算机系统进程包括（或者说“拥有”）下列数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;那个程序的可执行机器码的一个在内存的映像。&lt;/li&gt;
&lt;li&gt;分配到的内存（通常是虚拟的一个内存区域）。内存的内容包括可执行代码、特定于进程的数据（输入、输出）、调用堆栈、堆栈（用于保存运行时运输中途产生的数据）。&lt;/li&gt;
&lt;li&gt;分配给该进程的资源的操作系统描述符，诸如文件描述符（Unix术语）或文件句柄（Windows）、数据源和数据终端。&lt;/li&gt;
&lt;li&gt;安全特性，诸如进程拥有者和进程的权限集（可以容许的操作）。&lt;/li&gt;
&lt;li&gt;处理器状态（内文），诸如寄存器内容、物理内存定址等。当进程正在运行时，状态通常存储在寄存器，其他情况在内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;进程的状态&quot;&gt;&lt;a href=&quot;#进程的状态&quot; class=&quot;headerlink&quot; title=&quot;进程的状态&quot;&gt;&lt;/a&gt;进程的状态&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;运行态：running&lt;/li&gt;
&lt;li&gt;就绪态：ready&lt;/li&gt;
&lt;li&gt;睡眠态：又称阻塞态或等待态,可以分为中断睡眠、不可中断睡眠&lt;ul&gt;
&lt;li&gt;可中断：interruptable&lt;/li&gt;
&lt;li&gt;不可中断：uninterruptable&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;停止态：暂停于内存中，但不会被调度，除非手动启动之；stopped&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;僵死态&lt;/a&gt;：zombie&lt;/li&gt;
&lt;li&gt;空闲状态（idle）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="linux基础" scheme="http://www.chenfanlinux.org/categories/linux%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="进程" scheme="http://www.chenfanlinux.org/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="linux" scheme="http://www.chenfanlinux.org/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>awk学习笔记</title>
    <link href="http://www.chenfanlinux.org/2018/01/26/awk%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.chenfanlinux.org/2018/01/26/awk学习笔记/</id>
    <published>2018-01-26T03:52:25.000Z</published>
    <updated>2018-01-26T03:53:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="awk简介"><a href="#awk简介" class="headerlink" title="awk简介"></a>awk简介</h2><blockquote><p>awk是一种编程语言，用于在linux/unix下对文本和数据进行处理。数据可以来自标准输入、一个或多个文件，或其它命令的输出。它支持用户自定义函数和动态正则表达式等先进功能，是linux/unix下的一个强大编程工具。</p></blockquote><h3 id="特性介绍"><a href="#特性介绍" class="headerlink" title="特性介绍"></a>特性介绍</h3><ul><li>awk的处理文本和数据的方式是这样的，它逐行扫描文件，从第一行到最后一行，寻找匹配的特定模式的行，并在这些行上进行你想要的操作。</li><li>如果没有指定处理动作，则把匹配的行显示到标准输出(屏幕)；如果没有指定模式，则所有被操作所指定的行都被处理。</li><li>下面介绍的awk是以GUN的gawk为例的，在linux系统中已把awk链接到gawk，所以下面全部以awk进行介绍。</li></ul><h2 id="awk命令格式和选项"><a href="#awk命令格式和选项" class="headerlink" title="awk命令格式和选项"></a>awk命令格式和选项</h2><h3 id="awk的语法"><a href="#awk的语法" class="headerlink" title="awk的语法"></a>awk的语法</h3><ul><li>awk [options] ‘script’ var=value file(s)</li><li>awk [options] -f scriptfile var=value file(s)</li></ul><p><code>script= PATTERN {ACTION STATEMENTS}</code></p><ul><li>PATTERN: 模式,用于地址定界</li><li>ACTION STATEMENTS:动作语句,语句之间用分号分隔</li></ul><h3 id="2-2-命令选项"><a href="#2-2-命令选项" class="headerlink" title="2.2. 命令选项"></a>2.2. 命令选项</h3><pre><code>-F fs ：指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:-v var=val ： 自定义变量</code></pre><h2 id="awk的模式与动作"><a href="#awk的模式与动作" class="headerlink" title="awk的模式与动作"></a>awk的模式与动作</h2><blockquote><p>awk脚本是由模式(PATTERN)和操作语句(ACTION STATEMENTS)两个部分组成,下面将详细介绍这两个部分。</p></blockquote><h3 id="模式-地址定界"><a href="#模式-地址定界" class="headerlink" title="模式(地址定界)"></a>模式(地址定界)</h3><ul><li>empty: 匹配每一行。</li><li>/regular expression/: 正则表达式,仅处理被模式匹配到的行。<br><code>awk -F: &#39;!/^UUID/{print $1}&#39; /etc/fstab</code></li><li>relation expression: 关系表达式,结果有”真”有假: 结果为”真”的行才会被处理。<br><code>awk -F: &#39;$3&lt;1000{print $1,$3}&#39; /etc/passwd</code><br><code>awk -F: &#39;$NF~/bash$/{print $1,$NF}&#39; /etc/passwd</code></li><li>line ranges:行范围<ul><li>(NR&gt;2&amp;&amp;NR&lt;10)  行匹配</li><li>/pattern1/,/pattern2/ 第一次匹配模式1起始和第一次匹配模式2终</li></ul></li><li>BEGIN/END模式<ul><li>BEGIN{}: 仅在开始处理文件中的文本之前执行一次，通常可在这里设置全局变量。</li><li>END{}: 仅在文本处理完成后执行一次<br><code>awk -F: &#39;BEGIN{print &quot;     username   uid\n---------------&quot;} {print $1,$3} END {print &quot;==============\n  end&quot;}&#39; /etc/passwd</code></li></ul></li></ul><a id="more"></a><h3 id="动作语句"><a href="#动作语句" class="headerlink" title="动作语句"></a>动作语句</h3><blockquote><p>动作由一个或多个命令、函数、表达式组成，之间由换行符或分号隔开，并位于大括号内，主要有下面四部分。</p></blockquote><ul><li><p>变量或数组赋值</p></li><li><p>输出命令</p></li><li><p>内置函数</p></li><li><p>控制流命令</p></li></ul><h3 id="awk变量"><a href="#awk变量" class="headerlink" title="awk变量"></a>awk变量</h3><p><strong>awk的环境变量</strong></p><table><thead><tr><th>变量</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>$n</td><td style="text-align:center">当前行的第n个字段，字段间由FS分隔。</td></tr><tr><td>$0</td><td style="text-align:center">完整的行</td></tr><tr><td>FS</td><td style="text-align:center">输入字段分隔符，默认为空格</td></tr><tr><td>OFS</td><td style="text-align:center">输出字段分隔符，默认为空格</td></tr><tr><td>NF</td><td style="text-align:center">当前行的字段总数</td></tr><tr><td>NR</td><td style="text-align:center">当前行的记录数,行号</td></tr><tr><td>RS</td><td style="text-align:center">输入时的行的分隔符,默认换行符(\n)</td></tr><tr><td>ORS</td><td style="text-align:center">输出时的行的分隔符,默认换行符(\n)</td></tr><tr><td>ARGC</td><td style="text-align:center">命令行参数个数</td></tr><tr><td>ARGV</td><td style="text-align:center">数组,命令行中所给定的各参数</td></tr></tbody></table><p><strong><em>注意事项:awk 内部引用变量,无须加$</em></strong></p><p><strong>自定义变量</strong></p><ul><li><p>-v var=value<br><code>awk -v test=&#39;hello&#39; &#39;BEGIN{print test}&#39; /etc/fstab</code></p></li><li><p>在program中直接定义<br><code>awk &#39;BEGIN{test=&quot;hello&quot;;print test}&#39; /etc/fstab</code></p></li></ul><h3 id="运算操作符"><a href="#运算操作符" class="headerlink" title="运算操作符"></a>运算操作符</h3><p><strong>算术操作符</strong><br> x+y,x-y,x*y,x/y,x%y,x^y,-x，+x</p><p><strong>字符串操作符</strong><br>没有符号的操作符,字符串连接</p><p><strong>赋值操作符</strong><br> =,+=,-=,/=,%=,^=,++,–</p><p><strong>比较操作符</strong><br>&lt;,&gt;=,&lt;,&lt;=,!=,==</p><p><strong>模式匹配符</strong><br>~ :是否匹配正则表达式<br>!~：是否不匹正则表达式</p><p><strong>逻辑操作符</strong><br>&amp;&amp;  与<br>||  或<br>!   非</p><p><strong>函数调用</strong><br><code>function_name(argu1,argu2,....）</code></p><p><strong>条件表达式 ?: 选择器</strong><br>语法：selector? if-true-expression:if-fales-expression<br><code>awk -F: &#39;{$3&gt;=1000?usertype=&quot;common user&quot;:usertype=&quot;sysadmin or sysuser&quot;;printf&quot;%15s:%s\n&quot;,$1,usertype}&#39; /etc/passwd</code></p><h3 id="printf命令"><a href="#printf命令" class="headerlink" title="printf命令"></a>printf命令</h3><p>格式化输出: <code>printf FORMAT,item1,item2....</code></p><p>FORMAT注意点：</p><ul><li>FORMAT必须给出</li><li>不会自动换行,需要显示给出换行符,\n</li><li>FORMAT中需要分别为后面的每个item指定一个格式化符号</li></ul><p>格式符:</p><ul><li>%c: 显示字符的ASCII码</li><li>%d: 显示十进制整数</li><li>%e: 科学计数数值显示</li><li>%f: 显示浮点数</li><li>%g: 科学计数法或浮点形式</li><li>%s: 显示字符串</li><li>%u: 无符号整数</li><li>%%: 显示%自身</li></ul><p>修饰符:</p><ul><li>num[.num]: 第一个数字控制显示的宽度,第二个表示小数的精度<br> %3.1f</li><li>-: 左对齐</li><li>+: 显示数值的符号</li></ul><p>范例：<br><code>awk -F: &#39;{printf &quot;Username: %s Uid:%d\n&quot;,$1,$3}&#39; /etc/passwd</code></p><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><blockquote><p>awk中的条件语句是从C语言中借鉴过来的，可控制程序的流程。</p></blockquote><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>格式：</p><pre><code>{if (expression){                  statement; statement; ...                    }       }</code></pre><p>范例：<br><code>awk -F: &#39;{if($3&gt;1000) {print$1,$3}}&#39; /etc/passwd</code></p><h3 id="if-else语句，用于双重判断"><a href="#if-else语句，用于双重判断" class="headerlink" title="if/else语句，用于双重判断"></a>if/else语句，用于双重判断</h3><p>格式：</p><pre><code>{if (expression){                statement; statement; ...                    }     else{                statement; statement; ...                    }     }</code></pre><p>范例：<br><code>awk -F: &#39;{if ($3&gt;=1000) {printf &quot;Admin user: %s\n&quot;,$1} else {printf &quot;Common user: %s\n&quot;,$1}}&#39; /etc/passwd</code></p><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>格式：</p><pre><code>{while (expression) {        statement;statement;....                     }     }</code></pre><p>范例：<br><code>awk &#39;/^[[:space:]]*linux16*/  {i=1;while(i&lt;=NF) {if(length($i)&gt;20) {print $i,length($i)};i++}}&#39; /etc/grub2.cfg</code></p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>格式:<br><code>for(expr1,expr2,expr3) statement</code><br><code>for (variable assignment;condition;iteration process) {for-body}</code><br>      <strong><em>初始化变量，条件，自增加程序</em></strong></p><p>范例:<br><code>awk &#39;/^[[:space:]]*linux16*/ {for (i=1;i&lt;=NF;i++) {print $i,length($i)}}&#39; /etc/grub2.cfg</code></p><h3 id="next"><a href="#next" class="headerlink" title="next"></a>next</h3><p><strong><em>提前结束对本行的处理,直接进入下一行</em></strong></p><p>范例：<br><code>awk -F: &#39;{if($3%2!=0) next;print $1,$3}&#39; /etc/passwd</code></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>关联数组: array[index-expression]</p><p>index-expression: 索引表达式</p><ul><li>可以使用任意字符串:字符串需要加双引号。</li><li>如果某数组元素事先不存在,在引用时,awk会自动创建此元素,并将其值初始化为空。</li></ul><p><strong>若要判断数组中是否存在某元素要使用”index in array”格式进行</strong></p><p><code>awk &#39;BEGIN{weekdays[&quot;mon&quot;]=&quot;Monday&quot;;weekdays[&quot;tue&quot;]=&quot;Tuesday&quot;;print weekdays[&quot;mon&quot;]}&#39;</code></p><p><strong>若要遍历数组中的每一个元素,要使用for循环</strong></p><p>格式：<br><code>for ( var in array) {for-body}</code><br><strong><em>注意: var会遍历array中的每个索引</em></strong></p><p>范例：<br><code>awk &#39;BEGIN{weekdays[&quot;mon&quot;]=&quot;Monday&quot;;weekdays[&quot;tue&quot;]=&quot;Tuesday&quot;;for (i in weekdays) {print weekdays[i]}}&#39;</code></p><p><strong><em>注意： i保存数组中的索引,而不是$i数组中的元素的值</em></strong></p><p>范例：统计tcp连接状态:<br><code>netstat -tan |awk &#39;/^tcp\&gt;/{state[$NF]++}END{for (i in state) {print i,state[i]}}&#39;</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;awk简介&quot;&gt;&lt;a href=&quot;#awk简介&quot; class=&quot;headerlink&quot; title=&quot;awk简介&quot;&gt;&lt;/a&gt;awk简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;awk是一种编程语言，用于在linux/unix下对文本和数据进行处理。数据可以来自标准输入、一个或多个文件，或其它命令的输出。它支持用户自定义函数和动态正则表达式等先进功能，是linux/unix下的一个强大编程工具。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;特性介绍&quot;&gt;&lt;a href=&quot;#特性介绍&quot; class=&quot;headerlink&quot; title=&quot;特性介绍&quot;&gt;&lt;/a&gt;特性介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;awk的处理文本和数据的方式是这样的，它逐行扫描文件，从第一行到最后一行，寻找匹配的特定模式的行，并在这些行上进行你想要的操作。&lt;/li&gt;
&lt;li&gt;如果没有指定处理动作，则把匹配的行显示到标准输出(屏幕)；如果没有指定模式，则所有被操作所指定的行都被处理。&lt;/li&gt;
&lt;li&gt;下面介绍的awk是以GUN的gawk为例的，在linux系统中已把awk链接到gawk，所以下面全部以awk进行介绍。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;awk命令格式和选项&quot;&gt;&lt;a href=&quot;#awk命令格式和选项&quot; class=&quot;headerlink&quot; title=&quot;awk命令格式和选项&quot;&gt;&lt;/a&gt;awk命令格式和选项&lt;/h2&gt;&lt;h3 id=&quot;awk的语法&quot;&gt;&lt;a href=&quot;#awk的语法&quot; class=&quot;headerlink&quot; title=&quot;awk的语法&quot;&gt;&lt;/a&gt;awk的语法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;awk [options] ‘script’ var=value file(s)&lt;/li&gt;
&lt;li&gt;awk [options] -f scriptfile var=value file(s)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;script= PATTERN {ACTION STATEMENTS}&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PATTERN: 模式,用于地址定界&lt;/li&gt;
&lt;li&gt;ACTION STATEMENTS:动作语句,语句之间用分号分隔&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-2-命令选项&quot;&gt;&lt;a href=&quot;#2-2-命令选项&quot; class=&quot;headerlink&quot; title=&quot;2.2. 命令选项&quot;&gt;&lt;/a&gt;2.2. 命令选项&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;-F fs ：指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:
-v var=val ： 自定义变量
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;awk的模式与动作&quot;&gt;&lt;a href=&quot;#awk的模式与动作&quot; class=&quot;headerlink&quot; title=&quot;awk的模式与动作&quot;&gt;&lt;/a&gt;awk的模式与动作&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;awk脚本是由模式(PATTERN)和操作语句(ACTION STATEMENTS)两个部分组成,下面将详细介绍这两个部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;模式-地址定界&quot;&gt;&lt;a href=&quot;#模式-地址定界&quot; class=&quot;headerlink&quot; title=&quot;模式(地址定界)&quot;&gt;&lt;/a&gt;模式(地址定界)&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;empty: 匹配每一行。&lt;/li&gt;
&lt;li&gt;/regular expression/: 正则表达式,仅处理被模式匹配到的行。&lt;br&gt;&lt;code&gt;awk -F: &amp;#39;!/^UUID/{print $1}&amp;#39; /etc/fstab&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;relation expression: 关系表达式,结果有”真”有假: 结果为”真”的行才会被处理。&lt;br&gt;&lt;code&gt;awk -F: &amp;#39;$3&amp;lt;1000{print $1,$3}&amp;#39; /etc/passwd&lt;/code&gt;&lt;br&gt;&lt;code&gt;awk -F: &amp;#39;$NF~/bash$/{print $1,$NF}&amp;#39; /etc/passwd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;line ranges:行范围&lt;ul&gt;
&lt;li&gt;(NR&amp;gt;2&amp;amp;&amp;amp;NR&amp;lt;10)  行匹配&lt;/li&gt;
&lt;li&gt;/pattern1/,/pattern2/ 第一次匹配模式1起始和第一次匹配模式2终&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BEGIN/END模式&lt;ul&gt;
&lt;li&gt;BEGIN{}: 仅在开始处理文件中的文本之前执行一次，通常可在这里设置全局变量。&lt;/li&gt;
&lt;li&gt;END{}: 仅在文本处理完成后执行一次&lt;br&gt;&lt;code&gt;awk -F: &amp;#39;BEGIN{print &amp;quot;     username   uid\n---------------&amp;quot;} {print $1,$3} END {print &amp;quot;==============\n  end&amp;quot;}&amp;#39; /etc/passwd&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="linux基础" scheme="http://www.chenfanlinux.org/categories/linux%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="awk" scheme="http://www.chenfanlinux.org/tags/awk/"/>
    
  </entry>
  
  <entry>
    <title>Bash编程入门之流程控制(四)</title>
    <link href="http://www.chenfanlinux.org/2018/01/25/Bash%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E4%B9%8B%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6-%E5%9B%9B/"/>
    <id>http://www.chenfanlinux.org/2018/01/25/Bash编程入门之流程控制-四/</id>
    <published>2018-01-25T03:17:48.000Z</published>
    <updated>2018-01-29T10:10:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><blockquote><p>bash shell中会根据命令的执行状态结果(0或1),来表示条件的true或false,根据不同的条件,选择的执行不同的语句,来达到流程控制的目的。</p></blockquote><h3 id="单分支-if结构"><a href="#单分支-if结构" class="headerlink" title="单分支 if结构"></a>单分支 if结构</h3><pre><code>if CONDITON;then    if-truefi---------------------------------------------if  [[ expression  ]];then    if-truefi</code></pre><p><strong><em>注意：此处的CONDITION相当于bash中的命令,根据命令的执行状态结构，来选择语句是否执行。</em></strong></p><h3 id="双分支-if-else结构"><a href="#双分支-if-else结构" class="headerlink" title="双分支 if/else结构"></a>双分支 if/else结构</h3><pre><code>if CONDITION;then    if-trueelse    if-falsefi----------------------------------------------if  [[ expression ]];then   if-trueelse  if-falsefi</code></pre><a id="more"></a><h3 id="多分支-if-elif-else结构"><a href="#多分支-if-elif-else结构" class="headerlink" title="多分支 if/elif/else结构"></a>多分支 if/elif/else结构</h3><pre><code>if CONDITION1;then    if-trueelif CONDITON2;then    if-trueelif CONDITION3;then    if-true........else    all-falsefi</code></pre><p><strong><em>注意: 逐条件判断,第一次遇到为”真的条件”时,执行其分支,而后结束。</em></strong></p><h3 id="case-esac结构"><a href="#case-esac结构" class="headerlink" title="case/esac结构"></a>case/esac结构</h3><pre><code>case variable_name in   pattern1)      statements         ;;   pattern2)      statements         ;;   pattern3)         ;;esac</code></pre><p><strong><em>注意：根据变量取值得不同，执行不同的语句，适合菜单功能的实现</em></strong></p><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><blockquote><p>根据循环的进入条件,开始执行循环语句,然后根据循环的退出条件,退出循环语句的执行。常见的循环有三种类型: while、until、for。</p></blockquote><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><pre><code>while CONDITONdo   循环体done------------------------------------while [[ string expression ]]do   循环体done------------------------------------while (( numeric expression ))do   循环体done</code></pre><p><strong><em>while循环,只要表达式为真，循环体就会被一直执行。</em></strong></p><h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><pre><code>while :do    循环体done--------------while truedo    循环体done--------------for (( ; ; ))</code></pre><h3 id="until-循环"><a href="#until-循环" class="headerlink" title="until 循环"></a>until 循环</h3><blockquote><p>until循环执行一系列命令直至条件为真时停止。until循环与while循环在处理方式上刚好相反。一般while循环优于until循环，但在某些时候—也只是极少数情况下，until循环更加有用。</p></blockquote><pre><code>until conditiondo    commanddone</code></pre><p><strong><em>注意：条件可为任意测试条件，测试发生在循环末尾，因此循环至少执行一次。</em></strong></p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><blockquote><p>依次将列表中的元素当值赋值给”变量名”,每次赋值后即执行一次循环体;直到列表中的元素耗尽,循环结束。</p></blockquote><pre><code>for 变量名  in 列表do 循环体done</code></pre><p><strong>列表生成的方式:</strong></p><ul><li><p>直接给出列表</p></li><li><p>整数列表</p><ul><li>{start..end}</li><li>`seq 1 10`</li></ul></li><li><p>返回列表的命令 $(COMMAND)</p></li><li><p>glob   /var/*</p></li><li>变量引用<br>$@,$*</li></ul><p><strong>for循环的特殊用法</strong></p><pre><code>for ((控制变量初始化;条件表达式;控制变量的修正表达式));do循环体done \\范例 declare -i sum=0 for ((i=0;i&lt;=100;i++));do let sum+=$i done echo &quot;$sum&quot;</code></pre><p><strong><em>控制变量的初始化:仅在运行循环代码段时执行一次</em></strong><br><strong><em>控制变量的修正表达式:每轮循环结束会先进行控制变量修正运算,而后进行条件判断。</em></strong></p><h3 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a>跳出循环</h3><blockquote><p>在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，Shell使用两个命令来实现该功能：break和continue。</p></blockquote><p><strong>break命令</strong><br>break命令允许跳出所有循环（终止执行后面的所有循环）。</p><p><strong>continue命令</strong><br>continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;条件判断&quot;&gt;&lt;a href=&quot;#条件判断&quot; class=&quot;headerlink&quot; title=&quot;条件判断&quot;&gt;&lt;/a&gt;条件判断&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;bash shell中会根据命令的执行状态结果(0或1),来表示条件的true或false,根据不同的条件,选择的执行不同的语句,来达到流程控制的目的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;单分支-if结构&quot;&gt;&lt;a href=&quot;#单分支-if结构&quot; class=&quot;headerlink&quot; title=&quot;单分支 if结构&quot;&gt;&lt;/a&gt;单分支 if结构&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;if CONDITON;then
    if-true
fi
---------------------------------------------
if  [[ expression  ]];then
    if-true
fi
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意：此处的CONDITION相当于bash中的命令,根据命令的执行状态结构，来选择语句是否执行。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;双分支-if-else结构&quot;&gt;&lt;a href=&quot;#双分支-if-else结构&quot; class=&quot;headerlink&quot; title=&quot;双分支 if/else结构&quot;&gt;&lt;/a&gt;双分支 if/else结构&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;if CONDITION;then
    if-true
else
    if-false
fi

----------------------------------------------
if  [[ expression ]];then
   if-true
else
  if-false
fi
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Bash Shell编程" scheme="http://www.chenfanlinux.org/categories/Bash-Shell%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Bash" scheme="http://www.chenfanlinux.org/tags/Bash/"/>
    
  </entry>
  
</feed>
