<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陈凡的个人站点</title>
  
  <subtitle>chenfanlinux.org</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.chenfanlinux.org/"/>
  <updated>2018-02-02T03:24:57.000Z</updated>
  <id>http://www.chenfanlinux.org/</id>
  
  <author>
    <name>陈凡</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL数据类型及SQL语句(二)</title>
    <link href="http://www.chenfanlinux.org/2018/02/02/MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8ASQL%E8%AF%AD%E5%8F%A5-%E4%BA%8C/"/>
    <id>http://www.chenfanlinux.org/2018/02/02/MySQL数据类型及SQL语句-二/</id>
    <published>2018-02-02T03:22:50.000Z</published>
    <updated>2018-02-02T03:24:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL数据类型"><a href="#MySQL数据类型" class="headerlink" title="MySQL数据类型"></a>MySQL数据类型</h2><blockquote><p>MySQL中定义数据字段的类型对你数据库的优化是非常重要的。MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。</p></blockquote><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><ul><li>精确数值型<ul><li>整形: TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT</li><li>十进制: DECIMAL</li></ul></li><li>近似数值型(浮点型):<ul><li>FLOAT</li><li>DOUBLE</li></ul></li></ul><p><img src="https://s1.ax1x.com/2018/01/31/9PaLMF.png" alt="数值类型"></p><h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><blockquote><p>char使用固定长度的空间进行存储，char(4)存储4个字符，根据编码方式的不同占用不同的字节，gbk编码方式，不论是中文还是英文，每个字符占用2个字节的空间，utf8编码方式，每个字符占用3个字节的空间。如果需要存储的字符串的长度跟所有值的平均长度相差不大，适合用char，如MD5。</p></blockquote><ul><li>CHAR,BINARY: 定长数据类型(CHAR不区分字符大小写,BINARY区分字符大小写)</li><li>VARCHAR,VARBINARY: 变长数据类型,需要结束符</li><li>TEXT: TINYTEXT, TEXT, MEDIUMTEXT, LOGTEXT</li><li>BLOB: TINYBLOB, BLOB, MEDIUMBLOB, LONGBLOB</li><li>ENUM,SET</li></ul><p><strong><em>注意：binary保存二进制字符串，就是说它们包含字节字符串而不是字符字符串，没有字符集限制</em></strong></p><p><img src="https://s1.ax1x.com/2018/01/31/9PdYon.png" alt="字符类型"><br><strong><em>注意：CHAR,VARCHAR,TEXT 不区分字符大小写；BINARY,VARBINARY,BLOB 区分字符大小写</em></strong></p><h3 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h3><ul><li>DATE</li><li>TIME</li><li>DATETIME</li><li>TIMESTAMP</li><li>YEAR(2), YEAR(4)</li></ul><p><img src="https://s1.ax1x.com/2018/01/31/9PwwtI.png" alt="日期时间型"></p><h3 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h3><ul><li>ENUM:从给定的字符串中选择一个字串</li><li>SET:集合,从指定字符集合中选择多个组合成一种变化形式</li></ul><a id="more"></a><h3 id="MySQL中字符大小写"><a href="#MySQL中字符大小写" class="headerlink" title="MySQL中字符大小写"></a>MySQL中字符大小写</h3><ol><li>SQL关键字及函数名不区字符大小写；<ul><li>SELECT, Select, select</li><li>切记：遵循同一种风格</li></ul></li><li>数据库、表、索引及视图的名称是否区分大小写取决于低层的OS及FS；</li><li>存储过程、存储函数及事件调度器不区分字符大小写；但触发器区分；</li><li>表别名不区分大小写；</li><li>字段中字符数据，类型为binary、blog、varbinary时区分大小写；其它的不区分；</li></ol><h3 id="数据类型的修饰符"><a href="#数据类型的修饰符" class="headerlink" title="数据类型的修饰符"></a>数据类型的修饰符</h3><h4 id="整形修饰符"><a href="#整形修饰符" class="headerlink" title="整形修饰符"></a>整形修饰符</h4><ul><li>NOT NULL</li><li>NULL</li><li>DEFAULT NUMBER</li><li>AUTO_INCREMENT:自动增长,需要下面三个条件的支持。<ul><li>UNSIGNED: 无符号,必须放在仅放在字段类型后</li><li>PRIMARY KEY | UNIQUE KEY</li><li>NOT NULL</li></ul></li></ul><p>例如:<br><code>CREATE TABLE t1 (id INT UNSIGNED AUTO_INCREMNET PRIMAY KEY NOT NULL,name VARCHAR(5) NOT NULL);</code></p><h4 id="字符型修饰符"><a href="#字符型修饰符" class="headerlink" title="字符型修饰符"></a>字符型修饰符</h4><blockquote><p>字符类型的修饰符: 定义在字段类型之后</p></blockquote><ul><li>NOT NULL: 非空约束</li><li>NULL: 默认为空</li><li>DEFAULT ‘STRING’: 指明默认值</li><li>CHARACTE SET ‘’: 使用字符集</li><li>COLLATION: 使用的排序规则</li></ul><p>查看字符集和排序规则: 在数据库上定义后,表可以继承,一般无须定义</p><p><code>mysql&gt;SHOW CHARACTER SET;</code><br><code>mysql&gt;SHOW COLLATION;</code></p><p>字符有通配符：</p><ul><li>%: 匹配任意长度的任意字符</li><li>_: 匹配任意单个字符；</li></ul><h4 id="日期时间型的修饰符"><a href="#日期时间型的修饰符" class="headerlink" title="日期时间型的修饰符:"></a>日期时间型的修饰符:</h4><ul><li>NOUT NULL</li><li>NULL</li><li>DEFAULT</li></ul><h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><blockquote><p><a href="https://zh.wikipedia.org/wiki/SQL" target="_blank" rel="noopener">SQL</a>（Structured Query Language),结构化查询语言，是关系数据库的标准语言;集数据定义语言（ DDL),数据操纵语言（ DML),<br>数据控制语言（ DCL）功能于一体。</p></blockquote><h3 id="SQL动词"><a href="#SQL动词" class="headerlink" title="SQL动词"></a>SQL动词</h3><table><thead><tr><th>SQL功能</th><th style="text-align:center">动词</th></tr></thead><tbody><tr><td>数据定义</td><td style="text-align:center">CREATE, DROP, ALTER</td></tr><tr><td>数据操作</td><td style="text-align:center">SELECT, INSERT, DELETE, UPDATE</td></tr><tr><td>数据控制</td><td style="text-align:center">GRANT, REVOKE</td></tr></tbody></table><h3 id="MySQL三级模式"><a href="#MySQL三级模式" class="headerlink" title="MySQL三级模式"></a>MySQL三级模式</h3><p><img src="https://s1.ax1x.com/2018/02/01/9kw5Q0.png" alt=""></p><h3 id="DDL-数据定义语言"><a href="#DDL-数据定义语言" class="headerlink" title="DDL 数据定义语言"></a>DDL 数据定义语言</h3><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E5%AE%9A%E7%BE%A9%E8%AA%9E%E8%A8%80" target="_blank" rel="noopener">数据定义语言</a>（Data Definition Language，DDL）是SQL语言集中负责数据结构定义与数据库对象定义的语言，由CREATE、ALTER与DROP三个语法所组成，最早是由Codasyl（Conference on Data Systems Languages）数据模型开始，现在被纳入SQL指令中作为其中一个子集。</p></blockquote><h4 id="CREATE对象"><a href="#CREATE对象" class="headerlink" title="CREATE对象"></a>CREATE对象</h4><p>CREATE操作的对象包括: 数据库表，索引，视图，用户，存储过程，存储函数，触发器，时间调度器等</p><pre><code>MariaDB [(none)]&gt; help createMany help items for your request exist.To make a more specific request, please type &apos;help &lt;item&gt;&apos;,where &lt;item&gt; is one of the followingtopics:   CREATE DATABASE  //数据库   CREATE EVENT    //事件   CREATE FUNCTION //函数   CREATE FUNCTION UDF //自定义函数   CREATE INDEX    //索引   CREATE PROCEDURE  //存储函数   CREATE SERVER     //服务器   CREATE TABLE   //表   CREATE TABLESPACE   //表空间   CREATE TRIGGER      //触发器   CREATE USER         //用户   CREATE VIEW         //视图   SHOW                //看CREATE语句过程   SHOW CREATE DATABASE   SHOW CREATE EVENT   SHOW CREATE FUNCTION   SHOW CREATE PROCEDURE   SHOW CREATE TABLE   SPATIAL</code></pre><h4 id="CREATE-DATABASE"><a href="#CREATE-DATABASE" class="headerlink" title="CREATE DATABASE"></a><a href="http://dev.mysql.com/doc/refman/5.5/en/create-database.html" target="_blank" rel="noopener">CREATE DATABASE</a></h4><p><strong>语法:</strong></p><pre><code>MariaDB [(none)]&gt; help create databaseCREATE {DATABASE | SCHEMA} [IF NOT EXISTS] db_name    [create_specification] ...create_specification:    [DEFAULT] CHARACTER SET [=] charset_name  | [DEFAULT] COLLATE [=] collation_name</code></pre><p><strong>实例:</strong><br><code>CREATE DATABASE IF NOT EXISTS test_db DEFAULT CHARACTER SET  utf8 COLLATE utf8_general_ci;</code></p><h4 id="CREATE-TABLE"><a href="#CREATE-TABLE" class="headerlink" title="CREATE TABLE"></a><a href="https://dev.mysql.com/doc/refman/5.5/en/create-table.html" target="_blank" rel="noopener">CREATE TABLE</a></h4><p><strong>语法：</strong></p><pre><code>CREATE TABLE [IF NOT EXISTS] tb_name(col1_def, col2_def,PRIMARY KEY(col_name,...),UNIQUE (col1,...), INDEX (col1,...))[table_option]------------------------table_option:ENGINE [=] engine_nameCOMMENT [=] &apos;string&apos;ROW_FORMAT [=] {DEFAULT|DYNAMIC|FIXED|COMPRESSED|REDUNDANT|COMPACT}TABLESPACE tablespace_name [STORAGE {DISK|MEMORY|DEFAULT}]</code></pre><p>显示表上的索引：<br><code>SHOW INDEXES FROM tb_name;</code></p><p><strong><em>注意: Storage Engine是指的表类型,也即在表创建时指明其使用的存储引擎:同一个库中要使用同一种存储引擎类型</em></strong></p><p><strong>范例:</strong><br><code>CREATE TABLE tb1 (id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY NOT NULL,name CHAR(5) NOT NULL);</code></p><p><strong>查看表结构：</strong><br><code>DESCRIBE tb1_name</code></p><p><strong>查看表状态信息：</strong><br><code>SHOW [FULL] TABLE STATUS [{FROM|IN} db_name] [LIKE &#39;pattern&#39; | WHERE expr]</code></p><p><strong>查看存储引擎：</strong><br><code>SELECT @@SESSION.default_storage_engine;</code></p><h4 id="ALTER-TABLE"><a href="#ALTER-TABLE" class="headerlink" title="ALTER TABLE"></a><a href="https://dev.mysql.com/doc/refman/5.5/en/alter-table.html" target="_blank" rel="noopener">ALTER TABLE</a></h4><p><strong>语法：</strong></p><pre><code>ALTER [ONLINE | OFFLINE] [IGNORE] TABLE tbl_name    [alter_specification [, alter_specification] ...]    [partition_options]    alter_specification:    table_options  | ADD [COLUMN] col_name column_definition        [FIRST | AFTER col_name ]  | ADD [COLUMN] (col_name column_definition,...)  | ADD {INDEX|KEY} [index_name]        [index_type] (index_col_name,...) [index_option] ...  | ALTER [COLUMN] col_name {SET DEFAULT literal | DROP DEFAULT}  | CHANGE [COLUMN] old_col_name new_col_name column_definition    [FIRST|AFTER col_name]  | DROP [COLUMN] col_name  ......</code></pre><p><strong>添加单列：</strong><br><code>ALTER TABLE tb_name ADD [COLUMN] col_name column_definition [FIRST|AFTER col_name]</code></p><p>范例:</p><pre><code>MariaDB [db1]&gt; ALTER TABLE tb1 ADD COLUMN sex ENUM(&apos;man&apos;,&apos;woman&apos;) AFTER name;Query OK, 0 rows affected (0.10 sec)Records: 0  Duplicates: 0  Warnings: 0MariaDB [db1]&gt; DESC tb1;+-------+---------------------+------+-----+---------+----------------+| Field | Type                | Null | Key | Default | Extra          |+-------+---------------------+------+-----+---------+----------------+| id    | int(10) unsigned    | NO   | PRI | NULL    | auto_increment || name  | char(5)             | NO   |     | NULL    |                || sex   | enum(&apos;man&apos;,&apos;woman&apos;) | YES  |     | NULL    |                |+-------+---------------------+------+-----+---------+----------------+</code></pre><p><strong>删除列：</strong><br><code>ALTER TABLE tb_name DROP [column] col_name</code></p><p>范例：</p><pre><code>MariaDB [db1]&gt; ALTER TABLE tb1 DROP sex;Query OK, 0 rows affected (0.14 sec)Records: 0  Duplicates: 0  Warnings: 0MariaDB [db1]&gt; DESC tb1;+-------+------------------+------+-----+---------+----------------+| Field | Type             | Null | Key | Default | Extra          |+-------+------------------+------+-----+---------+----------------+| id    | int(10) unsigned | NO   | PRI | NULL    | auto_increment || name  | char(5)          | NO   |     | NULL    |                |+-------+------------------+------+-----+---------+----------------+2 rows in set (0.00 sec)</code></pre><p><strong>修改列的类型：</strong><br><code>ALTER TABLE tb_name MODIFY [COLUMN] col_name column_definition</code></p><pre><code>MariaDB [db1]&gt; ALTER TABLE tb1 MODIFY  name  CHAR(6);Query OK, 0 rows affected (0.09 sec)Records: 0  Duplicates: 0  Warnings: 0MariaDB [db1]&gt; DESC tb1;+-------+------------------+------+-----+---------+----------------+| Field | Type             | Null | Key | Default | Extra          |+-------+------------------+------+-----+---------+----------------+| id    | int(10) unsigned | NO   | PRI | NULL    | auto_increment || name  | char(6)          | YES  |     | NULL    |                |+-------+------------------+------+-----+---------+----------------+2 rows in set (0.01 sec)</code></pre><h4 id="DROP-TABLE"><a href="#DROP-TABLE" class="headerlink" title="DROP TABLE"></a><a href="https://dev.mysql.com/doc/refman/5.5/en/drop-table.html" target="_blank" rel="noopener">DROP TABLE</a></h4><p><strong>语法：</strong></p><pre><code>DROP [TEMPORARY] TABLE [IF EXISTS]    tbl_name [, tbl_name] ...    [RESTRICT | CASCADE]</code></pre><ul><li>RESTRICT：删除表是有限制的<ul><li>欲删除的基本表不能被其他表的约束所引用</li><li>如果存在依赖该表的对象，则此表不能被删除</li></ul></li><li>CASCADE: 在删除基本表的同时，相关的依赖对象一起删除</li></ul><h3 id="DML-数据操作语言"><a href="#DML-数据操作语言" class="headerlink" title="DML 数据操作语言"></a>DML 数据操作语言</h3><blockquote><p><a href="http://www.360doc.com/content/16/0309/09/31217954_540682216.shtml" target="_blank" rel="noopener">数据操作语言</a>(Data Manipulation Language, DML）包含了数据库数据的增删改查操作，也是我们经常会见到的’CRUD’操作，其主要包括INSERT、SELECT、UPDATE和DELETE四条命令。</p></blockquote><h4 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h4><p><strong>语法：</strong></p><pre><code>INSERT [INTO] tbl_name [(col_name [, col_name] ...)]{VALUES | VALUE} ( value [, value] ...) [, ( value [, value] ...)] ...//批量插入INSERT  [INTO] tbl_name [(col_name,...)] SELECT ...INSERT [INTO] tbl_name SET col_name={expr | DEFAULT}, ...</code></pre><p><strong>范例：</strong></p><p>单行插入：</p><pre><code>mysql&gt; INSERT INTO tb1 (name) VALUES (&apos;chenfan&apos;);ERROR 1406 (22001): Data too long for column &apos;name&apos; at row 1mysql&gt; INSERT INTO tb1 (name) VALUES (&apos;chen&apos;);Query OK, 1 row affected (0.06 sec)mysql&gt; SELECT * FROM tb1;+----+------+| id | name |+----+------+|  1 | chen |+----+------+1 row in set (0.00 sec)</code></pre><p>插入查询到的数据:</p><pre><code>mysql&gt; INSERT INTO tb1 (name) SELECT name FROM tb1;Query OK, 1 row affected (0.06 sec)Records: 1  Duplicates: 0  Warnings: 0mysql&gt; SELECT * FROM tb1;+----+------+| id | name |+----+------+|  1 | chen ||  2 | chen |+----+------+2 rows in set (0.00 sec)</code></pre><h4 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h4><p><strong>语法:</strong></p><pre><code>UPDATE [LOW_PRIORITY] [IGNORE] table_reference    SET assignment_list    [WHERE where_condition]    [ORDER BY col1[,...] {ASC|DESC}]    [LIMIT row_count]assignment: col_name = valueassignment_list: assignment [, assignment] ...判断某字段值为空：IS NULL          不空：IS NOT NULLASC：升序DESC：降序</code></pre><p><strong>范例：</strong></p><pre><code>mysql&gt; SELECT * FROM tb1;+----+------+| id | name |+----+------+|  1 | chen ||  2 | chen |+----+------+2 rows in set (0.00 sec)mysql&gt; UPDATE tb1 SET name=&apos;fan&apos; WHERE id=&apos;2&apos; ;Query OK, 1 row affected (0.10 sec)Rows matched: 1  Changed: 1  Warnings: 0mysql&gt; SELECT * FROM tb1;+----+------+| id | name |+----+------+|  1 | chen ||  2 | fan  |+----+------+2 rows in set (0.00 sec)</code></pre><h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><p><strong>语法：</strong></p><pre><code>DELETE FROM tbl_name [WHERE where_condition]    [ORDER BY ...] [LIMIT row_count]</code></pre><p><strong>范例：</strong></p><pre><code>mysql&gt; DELETE FROM tb1 WHERE name=&apos;fan&apos;;Query OK, 1 row affected (0.06 sec)mysql&gt; SELECT * FROM tb1;+----+------+| id | name |+----+------+|  1 | chen |+----+------+1 row in set (0.00 sec)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MySQL数据类型&quot;&gt;&lt;a href=&quot;#MySQL数据类型&quot; class=&quot;headerlink&quot; title=&quot;MySQL数据类型&quot;&gt;&lt;/a&gt;MySQL数据类型&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;MySQL中定义数据字段的类型对你数据库的优化是非常重要的。MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;数值类型&quot;&gt;&lt;a href=&quot;#数值类型&quot; class=&quot;headerlink&quot; title=&quot;数值类型&quot;&gt;&lt;/a&gt;数值类型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;精确数值型&lt;ul&gt;
&lt;li&gt;整形: TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT&lt;/li&gt;
&lt;li&gt;十进制: DECIMAL&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;近似数值型(浮点型):&lt;ul&gt;
&lt;li&gt;FLOAT&lt;/li&gt;
&lt;li&gt;DOUBLE&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/01/31/9PaLMF.png&quot; alt=&quot;数值类型&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;字符型&quot;&gt;&lt;a href=&quot;#字符型&quot; class=&quot;headerlink&quot; title=&quot;字符型&quot;&gt;&lt;/a&gt;字符型&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;char使用固定长度的空间进行存储，char(4)存储4个字符，根据编码方式的不同占用不同的字节，gbk编码方式，不论是中文还是英文，每个字符占用2个字节的空间，utf8编码方式，每个字符占用3个字节的空间。如果需要存储的字符串的长度跟所有值的平均长度相差不大，适合用char，如MD5。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;CHAR,BINARY: 定长数据类型(CHAR不区分字符大小写,BINARY区分字符大小写)&lt;/li&gt;
&lt;li&gt;VARCHAR,VARBINARY: 变长数据类型,需要结束符&lt;/li&gt;
&lt;li&gt;TEXT: TINYTEXT, TEXT, MEDIUMTEXT, LOGTEXT&lt;/li&gt;
&lt;li&gt;BLOB: TINYBLOB, BLOB, MEDIUMBLOB, LONGBLOB&lt;/li&gt;
&lt;li&gt;ENUM,SET&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意：binary保存二进制字符串，就是说它们包含字节字符串而不是字符字符串，没有字符集限制&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/01/31/9PdYon.png&quot; alt=&quot;字符类型&quot;&gt;&lt;br&gt;&lt;strong&gt;&lt;em&gt;注意：CHAR,VARCHAR,TEXT 不区分字符大小写；BINARY,VARBINARY,BLOB 区分字符大小写&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;日期和时间类型&quot;&gt;&lt;a href=&quot;#日期和时间类型&quot; class=&quot;headerlink&quot; title=&quot;日期和时间类型&quot;&gt;&lt;/a&gt;日期和时间类型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;DATE&lt;/li&gt;
&lt;li&gt;TIME&lt;/li&gt;
&lt;li&gt;DATETIME&lt;/li&gt;
&lt;li&gt;TIMESTAMP&lt;/li&gt;
&lt;li&gt;YEAR(2), YEAR(4)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/01/31/9PwwtI.png&quot; alt=&quot;日期时间型&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;特殊类型&quot;&gt;&lt;a href=&quot;#特殊类型&quot; class=&quot;headerlink&quot; title=&quot;特殊类型&quot;&gt;&lt;/a&gt;特殊类型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;ENUM:从给定的字符串中选择一个字串&lt;/li&gt;
&lt;li&gt;SET:集合,从指定字符集合中选择多个组合成一种变化形式&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="MySQL基础入门" scheme="http://www.chenfanlinux.org/categories/MySQL%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="MySQL" scheme="http://www.chenfanlinux.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL基础概念及安装(一)</title>
    <link href="http://www.chenfanlinux.org/2018/01/30/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%89%E8%A3%85-%E4%B8%80/"/>
    <id>http://www.chenfanlinux.org/2018/01/30/MySQL基础概念及安装-一/</id>
    <published>2018-01-30T04:22:21.000Z</published>
    <updated>2018-02-02T03:24:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库概念及相关术语"><a href="#数据库概念及相关术语" class="headerlink" title="数据库概念及相关术语"></a>数据库概念及相关术语</h2><h3 id="什么是数据库？"><a href="#什么是数据库？" class="headerlink" title="什么是数据库？"></a>什么是数据库？</h3><p><a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93" target="_blank" rel="noopener">数据库</a>（Database）是按照数据结构来组织、存储和管理数据的仓库，每个数据库都有一个或多个不同的API用于创建，访问，管理，搜索和复制所保存的数据。我们也可以将数据存储在文件中，但是在文件中读写数据速度相对较慢。所以，现在我们使用关系型数据库管理系统（RDBMS）来存储和管理的大数据量。所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。</p><h3 id="RDBMS的特点"><a href="#RDBMS的特点" class="headerlink" title="RDBMS的特点"></a>RDBMS的特点</h3><blockquote><p>RDBMS即关系数据库管理系统(Relational Database Management System)</p></blockquote><ul><li>数据库中的数据集合都放在数据表(table)中</li><li>数据表由数据行(row)和数据列(column)构成</li><li>一个数据行就是一个数据表中的一条记录(record)</li><li>记录中包含多个信息项，数据表中的每一个数据列都对应一个信息项</li></ul><h3 id="RDBMS-术语"><a href="#RDBMS-术语" class="headerlink" title="RDBMS 术语"></a>RDBMS 术语</h3><ul><li><p>数据库：数据库是一些关联表的集合。</p></li><li><p>数据表：表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。</p></li><li><p>列： 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。</p></li><li><p>行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。</p></li><li><p>冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。</p></li><li><p>主键：主键是唯一的。必须提供数据，即字段不为空（null）；字段不重复，即唯一标识本行；一张表只能有一个主键。</p></li><li><p>外键：一个表中的某字段可填入的数据取决于另一个表的主 键或唯一键已有的数据 ，键表示了两个表之间的相关联系。一个表的主键是另外一张表的外键（唯一键也可以做外键）。</p></li><li><p>复合键：表中一个属性无法唯一标识一条记录，用两条属性组才可以唯一标识一条记录，那么两条属性主就组成了符合主键。单独的每列的字段可重复，但是两个列组成主键后总字段是不重复的，一般用于复合索引。</p></li><li><p>唯一键：一个或多个字段的组合，填入的数据必须能在本表唯一标识本行。和主键不同之处：在表中可以有多个；允许为空值。</p></li><li><p>索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构，类似于书籍的目录。</p></li></ul><h3 id="MySQL核心组件"><a href="#MySQL核心组件" class="headerlink" title="MySQL核心组件"></a>MySQL核心组件</h3><ul><li>连接池：认证、线程重用、连接数限制、内存检查、缓存；</li><li>SQL接口：DDL, DML, 关系型数据库的基本抽象；</li><li>parser: 查询转换、对象权限检查；</li><li>优化器：访问路径，性能相关的统计数据；</li><li>caches和buffers：与存储引擎自身相关的I/O性能提升工具；</li><li>存储引擎：<ul><li>MyISAM、InnoDB(变种：XtraDB)、Memory、Merge、Federated、CSV、Archive、Blackholl、Aria、SphinxSE、TokuDB</li></ul></li></ul><h3 id="数据库设计规范化"><a href="#数据库设计规范化" class="headerlink" title="数据库设计规范化"></a>数据库设计规范化</h3><blockquote><p>仅有好的DBMS并不足以避免数据冗余，必须在数据库的设计中创建好的表结构，数据库规范化的三个级别，范式是具有最小冗余的表结构。</p></blockquote><ul><li><p>第一范式(1NF)<br>就是属性不可分割，这个字段只能是一个值，不能被拆分成多个字段。</p></li><li><p>第二范式(2NF)<br>就是要有主键，要求其他字段都依赖于主键。为什么要有主键？没有主键就没有唯一性，没有唯一性在集合中就定位不到这行记录，所以要主键。</p></li><li><p>第三范式(3NF)<br>关系模式R中的非主关键字不能依赖于其他非主关键，即非主关键字之间不能有函数(传递)依赖关系，要消除传递依赖，消除冗余应该比较好理解一些，就是各种信息只在一个地方存储，不出现在多张表中。</p></li></ul><h3 id="事务（transaction）"><a href="#事务（transaction）" class="headerlink" title="事务（transaction）"></a>事务（transaction）</h3><blockquote><p>事务(Transaction)，一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)，通常就是指数据库事务。一个支持事务（Transaction）的数据库系统，必需要具有ACID特性。</p></blockquote><ul><li>原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</li><li>一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。</li><li>隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li><li>持久性（Durability）：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。</li></ul><a id="more"></a><h3 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h3><ul><li>域的完整性: domain integrity 该类型主要限制了列中的值大小。</li><li>实体完整性：entity integrity 实体属性中的标识属性不能为空、不能重复，该约束通过制定的主键实现，其约束有系统强制实施。</li><li>参照完整性：referential integrity 实体中的外键可以为空，但不能是错的。主要管理表（table）之间的关系。</li></ul><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><blockquote><p>约束主要完成对数据的检验和限制，从而保证数据库的完整性。</p></blockquote><ul><li><p>主键约束(PRIMARY KEY)<br>主键约束列不允许重复，即任意两行的主键值都不相同；每行都具有一个主键值，也不允许出现空值；</p></li><li><p>联合主键<br>有时候一个列的字段可能有重复，可以联合多个列设为主键。</p></li><li><p>外键约束(FOREIGN KEY)<br>外键约束是保证一个或两个表之间的参照完整性,保持数据一致性。表的外键可以是另一表的主键, 外键可以有重复的, 可以是空值。实现一对一或一对多关系。</p></li><li><p>唯一约束(UNIQUE)<br>指定表中某一列或多个列不能有相同的两行或者两行以上的数据存在</p></li><li><p>非空约束(NOT NULL)<br>输入值必须是非空的，需要注意的是允许控制尽量不要太多，太多会更消耗数据库性能。</p></li><li><p>默认约束(DEFAULT)<br>定义的常量必须与该列的数据类型、精度等匹配;每个列只能定义一个DEFAULT约束;DEFAULT约束会在使用INSERT语句。</p></li></ul><h2 id="安装MariaDB"><a href="#安装MariaDB" class="headerlink" title="安装MariaDB"></a>安装MariaDB</h2><blockquote><p>MariaDB的安装方式大致分为三种，第一种是利用程序包管理器的程序包进行安装，简单说可以通过配置yum源来进行安装；第二种是通过对源码进行编译安装进行一些功能选择，以满足生产活动中对一些特殊功能的要求；第三种是利用官网提供的已经编译好的二进制格式程序包进行安装。下面我们主要介绍如何在CentOS7上利用第三种方式进行安装。</p></blockquote><h3 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h3><h4 id="准备用户"><a href="#准备用户" class="headerlink" title="准备用户"></a>准备用户</h4><blockquote><p>因为MariaDB是通过用户身份进行运行的，因此要提前为其准备好运行账户和组。</p></blockquote><pre><code>[root@test ~] groupadd -r -g 306 mysql[root@test ~] useradd -r -g 306 -u 306 -s /sbin/nologin –m –d /app/data mysql[root@test ~] chown mysql:mysql /app/data</code></pre><p>改变目录/app/data目录的所有者和属组，我们可以用其当做数据库的存放目录，这也是我们之所以指定为其创建家目录的原因所在。</p><h4 id="准备二进制程序包"><a href="#准备二进制程序包" class="headerlink" title="准备二进制程序包"></a>准备二进制程序包</h4><pre><code>[root@test ~] tar xf mariadb-VERSION-linux-x86_64.tar.gz -C /usr/local[root@test ~] cd /usr/local;ln -sv mariadb-VERSION mysql[root@test ~] chown -R root:mysql /usr/local/mysql/</code></pre><h4 id="为数据库准备配置文件"><a href="#为数据库准备配置文件" class="headerlink" title="为数据库准备配置文件"></a>为数据库准备配置文件</h4><blockquote><p>数据库已经为我们准备了配置文件模板，我们可以通过这条命令查询并进行选择。而且有”my-small.cnf my-medium.cnf my-large.cnf my-huge.cnf”适合多种类型数据库的配置文件模板供我们选择。这里我们选择huge模板。</p></blockquote><pre><code>[root@test ~] cp  /usr/local/mysql/support-files/my-large.cnf /etc/my.cnf    [root@test ~] vim /etc/mysql/my.cnf  datadir = /app/data 指定数据库位置,必须要指定到我们之前选定的数据库存放目录。    innodb_file_per_table = on 允许每个表格单独存放,方便管理，可省略。    skip_name_resolve = on 禁止主机名反向解析，加快登录速度，可省略。</code></pre><p>数据库会在启动时自动读取配置文件，读取的次序是:<br>/etc/my.cnf —-&gt;/etc/mysql/my.cnf —-&gt;$MYSQL_HOME/my.cnf —&gt;default-extra-file=/path/to/somedir/my.cnf —&gt;~/.my.cnf</p><p>集中式的配置文件，能够为mysql的下面各应用程序提供配置信息</p><ul><li>[mysqld]</li><li>[mysqld_safe]</li><li>[mysqld-multi]</li><li>[server]</li><li>[mysql]</li><li>[mysqldump]</li><li>[client]</li></ul><h3 id="开始配置启动mysql"><a href="#开始配置启动mysql" class="headerlink" title="开始配置启动mysql"></a>开始配置启动mysql</h3><h4 id="为数据库准备配置文件-1"><a href="#为数据库准备配置文件-1" class="headerlink" title="为数据库准备配置文件"></a>为数据库准备配置文件</h4><blockquote><p>创建数据库文件并不需要我们直接手动进行，数据库为我们准备了脚本，我们只需要执行脚本即可。注意必须在目录/usr/local/mysql中，我们才可以执行这个脚本。</p></blockquote><pre><code>[root@test ~] cd /usr/local/mysql/[root@test ~] ./scripts/mysql_install_db --datadir=/app/data --user=mysql</code></pre><h4 id="创建日志文件"><a href="#创建日志文件" class="headerlink" title="创建日志文件"></a>创建日志文件</h4><blockquote><p>为了方便对数据进行管理和排错，我们要自己手动创建数据库文件，并且要给予数据库的运行账户mysql以权限，让其可以写数据进去。</p></blockquote><pre><code>[root@test ~] touch /var/log/mysqld.log[root@test ~] chown mysql /var/log/mysqld.log</code></pre><h4 id="配置服务脚本及开机自启"><a href="#配置服务脚本及开机自启" class="headerlink" title="配置服务脚本及开机自启"></a>配置服务脚本及开机自启</h4><pre><code>[root@test ~] install /usr/local/mysql/support-files/mysql.server /etc/rc.d/init.d/mysqld[root@test ~] chkconfig --add mysqld[root@test ~] chkconfig mysqld on[root@test ~] service mysqld start;ss -ntl</code></pre><p>为了使服务脚本可以利用service命令进行管理，我们需要将服务脚本copy进固定目录中，用install命令是因为这个命令既可以复制又可以加权限。</p><h4 id="为客户端工具指明PATH路径"><a href="#为客户端工具指明PATH路径" class="headerlink" title="为客户端工具指明PATH路径"></a>为客户端工具指明PATH路径</h4><blockquote><p>我们在安装编译好的二进制程序包的时候，不仅安装了服务端程序，也安装了客户端程序。所以我们要为客户端程序指明PATH路径。</p></blockquote><pre><code>[root@test ~] vim /etc/profile.d/mysql.sh   export PATH=/usr/local/mysql/bin:$PATH[root@test ~] source /etc/profile.d/mysql.sh</code></pre><h4 id="执行安全初始化脚本"><a href="#执行安全初始化脚本" class="headerlink" title="执行安全初始化脚本"></a>执行安全初始化脚本</h4><blockquote><p>刚安装好的数据库是无论什么身份都可以登录的，所以需要进行安全初始化，为数据库的root用户创建密码，以及禁止非数据库目录登录数据库。</p></blockquote><pre><code>[root@test ~] mysql_secure_installation\\ 执行后按照提示一步步进行设置即可。</code></pre><h4 id="安装后的设定"><a href="#安装后的设定" class="headerlink" title="安装后的设定"></a>安装后的设定</h4><p><strong>为所有root用户设定密码：</strong></p><ul><li><code>mysql&gt; SET PASSWORD FOR &#39;username&#39;@&#39;host&#39; = PASSWORD(&#39;your_password&#39;);</code></li><li><code>mysql&gt; update mysql.user SET password=PASSWORD(&#39;your_pass&#39;) WHERE clase;</code></li><li><code>$ mysqladmin -uUSERNMAE -hHOSTNAME_OR_IP -p password &#39;new_password&#39;</code></li></ul><p><strong>删除所有的匿名用户:</strong></p><p><code>mysql&gt; DORP USER &#39;&#39;@&#39;localhost&#39;;</code><br>上述可用 mysql_secure_installation 完成</p><p><strong>建议关闭主机名反解功能</strong></p><h2 id="MySQL客户端和服务端特性"><a href="#MySQL客户端和服务端特性" class="headerlink" title="MySQL客户端和服务端特性"></a>MySQL客户端和服务端特性</h2><h3 id="mysql客户端程序"><a href="#mysql客户端程序" class="headerlink" title="mysql客户端程序"></a>mysql客户端程序</h3><h4 id="常见的客户端程序"><a href="#常见的客户端程序" class="headerlink" title="常见的客户端程序"></a>常见的客户端程序</h4><ul><li><p>mysql: 交互式的CLI工具</p></li><li><p>mysqldump: 备份工具,基础mysql协议向mysqld发起查询请求,并将查得的数据保存在文本文件中,转换成create,insert语句保存在文本文件中</p></li><li><p>mysqladmin: 基于mysql协议管理mysqld</p></li><li><p>mysqlimport:数据导入工具</p></li><li>非客户端类的管理工具： myisamchk,myisampak</li></ul><h4 id="客户端类应用程序的可用选项"><a href="#客户端类应用程序的可用选项" class="headerlink" title="客户端类应用程序的可用选项:"></a>客户端类应用程序的可用选项:</h4><ul><li>-u, –user=</li><li>-h, –host=</li><li>-p, –password=</li><li>-P, –port=</li><li>–protocol={tcp|sock}</li><li>-S, –socket= 客户端和服务端位于同一主机</li><li>-D, –database=</li><li>-C, –compress</li><li>-e, 执行sql语句</li></ul><h4 id="如何获取程序默认使用的配置？"><a href="#如何获取程序默认使用的配置？" class="headerlink" title="如何获取程序默认使用的配置？"></a>如何获取程序默认使用的配置？</h4><ul><li>$ mysql  –print-defaults  客户端</li><li>$ mysqld –print-defaults  服务端</li></ul><h4 id="mysql的使用模式"><a href="#mysql的使用模式" class="headerlink" title="mysql的使用模式:"></a>mysql的使用模式:</h4><ul><li>交互式模式:可运行命令有两类<ul><li>客户端命令:<br>\h,help</li><li>服务器端命令:<br>SQL,需要语句结束符’;’</li></ul></li><li>脚本模式:<ul><li>$ mysql -uUSERNAME -hHOST -pPASSWORD &lt;/path/from/somefile.sql</li><li>mysql&gt; source /path/from/somefile.sql</li></ul></li></ul><h3 id="mysql服务端程序-mysqld）"><a href="#mysql服务端程序-mysqld）" class="headerlink" title="mysql服务端程序(mysqld）"></a>mysql服务端程序(mysqld）</h3><h4 id="获取配置文件参数"><a href="#获取配置文件参数" class="headerlink" title="获取配置文件参数"></a>获取配置文件参数</h4><pre><code>[root@docker mysql]# mysqld --verbose --helpsync-frm                                          TRUEsync-master-info                                  0sync-relay-log                                    0sync-relay-log-info                               0sysdate-is-now                                    FALSEtable-cache                                       256table-definition-cache                            400table-open-cache                                  256tc-heuristic-recover                              COMMITtemp-pool                                         TRUEthread-cache-size                                 8thread-concurrency                                8thread-handling                                   one-thread-per-connectionthread-pool-idle-timeout                          60thread-pool-max-threads                           500thread-pool-oversubscribe                         3thread-pool-size                                  1thread-pool-stall-limit                           500thread-stack                                      294912time-format                                       %H:%i:%stimed-mutexes                                     FALSEtmp-table-size                                    16777216tmpdir                                            /tmptransaction-alloc-block-size                      8192transaction-isolation                             REPEATABLE-READtransaction-prealloc-size                         4096updatable-views-with-limit                        YESuserstat                                          FALSEverbose                                           TRUEwait-timeout                                      28800xtradb-admin-command                              ON</code></pre><h4 id="获取运行中的mysql进程使用各参数及其值"><a href="#获取运行中的mysql进程使用各参数及其值" class="headerlink" title="获取运行中的mysql进程使用各参数及其值"></a>获取运行中的mysql进程使用各参数及其值</h4><pre><code>mysql&gt; SHOW GLOBAL VARIABLES;  //全局参数mysql&gt; SHOW SESSION VARIABLES; //会话级别参数</code></pre><p><strong><em>注意: 其中有些参数支持运行时修改，会立即生效;有些参数不支持,且只能通过修改配置文件,并重启服务器程序生效.有些参数的作用域是全局的,且不可改变;有些可以为每个用户提供单独的配置.</em></strong></p><h4 id="MySQL的服务器及状态变量"><a href="#MySQL的服务器及状态变量" class="headerlink" title="MySQL的服务器及状态变量"></a>MySQL的服务器及状态变量</h4><pre><code>SHOW {GLOBAL|SESSION} VARIABLES [LIKE CLAUSE];  //服务器变量SHOW {GLOBAL|SESSION} STATUS [LIKE CLAUSE];     //状态变量</code></pre><p> 状态变量：用户保存mysqld运行中的统计数据变量</p><h4 id="修改服务器变量的值"><a href="#修改服务器变量的值" class="headerlink" title="修改服务器变量的值"></a>修改服务器变量的值</h4><p><code>mysql&gt; help SET</code>  // 查看设置帮助</p><ul><li>全局:<ul><li>mysql&gt; SET GLOBAL system_var_name=value;</li><li>mysql&gt; SET @@global.system_var_name=value;</li></ul></li><li>会话:<ul><li>mysql&gt; SET [SESSION] system_var_name=value;</li><li>mysql&gt; SET @@[session.]system_var_name=value;</li></ul></li></ul><h4 id="SQL-MODE"><a href="#SQL-MODE" class="headerlink" title="SQL MODE"></a>SQL MODE</h4><blockquote><p>定义mysqld对约束等的响应行为</p></blockquote><pre><code>mysql&gt; SHOW GLOBAL VARIABLES LIKE &apos;sql_mode&apos;;mysql&gt; SET GLOBAL sql_mode=&apos;MODE&apos;mysql&gt; SET @@global.sql_mode=&apos;MODE&apos;</code></pre><p>常用的MODE:</p><ul><li>TRADITIONAL</li><li>STRICT_TRANS_TABLES：对支持事务的表使用严格模式</li><li>STRICT_ALL_TABLES：对所有表使用严格模式</li></ul><p><strong><em>使用global修改的变量仅对修改后的新创建的会话有效,对于已经建立的会话无效,无论是SESSION级别或者GLOBAL级别的,重启后都会失效,永久生效需要修改配置文件并重启</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据库概念及相关术语&quot;&gt;&lt;a href=&quot;#数据库概念及相关术语&quot; class=&quot;headerlink&quot; title=&quot;数据库概念及相关术语&quot;&gt;&lt;/a&gt;数据库概念及相关术语&lt;/h2&gt;&lt;h3 id=&quot;什么是数据库？&quot;&gt;&lt;a href=&quot;#什么是数据库？&quot; class=&quot;headerlink&quot; title=&quot;什么是数据库？&quot;&gt;&lt;/a&gt;什么是数据库？&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数据库&lt;/a&gt;（Database）是按照数据结构来组织、存储和管理数据的仓库，每个数据库都有一个或多个不同的API用于创建，访问，管理，搜索和复制所保存的数据。我们也可以将数据存储在文件中，但是在文件中读写数据速度相对较慢。所以，现在我们使用关系型数据库管理系统（RDBMS）来存储和管理的大数据量。所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。&lt;/p&gt;
&lt;h3 id=&quot;RDBMS的特点&quot;&gt;&lt;a href=&quot;#RDBMS的特点&quot; class=&quot;headerlink&quot; title=&quot;RDBMS的特点&quot;&gt;&lt;/a&gt;RDBMS的特点&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;RDBMS即关系数据库管理系统(Relational Database Management System)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;数据库中的数据集合都放在数据表(table)中&lt;/li&gt;
&lt;li&gt;数据表由数据行(row)和数据列(column)构成&lt;/li&gt;
&lt;li&gt;一个数据行就是一个数据表中的一条记录(record)&lt;/li&gt;
&lt;li&gt;记录中包含多个信息项，数据表中的每一个数据列都对应一个信息项&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;RDBMS-术语&quot;&gt;&lt;a href=&quot;#RDBMS-术语&quot; class=&quot;headerlink&quot; title=&quot;RDBMS 术语&quot;&gt;&lt;/a&gt;RDBMS 术语&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;数据库：数据库是一些关联表的集合。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数据表：表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;列： 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;主键：主键是唯一的。必须提供数据，即字段不为空（null）；字段不重复，即唯一标识本行；一张表只能有一个主键。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;外键：一个表中的某字段可填入的数据取决于另一个表的主 键或唯一键已有的数据 ，键表示了两个表之间的相关联系。一个表的主键是另外一张表的外键（唯一键也可以做外键）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;复合键：表中一个属性无法唯一标识一条记录，用两条属性组才可以唯一标识一条记录，那么两条属性主就组成了符合主键。单独的每列的字段可重复，但是两个列组成主键后总字段是不重复的，一般用于复合索引。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;唯一键：一个或多个字段的组合，填入的数据必须能在本表唯一标识本行。和主键不同之处：在表中可以有多个；允许为空值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构，类似于书籍的目录。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;MySQL核心组件&quot;&gt;&lt;a href=&quot;#MySQL核心组件&quot; class=&quot;headerlink&quot; title=&quot;MySQL核心组件&quot;&gt;&lt;/a&gt;MySQL核心组件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;连接池：认证、线程重用、连接数限制、内存检查、缓存；&lt;/li&gt;
&lt;li&gt;SQL接口：DDL, DML, 关系型数据库的基本抽象；&lt;/li&gt;
&lt;li&gt;parser: 查询转换、对象权限检查；&lt;/li&gt;
&lt;li&gt;优化器：访问路径，性能相关的统计数据；&lt;/li&gt;
&lt;li&gt;caches和buffers：与存储引擎自身相关的I/O性能提升工具；&lt;/li&gt;
&lt;li&gt;存储引擎：&lt;ul&gt;
&lt;li&gt;MyISAM、InnoDB(变种：XtraDB)、Memory、Merge、Federated、CSV、Archive、Blackholl、Aria、SphinxSE、TokuDB&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;数据库设计规范化&quot;&gt;&lt;a href=&quot;#数据库设计规范化&quot; class=&quot;headerlink&quot; title=&quot;数据库设计规范化&quot;&gt;&lt;/a&gt;数据库设计规范化&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;仅有好的DBMS并不足以避免数据冗余，必须在数据库的设计中创建好的表结构，数据库规范化的三个级别，范式是具有最小冗余的表结构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一范式(1NF)&lt;br&gt;就是属性不可分割，这个字段只能是一个值，不能被拆分成多个字段。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二范式(2NF)&lt;br&gt;就是要有主键，要求其他字段都依赖于主键。为什么要有主键？没有主键就没有唯一性，没有唯一性在集合中就定位不到这行记录，所以要主键。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第三范式(3NF)&lt;br&gt;关系模式R中的非主关键字不能依赖于其他非主关键，即非主关键字之间不能有函数(传递)依赖关系，要消除传递依赖，消除冗余应该比较好理解一些，就是各种信息只在一个地方存储，不出现在多张表中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;事务（transaction）&quot;&gt;&lt;a href=&quot;#事务（transaction）&quot; class=&quot;headerlink&quot; title=&quot;事务（transaction）&quot;&gt;&lt;/a&gt;事务（transaction）&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;事务(Transaction)，一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)，通常就是指数据库事务。一个支持事务（Transaction）的数据库系统，必需要具有ACID特性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。&lt;/li&gt;
&lt;li&gt;一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。&lt;/li&gt;
&lt;li&gt;隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。&lt;/li&gt;
&lt;li&gt;持久性（Durability）：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="MySQL基础入门" scheme="http://www.chenfanlinux.org/categories/MySQL%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="MySQL" scheme="http://www.chenfanlinux.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础之进程管理</title>
    <link href="http://www.chenfanlinux.org/2018/01/29/Linux%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>http://www.chenfanlinux.org/2018/01/29/Linux基础之进程管理/</id>
    <published>2018-01-29T15:10:26.000Z</published>
    <updated>2018-01-29T15:14:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程?"></a>什么是进程?</h2><h3 id="进程的基本概念"><a href="#进程的基本概念" class="headerlink" title="进程的基本概念"></a>进程的基本概念</h3><blockquote><p>程序本身只是指令、数据及其组织形式的描述，<a href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B" target="_blank" rel="noopener">进程</a>才是程序（那些指令和数据）的真正运行实例。现代计算机系统可在同一段时间内以进程的形式将多个程序加载到内存中，并借由时间共享（或称时分复用），以在一个处理器上表现出同时（平行性）运行的感觉。同样的，使用多线程技术（多线程即每一个线程都代表一个内的一个独立执行上下文）的操作系统或计算机架构，同样程序的平行线程，可在多CPU主机或网络上真正同时运行（在不同的CPU上）。</p></blockquote><h3 id="进程包含的资源"><a href="#进程包含的资源" class="headerlink" title="进程包含的资源"></a>进程包含的资源</h3><p>一个计算机系统进程包括（或者说“拥有”）下列数据：</p><ul><li>那个程序的可执行机器码的一个在内存的映像。</li><li>分配到的内存（通常是虚拟的一个内存区域）。内存的内容包括可执行代码、特定于进程的数据（输入、输出）、调用堆栈、堆栈（用于保存运行时运输中途产生的数据）。</li><li>分配给该进程的资源的操作系统描述符，诸如文件描述符（Unix术语）或文件句柄（Windows）、数据源和数据终端。</li><li>安全特性，诸如进程拥有者和进程的权限集（可以容许的操作）。</li><li>处理器状态（内文），诸如寄存器内容、物理内存定址等。当进程正在运行时，状态通常存储在寄存器，其他情况在内存。</li></ul><h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><ul><li>运行态：running</li><li>就绪态：ready</li><li>睡眠态：又称阻塞态或等待态,可以分为中断睡眠、不可中断睡眠<ul><li>可中断：interruptable</li><li>不可中断：uninterruptable</li></ul></li><li>停止态：暂停于内存中，但不会被调度，除非手动启动之；stopped</li><li><a href="https://zh.wikipedia.org/wiki/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener">僵死态</a>：zombie</li><li>空闲状态（idle）</li></ul><a id="more"></a><p><strong>R (task_running) : 可执行状态</strong></p><blockquote><p>只有在该状态的进程才可能在CPU上运行。而同一时刻可能有多个进程处于可执行状态，这些进程的task_struct结构（进程控制块）被放入对应CPU的可执行队列中（一个进程最多只能出现在一个CPU的可执行队列中）。进程调度器的任务就是从各个CPU的可执行队列中分别选择一个进程在该CPU上运行。<br>很多操作系统教科书将正在CPU上执行的进程定义为RUNNING状态、而将可执行但是尚未被调度执行的进程定义为READY状态，这两种状态在linux下统一为 TASK_RUNNING状态。</p></blockquote><p><strong>S 可中断睡眠: interruptible</strong></p><blockquote><p>处于这个状态的进程因为等待某某事件的发生（比如等待socket连接、等待信号量），而被挂起。这些进程的task_struct结构被放入对应事件的等待队列中。当这些事件发生时（由外部中断触发、或由其他进程触发），对应的等待队列中的一个或多个进程将被唤醒。通过ps命令我们会看到，一般情况下，进程列表中的绝大多数进程都处于task_interruptible状态（除非机器的负载很高）。毕竟CPU就这么一两个，进程动辄几十上百个，如果不是绝大多数进程都在睡眠，CPU又怎么响应得过来。</p></blockquote><p><strong>D 不可中断的睡眠: uninterruptible</strong></p><blockquote><p>进程处于睡眠状态，但是此刻进程是不可中断的。不可中断，指的并不是CPU不响应外部硬件的中断，而是指进程不响应异步信号。绝大多数情况下，进程处在睡眠状态时，总是应该能够响应异步信号的。但是uninterruptible sleep 状态的进程不接受外来的任何信号，因此无法用kill杀掉这些处于D状态的进程，无论是”kill”, “kill -9″还是”kill -15″，这种情况下，一个可选的方法就是reboot。处于uninterruptible sleep状态的进程通常是在等待IO，比如磁盘IO，网络IO，其他外设IO，如果进程正在等待的IO在较长的时间内都没有响应，那么就被ps看到了，同时也就意味着很有可能有IO出了问题，可能是外设本身出了故障，也可能是比如挂载的远程文件系统已经不可访问了。而task_uninterruptible状态存在的意义就在于，内核的某些处理流程是不能被打断的。如果响应异步信号，程序的执行流程中就会被插入一段用于处理异步信号的流程（这个插入的流程可能只存在于内核态，也可能延伸到用户态），于是原有的流程就被中断了。 在进程对某些硬件进行操作时（比如进程调用read系统调用对某个设备文件进行读操作，而read系统调用最终执行到对应设备驱动的代码，并与对应的物理设备进行交互），可能需要使用task_uninterruptible状态对进程进行保护，以避免进程与设备交互的过程被打断，造成设备陷入不可控的状态。这种情况下的task_uninterruptible状态总是非常短暂的，通过ps命令基本上不可能捕捉到。</p></blockquote><p><strong>Z 僵尸进程：zombie</strong></p><blockquote><p>在Linux进程的状态中，僵尸进程是非常特殊的一种，它是已经结束了的进程，但是没有从进程表中删除。太多了会导致进程表里面条目满了，进而导致系统崩溃，倒是不占用其他系统资源。它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的退出状态等信息供其他进程收集，除此之外，僵尸进程不再占有任何内存空间。<br>进程在退出的过程中，处于TASK_DEAD状态。在这个退出过程中，进程占有的所有资源将被回收，除了task_struct结构（以及少数资源）以外。于是进程就只剩下task_struct这么个空壳，故称为僵尸。<br>子进程在退出的过程中，内核会给其父进程发送一个信号，通知父进程来“收尸”。 父进程可以通过wait系列的系统调用（如wait4、waitid）来等待某个或某些子进程的退出，并获取它的退出信息。然后wait系列的系统调用会顺便将子进程的尸体（task_struct）也释放掉。<br>这个信号默认是SIGCHLD，但是在通过clone系统调用创建子进程时，可以设置这个信号。<br>如果他的父进程没安装SIGCHLD信号处理函数调用wait或waitpid()等待子进程结束，又没有显式忽略该信号，那么它就一直保持僵尸状态，子进程的尸体（task_struct）也就无法释放掉。<br>如果这时父进程结束了，那么init进程自动会接手这个子进程，为它收尸，它还是能被清除的。但是如果如果父进程是一个循环，不会结束，那么子进程就会一直保持僵尸状态，这就是为什么系统中有时会有很多的僵尸进程。</p></blockquote><p><strong>Unix/Linux 处理僵尸进程的方法：</strong></p><p>找出父进程号，然后kill 父进程，之后子进程（僵尸进程）会被托管到其他进程，如init进程，然后由init进程将子进程的尸体（task_struct）释放掉。</p><p><strong>T：Stopped：停止状态</strong></p><blockquote><p>向进程发送一个sigstop信号，它就会因响应该信号而进入task_stopped状态（除非该进程本身处于task_uninterruptible状态而不响应信号）。（sigstop与sigkill信号一样，是非常强制的。不允许用户进程通过signal系列的系统调用重新设置对应的信号处理函数。）<br> 向进程发送一个sigcont信号，可以让其从task_stopped状态恢复到task_running状态。<br> 当进程正在被跟踪时，它处于task_traced这个特殊的状态。“正在被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。比如在gdb中对被跟踪的进程下一个断点，进程在断点处停下来的时候就处于task_traced状态。而在其他时候，被跟踪的进程还是处于前面提到的那些状态。<br> 对于进程本身来说，task_stopped和task_traced状态很类似，都是表示进程暂停下来。<br> 而task_traced状态相当于在task_stopped之上多了一层保护，处于task_traced状态的进程不能响应sigcont信号而被唤醒。只能等到调试进程通过ptrace系统调用执行ptrace_cont、ptrace_detach等操作（通过ptrace系统调用的参数指定操作），或调试进程退出，被调试的进程才能恢复task_running状态。</p></blockquote><h3 id="IPC进程间通信"><a href="#IPC进程间通信" class="headerlink" title="IPC进程间通信"></a>IPC进程间通信</h3><ul><li>同一主机上：signal信号、shm: shared memory共享内存、semerphor旗语手势</li><li>不同主机上：rpc: remote process  call远程过程调用、socket套接字</li></ul><h3 id="fork-amp-exec"><a href="#fork-amp-exec" class="headerlink" title="fork &amp; exec"></a>fork &amp; exec</h3><ul><li><p>当计算机开机的时候，内核（kernel）只建立了一个 init 进程。Linux kernel 并不提供直接建立新进程的系统调用。剩下的所有进程都是 init 进程通过 fork 机制建立的。</p></li><li><p>新的进程要通过老的进程复制自身得到，这就是 fork。fork 是一个系统调用。进程存活于内存中。每个进程都在内存中分配有属于自己的一片空间 (内存空间，包含栈、堆、全局静态区、文本常量区、程序代码区)。</p></li><li><p>当一个程序调用 fork 的时候，实际上就是将上面的内存空间，又复制出来一个，构成一个新的进程，并在内核中为该进程创建新的附加信息 (比如新的 PID，而 PPID 为原进程的 PID)。此后，两个进程分别地继续运行下去。新的进程和原有进程有相同的运行状态(相同的变量值，相同的指令…)。我们只能通过进程的附加信息来区分两者。</p></li><li><p>程序调用 exec 的时候，进程清空自身的内存空间，并根据新的程序文件重建程序代码、文本常量、全局静态、堆和栈(此时堆和栈大小都为 0)，并开始运行。</p></li></ul><h2 id="进程管理相关命令"><a href="#进程管理相关命令" class="headerlink" title="进程管理相关命令"></a>进程管理相关命令</h2><h3 id="ps-用于显示当前进程的状态（非动态）"><a href="#ps-用于显示当前进程的状态（非动态）" class="headerlink" title="ps 用于显示当前进程的状态（非动态）"></a>ps 用于显示当前进程的状态（非动态）</h3><p>选项有三种风格：</p><ul><li><p>UNIX风格，必须在选项前面加“-”</p></li><li><p>BSD风格，选项前不能加“-”</p></li><li><p>GNU风格，选项前为两个“-”</p></li></ul><p><strong>常用组合之一：aux</strong></p><ul><li>a：所有与终端相关的进程</li><li>x：所有与终端无关的进程</li><li>u：以用户为中心组织进程状态信息显示</li></ul><p><img src="https://s1.ax1x.com/2018/01/29/9STeaV.png" alt="ps aux"></p><ul><li>USER：用户名</li><li>PID：进程号</li><li>CPU%：cpu时间占用比率</li><li>MEM%：内存占用百分比</li><li>VSZ：virtual size虚拟内存集</li><li>RSS：Resident Size，常驻内存集</li><li>STAT: 进程状态<ul><li>R：running 运行</li><li>S：interruptable sleeping 可中断睡眠</li><li>D：uninterruptable sleeping 不可中断睡眠</li><li>T：Stopped 停止</li><li>Z：zombie 僵死态</li><li>+：前台进程</li><li>l：多线程进程</li><li>N：低优先级进程</li><li>&lt;：高优先级进程</li><li>s：session leader  进程领导者</li></ul></li></ul><p><strong>常用组合之二：-ef</strong></p><ul><li>-e：显示所有进程</li><li>-f：显示完整格式的进程信息</li></ul><p><img src="https://s1.ax1x.com/2018/01/29/9SLS1O.png" alt="ps -ef "></p><h3 id="top动态查看进程状态"><a href="#top动态查看进程状态" class="headerlink" title="top动态查看进程状态"></a>top动态查看进程状态</h3><blockquote><p>系统响应变慢，首先得定位大致的问题出在哪里，是IO瓶颈、CPU瓶颈、内存瓶颈还是程序导致的系统问题；使用top工具能够比较全面的查看我们关注的点。</p></blockquote><p><img src="https://s1.ax1x.com/2018/01/29/9SLAAI.png" alt="top"></p><p><strong>top命令个参数具体含义：</strong></p><p><strong><em>系统状态</em></strong><br>top - 22:08:50 up 16 days, 10:03,  1 user,  load average: 0.00, 0.01, 0.05</p><ul><li>14:58:34：当前时间</li><li>up  5:28：运行时长</li><li>1 user：登录当前系统上的用户数</li><li>load average: 0.00, 0.01, 0.05：<a href="http://blog.scoutapp.com/articles/2009/07/31/understanding-load-averages" target="_blank" rel="noopener">平均负载</a>（等待运行的队列长度的负载）</li></ul><p><strong><em>系统任务情况</em></strong><br>Tasks: 232 total,   1 running, 231 sleeping,   0 stopped,   0 zombie</p><ul><li>232 total：一共运行多少进程</li><li>1 running：几个处于运行</li><li>231 sleeping：多少个睡眠</li><li>0 stopped：多少个停止</li><li>0 zombie：多少个僵死</li></ul><p><strong><em>占用Cpu百分比</em></strong><br>%Cpu(s):  0.1 us,  0.2 sy,  0.0 ni, 99.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</p><ul><li>0.1 us：用户空间占用时间的百分比</li><li>0.2 sy：内核空间占用时间的百分比</li><li>0.0 ni：对nice调整占用的内存百分比</li><li>99.8 id：Cpu的空闲百分比</li><li>0.0 wa：等待IO完成所消耗的百分比</li><li>0.0 hi：处理硬件中断所占用的百分比</li><li>0.0 si：处理软件中断所占用的百分比</li><li>0.0 st：被偷走的百分比（虚拟化程序）</li></ul><p><strong><em>内存的使用情况</em></strong><br>KiB Mem :  8003404 total,   458404 free,  2139240 used,  5405760 buff/cache</p><ul><li>KiB Mem：内存空间占用，以KB为单位：</li><li>8003404 total：总内存空间</li><li>458404 free：剩余内存空间</li><li>2139240 used：已用内存空间</li><li>5405760 buff/cache：用于缓存和缓冲的内存空间<ul><li>A buffer is something that has yet to be “written” to disk</li><li>A cache is something that has been “read” from the disk and stored for later use</li></ul></li></ul><p>注意：系统实际可用的内存为free工具输出第二行的free+buffer+cached,<br>也就是说buffer是用于存放要输出到disk（块设备）的数据的，而cache是存放从disk上读出的数据。这二者是为了提高IO性能的，并由OS管理。</p><p><strong><em>交换分区信息</em></strong></p><ul><li>6881272k total：交换区总量</li><li>4010444k used：使用的交换区量</li><li>2870828k free：空闲的交换区量</li><li>4336992k cached：缓冲交换区总量</li></ul><p><strong><em>进程状态</em></strong></p><ul><li>PID:用户pid</li><li>USER:用户名称</li><li>PR:优先级</li><li>NI:nice值</li><li>VIRT:virtual size虚拟内存集</li><li>RES:常驻内存集</li><li>SHR:共享内存空间</li><li>S:当前状态</li><li>%CPU:占据CPU百分比</li><li>%MEM:占据MEM百分比</li><li>TIME+:运行时长</li><li>COMMAND:命令</li></ul><p><strong><em>top内排序</em></strong></p><ul><li>P：按%CPU使用率排行</li><li>T：按MITE+排行</li><li>M：按%MEM排行</li></ul><h3 id="vmstat-监视内存使用情况"><a href="#vmstat-监视内存使用情况" class="headerlink" title="vmstat 监视内存使用情况"></a>vmstat 监视内存使用情况</h3><blockquote><p>vmstat是Virtual Meomory Statistics（虚拟内存统计）的缩写，可实时动态监视操作系统的虚拟内存、进程、CPU活动。</p></blockquote><p>语法格式：<br><code>vmstat [-V] [-n] [delay [count]]</code></p><ul><li>-V表示打印出版本信息；</li><li>-n表示在周期性循环输出时，输出的头部信息仅显示一次；</li><li>delay是两次输出之间的延迟时间；</li><li>count是指按照这个时间间隔统计的次数。</li></ul><p><img src="https://s1.ax1x.com/2018/01/29/9pPwAU.png" alt="vmstat"></p><ul><li><p>Procs（进程）:</p><ul><li>r: 等待运行进程的个数</li><li>b: 等待IO的进程数量</li></ul></li><li><p>Memory（内存）:</p><ul><li>swpd: 使用虚拟内存大小</li><li>free: 可用内存大小</li><li>buff: 用作缓冲的内存大小</li><li>cache: 用作缓存的内存大小</li></ul></li><li>Swap:<ul><li>si: 每秒从交换区写到内存的大小</li><li>so: 每秒写入交换区的内存大小</li><li>IO：（现在的Linux版本块的大小为1024bytes）</li><li>bi: 每秒读取的块数</li><li>bo: 每秒写入的块数</li></ul></li><li>system：<ul><li>in: 每秒中断数，包括时钟中断</li><li>cs: 每秒上下文切换数</li></ul></li><li>CPU（以百分比表示）<ul><li>us: 用户进程执行时间(user time)</li><li>sy: 系统进程执行时间(system time)</li><li>id: 空闲时间(包括IO等待时间)</li><li>wa: 等待IO时间</li></ul></li></ul><h3 id="dstat系统资源统计命令（动态）"><a href="#dstat系统资源统计命令（动态）" class="headerlink" title="dstat系统资源统计命令（动态）"></a>dstat系统资源统计命令（动态）</h3><blockquote><p>dstat 是一个用来替换 vmstat, iostat, netstat, nfsstat 和 ifstat 这些命令的工具，是一个全能系统信息统计工具。</p></blockquote><p>语法格式：<br><code>dstat [-afv] [options..] [delay [count]]</code></p><p><img src="https://s1.ax1x.com/2018/01/29/9pFDyR.png" alt="dstat"></p><ul><li>-c: 显示cpu信息,默认显示cpu</li><li>-d: 显示disk相关信息</li><li>-D total,sda,sdb</li><li>-g: 显示页面换进换出</li><li>-m :显示内存信息</li><li>-n :显示网络相关信息</li><li>-p :显示process相关统计数据</li><li>-s :显示交互内存的统计数据</li><li>–ipc:进程间通信</li><li>-fs:打开的文件</li><li>–tcp</li><li>–upd</li><li>–socket:socker显示信息</li><li>–top-cpu:显示最消耗cpu的进程</li><li>–top-io:显示最消耗io的进程</li><li>–top-mem:显示最占用内存的进程</li><li>–top-lantency: 显示延迟最大的进程</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是进程&quot;&gt;&lt;a href=&quot;#什么是进程&quot; class=&quot;headerlink&quot; title=&quot;什么是进程?&quot;&gt;&lt;/a&gt;什么是进程?&lt;/h2&gt;&lt;h3 id=&quot;进程的基本概念&quot;&gt;&lt;a href=&quot;#进程的基本概念&quot; class=&quot;headerlink&quot; title=&quot;进程的基本概念&quot;&gt;&lt;/a&gt;进程的基本概念&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;程序本身只是指令、数据及其组织形式的描述，&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;进程&lt;/a&gt;才是程序（那些指令和数据）的真正运行实例。现代计算机系统可在同一段时间内以进程的形式将多个程序加载到内存中，并借由时间共享（或称时分复用），以在一个处理器上表现出同时（平行性）运行的感觉。同样的，使用多线程技术（多线程即每一个线程都代表一个内的一个独立执行上下文）的操作系统或计算机架构，同样程序的平行线程，可在多CPU主机或网络上真正同时运行（在不同的CPU上）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;进程包含的资源&quot;&gt;&lt;a href=&quot;#进程包含的资源&quot; class=&quot;headerlink&quot; title=&quot;进程包含的资源&quot;&gt;&lt;/a&gt;进程包含的资源&lt;/h3&gt;&lt;p&gt;一个计算机系统进程包括（或者说“拥有”）下列数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;那个程序的可执行机器码的一个在内存的映像。&lt;/li&gt;
&lt;li&gt;分配到的内存（通常是虚拟的一个内存区域）。内存的内容包括可执行代码、特定于进程的数据（输入、输出）、调用堆栈、堆栈（用于保存运行时运输中途产生的数据）。&lt;/li&gt;
&lt;li&gt;分配给该进程的资源的操作系统描述符，诸如文件描述符（Unix术语）或文件句柄（Windows）、数据源和数据终端。&lt;/li&gt;
&lt;li&gt;安全特性，诸如进程拥有者和进程的权限集（可以容许的操作）。&lt;/li&gt;
&lt;li&gt;处理器状态（内文），诸如寄存器内容、物理内存定址等。当进程正在运行时，状态通常存储在寄存器，其他情况在内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;进程的状态&quot;&gt;&lt;a href=&quot;#进程的状态&quot; class=&quot;headerlink&quot; title=&quot;进程的状态&quot;&gt;&lt;/a&gt;进程的状态&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;运行态：running&lt;/li&gt;
&lt;li&gt;就绪态：ready&lt;/li&gt;
&lt;li&gt;睡眠态：又称阻塞态或等待态,可以分为中断睡眠、不可中断睡眠&lt;ul&gt;
&lt;li&gt;可中断：interruptable&lt;/li&gt;
&lt;li&gt;不可中断：uninterruptable&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;停止态：暂停于内存中，但不会被调度，除非手动启动之；stopped&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;僵死态&lt;/a&gt;：zombie&lt;/li&gt;
&lt;li&gt;空闲状态（idle）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="linux基础" scheme="http://www.chenfanlinux.org/categories/linux%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="进程" scheme="http://www.chenfanlinux.org/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="linux" scheme="http://www.chenfanlinux.org/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>awk学习笔记</title>
    <link href="http://www.chenfanlinux.org/2018/01/26/awk%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.chenfanlinux.org/2018/01/26/awk学习笔记/</id>
    <published>2018-01-26T03:52:25.000Z</published>
    <updated>2018-01-26T03:53:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="awk简介"><a href="#awk简介" class="headerlink" title="awk简介"></a>awk简介</h2><blockquote><p>awk是一种编程语言，用于在linux/unix下对文本和数据进行处理。数据可以来自标准输入、一个或多个文件，或其它命令的输出。它支持用户自定义函数和动态正则表达式等先进功能，是linux/unix下的一个强大编程工具。</p></blockquote><h3 id="特性介绍"><a href="#特性介绍" class="headerlink" title="特性介绍"></a>特性介绍</h3><ul><li>awk的处理文本和数据的方式是这样的，它逐行扫描文件，从第一行到最后一行，寻找匹配的特定模式的行，并在这些行上进行你想要的操作。</li><li>如果没有指定处理动作，则把匹配的行显示到标准输出(屏幕)；如果没有指定模式，则所有被操作所指定的行都被处理。</li><li>下面介绍的awk是以GUN的gawk为例的，在linux系统中已把awk链接到gawk，所以下面全部以awk进行介绍。</li></ul><h2 id="awk命令格式和选项"><a href="#awk命令格式和选项" class="headerlink" title="awk命令格式和选项"></a>awk命令格式和选项</h2><h3 id="awk的语法"><a href="#awk的语法" class="headerlink" title="awk的语法"></a>awk的语法</h3><ul><li>awk [options] ‘script’ var=value file(s)</li><li>awk [options] -f scriptfile var=value file(s)</li></ul><p><code>script= PATTERN {ACTION STATEMENTS}</code></p><ul><li>PATTERN: 模式,用于地址定界</li><li>ACTION STATEMENTS:动作语句,语句之间用分号分隔</li></ul><h3 id="2-2-命令选项"><a href="#2-2-命令选项" class="headerlink" title="2.2. 命令选项"></a>2.2. 命令选项</h3><pre><code>-F fs ：指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:-v var=val ： 自定义变量</code></pre><h2 id="awk的模式与动作"><a href="#awk的模式与动作" class="headerlink" title="awk的模式与动作"></a>awk的模式与动作</h2><blockquote><p>awk脚本是由模式(PATTERN)和操作语句(ACTION STATEMENTS)两个部分组成,下面将详细介绍这两个部分。</p></blockquote><h3 id="模式-地址定界"><a href="#模式-地址定界" class="headerlink" title="模式(地址定界)"></a>模式(地址定界)</h3><ul><li>empty: 匹配每一行。</li><li>/regular expression/: 正则表达式,仅处理被模式匹配到的行。<br><code>awk -F: &#39;!/^UUID/{print $1}&#39; /etc/fstab</code></li><li>relation expression: 关系表达式,结果有”真”有假: 结果为”真”的行才会被处理。<br><code>awk -F: &#39;$3&lt;1000{print $1,$3}&#39; /etc/passwd</code><br><code>awk -F: &#39;$NF~/bash$/{print $1,$NF}&#39; /etc/passwd</code></li><li>line ranges:行范围<ul><li>(NR&gt;2&amp;&amp;NR&lt;10)  行匹配</li><li>/pattern1/,/pattern2/ 第一次匹配模式1起始和第一次匹配模式2终</li></ul></li><li>BEGIN/END模式<ul><li>BEGIN{}: 仅在开始处理文件中的文本之前执行一次，通常可在这里设置全局变量。</li><li>END{}: 仅在文本处理完成后执行一次<br><code>awk -F: &#39;BEGIN{print &quot;     username   uid\n---------------&quot;} {print $1,$3} END {print &quot;==============\n  end&quot;}&#39; /etc/passwd</code></li></ul></li></ul><a id="more"></a><h3 id="动作语句"><a href="#动作语句" class="headerlink" title="动作语句"></a>动作语句</h3><blockquote><p>动作由一个或多个命令、函数、表达式组成，之间由换行符或分号隔开，并位于大括号内，主要有下面四部分。</p></blockquote><ul><li><p>变量或数组赋值</p></li><li><p>输出命令</p></li><li><p>内置函数</p></li><li><p>控制流命令</p></li></ul><h3 id="awk变量"><a href="#awk变量" class="headerlink" title="awk变量"></a>awk变量</h3><p><strong>awk的环境变量</strong></p><table><thead><tr><th>变量</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>$n</td><td style="text-align:center">当前行的第n个字段，字段间由FS分隔。</td></tr><tr><td>$0</td><td style="text-align:center">完整的行</td></tr><tr><td>FS</td><td style="text-align:center">输入字段分隔符，默认为空格</td></tr><tr><td>OFS</td><td style="text-align:center">输出字段分隔符，默认为空格</td></tr><tr><td>NF</td><td style="text-align:center">当前行的字段总数</td></tr><tr><td>NR</td><td style="text-align:center">当前行的记录数,行号</td></tr><tr><td>RS</td><td style="text-align:center">输入时的行的分隔符,默认换行符(\n)</td></tr><tr><td>ORS</td><td style="text-align:center">输出时的行的分隔符,默认换行符(\n)</td></tr><tr><td>ARGC</td><td style="text-align:center">命令行参数个数</td></tr><tr><td>ARGV</td><td style="text-align:center">数组,命令行中所给定的各参数</td></tr></tbody></table><p><strong><em>注意事项:awk 内部引用变量,无须加$</em></strong></p><p><strong>自定义变量</strong></p><ul><li><p>-v var=value<br><code>awk -v test=&#39;hello&#39; &#39;BEGIN{print test}&#39; /etc/fstab</code></p></li><li><p>在program中直接定义<br><code>awk &#39;BEGIN{test=&quot;hello&quot;;print test}&#39; /etc/fstab</code></p></li></ul><h3 id="运算操作符"><a href="#运算操作符" class="headerlink" title="运算操作符"></a>运算操作符</h3><p><strong>算术操作符</strong><br> x+y,x-y,x*y,x/y,x%y,x^y,-x，+x</p><p><strong>字符串操作符</strong><br>没有符号的操作符,字符串连接</p><p><strong>赋值操作符</strong><br> =,+=,-=,/=,%=,^=,++,–</p><p><strong>比较操作符</strong><br>&lt;,&gt;=,&lt;,&lt;=,!=,==</p><p><strong>模式匹配符</strong><br>~ :是否匹配正则表达式<br>!~：是否不匹正则表达式</p><p><strong>逻辑操作符</strong><br>&amp;&amp;  与<br>||  或<br>!   非</p><p><strong>函数调用</strong><br><code>function_name(argu1,argu2,....）</code></p><p><strong>条件表达式 ?: 选择器</strong><br>语法：selector? if-true-expression:if-fales-expression<br><code>awk -F: &#39;{$3&gt;=1000?usertype=&quot;common user&quot;:usertype=&quot;sysadmin or sysuser&quot;;printf&quot;%15s:%s\n&quot;,$1,usertype}&#39; /etc/passwd</code></p><h3 id="printf命令"><a href="#printf命令" class="headerlink" title="printf命令"></a>printf命令</h3><p>格式化输出: <code>printf FORMAT,item1,item2....</code></p><p>FORMAT注意点：</p><ul><li>FORMAT必须给出</li><li>不会自动换行,需要显示给出换行符,\n</li><li>FORMAT中需要分别为后面的每个item指定一个格式化符号</li></ul><p>格式符:</p><ul><li>%c: 显示字符的ASCII码</li><li>%d: 显示十进制整数</li><li>%e: 科学计数数值显示</li><li>%f: 显示浮点数</li><li>%g: 科学计数法或浮点形式</li><li>%s: 显示字符串</li><li>%u: 无符号整数</li><li>%%: 显示%自身</li></ul><p>修饰符:</p><ul><li>num[.num]: 第一个数字控制显示的宽度,第二个表示小数的精度<br> %3.1f</li><li>-: 左对齐</li><li>+: 显示数值的符号</li></ul><p>范例：<br><code>awk -F: &#39;{printf &quot;Username: %s Uid:%d\n&quot;,$1,$3}&#39; /etc/passwd</code></p><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><blockquote><p>awk中的条件语句是从C语言中借鉴过来的，可控制程序的流程。</p></blockquote><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>格式：</p><pre><code>{if (expression){                  statement; statement; ...                    }       }</code></pre><p>范例：<br><code>awk -F: &#39;{if($3&gt;1000) {print$1,$3}}&#39; /etc/passwd</code></p><h3 id="if-else语句，用于双重判断"><a href="#if-else语句，用于双重判断" class="headerlink" title="if/else语句，用于双重判断"></a>if/else语句，用于双重判断</h3><p>格式：</p><pre><code>{if (expression){                statement; statement; ...                    }     else{                statement; statement; ...                    }     }</code></pre><p>范例：<br><code>awk -F: &#39;{if ($3&gt;=1000) {printf &quot;Admin user: %s\n&quot;,$1} else {printf &quot;Common user: %s\n&quot;,$1}}&#39; /etc/passwd</code></p><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>格式：</p><pre><code>{while (expression) {        statement;statement;....                     }     }</code></pre><p>范例：<br><code>awk &#39;/^[[:space:]]*linux16*/  {i=1;while(i&lt;=NF) {if(length($i)&gt;20) {print $i,length($i)};i++}}&#39; /etc/grub2.cfg</code></p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>格式:<br><code>for(expr1,expr2,expr3) statement</code><br><code>for (variable assignment;condition;iteration process) {for-body}</code><br>      <strong><em>初始化变量，条件，自增加程序</em></strong></p><p>范例:<br><code>awk &#39;/^[[:space:]]*linux16*/ {for (i=1;i&lt;=NF;i++) {print $i,length($i)}}&#39; /etc/grub2.cfg</code></p><h3 id="next"><a href="#next" class="headerlink" title="next"></a>next</h3><p><strong><em>提前结束对本行的处理,直接进入下一行</em></strong></p><p>范例：<br><code>awk -F: &#39;{if($3%2!=0) next;print $1,$3}&#39; /etc/passwd</code></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>关联数组: array[index-expression]</p><p>index-expression: 索引表达式</p><ul><li>可以使用任意字符串:字符串需要加双引号。</li><li>如果某数组元素事先不存在,在引用时,awk会自动创建此元素,并将其值初始化为空。</li></ul><p><strong>若要判断数组中是否存在某元素要使用”index in array”格式进行</strong></p><p><code>awk &#39;BEGIN{weekdays[&quot;mon&quot;]=&quot;Monday&quot;;weekdays[&quot;tue&quot;]=&quot;Tuesday&quot;;print weekdays[&quot;mon&quot;]}&#39;</code></p><p><strong>若要遍历数组中的每一个元素,要使用for循环</strong></p><p>格式：<br><code>for ( var in array) {for-body}</code><br><strong><em>注意: var会遍历array中的每个索引</em></strong></p><p>范例：<br><code>awk &#39;BEGIN{weekdays[&quot;mon&quot;]=&quot;Monday&quot;;weekdays[&quot;tue&quot;]=&quot;Tuesday&quot;;for (i in weekdays) {print weekdays[i]}}&#39;</code></p><p><strong><em>注意： i保存数组中的索引,而不是$i数组中的元素的值</em></strong></p><p>范例：统计tcp连接状态:<br><code>netstat -tan |awk &#39;/^tcp\&gt;/{state[$NF]++}END{for (i in state) {print i,state[i]}}&#39;</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;awk简介&quot;&gt;&lt;a href=&quot;#awk简介&quot; class=&quot;headerlink&quot; title=&quot;awk简介&quot;&gt;&lt;/a&gt;awk简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;awk是一种编程语言，用于在linux/unix下对文本和数据进行处理。数据可以来自标准输入、一个或多个文件，或其它命令的输出。它支持用户自定义函数和动态正则表达式等先进功能，是linux/unix下的一个强大编程工具。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;特性介绍&quot;&gt;&lt;a href=&quot;#特性介绍&quot; class=&quot;headerlink&quot; title=&quot;特性介绍&quot;&gt;&lt;/a&gt;特性介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;awk的处理文本和数据的方式是这样的，它逐行扫描文件，从第一行到最后一行，寻找匹配的特定模式的行，并在这些行上进行你想要的操作。&lt;/li&gt;
&lt;li&gt;如果没有指定处理动作，则把匹配的行显示到标准输出(屏幕)；如果没有指定模式，则所有被操作所指定的行都被处理。&lt;/li&gt;
&lt;li&gt;下面介绍的awk是以GUN的gawk为例的，在linux系统中已把awk链接到gawk，所以下面全部以awk进行介绍。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;awk命令格式和选项&quot;&gt;&lt;a href=&quot;#awk命令格式和选项&quot; class=&quot;headerlink&quot; title=&quot;awk命令格式和选项&quot;&gt;&lt;/a&gt;awk命令格式和选项&lt;/h2&gt;&lt;h3 id=&quot;awk的语法&quot;&gt;&lt;a href=&quot;#awk的语法&quot; class=&quot;headerlink&quot; title=&quot;awk的语法&quot;&gt;&lt;/a&gt;awk的语法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;awk [options] ‘script’ var=value file(s)&lt;/li&gt;
&lt;li&gt;awk [options] -f scriptfile var=value file(s)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;script= PATTERN {ACTION STATEMENTS}&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PATTERN: 模式,用于地址定界&lt;/li&gt;
&lt;li&gt;ACTION STATEMENTS:动作语句,语句之间用分号分隔&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-2-命令选项&quot;&gt;&lt;a href=&quot;#2-2-命令选项&quot; class=&quot;headerlink&quot; title=&quot;2.2. 命令选项&quot;&gt;&lt;/a&gt;2.2. 命令选项&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;-F fs ：指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:
-v var=val ： 自定义变量
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;awk的模式与动作&quot;&gt;&lt;a href=&quot;#awk的模式与动作&quot; class=&quot;headerlink&quot; title=&quot;awk的模式与动作&quot;&gt;&lt;/a&gt;awk的模式与动作&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;awk脚本是由模式(PATTERN)和操作语句(ACTION STATEMENTS)两个部分组成,下面将详细介绍这两个部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;模式-地址定界&quot;&gt;&lt;a href=&quot;#模式-地址定界&quot; class=&quot;headerlink&quot; title=&quot;模式(地址定界)&quot;&gt;&lt;/a&gt;模式(地址定界)&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;empty: 匹配每一行。&lt;/li&gt;
&lt;li&gt;/regular expression/: 正则表达式,仅处理被模式匹配到的行。&lt;br&gt;&lt;code&gt;awk -F: &amp;#39;!/^UUID/{print $1}&amp;#39; /etc/fstab&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;relation expression: 关系表达式,结果有”真”有假: 结果为”真”的行才会被处理。&lt;br&gt;&lt;code&gt;awk -F: &amp;#39;$3&amp;lt;1000{print $1,$3}&amp;#39; /etc/passwd&lt;/code&gt;&lt;br&gt;&lt;code&gt;awk -F: &amp;#39;$NF~/bash$/{print $1,$NF}&amp;#39; /etc/passwd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;line ranges:行范围&lt;ul&gt;
&lt;li&gt;(NR&amp;gt;2&amp;amp;&amp;amp;NR&amp;lt;10)  行匹配&lt;/li&gt;
&lt;li&gt;/pattern1/,/pattern2/ 第一次匹配模式1起始和第一次匹配模式2终&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BEGIN/END模式&lt;ul&gt;
&lt;li&gt;BEGIN{}: 仅在开始处理文件中的文本之前执行一次，通常可在这里设置全局变量。&lt;/li&gt;
&lt;li&gt;END{}: 仅在文本处理完成后执行一次&lt;br&gt;&lt;code&gt;awk -F: &amp;#39;BEGIN{print &amp;quot;     username   uid\n---------------&amp;quot;} {print $1,$3} END {print &amp;quot;==============\n  end&amp;quot;}&amp;#39; /etc/passwd&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="linux基础" scheme="http://www.chenfanlinux.org/categories/linux%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="awk" scheme="http://www.chenfanlinux.org/tags/awk/"/>
    
  </entry>
  
  <entry>
    <title>Bash编程入门之流程控制(四)</title>
    <link href="http://www.chenfanlinux.org/2018/01/25/Bash%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E4%B9%8B%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6-%E5%9B%9B/"/>
    <id>http://www.chenfanlinux.org/2018/01/25/Bash编程入门之流程控制-四/</id>
    <published>2018-01-25T03:17:48.000Z</published>
    <updated>2018-01-29T10:10:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><blockquote><p>bash shell中会根据命令的执行状态结果(0或1),来表示条件的true或false,根据不同的条件,选择的执行不同的语句,来达到流程控制的目的。</p></blockquote><h3 id="单分支-if结构"><a href="#单分支-if结构" class="headerlink" title="单分支 if结构"></a>单分支 if结构</h3><pre><code>if CONDITON;then    if-truefi---------------------------------------------if  [[ expression  ]];then    if-truefi</code></pre><p><strong><em>注意：此处的CONDITION相当于bash中的命令,根据命令的执行状态结构，来选择语句是否执行。</em></strong></p><h3 id="双分支-if-else结构"><a href="#双分支-if-else结构" class="headerlink" title="双分支 if/else结构"></a>双分支 if/else结构</h3><pre><code>if CONDITION;then    if-trueelse    if-falsefi----------------------------------------------if  [[ expression ]];then   if-trueelse  if-falsefi</code></pre><a id="more"></a><h3 id="多分支-if-elif-else结构"><a href="#多分支-if-elif-else结构" class="headerlink" title="多分支 if/elif/else结构"></a>多分支 if/elif/else结构</h3><pre><code>if CONDITION1;then    if-trueelif CONDITON2;then    if-trueelif CONDITION3;then    if-true........else    all-falsefi</code></pre><p><strong><em>注意: 逐条件判断,第一次遇到为”真的条件”时,执行其分支,而后结束。</em></strong></p><h3 id="case-esac结构"><a href="#case-esac结构" class="headerlink" title="case/esac结构"></a>case/esac结构</h3><pre><code>case variable_name in   pattern1)      statements         ;;   pattern2)      statements         ;;   pattern3)         ;;esac</code></pre><p><strong><em>注意：根据变量取值得不同，执行不同的语句，适合菜单功能的实现</em></strong></p><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><blockquote><p>根据循环的进入条件,开始执行循环语句,然后根据循环的退出条件,退出循环语句的执行。常见的循环有三种类型: while、until、for。</p></blockquote><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><pre><code>while CONDITONdo   循环体done------------------------------------while [[ string expression ]]do   循环体done------------------------------------while (( numeric expression ))do   循环体done</code></pre><p><strong><em>while循环,只要表达式为真，循环体就会被一直执行。</em></strong></p><h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><pre><code>while :do    循环体done--------------while truedo    循环体done--------------for (( ; ; ))</code></pre><h3 id="until-循环"><a href="#until-循环" class="headerlink" title="until 循环"></a>until 循环</h3><blockquote><p>until循环执行一系列命令直至条件为真时停止。until循环与while循环在处理方式上刚好相反。一般while循环优于until循环，但在某些时候—也只是极少数情况下，until循环更加有用。</p></blockquote><pre><code>until conditiondo    commanddone</code></pre><p><strong><em>注意：条件可为任意测试条件，测试发生在循环末尾，因此循环至少执行一次。</em></strong></p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><blockquote><p>依次将列表中的元素当值赋值给”变量名”,每次赋值后即执行一次循环体;直到列表中的元素耗尽,循环结束。</p></blockquote><pre><code>for 变量名  in 列表do 循环体done</code></pre><p><strong>列表生成的方式:</strong></p><ul><li><p>直接给出列表</p></li><li><p>整数列表</p><ul><li>{start..end}</li><li>`seq 1 10`</li></ul></li><li><p>返回列表的命令 $(COMMAND)</p></li><li><p>glob   /var/*</p></li><li>变量引用<br>$@,$*</li></ul><p><strong>for循环的特殊用法</strong></p><pre><code>for ((控制变量初始化;条件表达式;控制变量的修正表达式));do循环体done \\范例 declare -i sum=0 for ((i=0;i&lt;=100;i++));do let sum+=$i done echo &quot;$sum&quot;</code></pre><p><strong><em>控制变量的初始化:仅在运行循环代码段时执行一次</em></strong><br><strong><em>控制变量的修正表达式:每轮循环结束会先进行控制变量修正运算,而后进行条件判断。</em></strong></p><h3 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a>跳出循环</h3><blockquote><p>在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，Shell使用两个命令来实现该功能：break和continue。</p></blockquote><p><strong>break命令</strong><br>break命令允许跳出所有循环（终止执行后面的所有循环）。</p><p><strong>continue命令</strong><br>continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;条件判断&quot;&gt;&lt;a href=&quot;#条件判断&quot; class=&quot;headerlink&quot; title=&quot;条件判断&quot;&gt;&lt;/a&gt;条件判断&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;bash shell中会根据命令的执行状态结果(0或1),来表示条件的true或false,根据不同的条件,选择的执行不同的语句,来达到流程控制的目的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;单分支-if结构&quot;&gt;&lt;a href=&quot;#单分支-if结构&quot; class=&quot;headerlink&quot; title=&quot;单分支 if结构&quot;&gt;&lt;/a&gt;单分支 if结构&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;if CONDITON;then
    if-true
fi
---------------------------------------------
if  [[ expression  ]];then
    if-true
fi
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意：此处的CONDITION相当于bash中的命令,根据命令的执行状态结构，来选择语句是否执行。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;双分支-if-else结构&quot;&gt;&lt;a href=&quot;#双分支-if-else结构&quot; class=&quot;headerlink&quot; title=&quot;双分支 if/else结构&quot;&gt;&lt;/a&gt;双分支 if/else结构&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;if CONDITION;then
    if-true
else
    if-false
fi

----------------------------------------------
if  [[ expression ]];then
   if-true
else
  if-false
fi
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Bash Shell编程" scheme="http://www.chenfanlinux.org/categories/Bash-Shell%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Bash" scheme="http://www.chenfanlinux.org/tags/Bash/"/>
    
  </entry>
  
  <entry>
    <title>awk应用指南</title>
    <link href="http://www.chenfanlinux.org/2018/01/23/awk%E5%BA%94%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://www.chenfanlinux.org/2018/01/23/awk应用指南/</id>
    <published>2018-01-23T01:08:59.000Z</published>
    <updated>2018-01-26T03:58:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="awk简介"><a href="#awk简介" class="headerlink" title="awk简介"></a>awk简介</h2><blockquote><p>awk是一种编程语言，用于在linux/unix下对文本和数据进行处理。数据可以来自标准输入、一个或多个文件，或其它命令的输出。它支持用户自定义函数和动态正则表达式等先进功能，是linux/unix下的一个强大编程工具。</p></blockquote><h3 id="特性介绍"><a href="#特性介绍" class="headerlink" title="特性介绍"></a>特性介绍</h3><ul><li>awk的处理文本和数据的方式是这样的，它逐行扫描文件，从第一行到最后一行，寻找匹配的特定模式的行，并在这些行上进行你想要的操作。</li><li>如果没有指定处理动作，则把匹配的行显示到标准输出(屏幕)；如果没有指定模式，则所有被操作所指定的行都被处理。</li><li>下面介绍的awk是以GUN的gawk为例的，在linux系统中已把awk链接到gawk，所以下面全部以awk进行介绍。</li></ul><h2 id="awk命令格式和选项"><a href="#awk命令格式和选项" class="headerlink" title="awk命令格式和选项"></a>awk命令格式和选项</h2><h3 id="awk的语法"><a href="#awk的语法" class="headerlink" title="awk的语法"></a>awk的语法</h3><ul><li>awk [options] ‘script’ var=value file(s)</li><li>awk [options] -f scriptfile var=value file(s)</li></ul><p><code>script= PATTERN {ACTION STATEMENTS}</code></p><ul><li>PATTERN: 模式,用于地址定界</li><li>ACTION STATEMENTS:动作语句,语句之间用分号分隔</li></ul><h3 id="2-2-命令选项"><a href="#2-2-命令选项" class="headerlink" title="2.2. 命令选项"></a>2.2. 命令选项</h3><pre><code>-F fs ：指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:-v var=val ： 自定义变量</code></pre><h2 id="awk的模式与动作"><a href="#awk的模式与动作" class="headerlink" title="awk的模式与动作"></a>awk的模式与动作</h2><blockquote><p>awk脚本是由模式(PATTERN)和操作语句(ACTION STATEMENTS)两个部分组成,下面将详细介绍这两个部分。</p></blockquote><h3 id="模式-地址定界"><a href="#模式-地址定界" class="headerlink" title="模式(地址定界)"></a>模式(地址定界)</h3><ul><li>empty: 匹配每一行。</li><li>/regular expression/: 正则表达式,仅处理被模式匹配到的行。<br><code>awk -F: &#39;!/^UUID/{print $1}&#39; /etc/fstab</code></li><li>relation expression: 关系表达式,结果有”真”有假: 结果为”真”的行才会被处理。<br><code>awk -F: &#39;$3&lt;1000{print $1,$3}&#39; /etc/passwd</code><br><code>awk -F: &#39;$NF~/bash$/{print $1,$NF}&#39; /etc/passwd</code></li><li>line ranges:行范围<ul><li>(NR&gt;2&amp;&amp;NR&lt;10)  行匹配</li><li>/pattern1/,/pattern2/ 第一次匹配模式1起始和第一次匹配模式2终</li></ul></li><li>BEGIN/END模式<ul><li>BEGIN{}: 仅在开始处理文件中的文本之前执行一次，通常可在这里设置全局变量。</li><li>END{}: 仅在文本处理完成后执行一次<br><code>awk -F: &#39;BEGIN{print &quot;     username   uid\n---------------&quot;} {print $1,$3} END {print &quot;==============\n  end&quot;}&#39; /etc/passwd</code></li></ul></li></ul><a id="more"></a><h3 id="动作语句"><a href="#动作语句" class="headerlink" title="动作语句"></a>动作语句</h3><blockquote><p>动作由一个或多个命令、函数、表达式组成，之间由换行符或分号隔开，并位于大括号内，主要有下面四部分。</p></blockquote><ul><li><p>变量或数组赋值</p></li><li><p>输出命令</p></li><li><p>内置函数</p></li><li><p>控制流命令</p></li></ul><h3 id="awk变量"><a href="#awk变量" class="headerlink" title="awk变量"></a>awk变量</h3><p><strong>awk的环境变量</strong></p><table><thead><tr><th>变量</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>$n</td><td style="text-align:center">当前行的第n个字段，字段间由FS分隔。</td></tr><tr><td>$0</td><td style="text-align:center">完整的行</td></tr><tr><td>FS</td><td style="text-align:center">输入字段分隔符，默认为空格</td></tr><tr><td>OFS</td><td style="text-align:center">输出字段分隔符，默认为空格</td></tr><tr><td>NF</td><td style="text-align:center">当前行的字段总数</td></tr><tr><td>NR</td><td style="text-align:center">当前行的记录数,行号</td></tr><tr><td>RS</td><td style="text-align:center">输入时的行的分隔符,默认换行符(\n)</td></tr><tr><td>ORS</td><td style="text-align:center">输出时的行的分隔符,默认换行符(\n)</td></tr><tr><td>ARGC</td><td style="text-align:center">命令行参数个数</td></tr><tr><td>ARGV</td><td style="text-align:center">数组,命令行中所给定的各参数</td></tr></tbody></table><p><strong><em>注意事项:awk 内部引用变量,无须加$</em></strong></p><p><strong>自定义变量</strong></p><ul><li><p>-v var=value<br><code>awk -v test=&#39;hello&#39; &#39;BEGIN{print test}&#39; /etc/fstab</code></p></li><li><p>在program中直接定义<br><code>awk &#39;BEGIN{test=&quot;hello&quot;;print test}&#39; /etc/fstab</code></p></li></ul><h3 id="运算操作符"><a href="#运算操作符" class="headerlink" title="运算操作符"></a>运算操作符</h3><p><strong>算术操作符</strong><br> x+y,x-y,x*y,x/y,x%y,x^y,-x，+x</p><p><strong>字符串操作符</strong><br>没有符号的操作符,字符串连接</p><p><strong>赋值操作符</strong><br> =,+=,-=,/=,%=,^=,++,–</p><p><strong>比较操作符</strong><br>&lt;,&gt;=,&lt;,&lt;=,!=,==</p><p><strong>模式匹配符</strong><br>~ :是否匹配正则表达式<br>!~：是否不匹正则表达式</p><p><strong>逻辑操作符</strong><br>&amp;&amp;  与<br>||  或<br>!   非</p><p><strong>函数调用</strong><br><code>function_name(argu1,argu2,....）</code></p><p><strong>条件表达式 ?: 选择器</strong><br>语法：selector? if-true-expression:if-fales-expression<br><code>awk -F: &#39;{$3&gt;=1000?usertype=&quot;common user&quot;:usertype=&quot;sysadmin or sysuser&quot;;printf&quot;%15s:%s\n&quot;,$1,usertype}&#39; /etc/passwd</code></p><h3 id="printf命令"><a href="#printf命令" class="headerlink" title="printf命令"></a>printf命令</h3><p>格式化输出: <code>printf FORMAT,item1,item2....</code></p><p>FORMAT注意点：</p><ul><li>FORMAT必须给出</li><li>不会自动换行,需要显示给出换行符,\n</li><li>FORMAT中需要分别为后面的每个item指定一个格式化符号</li></ul><p>格式符:</p><ul><li>%c: 显示字符的ASCII码</li><li>%d: 显示十进制整数</li><li>%e: 科学计数数值显示</li><li>%f: 显示浮点数</li><li>%g: 科学计数法或浮点形式</li><li>%s: 显示字符串</li><li>%u: 无符号整数</li><li>%%: 显示%自身</li></ul><p>修饰符:</p><ul><li>num[.num]: 第一个数字控制显示的宽度,第二个表示小数的精度<br> %3.1f</li><li>-: 左对齐</li><li>+: 显示数值的符号</li></ul><p>范例：<br><code>awk -F: &#39;{printf &quot;Username: %s Uid:%d\n&quot;,$1,$3}&#39; /etc/passwd</code></p><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><blockquote><p>awk中的条件语句是从C语言中借鉴过来的，可控制程序的流程。</p></blockquote><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>格式：</p><pre><code>{if (expression){                  statement; statement; ...                    }       }</code></pre><p>范例：<br><code>awk -F: &#39;{if($3&gt;1000) {print$1,$3}}&#39; /etc/passwd</code></p><h3 id="if-else语句，用于双重判断"><a href="#if-else语句，用于双重判断" class="headerlink" title="if/else语句，用于双重判断"></a>if/else语句，用于双重判断</h3><p>格式：</p><pre><code>{if (expression){                statement; statement; ...                    }     else{                statement; statement; ...                    }     }</code></pre><p>范例：<br><code>awk -F: &#39;{if ($3&gt;=1000) {printf &quot;Admin user: %s\n&quot;,$1} else {printf &quot;Common user: %s\n&quot;,$1}}&#39; /etc/passwd</code></p><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>格式：</p><pre><code>{while (expression) {        statement;statement;....                     }     }</code></pre><p>范例：<br><code>awk &#39;/^[[:space:]]*linux16*/  {i=1;while(i&lt;=NF) {if(length($i)&gt;20) {print $i,length($i)};i++}}&#39; /etc/grub2.cfg</code></p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>格式:<br><code>for(expr1,expr2,expr3) statement</code><br><code>for (variable assignment;condition;iteration process) {for-body}</code><br>      <strong><em>初始化变量，条件，自增加程序</em></strong></p><p>范例:<br><code>awk &#39;/^[[:space:]]*linux16*/ {for (i=1;i&lt;=NF;i++) {print $i,length($i)}}&#39; /etc/grub2.cfg</code></p><h3 id="next"><a href="#next" class="headerlink" title="next"></a>next</h3><p><strong><em>提前结束对本行的处理,直接进入下一行</em></strong></p><p>范例：<br><code>awk -F: &#39;{if($3%2!=0) next;print $1,$3}&#39; /etc/passwd</code></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>关联数组: array[index-expression]</p><p>index-expression: 索引表达式</p><ul><li>可以使用任意字符串:字符串需要加双引号。</li><li>如果某数组元素事先不存在,在引用时,awk会自动创建此元素,并将其值初始化为空。</li></ul><p><strong>若要判断数组中是否存在某元素要使用”index in array”格式进行</strong></p><p><code>awk &#39;BEGIN{weekdays[&quot;mon&quot;]=&quot;Monday&quot;;weekdays[&quot;tue&quot;]=&quot;Tuesday&quot;;print weekdays[&quot;mon&quot;]}&#39;</code></p><p><strong>若要遍历数组中的每一个元素,要使用for循环</strong></p><p>格式：<br><code>for ( var in array) {for-body}</code><br><strong><em>注意: var会遍历array中的每个索引</em></strong></p><p>范例：<br><code>awk &#39;BEGIN{weekdays[&quot;mon&quot;]=&quot;Monday&quot;;weekdays[&quot;tue&quot;]=&quot;Tuesday&quot;;for (i in weekdays) {print weekdays[i]}}&#39;</code></p><p><strong><em>注意： i保存数组中的索引,而不是$i数组中的元素的值</em></strong></p><p>范例：统计tcp连接状态:<br><code>netstat -tan |awk &#39;/^tcp\&gt;/{state[$NF]++}END{for (i in state) {print i,state[i]}}&#39;</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;awk简介&quot;&gt;&lt;a href=&quot;#awk简介&quot; class=&quot;headerlink&quot; title=&quot;awk简介&quot;&gt;&lt;/a&gt;awk简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;awk是一种编程语言，用于在linux/unix下对文本和数据进行处理。数据可以来自标准输入、一个或多个文件，或其它命令的输出。它支持用户自定义函数和动态正则表达式等先进功能，是linux/unix下的一个强大编程工具。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;特性介绍&quot;&gt;&lt;a href=&quot;#特性介绍&quot; class=&quot;headerlink&quot; title=&quot;特性介绍&quot;&gt;&lt;/a&gt;特性介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;awk的处理文本和数据的方式是这样的，它逐行扫描文件，从第一行到最后一行，寻找匹配的特定模式的行，并在这些行上进行你想要的操作。&lt;/li&gt;
&lt;li&gt;如果没有指定处理动作，则把匹配的行显示到标准输出(屏幕)；如果没有指定模式，则所有被操作所指定的行都被处理。&lt;/li&gt;
&lt;li&gt;下面介绍的awk是以GUN的gawk为例的，在linux系统中已把awk链接到gawk，所以下面全部以awk进行介绍。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;awk命令格式和选项&quot;&gt;&lt;a href=&quot;#awk命令格式和选项&quot; class=&quot;headerlink&quot; title=&quot;awk命令格式和选项&quot;&gt;&lt;/a&gt;awk命令格式和选项&lt;/h2&gt;&lt;h3 id=&quot;awk的语法&quot;&gt;&lt;a href=&quot;#awk的语法&quot; class=&quot;headerlink&quot; title=&quot;awk的语法&quot;&gt;&lt;/a&gt;awk的语法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;awk [options] ‘script’ var=value file(s)&lt;/li&gt;
&lt;li&gt;awk [options] -f scriptfile var=value file(s)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;script= PATTERN {ACTION STATEMENTS}&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PATTERN: 模式,用于地址定界&lt;/li&gt;
&lt;li&gt;ACTION STATEMENTS:动作语句,语句之间用分号分隔&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-2-命令选项&quot;&gt;&lt;a href=&quot;#2-2-命令选项&quot; class=&quot;headerlink&quot; title=&quot;2.2. 命令选项&quot;&gt;&lt;/a&gt;2.2. 命令选项&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;-F fs ：指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:
-v var=val ： 自定义变量
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;awk的模式与动作&quot;&gt;&lt;a href=&quot;#awk的模式与动作&quot; class=&quot;headerlink&quot; title=&quot;awk的模式与动作&quot;&gt;&lt;/a&gt;awk的模式与动作&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;awk脚本是由模式(PATTERN)和操作语句(ACTION STATEMENTS)两个部分组成,下面将详细介绍这两个部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;模式-地址定界&quot;&gt;&lt;a href=&quot;#模式-地址定界&quot; class=&quot;headerlink&quot; title=&quot;模式(地址定界)&quot;&gt;&lt;/a&gt;模式(地址定界)&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;empty: 匹配每一行。&lt;/li&gt;
&lt;li&gt;/regular expression/: 正则表达式,仅处理被模式匹配到的行。&lt;br&gt;&lt;code&gt;awk -F: &amp;#39;!/^UUID/{print $1}&amp;#39; /etc/fstab&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;relation expression: 关系表达式,结果有”真”有假: 结果为”真”的行才会被处理。&lt;br&gt;&lt;code&gt;awk -F: &amp;#39;$3&amp;lt;1000{print $1,$3}&amp;#39; /etc/passwd&lt;/code&gt;&lt;br&gt;&lt;code&gt;awk -F: &amp;#39;$NF~/bash$/{print $1,$NF}&amp;#39; /etc/passwd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;line ranges:行范围&lt;ul&gt;
&lt;li&gt;(NR&amp;gt;2&amp;amp;&amp;amp;NR&amp;lt;10)  行匹配&lt;/li&gt;
&lt;li&gt;/pattern1/,/pattern2/ 第一次匹配模式1起始和第一次匹配模式2终&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BEGIN/END模式&lt;ul&gt;
&lt;li&gt;BEGIN{}: 仅在开始处理文件中的文本之前执行一次，通常可在这里设置全局变量。&lt;/li&gt;
&lt;li&gt;END{}: 仅在文本处理完成后执行一次&lt;br&gt;&lt;code&gt;awk -F: &amp;#39;BEGIN{print &amp;quot;     username   uid\n---------------&amp;quot;} {print $1,$3} END {print &amp;quot;==============\n  end&amp;quot;}&amp;#39; /etc/passwd&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="linux基础" scheme="http://www.chenfanlinux.org/categories/linux%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Awk" scheme="http://www.chenfanlinux.org/tags/Awk/"/>
    
  </entry>
  
  <entry>
    <title>流编辑器sed学习笔记</title>
    <link href="http://www.chenfanlinux.org/2018/01/21/%E6%B5%81%E7%BC%96%E8%BE%91%E5%99%A8sed%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.chenfanlinux.org/2018/01/21/流编辑器sed学习笔记/</id>
    <published>2018-01-21T15:25:16.000Z</published>
    <updated>2018-01-26T03:39:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Sed"><a href="#Sed" class="headerlink" title="Sed"></a>Sed</h2><blockquote><p>全称Stream Editor,Sed从本质上来讲其实是一种非交互式的编辑器。</p></blockquote><h3 id="sed的处理流程"><a href="#sed的处理流程" class="headerlink" title="sed的处理流程"></a>sed的处理流程</h3><blockquote><p>sed中script执行是有先后顺序的</p></blockquote><ol><li>读入一行内行到缓存空间(模式空间)</li><li>从script中取出一条命令, 判断是否匹配pattern(一般为正则表达式)</li><li>如果不匹配, 则忽略后续命令, 回到第二步取下一条命令</li><li>如果匹配, 则对缓存的行执行后续的编辑命令; 完成后, 回到第二步继续取下一条命令</li><li>当所有命令应用后, 输出缓存行的内容, 回到第一步读取下一行</li><li>当所有行处理完则执行结束</li></ol><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><p><code>sed [options] &#39;script&#39; inputfile</code><br>对于script的语法有两种约定，分别是</p><ul><li>[address]command              指可以为任意地址包括地址对</li><li>[line-address]command         只能为单个地址</li></ul><h3 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h3><pre><code>-n: 不输出模式空间中的内容至屏幕-e: 多点编辑-r: 支持使用扩展的正则表达式-i: 修改原文件</code></pre><h3 id="地址定界"><a href="#地址定界" class="headerlink" title="地址定界"></a>地址定界</h3><ul><li>no-address:对全文进行处理</li><li><p>line-address 单地址</p><ul><li>n1  指定的行,数字表示</li><li>/pattern/ 被此处模式所能匹配到的每一行</li></ul></li><li><p>address 地址对</p><ul><li>n1,n2</li><li>n1,+n2</li><li>/pattern1/,/pattern2/</li><li>n1,/pattern1/</li></ul></li></ul><a id="more"></a><h3 id="sed基础命令"><a href="#sed基础命令" class="headerlink" title="sed基础命令"></a>sed基础命令</h3><p><img src="https://s1.ax1x.com/2018/01/21/pfgjyQ.png" alt="sed基础命令"></p><h3 id="sed命令实践"><a href="#sed命令实践" class="headerlink" title="sed命令实践"></a>sed命令实践</h3><p><strong>删除匹配的某行</strong></p><pre><code>[root@docker ~]# sed &apos;/^UUID/d&apos; /etc/fstab## /etc/fstab# Created by anaconda on Fri Nov 17 00:04:38 2017## Accessible filesystems, by reference, are maintained under &apos;/dev/disk&apos;# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info#fhfh/dev/mapper/centos-root /                       xfs     defaults        0 0/dev/mapper/centos-swap swap                    swap    defaults        0 0</code></pre><p><strong>显示模式空间中内容,仅打印模式空间中被匹配</strong></p><pre><code>[root@docker ~]# sed -n &apos;/^UUID/p&apos; /etc/fstabUUID=377d33fc-dff8-4bb1-9620-20ae6638453d /boot    xfs     defaults        0 0</code></pre><p><strong>a \text 在行后面追加文本: 支持使用\n实现多行追加</strong></p><pre><code>[root@docker ~]# sed &apos;/^UUID/a \hello boy\nwelcome to chenfanlinux.org&apos; /etc/fstab# /etc/fstab# Created by anaconda on Fri Nov 17 00:04:38 2017## Accessible filesystems, by reference, are maintained under &apos;/dev/disk&apos;# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info/dev/mapper/centos-root /                       xfs     defaults        0 0UUID=377d33fc-dff8-4bb1-9620-20ae6638453d /boot                   xfs     defaults        0 0hello boywelcome to chenfanlinux.org/dev/mapper/centos-swap swap                    swap    defaults        0 0</code></pre><p><strong>i \text 在符合条件的行前面追加文本</strong></p><pre><code>[root@docker ~]#  sed &apos;/^UUID/i \hello world\nwelcome&apos; /etc/fstab# /etc/fstab# Created by anaconda on Fri Nov 17 00:04:38 2017## Accessible filesystems, by reference, are maintained under &apos;/dev/disk&apos;# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info/dev/mapper/centos-root /                       xfs     defaults        0 0hello worldwelcomeUUID=377d33fc-dff8-4bb1-9620-20ae6638453d /boot                   xfs     defaults        0 0/dev/mapper/centos-swap swap                    swap    defaults        0 0</code></pre><p><strong>c \text 替换符合添加的行</strong></p><pre><code>[root@docker ~]#  sed &apos;/^UUID/c \hello world\nwelcome&apos; /etc/fstab## /etc/fstab# Created by anaconda on Fri Nov 17 00:04:38 2017## Accessible filesystems, by reference, are maintained under &apos;/dev/disk&apos;# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info/dev/mapper/centos-root /                       xfs     defaults        0 0hello worldwelcome/dev/mapper/centos-swap swap                    swap    defaults        0 0</code></pre><p><strong>s///: 支持使用其他分隔符,如$@@@、$###</strong></p><p>格式： <code>[address]s/pattern/replacement/flag</code></p><p><strong>flag:</strong></p><ul><li>g: 全局替换</li><li>p: 显示替换成功的行</li><li>w /path/to/somefile: 将替换成功的结果保存至指定文件中</li></ul><p><strong><em>替换匹配r..t的字符，并在其后加er</em></strong></p><pre><code>[root@docker ~]# sed -n &apos;s/\(r..t\)#\1er/p&apos; /etc/passwdrooter:x:0:0:root:/root:/bin/bashoperator:x:11:0:operator:/rooter:/sbin/nologinftp:x:14:50:FTP User:/var/fterp:/sbin/nologin</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Sed&quot;&gt;&lt;a href=&quot;#Sed&quot; class=&quot;headerlink&quot; title=&quot;Sed&quot;&gt;&lt;/a&gt;Sed&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;全称Stream Editor,Sed从本质上来讲其实是一种非交互式的编辑器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;sed的处理流程&quot;&gt;&lt;a href=&quot;#sed的处理流程&quot; class=&quot;headerlink&quot; title=&quot;sed的处理流程&quot;&gt;&lt;/a&gt;sed的处理流程&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;sed中script执行是有先后顺序的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;读入一行内行到缓存空间(模式空间)&lt;/li&gt;
&lt;li&gt;从script中取出一条命令, 判断是否匹配pattern(一般为正则表达式)&lt;/li&gt;
&lt;li&gt;如果不匹配, 则忽略后续命令, 回到第二步取下一条命令&lt;/li&gt;
&lt;li&gt;如果匹配, 则对缓存的行执行后续的编辑命令; 完成后, 回到第二步继续取下一条命令&lt;/li&gt;
&lt;li&gt;当所有命令应用后, 输出缓存行的内容, 回到第一步读取下一行&lt;/li&gt;
&lt;li&gt;当所有行处理完则执行结束&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;命令格式&quot;&gt;&lt;a href=&quot;#命令格式&quot; class=&quot;headerlink&quot; title=&quot;命令格式&quot;&gt;&lt;/a&gt;命令格式&lt;/h3&gt;&lt;p&gt;&lt;code&gt;sed [options] &amp;#39;script&amp;#39; inputfile&lt;/code&gt;&lt;br&gt;对于script的语法有两种约定，分别是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[address]command              指可以为任意地址包括地址对&lt;/li&gt;
&lt;li&gt;[line-address]command         只能为单个地址&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;常用选项&quot;&gt;&lt;a href=&quot;#常用选项&quot; class=&quot;headerlink&quot; title=&quot;常用选项&quot;&gt;&lt;/a&gt;常用选项&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;-n: 不输出模式空间中的内容至屏幕
-e: 多点编辑
-r: 支持使用扩展的正则表达式
-i: 修改原文件
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;地址定界&quot;&gt;&lt;a href=&quot;#地址定界&quot; class=&quot;headerlink&quot; title=&quot;地址定界&quot;&gt;&lt;/a&gt;地址定界&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;no-address:对全文进行处理&lt;/li&gt;
&lt;li&gt;&lt;p&gt;line-address 单地址&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;n1  指定的行,数字表示&lt;/li&gt;
&lt;li&gt;/pattern/ 被此处模式所能匹配到的每一行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;address 地址对&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;n1,n2&lt;/li&gt;
&lt;li&gt;n1,+n2&lt;/li&gt;
&lt;li&gt;/pattern1/,/pattern2/&lt;/li&gt;
&lt;li&gt;n1,/pattern1/&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="linux基础" scheme="http://www.chenfanlinux.org/categories/linux%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Sed" scheme="http://www.chenfanlinux.org/tags/Sed/"/>
    
  </entry>
  
  <entry>
    <title>Shell通配符与正则表达式</title>
    <link href="http://www.chenfanlinux.org/2018/01/21/Shell%E9%80%9A%E9%85%8D%E7%AC%A6%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://www.chenfanlinux.org/2018/01/21/Shell通配符与正则表达式/</id>
    <published>2018-01-21T09:26:51.000Z</published>
    <updated>2018-01-26T03:39:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通配符是系统level,而正则表达式需要相关工具的支持:grep,awk,vi,perl。在文本过滤工具里,都是用正则表达式，比如像awk,sed等，是针对文件的内容的。通配符多用在文件名上,比如查找find,ls,cp,等等。</p></blockquote><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><blockquote><p>通配符的作用是用于模糊查询时通配文件名中某些不确定的字符, 通配符只有三个元字符 ？ * []</p></blockquote><h3 id="Bash中的通配符"><a href="#Bash中的通配符" class="headerlink" title="Bash中的通配符"></a>Bash中的通配符</h3><table><thead><tr><th style="text-align:center">通配符</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">?</td><td style="text-align:center">匹配任意单个字符，不包括路径标识”/“</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">匹配任意长度的字符，包括空字符,不包括路径标识”/“</td></tr><tr><td style="text-align:center">**</td><td style="text-align:center">匹配任意级别目录(bash 4.0以上版本支持,不包括路径标识”/“</td></tr><tr><td style="text-align:center">[]</td><td style="text-align:center">匹配一个单字符范围,如[a-z],[0-9],不包括路径标识”/“</td></tr></tbody></table><h3 id="的特殊用例"><a href="#的特殊用例" class="headerlink" title="[ ]的特殊用例"></a>[ ]的特殊用例</h3><ul><li>[]：匹配范围</li><li>[^]：排除匹配范围</li><li>[:alnum:]：所有字母和数字</li><li>[:alpha:]：所有字母</li><li>[:digit:]：所有数字</li><li>[:lower:]：所有小写字母</li><li>[:upper:]：所有大写字母</li><li>[:blank:]：空白字符和TAB制表符</li><li>[:space:]：包括空白字符、TAB制表符(\t)、换页(\f)</li><li>[:cntrl:]：所有控制字符</li><li>[:graph:]：可打印并可看到的字符。空格是可打印的，但是不是可看到的</li><li>[:print:]：所有可打印字符</li><li>[:punct:]：所有标点符号，非字母、数字、控制字符和space字符</li><li>[:xdigit:]：十六进制数的字符</li></ul><p><strong><em>注意：引用时，需要在加一层括号，如[[:alnum:]]</em></strong></p><h3 id="通配符范例"><a href="#通配符范例" class="headerlink" title="通配符范例"></a>通配符范例</h3><ul><li>*.txt               匹配全部后缀为.txt的文件</li><li>file?.log           匹配file1.log, file2.log, …</li><li>[a-z]*.log          匹配a-Z开头的.log文件,这里不区分字母大小写</li><li>[^a-z]*.log         上面的反向匹配</li><li>/etc/<em>*/</em>.conf      匹配/etc目录下第一层子目录下的所有.conf结尾的文件</li></ul><p><strong><em>注意: 反斜杠\或单双引号[‘ “]都会使通配符失效；如:  “\</em>“, ‘*‘都表示*本身，不通配任何文件。</strong></p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><blockquote><p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。</p></blockquote><p>在正则表达式出现后的一段时间里，诸子百家争鸣，乱世显现。这一年诞生了第一个较为统一的标准 —— POSIX，POSIX将正则表达式分为了两种标准Basic Regular Expressions(BREs)和 Extended Regular Expressions(EREs)</p><a id="more"></a><h3 id="BRE正则引擎"><a href="#BRE正则引擎" class="headerlink" title="BRE正则引擎"></a>BRE正则引擎</h3><p><strong>特性</strong></p><ul><li><p>基本正则表达式(Basic Regular Expressions)是速度最快的正则引擎标准。</p></li><li><p>Linux中使用BRE引擎的程序主要有grep和sed,由于sed注重速度，所以只实现了BRE的子集。意味着BRE的特性sed并不能全部支持。</p></li><li><p>正则表达式有元字符和非元字符组成，意味着写正则的时候只需要注意元字符的含义就行了。 非元字符代表直接匹配字符本身。</p></li></ul><p><strong>BRE正则的元字符</strong><br>BRE的元字符很少，只有. [] ^ $ * \ () {}这几种，甚至不支持|这种选择模式。</p><table><thead><tr><th style="text-align:center">元字符</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">.</td><td style="text-align:center">匹配任意单字符，如a, b, 1等等，不包括空白字符</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">不匹配任何字符，代表锚定行首,如^abc代表以abc开头的模式中</td></tr><tr><td style="text-align:center">$</td><td style="text-align:center">不匹配任何字符，代表锚定行尾,如abc$代表以abc结尾的模式</td></tr><tr><td style="text-align:center">[]</td><td style="text-align:center">代表匹配括号内任意一个单字符,如[abc]代表匹配a或b或c任意一个</td></tr><tr><td style="text-align:center">[^]</td><td style="text-align:center">[^pattern]    代表取反匹配,不匹配pattern的模式,如abc代表除abc之外的其他单字符</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">代表匹配前面一个单字符任意次(包括0次) ,如a*b代表匹配b,ab,aab…</td></tr><tr><td style="text-align:center">\</td><td style="text-align:center">转义字符，\会匹配\这个字符</td></tr><tr><td style="text-align:center">()</td><td style="text-align:center">后项引用，后续将详细介绍</td></tr><tr><td style="text-align:center">{}</td><td style="text-align:center">重复前面字符的次数,后续将详细介绍</td></tr></tbody></table><p><strong>注意点</strong></p><ul><li><p>正则都是区分大小写的，，意味着[a-z]不能匹配到ABCD。有些程序的命令或参数支持忽略大小写匹配, 如grep -i。但要注意，对于正则表达式本身是大小写敏感的。</p></li><li><p>^和$出现在模式中间的时候，无特殊含义，如a^b匹配的就是a^b这个字符串。 类似的，只有右半个括号时 ) ] } 也无特殊含义，无需转义, 如 <code>[]abc]</code></p></li><li><p>[]里面的pattern可以配合-简写, 如 <code>[a-zA-Z], [0-9]</code></p></li></ul><p><strong><em>此外，POSIX class也可以在正则表达式中运用，以下是对照表:</em></strong></p><p><img src="https://s1.ax1x.com/2018/01/21/pWMHH0.png" alt="POSIX class"></p><p><strong>\ 的妙用</strong><br>\ 的作用是转义字符，对元字符使用会失去元字符的作用，但对于某些非元字符使用会带来意想不到的妙用。 这里讲解一些边界的匹配问题，后面还会看到更多关于\的奇妙的用法。</p><ul><li><p>如果要匹配单词的起始(左边界)，可以用\&lt;匹配。例如:\&lt;book可以匹配book, bookooooo,但是不能匹配abook。</p></li><li><p>类似的，如果要匹配单词的结尾(右边界),可以用>匹配。例如: do>不能匹配到doing, 但能匹配到todo</p></li><li><p>左右边界的匹配合起来可以使用\b。例如\bset\b匹配的就是set这个单词，等同于\<set\>。</set\></p></li></ul><h3 id="ERE正则引擎"><a href="#ERE正则引擎" class="headerlink" title="ERE正则引擎"></a>ERE正则引擎</h3><blockquote><p>扩展正则表达式(Extended Regular Expression)在BRE的基础上，进行了功能上的扩充，增加了元字符。在Linux中，常见的使用ERE正则的程序有grep -E,egrep，sed -r,awk等。</p></blockquote><p><strong>扩展正则表达式的元字符</strong></p><p>ERE和BRE的元字符完全相同，在此之上，新增了元字符。<br>(),{}在BRE正则中需要配合\使用(),{}),在ERE中不再需要转义字符。 增加了 <strong><em>+ ?  |</em></strong> 这三个元字符。</p><p><img src="https://s1.ax1x.com/2018/01/21/pWjX24.png" alt="扩展的正则表达式"></p><p><strong>*和+的原罪 —— 贪婪匹配</strong></p><p>*和+在正则引擎中，会尽可能多的匹配满足条件的pattern，此外，还有{},? 也满足这个规律。这种规律称为贪婪匹配(greedy matching)。</p><h2 id="grep命令深度实践"><a href="#grep命令深度实践" class="headerlink" title="grep命令深度实践"></a>grep命令深度实践</h2><blockquote><p>grep: Global search REgular expression and Print out the line</p></blockquote><h3 id="使用语法及功能介绍"><a href="#使用语法及功能介绍" class="headerlink" title="使用语法及功能介绍"></a>使用语法及功能介绍</h3><p><strong>特性</strong></p><ul><li>文本搜索工具,根据用户指定的”模式”对目标文本逐行进行匹配检查,然后 打印匹配的行</li><li>模式: 由正则表达式字符及文本字符所编写的过滤条件</li></ul><p><strong>命令语法格式</strong></p><p><code>grep [OPTIONS] PATTERN [FILE...]</code></p><p><strong>常用选项</strong></p><pre><code>-E :使用扩展正则表达式-i :忽略大小写 -o :仅显示匹配到的字符串本身 -A n:after,显示匹配到的行及后n行 -B n:before,前n行-C n:context,前后各n行</code></pre><p><strong>基础正则按功能分类</strong></p><ul><li><p>字符匹配</p><ul><li>.  匹配任意单个字符</li><li>[]  匹配指定范围内的任意单个字符</li><li>[^]  匹配字符外的任意单个字符</li></ul></li><li><p>匹配次数:用在指定次数的字符后面,用于指定前面字符出现的次数</p><ul><li>*  匹配前面的字符任意次(包含0次)</li><li>.*  任意长度的任意字符,包含没有</li><li>\?  匹配前面的字符0次或1次,即前面字符可有可无</li><li>+  匹配前面字符至少一次</li><li>{m}  匹配前面的字符m次</li><li>{m,n}  匹配前面的字符至少m次,至多n次</li></ul></li><li><p>位置锚定</p><ul><li>^           行首锚定: 用于模式最左侧</li><li>$          行尾锚定: 用于模式的最右侧</li><li>^PATTERN$ 用模式匹配整行</li><li>^$ 空行</li><li>\&lt; 或 \b  词首锚定: 用于单词模式的左侧</li><li>> 或 \b  词尾锚定: 用于单词的右边</li><li>>PATTERN> 匹配整个单词</li></ul></li><li><p>分组:将一个或多个字符捆绑在一起,当作一个整体处理</p><ul><li>\(xy\)*  匹配xy任意次</li><li>后向引用: 引用前面的分组括号中的模式所匹配到的字符</li><li>分组括号中的模式匹配到的内容会被正则表达式引擎记录到内部变量中,这些变量的命名为 <strong><em>\1 \2 \3</em></strong></li></ul></li></ul><h3 id="命令实战"><a href="#命令实战" class="headerlink" title="命令实战"></a>命令实战</h3><p><strong>匹配passwd文件中以root开头的所有行</strong></p><pre><code>[root@docker ~]# grep &apos;^root&apos; /etc/passwdroot:x:0:0:root:/root:/bin/bash</code></pre><p><strong>匹配passwd文件中/bin/bash结尾的所有行</strong></p><pre><code>[root@docker ~]# grep &apos;/bin/bash$&apos; /etc/passwdroot:x:0:0:root:/root:/bin/bashchenfan:x:1000:1000::/home/chenfan:/bin/bash</code></pre><p><strong>匹配fatab文件中，以#开头，然后有至少一个空格的行</strong></p><pre><code>[root@docker ~]# grep -E &apos;#[[:space:]]+&apos; /etc/fstab# /etc/fstab# Created by anaconda on Fri Nov 17 00:04:38 2017# Accessible filesystems, by reference, are maintained under &apos;/dev/disk&apos;# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info</code></pre><p><strong>匹配system或System</strong></p><pre><code>[root@docker ~]# grep &apos;[sS]ystem&apos; /etc/passwdsystemd-network:x:192:192:systemd Network Management:/:/sbin/nologindbus:x:81:81:System message bus:/:/sbin/nologin</code></pre><p><strong>匹配至少两次</strong></p><pre><code>[root@docker ~]# grep &apos;o\{2,\}&apos; /etc/passwdroot:x:0:0:root:/root:/bin/bashlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinmail:x:8:12:mail:/var/spool/mail:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologinpostfix:x:89:89::/var/spool/postfix:/sbin/nologin</code></pre><p><strong>匹配root或mail的行</strong></p><pre><code>[root@docker ~]# egrep &apos;/root|mail&apos; /etc/passwdroot:x:0:0:root:/root:/bin/bashmail:x:8:12:mail:/var/spool/mail:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologin</code></pre><p><strong>分组过滤匹配</strong></p><pre><code>[root@docker ~]# grep -E &apos;(no|No)body&apos; /etc/passwdnobody:x:99:99:Nobody:/:/sbin/nologin</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通配符是系统level,而正则表达式需要相关工具的支持:grep,awk,vi,perl。在文本过滤工具里,都是用正则表达式，比如像awk,sed等，是针对文件的内容的。通配符多用在文件名上,比如查找find,ls,cp,等等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;通配符&quot;&gt;&lt;a href=&quot;#通配符&quot; class=&quot;headerlink&quot; title=&quot;通配符&quot;&gt;&lt;/a&gt;通配符&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;通配符的作用是用于模糊查询时通配文件名中某些不确定的字符, 通配符只有三个元字符 ？ * []&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Bash中的通配符&quot;&gt;&lt;a href=&quot;#Bash中的通配符&quot; class=&quot;headerlink&quot; title=&quot;Bash中的通配符&quot;&gt;&lt;/a&gt;Bash中的通配符&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;通配符&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;?&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;匹配任意单个字符，不包括路径标识”/“&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;*&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;匹配任意长度的字符，包括空字符,不包括路径标识”/“&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;**&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;匹配任意级别目录(bash 4.0以上版本支持,不包括路径标识”/“&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;[]&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;匹配一个单字符范围,如[a-z],[0-9],不包括路径标识”/“&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;的特殊用例&quot;&gt;&lt;a href=&quot;#的特殊用例&quot; class=&quot;headerlink&quot; title=&quot;[ ]的特殊用例&quot;&gt;&lt;/a&gt;[ ]的特殊用例&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;[]：匹配范围&lt;/li&gt;
&lt;li&gt;[^]：排除匹配范围&lt;/li&gt;
&lt;li&gt;[:alnum:]：所有字母和数字&lt;/li&gt;
&lt;li&gt;[:alpha:]：所有字母&lt;/li&gt;
&lt;li&gt;[:digit:]：所有数字&lt;/li&gt;
&lt;li&gt;[:lower:]：所有小写字母&lt;/li&gt;
&lt;li&gt;[:upper:]：所有大写字母&lt;/li&gt;
&lt;li&gt;[:blank:]：空白字符和TAB制表符&lt;/li&gt;
&lt;li&gt;[:space:]：包括空白字符、TAB制表符(\t)、换页(\f)&lt;/li&gt;
&lt;li&gt;[:cntrl:]：所有控制字符&lt;/li&gt;
&lt;li&gt;[:graph:]：可打印并可看到的字符。空格是可打印的，但是不是可看到的&lt;/li&gt;
&lt;li&gt;[:print:]：所有可打印字符&lt;/li&gt;
&lt;li&gt;[:punct:]：所有标点符号，非字母、数字、控制字符和space字符&lt;/li&gt;
&lt;li&gt;[:xdigit:]：十六进制数的字符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意：引用时，需要在加一层括号，如[[:alnum:]]&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;通配符范例&quot;&gt;&lt;a href=&quot;#通配符范例&quot; class=&quot;headerlink&quot; title=&quot;通配符范例&quot;&gt;&lt;/a&gt;通配符范例&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;*.txt               匹配全部后缀为.txt的文件&lt;/li&gt;
&lt;li&gt;file?.log           匹配file1.log, file2.log, …&lt;/li&gt;
&lt;li&gt;[a-z]*.log          匹配a-Z开头的.log文件,这里不区分字母大小写&lt;/li&gt;
&lt;li&gt;[^a-z]*.log         上面的反向匹配&lt;/li&gt;
&lt;li&gt;/etc/&lt;em&gt;*/&lt;/em&gt;.conf      匹配/etc目录下第一层子目录下的所有.conf结尾的文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意: 反斜杠\或单双引号[‘ “]都会使通配符失效；如:  “\&lt;/em&gt;“, ‘*‘都表示*本身，不通配任何文件。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在正则表达式出现后的一段时间里，诸子百家争鸣，乱世显现。这一年诞生了第一个较为统一的标准 —— POSIX，POSIX将正则表达式分为了两种标准Basic Regular Expressions(BREs)和 Extended Regular Expressions(EREs)&lt;/p&gt;
    
    </summary>
    
      <category term="linux基础" scheme="http://www.chenfanlinux.org/categories/linux%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="正则表达式" scheme="http://www.chenfanlinux.org/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Bash编程入门之条件测试(三)</title>
    <link href="http://www.chenfanlinux.org/2018/01/18/Bash%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E4%B9%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95-%E4%B8%89/"/>
    <id>http://www.chenfanlinux.org/2018/01/18/Bash编程入门之条件测试-三/</id>
    <published>2018-01-18T02:23:09.000Z</published>
    <updated>2018-01-25T03:09:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="条件测试语法"><a href="#条件测试语法" class="headerlink" title="条件测试语法"></a>条件测试语法</h2><blockquote><p>在bash的各种流程控制结构中通常要进行各种测试，然后根据测试结果执行不同的操作，有时也会通过与if等条件语句相结合，让我们可以方便的完成判断。</p></blockquote><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>支持三种格式的条件测试语法</p><ul><li>test&lt;测试表达式&gt;</li><li>[ &lt;测试表达式&gt; ]</li><li>[[ &lt;测试表达式&gt; ]]</li></ul><p><strong>格式1和格式2是等价的，格式3为扩展的test命令</strong></p><p>在[[]]中可以使用通配符进行匹配。&amp;&amp;、||、&gt;、&lt;等操作符可以应用与[[]]中，但不能应用与[]中。</p><h3 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h3><p><strong>文件存在则输出1，文件不存在则输出0</strong></p><pre><code>[root@chenfanlinux ~]#  [ -f /etc/passwd ] &amp;&amp; echo 1||echo 01[root@chenfanlinux ~]# test -f /etc/passwd &amp;&amp; echo 1||echo 01[root@chenfanlinux ~]#  [[ -f /etc/passwd ]] &amp;&amp; echo 1||echo 01[root@chenfanlinux ~]#  [[ -f /etc/passd ]] &amp;&amp; echo 1||echo 00</code></pre><a id="more"></a><p><strong>非!的写法</strong><br>test.txt文件如果不存在，则创建。</p><pre><code>[root@chenfanlinux ~]# test ! -f test1.txt &amp;&amp; touch test.txt || ehco &quot;test1.txt已经存在&quot;[root@chenfanlinux ~]# test ! -f test1.txt &amp;&amp; touch test1.txt || echo &quot;test1.txt已经存在&quot;test1.txt已经存在[root@chenfanlinux ~]# [ ! -f test.txt ] &amp;&amp; touch test.txt || echo &apos;test.txt已经存在&apos;[root@chenfanlinux~]# [ ! -f test.txt ] &amp;&amp; touch test.txt || echo &apos;test.txt已经存在&apos;test.txt已经存在</code></pre><h2 id="test-或-测试语法"><a href="#test-或-测试语法" class="headerlink" title="test 或 [] 测试语法"></a>test 或 [] 测试语法</h2><p>从功能上来看 <code>test 测试表达式</code> 命令等同于 <code>[测试表达式]</code> ，因此这里将它们归纳在一起进行总结。</p><h3 id="数值测试"><a href="#数值测试" class="headerlink" title="数值测试"></a>数值测试</h3><p><strong>参数说明</strong></p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">-eq</td><td style="text-align:center">等于则为真</td></tr><tr><td style="text-align:center">-ne</td><td style="text-align:center">不等于则为真</td></tr><tr><td style="text-align:center">-gt</td><td style="text-align:center">大于则为真</td></tr><tr><td style="text-align:center">-ge</td><td style="text-align:center">大于等于则为真</td></tr><tr><td style="text-align:center">-lt</td><td style="text-align:center">小于则为真</td></tr><tr><td style="text-align:center">-le</td><td style="text-align:center">小于则为真</td></tr></tbody></table><p><strong>范例</strong></p><p><strong><em>判断两个数是否相等</em></strong></p><pre><code>[root@chenfanlinux ~]# num1=1[root@chenfanlinux ~]#chenfanlinux num2=2[root@chenfanlinux ~]# [ $num1 -eq $num2 ] &amp;&amp; echo &quot;两个数相等&quot; || echo &quot;两个数不相等&quot;两个数不相等</code></pre><p><strong><em>数值运算</em></strong></p><pre><code>[root@chenfanlinux ~]# a=5[root@chenfanlinux ~]# b=6[root@chenfanlinux ~]# c=$[a+b][root@chenfanlinux ~]# echo $c11[root@chenfanlinux ~]# ((c=a+b))[root@chenfanlinux ~]# echo $c11[root@chenfanlinux ~]# c=`expr $a + $b`[root@chenfanlinux ~]# echo $c11[root@chenfanlinux ~]# let c=a+b[root@chenfanlinux ~]# echo $c11</code></pre><ul><li>(())</li><li>let</li><li>expr</li><li>bc(小数)</li><li>$[]</li></ul><h3 id="字符串测试"><a href="#字符串测试" class="headerlink" title="字符串测试"></a>字符串测试</h3><p><strong>参数说明</strong></p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">“串1” = “串2”</td><td style="text-align:center">若串1等于串2则真，可以使用”==”代替”=”</td></tr><tr><td style="text-align:center">“串1” ！= “串2”</td><td style="text-align:center">若串1不等于串2则真，但不能用”!==” 代替”!=”</td></tr><tr><td style="text-align:center">-z “字符串”</td><td style="text-align:center">若串长度为0则真，-z可以理解为zero</td></tr><tr><td style="text-align:center">-n “字符串”</td><td style="text-align:center">若串长度不为0则真，-n可以理解为no zero</td></tr></tbody></table><p><strong>范例</strong></p><p><strong><em>比较两个字符串是否相同</em></strong></p><pre><code>num1=&quot;chenfan&quot;num2=&quot;chenfanlinux&quot;if [ &quot;$num1&quot; = &quot;$num2&quot; ]then    echo &apos;两个字符串相等!&apos;else    echo &apos;两个字符串不相等!&apos;fi</code></pre><h3 id="文件测试"><a href="#文件测试" class="headerlink" title="文件测试"></a>文件测试</h3><p><strong>参数说明</strong></p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">-e 文件名</td><td style="text-align:center">如果文件存在则为真</td></tr><tr><td style="text-align:center">-r 文件名</td><td style="text-align:center">如果文件存在且可读则为真</td></tr><tr><td style="text-align:center">-w 文件名</td><td style="text-align:center">如果文件存在且可写则为真</td></tr><tr><td style="text-align:center">-x 文件名</td><td style="text-align:center">如果文件存在且可执行则为真</td></tr><tr><td style="text-align:center">-s 文件名</td><td style="text-align:center">如果文件存在且至少有一个字符则为真</td></tr><tr><td style="text-align:center">-d 文件名</td><td style="text-align:center">如果文件存在且为目录则为真</td></tr><tr><td style="text-align:center">-f 文件名</td><td style="text-align:center">如果文件存在且为普通文件则为真</td></tr><tr><td style="text-align:center">-c 文件名</td><td style="text-align:center">如果文件存在且为字符型特殊文件则为真</td></tr><tr><td style="text-align:center">-b 文件名</td><td style="text-align:center">如果文件存在且为块特殊文件则为真</td></tr></tbody></table><blockquote><p>以上表格中的字符串测试操作符号务必要用 “字符串” 引起来。</p></blockquote><p><strong>范例</strong></p><p><strong><em>文件存在则打印存在</em></strong></p><pre><code>cd /binif test -e ./bashthen    echo &apos;文件已存在!&apos;else    echo &apos;文件不存在!&apos;fi</code></pre><h3 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h3><p><strong>参数说明</strong></p><p><img src="https://s1.ax1x.com/2018/01/18/ps8WEF.png" alt="逻辑操作符"> </p><p><strong>范例</strong></p><p><strong><em>判断文件是否同时存在</em></strong></p><pre><code>[root@chenfanlinux ~]# f1=&apos;/etc/rc.local&apos;[root@chenfanlinux ~]# f2=&apos;/etc/pass&apos;[root@chenfanlinux ~]# [ -f &quot;$f1&quot; -o -f &quot;$f2&quot; ] &amp;&amp; echo 1|| echo 01[root@chenfanlinux ~]# [ -f &quot;$f1&quot; -a -f &quot;$f2&quot; ] &amp;&amp; echo 1|| echo 00</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;条件测试语法&quot;&gt;&lt;a href=&quot;#条件测试语法&quot; class=&quot;headerlink&quot; title=&quot;条件测试语法&quot;&gt;&lt;/a&gt;条件测试语法&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在bash的各种流程控制结构中通常要进行各种测试，然后根据测试结果执行不同的操作，有时也会通过与if等条件语句相结合，让我们可以方便的完成判断。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h3&gt;&lt;p&gt;支持三种格式的条件测试语法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;test&amp;lt;测试表达式&amp;gt;&lt;/li&gt;
&lt;li&gt;[ &amp;lt;测试表达式&amp;gt; ]&lt;/li&gt;
&lt;li&gt;[[ &amp;lt;测试表达式&amp;gt; ]]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;格式1和格式2是等价的，格式3为扩展的test命令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在[[]]中可以使用通配符进行匹配。&amp;amp;&amp;amp;、||、&amp;gt;、&amp;lt;等操作符可以应用与[[]]中，但不能应用与[]中。&lt;/p&gt;
&lt;h3 id=&quot;范例&quot;&gt;&lt;a href=&quot;#范例&quot; class=&quot;headerlink&quot; title=&quot;范例&quot;&gt;&lt;/a&gt;范例&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;文件存在则输出1，文件不存在则输出0&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@chenfanlinux ~]#  [ -f /etc/passwd ] &amp;amp;&amp;amp; echo 1||echo 0
1
[root@chenfanlinux ~]# test -f /etc/passwd &amp;amp;&amp;amp; echo 1||echo 0
1
[root@chenfanlinux ~]#  [[ -f /etc/passwd ]] &amp;amp;&amp;amp; echo 1||echo 0
1
[root@chenfanlinux ~]#  [[ -f /etc/passd ]] &amp;amp;&amp;amp; echo 1||echo 0
0
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Bash Shell编程" scheme="http://www.chenfanlinux.org/categories/Bash-Shell%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Bash" scheme="http://www.chenfanlinux.org/tags/Bash/"/>
    
  </entry>
  
  <entry>
    <title>Bash编程入门之变量基础(二)</title>
    <link href="http://www.chenfanlinux.org/2018/01/17/Bash%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E4%B9%8B%E5%8F%98%E9%87%8F%E5%9F%BA%E7%A1%80-%E4%B8%80/"/>
    <id>http://www.chenfanlinux.org/2018/01/17/Bash编程入门之变量基础-一/</id>
    <published>2018-01-17T07:39:19.000Z</published>
    <updated>2018-01-26T03:39:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量基础"><a href="#变量基础" class="headerlink" title="变量基础"></a>变量基础</h2><h3 id="什么是变量？"><a href="#什么是变量？" class="headerlink" title="什么是变量？"></a>什么是变量？</h3><blockquote><p>变量的实质是命名的内存空间，变量是一个用固定的字符串（也可能是字符数字等的组合），替代更多更复杂的内容，这个内容里可能还会包含变量和路径，字符串等其他的内容。对于代码一块某个值得改变，只需要改变变量值得内容，不需要全局修改。</p></blockquote><p><strong>变量的类型</strong><br>根据变量的生效范围等标准:</p><ul><li>本地变量：生效范围为当前的shell进程,对当前shell之外的其他进程,包括当前进程的父子shell都无效</li><li>环境变量: 生效范围为当前进程及其子进程</li><li>局部变量: 生效范围为当前进程的某代码片段(通常指函数上下文)</li><li>特殊变量: 包括位置变量和进程状态变量</li></ul><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><blockquote><p>环境变量用于定义shell的运行环境，保证Shell命令的正确执行，通过环境变量来确定登陆用户名、命令路径、终端类型、登陆目录等，所有的环境变量都是系统全局变量，可用于所有子进程中，这包括编辑器、Shell脚本和各类应用。</p></blockquote><p>环境变量可以在命令行中设置，当用户退出时这些变量值也会丢失，因此最好在用户家目录下的.bash_profile文件中或全局配置/etc/bashrc,/etc/profile文件或者/etc/profile.d/中定义。将环境变量放入上述的文件中，每次用户登陆时这些变量值都将被初始化。</p><p>可以通过一下的命令查看环境变量</p><ul><li>env（只显示全局变量）</li><li>set（所有的变量）</li><li>declare（所有变量，包括函数、整数和已导出的）</li></ul><p><strong>定义环境变量</strong></p><pre><code>[root@dokcer ~]# export NAME=chenfanlinux[root@dokcer ~]# declare -x NAME=chenfan</code></pre><p><strong>显示与取消环境变量</strong></p><pre><code>[root@dokcer ~]# echo $NAME chenfan[root@dokcer ~]# $ unset NAME</code></pre><a id="more"></a><h3 id="本地变量"><a href="#本地变量" class="headerlink" title="本地变量"></a>本地变量</h3><p>本地变量在用户当前的Shell生存期内脚本或命令行使用。这个值只在用户当前Shell生存期中有意义，如果在shell中启动另一个进程或退出，本地变量的值无效。</p><p><strong>变量的命名规范</strong></p><ul><li>变量名只能为字母，数字，下划线，字母开头。</li><li>规范的变量名定义方法：见名只意</li><li>避免无意义字符或数字：例如下面的COUNT，并不知道其确切含义；</li></ul><p><strong>变量赋值</strong></p><ol><li>可以是直接字符串: name=”username” 或 name=’username’</li><li>变量引用: name=”$username” 或 ${username}</li><li>命令引用: name= `COMMAND` 或 name=$(COMMAND)</li></ol><p><strong>变量引用</strong><br>${name}或$name</p><ul><li>“$name” : 弱引用,其中变量引用会被替换为变量值，</li><li>‘$name’ : 强引用,其中变量引用不会被替换为变量值,而保持原字符串</li></ul><p>最好以${NAME}加大括号或”$NAME”外面加双引号方式引用变量</p><p><strong>区分单引号和双引号</strong></p><pre><code>[root@yiwutest ~]# echo &apos;Today is `date`&apos;Today is `date`[root@yiwutest ~]# echo &quot;Today is `date`&quot;Today is Wed Jan 17 14:49:51 CST 2018</code></pre><ul><li>单引号    单引号内的所有内容都原样输出，或者描述为单引号里面看到的是什么就会输出什么。</li><li>双引号    把双引号内的所有内容都输出出来，如果内容中有命令（要反引下）、变量、特殊转移符等，会先把变量、命令、转义符解析出来，然后在输出最终内容来。</li><li>无引号    把内容输出出来，会将含有空格的字符串视为一个整体输出出来。</li></ul><p><strong>区分 $name 和 ${name}</strong><br>{变量}可以界定变量名的范围，用于变量之间的组合使用或变量与字符串的组合。</p><pre><code>[root@docker ~]# name=&apos;chenfan&apos;[root@docker ~]# echo &quot;$name_123&quot;[root@docker ~]# echo &quot;${name}_123&quot;chenfan_123[root@docker ~]# test1=&apos;chenfan&apos;[root@docker ~]# test2=&apos;fan&apos;[root@yiwutest ~]# echo &quot;${test1}_$test2&quot;chenfan_fan[root@yiwutest ~]# echo &quot;$test1_${test2}&quot;fan</code></pre><h3 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h3><p><strong>位置变量</strong></p><ul><li><p>$0    获取当前执行的shell脚本文件名，包括脚本路径</p></li><li><p>$n    获取当前执行的shell脚本的第n个参数值，n=1..9，当n为0时表示脚本的文件名，如果n大于9就要用大括号括起来${10}</p></li><li><p>$*    获取当前的shell的所有参数，将所有的命令行参数视为单个字符串，相当于“$1$2$3$4$5”..注意与$#的区别</p></li><li><p>$#    获取当前shell命令行中参数的总个数</p></li><li><p>$@    这额程序的所有参数$1 $2 $3 …，这是将参数传递给其他程序的最佳方式，因为他会保留内嵌在每个参数里的任意空白</p></li></ul><p><strong>进程状态变量</strong></p><ul><li>$$  获取当前shell脚本的进程号（PID）</li><li>$!  执行上一个指令的PID</li><li>$?  获取执行上一个指令的返回值（0为成功，非0为失败）</li><li>$_  在此之前执行的命令或脚本的最后一个参数</li></ul><h3 id="数值计算的命令"><a href="#数值计算的命令" class="headerlink" title="数值计算的命令"></a>数值计算的命令</h3><p>变量的数值计算常见的有如下几个命令：</p><ul><li>(())</li><li>let(推荐使用)</li><li>expr</li><li>bc(小数)$[]</li></ul><p>shell的算术运算符号常置于 $((“…….”)) 的语法中，如果要执行简单的整数运算，只需将特定的算术表达式用” $((表达式))”括起来即可;使用let命令,它用于执行一个或多个表达式,变量计算中不需要使用$来引用变量。</p><h3 id="字符串变量截取"><a href="#字符串变量截取" class="headerlink" title="字符串变量截取"></a>字符串变量截取</h3><p>变量web=”<a href="http://www.chenfanlinux.org/index.html&quot;，接下来介绍几种不同的变量截取方法。">http://www.chenfanlinux.org/index.html&quot;，接下来介绍几种不同的变量截取方法。</a></p><p>（1）#*fs 删除第一个匹配到的分隔符及其左侧的内容,这里的以fs是”/“为例 </p><pre><code>[root@chenfanlinux ~]# echo $webhttp://www.chenfanlinux.org/index.html[root@chenfanlinux ~]# echo ${web#*/}/www.chenfanlinux.org/index.html</code></pre><p> (2)##*fs 删除最后一个匹配到的分隔符及其左侧的内容</p><pre><code>[root@chenfanlinux ~]# echo ${web##*/}index.html</code></pre><p> (3)%fs* 删除最后匹配到的分隔符及其右侧的内容  </p><pre><code>[root@chenfanlinux ~]# echo ${web%/*}http://www.chenfanlinux.org</code></pre><p> (4) %%fs* 删除第一个匹配到的分隔符及其右侧的内容  </p><pre><code>[root@chenfanlinux ~]# echo ${web%%/*}http:</code></pre><p> (5) 删除从左边第几个字符开始，及字符的个数</p><pre><code>[root@inmalltest ~]# echo ${web:0,3}p://www.chenfanlinux.org/index.html0 表示左边第一个字符开始，3表示删除字符的总个数</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;变量基础&quot;&gt;&lt;a href=&quot;#变量基础&quot; class=&quot;headerlink&quot; title=&quot;变量基础&quot;&gt;&lt;/a&gt;变量基础&lt;/h2&gt;&lt;h3 id=&quot;什么是变量？&quot;&gt;&lt;a href=&quot;#什么是变量？&quot; class=&quot;headerlink&quot; title=&quot;什么是变量？&quot;&gt;&lt;/a&gt;什么是变量？&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;变量的实质是命名的内存空间，变量是一个用固定的字符串（也可能是字符数字等的组合），替代更多更复杂的内容，这个内容里可能还会包含变量和路径，字符串等其他的内容。对于代码一块某个值得改变，只需要改变变量值得内容，不需要全局修改。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;变量的类型&lt;/strong&gt;&lt;br&gt;根据变量的生效范围等标准:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本地变量：生效范围为当前的shell进程,对当前shell之外的其他进程,包括当前进程的父子shell都无效&lt;/li&gt;
&lt;li&gt;环境变量: 生效范围为当前进程及其子进程&lt;/li&gt;
&lt;li&gt;局部变量: 生效范围为当前进程的某代码片段(通常指函数上下文)&lt;/li&gt;
&lt;li&gt;特殊变量: 包括位置变量和进程状态变量&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;环境变量&quot;&gt;&lt;a href=&quot;#环境变量&quot; class=&quot;headerlink&quot; title=&quot;环境变量&quot;&gt;&lt;/a&gt;环境变量&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;环境变量用于定义shell的运行环境，保证Shell命令的正确执行，通过环境变量来确定登陆用户名、命令路径、终端类型、登陆目录等，所有的环境变量都是系统全局变量，可用于所有子进程中，这包括编辑器、Shell脚本和各类应用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;环境变量可以在命令行中设置，当用户退出时这些变量值也会丢失，因此最好在用户家目录下的.bash_profile文件中或全局配置/etc/bashrc,/etc/profile文件或者/etc/profile.d/中定义。将环境变量放入上述的文件中，每次用户登陆时这些变量值都将被初始化。&lt;/p&gt;
&lt;p&gt;可以通过一下的命令查看环境变量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;env（只显示全局变量）&lt;/li&gt;
&lt;li&gt;set（所有的变量）&lt;/li&gt;
&lt;li&gt;declare（所有变量，包括函数、整数和已导出的）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;定义环境变量&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@dokcer ~]# export NAME=chenfanlinux
[root@dokcer ~]# declare -x NAME=chenfan
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;显示与取消环境变量&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@dokcer ~]# echo $NAME
 chenfan
[root@dokcer ~]# $ unset NAME
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Bash Shell编程" scheme="http://www.chenfanlinux.org/categories/Bash-Shell%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Bash" scheme="http://www.chenfanlinux.org/tags/Bash/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门之数据管理(六)</title>
    <link href="http://www.chenfanlinux.org/2018/01/16/Docker%E5%85%A5%E9%97%A8%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/"/>
    <id>http://www.chenfanlinux.org/2018/01/16/Docker入门之数据管理/</id>
    <published>2018-01-16T08:33:51.000Z</published>
    <updated>2018-01-26T03:39:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何存储Docker数据"><a href="#如何存储Docker数据" class="headerlink" title="如何存储Docker数据"></a>如何存储Docker数据</h2><p>Docker 为容器提供了两种存放数据的资源：</p><ul><li>Storage Driver 管理的镜像层和容器层。</li><li>Data Volume</li></ul><p><strong>Storage Driver</strong></p><p>容器由最上面一个可写的容器层，以及若干只读的镜像层组成，容器的数据就存放在这些层中。这样的分层结构最大的特性是 <strong><em>Copy-on-Write</em></strong>：</p><ul><li>新数据会直接存放在最上面的容器层。</li><li>修改现有数据会先从镜像层将数据复制到容器层，修改后的数据直接保存在容器层中，镜像层保持不变。</li><li>如果多个层中有命名相同的文件，用户只能看到最上面那层中的文件。</li></ul><p><img src="https://s1.ax1x.com/2018/01/15/pUMMh4.jpg" alt=""><br>Storage Driver 实现了多层数据的堆叠并为用户提供一个单一的合并之后的统一视图。适合无状态的应用，不需要持久化存储数据。</p><p><strong>Data Volume</strong></p><p>Data Volume 本质上是 Docker Host 文件系统中的目录或文件，能够直接被 mount 到容器的文件系统中。适合于持久化数据的需求的数据存储，容器启动时需要加载已有的数据，容器销毁时希望保留产生的新数据，也就是说，这类容器是有状态的。Data Volume有如下特点:</p><ul><li>Data Volume 是目录或文件，而非没有格式化的磁盘（块设备）。</li><li>容器可以读写 volume 中的数据。</li><li>volume 数据可以被永久的保存，即使使用它的容器已经销毁。</li></ul><h2 id="Data-volume的类型"><a href="#Data-volume的类型" class="headerlink" title="Data volume的类型"></a>Data volume的类型</h2><p>在具体的使用上，docker 提供了两种类型的 volume：bind mount 和 docker managed volume。</p><h3 id="bind-mount"><a href="#bind-mount" class="headerlink" title="bind mount"></a>bind mount</h3><p>bind mount 是将 host 上已存在的目录或文件 mount 到容器。</p><pre><code>[root@chenfanlinux ~]# mkdir /root/htdocs[root@chenfanlinux ~]# echo &quot;Welcome to chenfanlinux.org&quot; &gt;/root/htdocs/index.html[root@chenfanlinux ~]# docker run -d -p 80:80 -v /root/htdocs:/usr/local/apache2/htdocs httpdc7a396731c62e35b0704e16ffa6ea0a4b4d7e3488cd220dca0d41958eff46c30[root@chenfanlinux ~]# docker psCONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS                NAMESc7a396731c62        httpd               &quot;httpd-foreground&quot;   15 seconds ago      Up 14 seconds       0.0.0.0:80-&gt;80/tcp   serene_mccarthy[root@chenfanlinux ~]# curl &apos;http://127.0.0.1:80&apos;Welcome to chenfanlinux.org</code></pre><p>通过 <strong><em>-v &lt;host path&gt;:&lt;container path&gt;</em></strong> 这种格式将host上的/root/htdocs挂载到容器/usr/local/apache2/htdocs目录下。由于/root/htdocs目录下有文件，会隐藏容器/usr/local/apache2/htdocs下的文件内容。</p><p>当我们更新一下/root/htdocs目录下的文件内容时，看看容器里的文件是否发生变化。</p><pre><code>[root@chenfanlinux htdocs]# echo &apos;this is www.chenfanlinux.org&apos;&gt; index.html[root@chenfanlinux htdocs]# lsindex.html[root@chenfanlinux htdocs]# curl &apos;http://127.0.0.1&apos;this is www.chenfanlinux.org</code></pre><p>这里的host 目录的/root/htdocs和容器/usr/local/apache2/htdocs属于共享目录，它们会共享数据。<br>下面我们将容器销毁，看看对 bind mount 有什么影响：</p><pre><code>[root@chenfanlinux htdocs]# docker stop 177051349c19177051349c19[root@chenfanlinux htdocs]# docker rm 177051349c19177051349c19[root@chenfanlinux htdocs]# cat /root/htdocs/index.htmlthis is www.chenfanlinux.org</code></pre><p>可以看到/root/htdocs数据依然存在，bind mount是文件系统中的数据，容器在销毁时，这些数据不会删除。</p><p>bind mount 时还可以指定数据的读写权限，默认是可读可写，可指定为只读，ro 设置了只读权限，在容器中是无法对 bind mount 数据进行修改的。只有 host 有权修改数据，提高了安全性。</p><pre><code>[root@chenfanlinux htdocs]# docker run -d -p 80:80 -v /root/htdocs:/usr/local/apache2/htdocs:ro  httpdd0d2fa8b29b120a8c20d88a20a77b18018bb348d6605218af09ec35f2ec59785[root@chenfanlinux htdocs]# docker exec -it d0d2fa8b29b1 /bin/bashroot@d0d2fa8b29b1:/usr/local/apache2#root@d0d2fa8b29b1:/usr/local/apache2# echo &apos;host path:container path:perm&apos; &gt;htdocbash: htdocs//index.htm: Read-only file system</code></pre><p>mount point 有很多应用场景，比如我们可以将源代码目录 mount 到容器中，在 host 中修改代码就能看到应用的实时效果。再比如将 mysql 容器的数据放在 bind mount 里，这样 host 可以方便地备份和迁移数据。</p><p>bind mount 的使用直观高效，易于理解，但它也有不足的地方：bind mount 需要指定 host 文件系统的特定路径，这就限制了容器的可移植性，当需要将容器迁移到其他 host，而该 host 没有要 mount 的数据或者数据不在相同的路径时，操作会失败。移植性更好的方式是 docker managed volume，下面就会讨论。<br><a id="more"></a></p><h3 id="docker-managed-volume"><a href="#docker-managed-volume" class="headerlink" title="docker managed volume"></a>docker managed volume</h3><p><strong><em>docker managed volume</em></strong> 与 <strong><em>bind mount</em></strong> 在使用上的最大区别是不需要指定 mount 源，指明 mount point 就行了。还是以 httpd 容器为例：</p><pre><code>[root@chenfanlinux ~]# docker run -d -p 80:80 -v /usr/local/apache2/htdocs httpd8dcabf706808e73c2801d1f0cc52bad84c7a9206dc35b3284edfaf5086addc30[root@chenfanlinux ~]# docker psCONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS                NAMES8dcabf706808        httpd               &quot;httpd-foreground&quot;   34 seconds ago      Up 33 seconds       0.0.0.0:80-&gt;80/tcp   kind_mirzakh</code></pre><p>我们通过 -v 告诉 docker 需要一个 data volume，并将其 mount 到 /usr/local/apache2/htdocs。这样不需要指定 host 上面的 data volume，只需要指定容器中的 mount point 即可。那么host上的data volume肯定是由系统自动指定的，通过 <code>docker inspect container id</code> 可以看到host上的 data volume 。</p><pre><code>[root@chenfanlinux ~]# docker inspect e23d25dc38c1.................. &quot;Mounts&quot;: [        {            &quot;Type&quot;: &quot;volume&quot;,            &quot;Name&quot;: &quot;57b81889f9ed419b26ef6c87a7ce8e62372febc85ee573cf162d4d96fecc1986&quot;,            &quot;Source&quot;: &quot;/var/lib/docker/volumes/57b81889f9ed419b26ef6c87a7ce8e62372febc85ee573cf162d4d96fecc1986/_data&quot;,            &quot;Destination&quot;: &quot;/usr/local/apache2/htdocs&quot;,            &quot;Driver&quot;: &quot;local&quot;,            &quot;Mode&quot;: &quot;&quot;,            &quot;RW&quot;: true,            &quot;Propagation&quot;: &quot;&quot;        }    ], .........................</code></pre><p>可以看到<strong>Source</strong>就是 data volume为/var/lib/docker/volumes/57b81889f9ed419b26ef6c87a7ce8e62372febc85ee573cf162d4d96fecc1986/_data，mount point就是 <strong>Destination</strong> 挂载点 /usr/local/apache2/htdoc。这里的data volome是系统指定的。</p><p>进一步研究 源host volome和目标 mount point的关系</p><pre><code>[root@chenfanlinux ~]# cat  /var/lib/docker/volumes/57b81889f9ed419b26ef6c87a7ce8e62372febc85ee573cf162d4d96fecc1986/_data/index.html&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;[root@chenfanlinux ~]# docker psCONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS                NAMES8dcabf706808        httpd               &quot;httpd-foreground&quot;   4 minutes ago       Up 4 minutes        0.0.0.0:80-&gt;80/tcp   kind_mirzakhani[root@chenfanlinux ~]# docker exec -it 8dcabf706808 /bin/bashroot@8dcabf706808:/usr/local/apache2# cat htdocs/index.html&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>可以发现data volume和 mount point下的数据是一致的，这是因为当mount point指向host data volume，会将容器的数据复制到host目录中。</p><p>docker managed volume 的创建过程如下：</p><ul><li>容器启动时，简单的告诉 docker “我需要一个 volume 存放数据，帮我 mount 到目录 /abc”。</li><li>docker 在 /var/lib/docker/volumes 中生成一个随机目录作为 mount 源。</li><li>如果 /abc 已经存在，则将数据复制到 mount 源。</li><li>将 volume mount 到 /abc。</li></ul><p>我们也可以用 <code>docker volume ls</code> 命令看查看系统有哪些data volume， 只能查看 docker managed volume，看不到bind mount。<br>通过 <code>docker volume inspect VOLUME NAME</code> 来查看具体的 volume信息。</p><pre><code>[root@chenfanlinux ~]#  docker volume lsDRIVER              VOLUME NAMElocal               57b81889f9ed419b26ef6c87a7ce8e62372febc85ee573cf162d4d96fecc1986local               73eeefd987d049878abeab0f4b9521e8e041ab8af9ab9cbf417e612690d63d20local               ae070fe09d1f55198364c45b40f2deaa48fdd4005faf986b7450aeb24773c39clocal               ceb6f3f1f987c45afaa80fbc15ddf2d51a85583e7793e3e8be277cc31efa4aa2local               f69f555dcd6816d602df1308ce4b845e8d24948a50bdbdfbba10b9ee5a21e540[root@chenfanlinux ~]# docker volume inspect 57b81889f9ed419b26ef6c87a7ce8e62372febc85ee573cf162d4d96fecc1986[{    &quot;CreatedAt&quot;: &quot;2018-01-12T22:54:09+08:00&quot;,    &quot;Driver&quot;: &quot;local&quot;,    &quot;Labels&quot;: null,    &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/57b81889f9ed419b26ef6c87a7ce8e62372febc85ee573cf162d4d96fecc1986/_data&quot;,    &quot;Name&quot;: &quot;57b81889f9ed419b26ef6c87a7ce8e62372febc85ee573cf162d4d96fecc1986&quot;,    &quot;Options&quot;: {},    &quot;Scope&quot;: &quot;local&quot;}]</code></pre><h3 id="bind-mount-对比-docker-manage-volume"><a href="#bind-mount-对比-docker-manage-volume" class="headerlink" title="bind mount 对比 docker manage volume"></a>bind mount 对比 docker manage volume</h3><p><img src="https://s1.ax1x.com/2018/01/15/pa1Hwq.png" alt=""></p><h2 id="volume如何共享数据？"><a href="#volume如何共享数据？" class="headerlink" title="volume如何共享数据？"></a>volume如何共享数据？</h2><h3 id="容器与host共享数据"><a href="#容器与host共享数据" class="headerlink" title="容器与host共享数据"></a>容器与host共享数据</h3><p>bind mount和docker managed volume都可以实现容器与host之间共享数据，但他们的方式有所区别。<br>bind mount:直接将要共享的目录mount到容器中，会隐藏容器中对应目录的内容，显示 data volume内容。<br>docker managed volume:这种机制是容器启动的时候，将挂载点需要共享的数据复制到host volume中。</p><pre><code>[root@docker ~]# docker run -d -p 80:80 -v /usr/local/apache2/htdocs httpdc7a396731c62e35b0704e16ffa6ea0a4b4d7e3488cd220dca0d41958eff46c30[root@docker ~]# curl &apos;http://127.0.0.1:80&apos;&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;[root@docker ~]# docker cp htdocs/index.html c7a396731c62:/usr/local/apache2/htdocs[root@docker ~]# curl &apos;http://127.0.0.1:80&apos;welcome to chenfanlinux.org</code></pre><p><code>docker cp  host_path container_path</code> 可以在容器和 host 之间拷贝数据，当然我们也可以直接通过 Linux 的 cp 命令复制到 /var/lib/docker/volumes/xxx。</p><h3 id="容器之间共享数据"><a href="#容器之间共享数据" class="headerlink" title="容器之间共享数据"></a>容器之间共享数据</h3><p>将要共享的数据放在bind mount中，然后将其mount到多个容器中，三个web应用共享/root/htdocs目录下的内容。</p><pre><code>[root@docker ~]# docker run -d -p 8081:80 -v /root/htdocs:/usr/local/apache2/htdocs httpd6de2eea95249c6cd534424100b692b4b9df3ad6246e533405ae54a4f5e224e3f[root@docker ~]# docker run -d -p 8082:80 -v /root/htdocs:/usr/local/apache2/htdocs httpdecd5da2b050dddbacc12c0c3c976ef26f173ad7968e4664060bb480fbdabd91d[root@docker ~]# docker run -d -p 8083:80 -v /root/htdocs:/usr/local/apache2/htdocs httpd9a56caf5dc8520a8c20d88a20a77b18018bb348d6605218af09ec35f2ec59785[root@docker ~]# curl &apos;http://127.0.0.1:8081&apos;welcome to chenfanlinux.org[root@docker ~]# curl &apos;http://127.0.0.1:8082&apos;welcome to chenfanlinux.org[root@docker ~]# curl &apos;http://127.0.0.1:8083&apos;welcome to chenfanlinux.org[root@docker ~]# docker exec -it 9a56caf5dc85 /bin/bashroot@9a56caf5dc85:/usr/local/apache2# echo &apos;this is new page&apos; &gt;htdocs/index.html[root@docker ~]# curl &apos;http://127.0.0.1:8081&apos;this is new page[root@docker ~]# curl &apos;http://127.0.0.1:8082&apos;this is new page[root@docker ~]# curl &apos;http://127.0.0.1:8083&apos;this is new page</code></pre><p><strong>volume container</strong> 是专门为其他容器提供 volume 的容器。它提供的卷可以是 bind mount，也可以是 docker managed volume。</p><p>创建一个 <strong>volume container</strong>,命令为vc01,而且提供两种类型的 data volume。volume contained的作用只是提供数据，本身不需要运行状态。</p><pre><code>[root@docker ~]# docker create --name=vc01 -v /root/htdocs:/usr/local/apache2/htdocs -v /docker_manage_data  busyboxe23d25dc38c15f91dd9ad4833878a3d965f77f101e91f6c9b2873cef284b3c97[root@docker ~]# docker inspect e23d25dc38c15f91dd9ad4833878a3d965f77f101e91f6c9b2873cef284b3c97        &quot;Mounts&quot;: [        {            &quot;Type&quot;: &quot;bind&quot;,            &quot;Source&quot;: &quot;/root/htdocs&quot;,            &quot;Destination&quot;: &quot;/usr/local/apache2/htdocs&quot;,            &quot;Mode&quot;: &quot;&quot;,            &quot;RW&quot;: true,            &quot;Propagation&quot;: &quot;rprivate&quot;        },        {            &quot;Type&quot;: &quot;volume&quot;,            &quot;Name&quot;: &quot;ceb7995923bfbb0b425f36a492698db6f3f1f987c45afaa80fbc15ddf2d51a85&quot;,            &quot;Source&quot;: &quot;/var/lib/docker/volumes/ceb7995923bfbb0b425f36a492698db6f3f1f987c45afaa80fbc15ddf2d51a85/_data&quot;,            &quot;Destination&quot;: &quot;/docker_manage_data&quot;,            &quot;Driver&quot;: &quot;local&quot;,            &quot;Mode&quot;: &quot;&quot;,            &quot;RW&quot;: true,            &quot;Propagation&quot;: &quot;&quot;        }    ],</code></pre><p>其他容器可以通过 –volumes-from 使用 <strong>vc01</strong>这个 volume container：</p><pre><code>[root@docker ~]# docker run --name web01 -d -p 80 --volumes-from vc01 httpd583e7793e3e8be277cc31efa4aa27c9136b224b3258fafe87be5a8839a827c66[root@docker ~]# docker run --name web02 -d -p 80 --volumes-from vc01 httpdd826c43f2f0fa7e669ed69c59b6d37b00714f84fe490e26139c1a6c2b04225cb[root@docker ~]# docker run --name web03 -d -p 80 --volumes-from vc01 httpd8a5955198364c45b40f2deaa48fdd4005faf986b7450aeb24773c39c0c5d3189[root@docker ~]# docker ps -aCONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS                   NAMES8a5955198364        httpd               &quot;httpd-foreground&quot;   2 minutes ago       Up 2 minutes        0.0.0.0:32770-&gt;80/tcp   web03d826c43f2f0f        httpd               &quot;httpd-foreground&quot;   3 minutes ago       Up 2 minutes        0.0.0.0:32769-&gt;80/tcp   web02583e7793e3e8        httpd               &quot;httpd-foreground&quot;   3 minutes ago       Up 3 minutes        0.0.0.0:32768-&gt;80/tcp   web01[root@docker ~]# curl &apos;http://127.0.0.1:32770&apos;this is new page[root@docker ~]# curl &apos;http://127.0.0.1:32769&apos;this is new page[root@docker ~]# curl &apos;http://127.0.0.1:32768&apos;this is new page[root@docker ~]# echo &apos;This is shared bind mount&apos; &gt;/root/htdocs/index.html[root@docker ~]# curl &apos;http://127.0.0.1:32770&apos;This is shared bind mount[root@docker ~]# curl &apos;http://127.0.0.1:32768&apos;This is shared bind mount[root@docker ~]# curl &apos;http://127.0.0.1:32769&apos;This is shared bind mount</code></pre><p>可见，三个容器已经成功共享了 volume container 中的 volume。</p><ul><li><p>与 bind mount 相比，不必为每一个容器指定 host path，所有 path 都在 volume container 中定义好了，容器只需与 volume container 关联，实现了容器与 host 的解耦。</p></li><li><p>使用 volume container 的容器其 mount point 是一致的，有利于配置的规范和标准化，但也带来一定的局限，使用时需要综合考虑。</p></li></ul><p><strong>data-packed volume container</strong><br>volume container 的数据归根到底还是在 host 里，有没有办法将数据完全放到 volume container 中，同时又能与其他容器共享呢？</p><p>当然可以，通常我们称这种容器为 data-packed volume container。其原理是将数据打包到镜像中，然后通过 docker managed volume 共享。</p><p>先创建一个vc_datapacked镜像</p><pre><code>[root@docker ~]# mkdir build[root@docker ~]# cd build[root@docker build]# mkdir htdocs[root@docker build]# echo &apos;This  data-packed volume container&apos; &gt;htdocs/index.html[root@docker build]# cat DockerfileFROM busybox:latestADD htdocs /usr/local/apache2/htdocsVOLUME /usr/local/apache2/htdocs[root@docker build]# docker build -t vc_datapacked  .Sending build context to Docker daemon  3.584kBStep 1/3 : FROM busybox:latest ---&gt; 807fd4df40d1Step 2/3 : ADD htdocs /usr/local/apache2/htdocs ---&gt; 73edca1e0721Step 3/3 : VOLUME /usr/local/apache2/htdocs ---&gt; Running in 9cbf417e6126Removing intermediate container 9cbf417e6126 ---&gt; 218f809be766Successfully built 218f809be766Successfully tagged vc_datapacked:latest</code></pre><p>再创建一个共享的volume contained (datapacked)</p><pre><code>[root@docker build]# docker inspect datapacked[root@docker build]# docker create --name datapacked vc_datapacked     &quot;Mounts&quot;: [        {            &quot;Type&quot;: &quot;volume&quot;,            &quot;Name&quot;: &quot;cb02a8020d38d9d7e8f68dcabf706808e73c2801d1f0cc52bad84c7a9206dc35&quot;,            &quot;Source&quot;: &quot;/var/lib/docker/volumes/cb02a8020d38d9d7e8f68dcabf706808e73c2801d1f0cc52bad84c7a9206dc35/_data&quot;,            &quot;Destination&quot;: &quot;/usr/local/apache2/htdocs&quot;,            &quot;Driver&quot;: &quot;local&quot;,            &quot;Mode&quot;: &quot;&quot;,            &quot;RW&quot;: true,            &quot;Propagation&quot;: &quot;&quot;        }    ],</code></pre><p>启动一个httpd应用，共享datapacked 数据</p><pre><code>[root@docker build]# docker run -d -p 8081:80 --volumes-from datapacked httpd[root@docker build]# curl http://127.0.0.1:8081This  data-packed volume container</code></pre><p>本质来说，这是一种dokcer managed volume的应用，只是将需要共享的数据放在了volume容器的镜像中。data-packed volume container 是自包含的，不依赖 host 提供数据，具有很强的移植性，非常适合 只使用 静态数据的场景，比如应用的配置信息、web server 的静态文件等。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;如何存储Docker数据&quot;&gt;&lt;a href=&quot;#如何存储Docker数据&quot; class=&quot;headerlink&quot; title=&quot;如何存储Docker数据&quot;&gt;&lt;/a&gt;如何存储Docker数据&lt;/h2&gt;&lt;p&gt;Docker 为容器提供了两种存放数据的资源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Storage Driver 管理的镜像层和容器层。&lt;/li&gt;
&lt;li&gt;Data Volume&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Storage Driver&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;容器由最上面一个可写的容器层，以及若干只读的镜像层组成，容器的数据就存放在这些层中。这样的分层结构最大的特性是 &lt;strong&gt;&lt;em&gt;Copy-on-Write&lt;/em&gt;&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新数据会直接存放在最上面的容器层。&lt;/li&gt;
&lt;li&gt;修改现有数据会先从镜像层将数据复制到容器层，修改后的数据直接保存在容器层中，镜像层保持不变。&lt;/li&gt;
&lt;li&gt;如果多个层中有命名相同的文件，用户只能看到最上面那层中的文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/01/15/pUMMh4.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;Storage Driver 实现了多层数据的堆叠并为用户提供一个单一的合并之后的统一视图。适合无状态的应用，不需要持久化存储数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Data Volume&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Data Volume 本质上是 Docker Host 文件系统中的目录或文件，能够直接被 mount 到容器的文件系统中。适合于持久化数据的需求的数据存储，容器启动时需要加载已有的数据，容器销毁时希望保留产生的新数据，也就是说，这类容器是有状态的。Data Volume有如下特点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Data Volume 是目录或文件，而非没有格式化的磁盘（块设备）。&lt;/li&gt;
&lt;li&gt;容器可以读写 volume 中的数据。&lt;/li&gt;
&lt;li&gt;volume 数据可以被永久的保存，即使使用它的容器已经销毁。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Data-volume的类型&quot;&gt;&lt;a href=&quot;#Data-volume的类型&quot; class=&quot;headerlink&quot; title=&quot;Data volume的类型&quot;&gt;&lt;/a&gt;Data volume的类型&lt;/h2&gt;&lt;p&gt;在具体的使用上，docker 提供了两种类型的 volume：bind mount 和 docker managed volume。&lt;/p&gt;
&lt;h3 id=&quot;bind-mount&quot;&gt;&lt;a href=&quot;#bind-mount&quot; class=&quot;headerlink&quot; title=&quot;bind mount&quot;&gt;&lt;/a&gt;bind mount&lt;/h3&gt;&lt;p&gt;bind mount 是将 host 上已存在的目录或文件 mount 到容器。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@chenfanlinux ~]# mkdir /root/htdocs
[root@chenfanlinux ~]# echo &amp;quot;Welcome to chenfanlinux.org&amp;quot; &amp;gt;/root/htdocs/index.html
[root@chenfanlinux ~]# docker run -d -p 80:80 -v /root/htdocs:/usr/local/apache2/htdocs httpd
c7a396731c62e35b0704e16ffa6ea0a4b4d7e3488cd220dca0d41958eff46c30
[root@chenfanlinux ~]# docker ps
CONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS                NAMES
c7a396731c62        httpd               &amp;quot;httpd-foreground&amp;quot;   15 seconds ago      Up 14 seconds       0.0.0.0:80-&amp;gt;80/tcp   serene_mccarthy
[root@chenfanlinux ~]# curl &amp;apos;http://127.0.0.1:80&amp;apos;
Welcome to chenfanlinux.org
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过 &lt;strong&gt;&lt;em&gt;-v &amp;lt;host path&amp;gt;:&amp;lt;container path&amp;gt;&lt;/em&gt;&lt;/strong&gt; 这种格式将host上的/root/htdocs挂载到容器/usr/local/apache2/htdocs目录下。由于/root/htdocs目录下有文件，会隐藏容器/usr/local/apache2/htdocs下的文件内容。&lt;/p&gt;
&lt;p&gt;当我们更新一下/root/htdocs目录下的文件内容时，看看容器里的文件是否发生变化。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@chenfanlinux htdocs]# echo &amp;apos;this is www.chenfanlinux.org&amp;apos;&amp;gt; index.html
[root@chenfanlinux htdocs]# ls
index.html
[root@chenfanlinux htdocs]# curl &amp;apos;http://127.0.0.1&amp;apos;
this is www.chenfanlinux.org
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里的host 目录的/root/htdocs和容器/usr/local/apache2/htdocs属于共享目录，它们会共享数据。&lt;br&gt;下面我们将容器销毁，看看对 bind mount 有什么影响：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@chenfanlinux htdocs]# docker stop 177051349c19
177051349c19
[root@chenfanlinux htdocs]# docker rm 177051349c19
177051349c19
[root@chenfanlinux htdocs]# cat /root/htdocs/index.html
this is www.chenfanlinux.org
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到/root/htdocs数据依然存在，bind mount是文件系统中的数据，容器在销毁时，这些数据不会删除。&lt;/p&gt;
&lt;p&gt;bind mount 时还可以指定数据的读写权限，默认是可读可写，可指定为只读，ro 设置了只读权限，在容器中是无法对 bind mount 数据进行修改的。只有 host 有权修改数据，提高了安全性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@chenfanlinux htdocs]# docker run -d -p 80:80 -v /root/htdocs:/usr/local/apache2/htdocs:ro  httpd
d0d2fa8b29b120a8c20d88a20a77b18018bb348d6605218af09ec35f2ec59785
[root@chenfanlinux htdocs]# docker exec -it d0d2fa8b29b1 /bin/bash
root@d0d2fa8b29b1:/usr/local/apache2#
root@d0d2fa8b29b1:/usr/local/apache2# echo &amp;apos;host path:container path:perm&amp;apos; &amp;gt;htdoc
bash: htdocs//index.htm: Read-only file system
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;mount point 有很多应用场景，比如我们可以将源代码目录 mount 到容器中，在 host 中修改代码就能看到应用的实时效果。再比如将 mysql 容器的数据放在 bind mount 里，这样 host 可以方便地备份和迁移数据。&lt;/p&gt;
&lt;p&gt;bind mount 的使用直观高效，易于理解，但它也有不足的地方：bind mount 需要指定 host 文件系统的特定路径，这就限制了容器的可移植性，当需要将容器迁移到其他 host，而该 host 没有要 mount 的数据或者数据不在相同的路径时，操作会失败。移植性更好的方式是 docker managed volume，下面就会讨论。&lt;br&gt;
    
    </summary>
    
      <category term="Docker系列" scheme="http://www.chenfanlinux.org/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Docker" scheme="http://www.chenfanlinux.org/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门之网络管理(五)</title>
    <link href="http://www.chenfanlinux.org/2018/01/14/Docker%E5%85%A5%E9%97%A8%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86-%E4%BA%94/"/>
    <id>http://www.chenfanlinux.org/2018/01/14/Docker入门之网络管理-五/</id>
    <published>2018-01-14T12:48:37.000Z</published>
    <updated>2018-01-26T03:39:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker中自带的网络类型"><a href="#Docker中自带的网络类型" class="headerlink" title="Docker中自带的网络类型"></a>Docker中自带的网络类型</h2><blockquote><p>在Docker容器技术中，网络部分算是比较复杂的一部分。了解Docker提供了几种原生的网络，了解容器与外界通信以及外界对容器如何进行访问，这是本文的重点。</p></blockquote><p>Docker 安装时会自动在 host 上创建三个网络，我们可用 docker network ls 命令查看：</p><pre><code>[root@localhost ~]# docker network lsNETWORK ID          NAME                DRIVER              SCOPE39e6a520b768        bridge              bridge              localb31da46610a3        host                host                local7d42c5a35cce        none                null                local</code></pre><p>上面我们可以看到三种类型的网络，包括none、host、bridge这三种原生的网络，还有一种container网络用于容器间通信的后面也会做介绍。</p><h3 id="none网络"><a href="#none网络" class="headerlink" title="none网络"></a>none网络</h3><p>none 网络就是什么都没有的网络。挂在这个网络下的容器除了 lo，没有其他任何网卡。容器创建时，可以通过 –network=none 指定使用 none 网络。</p><pre><code>[root@docker ~]# docker run -it --network=none busyboxUnable to find image &apos;busybox:latest&apos; locallylatest: Pulling from library/busyboxfb46b04c527d: Pull completeDigest: sha256:436bbf48aa1198ebca8eac0ad9a9c80c8929d9242e02608f76ce18334e0cfe6aStatus: Downloaded newer image for busybox:latest/ # ifconfiglo        Link encap:Local Loopback          inet addr:127.0.0.1  Mask:255.0.0.0          UP LOOPBACK RUNNING  MTU:65536  Metric:1          RX packets:0 errors:0 dropped:0 overruns:0 frame:0          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</code></pre><p>这里我们可以看到none网络中只有一个lo，没有其他网卡，就是一个封闭的网络，不与外界通信。封闭意味着隔离，一些对安全性要求高并且不需要联网的应用可以使用 none 网络。</p><h3 id="host网络"><a href="#host网络" class="headerlink" title="host网络"></a>host网络</h3><p>连接到 host 网络的容器共享 Docker host 的网络栈，容器的网络配置与宿主机完全一样。可以通过 –network=host 指定使用 host 网络。</p><pre><code>[root@docker ~]# docker run -it --network=host busybox/ # ifconfigdocker0   Link encap:Ethernet  HWaddr 02:42:02:90:4E:49          inet addr:172.17.0.1  Bcast:0.0.0.0  Mask:255.255.0.0          UP BROADCAST MULTICAST  MTU:1500  Metric:1          RX packets:0 errors:0 dropped:0 overruns:0 frame:0          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:0          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)ens33     Link encap:Ethernet  HWaddr 00:0C:29:95:F6:22          inet addr:192.168.175.40  Bcast:192.168.175.255  Mask:255.255.255.0          inet6 addr: fe80::f1c9:d94d:f12b:990c/64 Scope:Link          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:203380 errors:0 dropped:0 overruns:0 frame:0          TX packets:73455 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1000          RX bytes:270648213 (258.1 MiB)  TX bytes:6886880 (6.5 MiB)lo        Link encap:Local Loopback          inet addr:127.0.0.1  Mask:255.0.0.0          inet6 addr: ::1/128 Scope:Host          UP LOOPBACK RUNNING  MTU:65536  Metric:1          RX packets:0 errors:0 dropped:0 overruns:0 frame:0          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)/ # hostnamedocker</code></pre><p>在容器内可以看到所有宿主机的网卡，跟宿主机ifconfig看到的结果时一致的，并且hostname并不是短ID，而是宿主机的hostname。<br>直接使用 Docker host 的网络最大的好处就是性能，如果容器对网络传输效率有较高要求，则可以选择 host 网络。当然不便之处就是牺牲一些灵活性，比如要考虑端口冲突问题，宿主机上已经使用的端口就不能再用了。</p><a id="more"></a><h3 id="container模式"><a href="#container模式" class="headerlink" title="container模式"></a>container模式</h3><p>这个模式指定新创建的容器和已经存在的一个容器共享一个Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，它可以使两个或多个容器共享一个网络栈等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过lo（127.0.0.1）网卡设备通信，这篇文章的后面降到容器间通信的时候，会讲到这种网络模式。</p><h3 id="bridge网络"><a href="#bridge网络" class="headerlink" title="bridge网络"></a>bridge网络</h3><p>bridge网络是Docker默认的网络类型，具有更广泛的使用价值。也是本文及后续探讨的重点，明确bridge网络原理，对应用Docker技术至关重要。</p><pre><code>[root@docker ~]# ifconfigdocker0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500        inet 172.17.0.1  netmask 255.255.0.0  broadcast 0.0.0.0        ether 02:42:02:90:4e:49  txqueuelen 0  (Ethernet)        RX packets 0  bytes 0 (0.0 B)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 (0.0 B)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0[root@docker ~]# brctl showbridge name    bridge id        STP enabled    interfacesdocker0        8000.02425cb5b194    no</code></pre><p>Docker 安装时会创建一个 命名为 docker0 的 linux bridge。如果不指定–network，创建的容器默认都会挂到 docker0 上。利用brctl show命令可以看到虚拟网桥上暂时是空的，当我运行一个容器的时候，接下来会发现什么变化呢？</p><pre><code>[root@docker ~]# docker run -it busyboxUnable to find image &apos;busybox:latest&apos; locallylatest: Pulling from library/busyboxfb46b04c527d: Pull completeDigest: sha256:7962088087138b6cb316047648316287e110c5d46569900d332b80fbd7840a40Status: Downloaded newer image for busybox:latest[root@docker ~]# brctl showbridge name    bridge id        STP enabled    interfacesdocker0        8000.02425cb5b194    no        vetha36b044</code></pre><p>上面我们运行一个busybox后,发现docker0上多了一个网络接口 <strong><em>vetha36b044</em></strong>，这是新建容器的虚拟网卡。下面我们进入到容器内部看看网卡的信息。</p><pre><code>/ # ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever4: eth0@if5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0       valid_lft forever preferred_lft forever[root@docker ~]# ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever    inet6 ::1/128 scope host       valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000    link/ether 00:0c:29:95:f6:22 brd ff:ff:ff:ff:ff:ff    inet 192.168.175.40/24 brd 192.168.175.255 scope global ens33       valid_lft forever preferred_lft forever    inet6 fe80::f1c9:d94d:f12b:990c/64 scope link       valid_lft forever preferred_lft forever3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP    link/ether 02:42:5c:b5:b1:94 brd ff:ff:ff:ff:ff:ff    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0       valid_lft forever preferred_lft forever    inet6 fe80::42:5cff:feb5:b194/64 scope link       valid_lft forever preferred_lft forever5: vetha36b044@if4: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP    link/ether 4e:23:f7:66:08:13 brd ff:ff:ff:ff:ff:ff link-netnsid 0    inet6 fe80::4c23:f7ff:fe66:813/64 scope link       valid_lft forever preferred_lft forever</code></pre><p>通过上面的实验，我们可以发现通过brctl show看到的dokcer0上挂载网卡接口为<strong><em>vetha36b044</em></strong>，而容器的网卡为eth0@if5，他们两个居然不一样！其实他们两个是一对 <strong>veth pair</strong>，veth pair是用于不同network namespace间进行通信的方式，veth pair将一个network namespace数据发往另一个network namespace的veth。网卡的一头（eth0@if5）在容器中，另一头（vetha36b044）挂在网桥 docker0 上，其效果就是将 eth0@if34 也挂在了 docker0 上。</p><p>进一步分析busybox容器的网络地址为172.17.0.2/16,而docker0的网络地址为172.17.0.1/16，可以通过<code>docker inspect network bridge</code> 来查看bridge网络的配置情况如下。</p><pre><code>[root@docker ~]# docker network inspect bridge[    {        &quot;Name&quot;: &quot;bridge&quot;,        &quot;Id&quot;: &quot;0a38d5dc818f2d1dafce109c3aa955e6d5854f296f0fd34704decb756538c985&quot;,        &quot;Created&quot;: &quot;2018-01-12T10:25:49.592636268+08:00&quot;,        &quot;Scope&quot;: &quot;local&quot;,        &quot;Driver&quot;: &quot;bridge&quot;,        &quot;EnableIPv6&quot;: false,        &quot;IPAM&quot;: {            &quot;Driver&quot;: &quot;default&quot;,            &quot;Options&quot;: null,            &quot;Config&quot;: [                {                    &quot;Subnet&quot;: &quot;172.17.0.0/16&quot;,                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;                }            ]        },        &quot;Internal&quot;: false,        &quot;Attachable&quot;: false,        &quot;Ingress&quot;: false,        &quot;ConfigFrom&quot;: {            &quot;Network&quot;: &quot;&quot;        },        &quot;ConfigOnly&quot;: false,        &quot;Containers&quot;: {            &quot;e519d169f8d3d686245a27d0dfdd05ff3d8dc605534b48f882cd37428ef3b5af&quot;: {                &quot;Name&quot;: &quot;eager_bohr&quot;,                &quot;EndpointID&quot;: &quot;9c6abac0b5336d5415075091209e9779879579a913c00ef4dcb0ac55fca639ed&quot;,                &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,                &quot;IPv4Address&quot;: &quot;172.17.0.2/16&quot;,                &quot;IPv6Address&quot;: &quot;&quot;            }        },        &quot;Options&quot;: {            &quot;com.docker.network.bridge.default_bridge&quot;: &quot;true&quot;,            &quot;com.docker.network.bridge.enable_icc&quot;: &quot;true&quot;,            &quot;com.docker.network.bridge.enable_ip_masquerade&quot;: &quot;true&quot;,            &quot;com.docker.network.bridge.host_binding_ipv4&quot;: &quot;0.0.0.0&quot;,            &quot;com.docker.network.bridge.name&quot;: &quot;docker0&quot;,            &quot;com.docker.network.driver.mtu&quot;: &quot;1500&quot;        },        &quot;Labels&quot;: {}    }][root@docker ~]# ifconfig docker0    docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500    inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255    inet6 fe80::42:5cff:feb5:b194  prefixlen 64  scopeid 0x20&lt;link&gt;    ether 02:42:5c:b5:b1:94  txqueuelen 0  (Ethernet)    RX packets 0  bytes 0 (0.0 B)    RX errors 0  dropped 0  overruns 0  frame 0    TX packets 8  bytes 648 (648.0 B)    TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><p>可以看到bridge网络的 子网”Subnet”: “172.17.0.0/16”； 网关”Gateway”: “172.17.0.1”；容器的网络为”IPv4Address”: “172.17.0.2/16”；可以看出容器的网络由bridge子网分配一个ip地址，而网关就是dokcer0 172.17.0.1。</p><p>因此可以得出当前docker环境下的网络拓扑图如下：</p><p><img src="https://s1.ax1x.com/2018/01/14/pt44gg.png" alt="Docker容器网络拓扑图1"></p><p>容器创建时，docker 会自动从 172.17.0.0/16 中分配一个 IP，这里 16 位的掩码保证有足够多的 IP 可以供容器使用。</p><h2 id="用户自定义网络"><a href="#用户自定义网络" class="headerlink" title="用户自定义网络"></a>用户自定义网络</h2><blockquote><p>除了Docker提供的上面三种none、host、bridge网络，用户还可以根据需求自定义网络。Docker 提供三种 user-defined 网络驱动：bridge, overlay 和 macvlan。overlay 和 macvlan 用于创建跨主机的网络。</p></blockquote><h3 id="系统自动分配网络地址"><a href="#系统自动分配网络地址" class="headerlink" title="系统自动分配网络地址"></a>系统自动分配网络地址</h3><p>我们可通过 bridge 驱动创建类似前面默认的 bridge 网络，网络名为br01，例如：</p><pre><code>[root@docker ~]# docker network create --driver bridge br0151123511575b1593773727c61703ca2b2b86e6e33efe48be398c402b774811c3</code></pre><p>查看host网络网桥的情况：<br>发现多了一个 名为 <strong><em>br-51123511575b</em></strong> 的网桥，这里的 <strong>51123511575b</strong> 正好是新建的网桥 <strong>br01</strong> 的短id.</p><pre><code>[root@docker ~]# brctl showbridge name    bridge id        STP enabled    interfacesbr-51123511575b        8000.02425d1b64f0    nodocker0        8000.02425cb5b194    no        vetha36b044</code></pre><p>使用     <code>docker network inspect br01</code> 看一下具体的br01网络配置信息。使用 <code>docker network inspect br01</code> 前需要通过  <code>docker network ls</code> 看一下 网络名</p><p>docker0（网桥名） —-&gt; bridge（网络名）<br>br-51123511575b（网桥名）—–&gt; br01（网络名）</p><pre><code>[root@docker ~]# docker network lsNETWORK ID          NAME                DRIVER              SCOPE51123511575b        br01                bridge              local0a38d5dc818f        bridge              bridge              local780f6f3484b4        host                host                local26045d3b36ad        none                null                local[root@docker ~]# docker network inspect br01[    {        &quot;Name&quot;: &quot;br01&quot;,        &quot;Id&quot;: &quot;51123511575b1593773727c61703ca2b2b86e6e33efe48be398c402b774811c3&quot;,        &quot;Created&quot;: &quot;2018-01-12T16:30:26.109384839+08:00&quot;,        &quot;Scope&quot;: &quot;local&quot;,        &quot;Driver&quot;: &quot;bridge&quot;,        &quot;EnableIPv6&quot;: false,        &quot;IPAM&quot;: {            &quot;Driver&quot;: &quot;default&quot;,            &quot;Options&quot;: {},            &quot;Config&quot;: [                {                    &quot;Subnet&quot;: &quot;172.18.0.0/16&quot;,                    &quot;Gateway&quot;: &quot;172.18.0.1&quot;                }            ]        },        &quot;Internal&quot;: false,        &quot;Attachable&quot;: false,        &quot;Ingress&quot;: false,        &quot;ConfigFrom&quot;: {            &quot;Network&quot;: &quot;&quot;        },        &quot;ConfigOnly&quot;: false,        &quot;Containers&quot;: {},        &quot;Options&quot;: {},        &quot;Labels&quot;: {}    }]</code></pre><p>刚才新建的bridge网络br01的网络配置信息如上，子网为172.18.0.0/16，网关为172.18.0.1。网络名为 <strong>br01</strong> 的网络对应的网桥名为 <strong>br-51123511575b</strong>，也是它的网关。</p><pre><code>[root@docker ~]# ifconfig br-51123511575bbr-51123511575b: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500        inet 172.18.0.1  netmask 255.255.0.0  broadcast 172.18.255.255        ether 02:42:5d:1b:64:f0  txqueuelen 0  (Ethernet)        RX packets 0  bytes 0 (0.0 B)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 (0.0 B)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><h3 id="用户指定固定网络地址"><a href="#用户指定固定网络地址" class="headerlink" title="用户指定固定网络地址"></a>用户指定固定网络地址</h3><blockquote><p>上面我们创建的bridge网络 <strong>br01</strong> 是系统给分配的子网地址和网关，在创建bridge网络的时候，用户也可以自定义网络地址，配置如下： 只需在创建网段时指定 –subnet 和 –gateway 参数</p></blockquote><pre><code>[root@docker ~]# docker network create --driver bridge --subnet=172.20.0.0/16 --gateway=172.20.0.1 br0210aea5be498f0de091bd078a640cf07d58903ac6af7c8f75d9045752414f8d6f[root@docker ~]# brctl showbridge name    bridge id        STP enabled    interfacesbr-10aea5be498f        8000.0242452b7e17    nobr-51123511575b        8000.02425d1b64f0    nodocker0        8000.02425cb5b194    no        vetha36b044</code></pre><p>可以看到我们新创建了一个网桥<strong>br-10aea5be498f</strong>，<strong>10aea5be498f</strong> 也是网桥的短id。</p><pre><code>[root@docker ~]# docker network lsNETWORK ID          NAME                DRIVER              SCOPE51123511575b        br01                bridge              local10aea5be498f        br02                bridge              local0a38d5dc818f        bridge              bridge              local780f6f3484b4        host                host                local26045d3b36ad        none                null                local[root@docker ~]# docker network inspect br02[    {        &quot;Name&quot;: &quot;br02&quot;,        &quot;Id&quot;: &quot;10aea5be498f0de091bd078a640cf07d58903ac6af7c8f75d9045752414f8d6f&quot;,        &quot;Created&quot;: &quot;2018-01-12T17:01:13.134341096+08:00&quot;,        &quot;Scope&quot;: &quot;local&quot;,        &quot;Driver&quot;: &quot;bridge&quot;,        &quot;EnableIPv6&quot;: false,        &quot;IPAM&quot;: {            &quot;Driver&quot;: &quot;default&quot;,            &quot;Options&quot;: {},            &quot;Config&quot;: [                {                    &quot;Subnet&quot;: &quot;172.20.0.0/16&quot;,                    &quot;Gateway&quot;: &quot;172.20.0.1&quot;                }            ]        },        &quot;Internal&quot;: false,        &quot;Attachable&quot;: false,        &quot;Ingress&quot;: false,        &quot;ConfigFrom&quot;: {            &quot;Network&quot;: &quot;&quot;        },        &quot;ConfigOnly&quot;: false,        &quot;Containers&quot;: {},        &quot;Options&quot;: {},        &quot;Labels&quot;: {}    }]</code></pre><p>进一步可以发现，网络名为 <strong>br02</strong>的网络地址配置为子网172.20.0.0/16，网关为172.20.0.1，对应的也就是网桥 <strong>br-10aea5be498f</strong> 的ip地址。</p><pre><code>[root@docker ~]# ifconfig br-10aea5be498fbr-10aea5be498f: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500        inet 172.20.0.1  netmask 255.255.0.0  broadcast 172.20.255.255        ether 02:42:45:2b:7e:17  txqueuelen 0  (Ethernet)        RX packets 0  bytes 0 (0.0 B)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 (0.0 B)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><h3 id="使用新的网络地址运行容器应用"><a href="#使用新的网络地址运行容器应用" class="headerlink" title="使用新的网络地址运行容器应用"></a>使用新的网络地址运行容器应用</h3><blockquote><p>刚才我们利用创建了两个bridge网络<strong>br01</strong>、<strong>br02</strong>，br01的网络地址是系统分配的,br02的网络地址是用户自定义的。下面我们运行一个容器应用，使用 <strong>br02</strong> 网络来研究当前网络的变化。</p></blockquote><pre><code>[root@docker ~]# docker run -d --network=br02 httpdUnable to find image &apos;httpd:latest&apos; locallylatest: Pulling from library/httpdf49cf87b52c1: Pull complete02ca099fb6cd: Pull completede7acb18da57: Pull complete770c8edb393d: Pull complete0e252730aeae: Pull complete6e6ca341873f: Pull complete2daffd0a6144: Pull completeDigest: sha256:b5f21641a9d7bbb59dc94fb6a663c43fbf3f56270ce7c7d51801ac74d2e70046Status: Downloaded newer image for httpd:latesta91d76993197d93d6757c38179b264000d26cabe4afe771a12090ef48de4f8a6[root@docker ~]# docker psCONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS               NAMESa91d76993197        httpd               &quot;httpd-foreground&quot;   49 seconds ago      Up 38 seconds       80/tcp              happy_visvesvarayae519d169f8d3        busybox             &quot;sh&quot;                 7 hours ago         Up 7 hours                              eager_bohr[root@docker ~]# docker exec -it a91d76993197 /bin/sh/ # ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever8: eth0@if9: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default    link/ether 02:42:ac:14:00:02 brd ff:ff:ff:ff:ff:ff    inet 172.20.0.2/16 brd 172.20.255.255 scope global eth0       valid_lft forever preferred_lft forever</code></pre><p>可以看到以 <strong>br02</strong> 网络创建的新容器应用httpd，分配的IP为  172.20.0.2/16，这个IP是从 <strong>br02</strong> 网络的子网地址中随机分配的IP。如果我们想指定容器的静态IP,可以使用–ip参数指定。</p><pre><code>[root@docker ~]# docker run -d --network=br02 --ip 172.20.0.9  httpd9da4e8e73e3c3a5d19337d53dbad6d846bef63150bd76dc074642e0063a60e28[root@docker ~]# docker psCONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS               NAMES9da4e8e73e3c        httpd               &quot;httpd-foreground&quot;   21 seconds ago      Up 19 seconds       80/tcp              upbeat_wescoffa91d76993197        httpd               &quot;httpd-foreground&quot;   7 minutes ago       Up 7 minutes        80/tcp              happy_visvesvarayae519d169f8d3        busybox             &quot;sh&quot;                 7 hours ago         Up 7 hours                              eager_bohr[root@docker ~]# docker exec -it 9da4e8e73e3c /bin/bashroot@9da4e8e73e3c:/usr/local/apache2# ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever10: eth0@if11: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default    link/ether 02:42:ac:14:00:09 brd ff:ff:ff:ff:ff:ff    inet 172.20.0.9/16 brd 172.20.255.255 scope global eth0       valid_lft forever preferred_lft forever</code></pre><p>上面就可以看到容器ID为 <strong>9da4e8e73e3c</strong> 的httpd应用的IP地址为 172.20.0.9/16 。刚才的br01网络地址是系统自动分配的，看看使用这个网络地址是否能够给容器指定静态地址。</p><pre><code>[root@docker ~]# docker  run -d --network=br01 --ip 172.18.0.9 httpdda7057c2a5f00e68d7f0017e675e25a2cbf44e086944b2d1898f70345f5ada77docker: Error response from daemon: user specified IP address is supported only when connecting to networks with user configured subnets</code></pre><p>可以看到明显的报错信息，用户自定义的IP地址需要用户自定义的网络地址的支持。</p><h2 id="容器之间的通信"><a href="#容器之间的通信" class="headerlink" title="容器之间的通信"></a>容器之间的通信</h2><h3 id="当前Docker的网络拓扑"><a href="#当前Docker的网络拓扑" class="headerlink" title="当前Docker的网络拓扑"></a>当前Docker的网络拓扑</h3><blockquote><p>经过上面创建了两个bridge网络 <strong>br01</strong> 、<strong>br02</strong>。 <strong>br01</strong>是系统分配的网络地址，<strong>br02</strong>是我们指定的网络地址，并且指定 br02 为网络地址，运行了两个httpd应用。其中一个应用利用 –ip 指定了容器的静态IP，另一个是系统分配的IP地址。</p></blockquote><p><img src="https://s1.ax1x.com/2018/01/12/p8X2kR.md.png" alt="Docker网络拓扑"></p><h3 id="容器之间连通性"><a href="#容器之间连通性" class="headerlink" title="容器之间连通性"></a>容器之间连通性</h3><p>由于两个httpd容器应用都挂在同一个网络br02上，他们之间应该是连通的。</p><pre><code>root@cba8fa31d272:/usr/local/apache2# ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever11: eth0@if12: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default    link/ether 02:42:ac:14:00:02 brd ff:ff:ff:ff:ff:ff    inet 172.20.0.2/16 brd 172.20.255.255 scope global eth0       valid_lft forever preferred_lft foreverroot@cba8fa31d272:/usr/local/apache2# ping -c 5 172.20.0.9PING 172.20.0.9 (172.20.0.9): 56 data bytes64 bytes from 172.20.0.9: icmp_seq=0 ttl=64 time=0.232 ms64 bytes from 172.20.0.9: icmp_seq=1 ttl=64 time=0.145 ms64 bytes from 172.20.0.9: icmp_seq=2 ttl=64 time=0.167 ms64 bytes from 172.20.0.9: icmp_seq=3 ttl=64 time=0.169 ms64 bytes from 172.20.0.9: icmp_seq=4 ttl=64 time=0.340 ms--- 172.20.0.9 ping statistics ---5 packets transmitted, 5 packets received, 0% packet lossround-trip min/avg/max/stddev = 0.145/0.211/0.340/0.071 msroot@0cd3ba4c84a1:/usr/local/apache2# ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever9: eth0@if10: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default    link/ether 02:42:ac:14:00:09 brd ff:ff:ff:ff:ff:ff    inet 172.20.0.9/16 brd 172.20.255.255 scope global eth0       valid_lft forever preferred_lft foreverroot@0cd3ba4c84a1:/usr/local/apache2# ping 172.20.0.2 -c 5PING 172.20.0.2 (172.20.0.2): 56 data bytes64 bytes from 172.20.0.2: icmp_seq=0 ttl=64 time=0.295 ms64 bytes from 172.20.0.2: icmp_seq=1 ttl=64 time=0.282 ms64 bytes from 172.20.0.2: icmp_seq=2 ttl=64 time=0.282 ms64 bytes from 172.20.0.2: icmp_seq=3 ttl=64 time=0.182 ms64 bytes from 172.20.0.2: icmp_seq=4 ttl=64 time=0.329 ms--- 172.20.0.2 ping statistics ---5 packets transmitted, 5 packets received, 0% packet lossround-trip min/avg/max/stddev = 0.182/0.274/0.329/0.049 ms</code></pre><p>很明显，两个httpd应用是可以互相通信的，但是httpd应用能够ping通 busybox容器吗？</p><pre><code>root@0cd3ba4c84a1:/usr/local/apache2# ping 172.17.0.2 -c 5PING 172.17.0.2 (172.17.0.2): 56 data bytes/ # ping 172.20.0.2PING 172.20.0.2 (172.20.0.2): 56 data bytes/ # ping 172.20.0.9PING 172.20.0.9 (172.20.0.9): 56 data bytes</code></pre><p>位于bridge的网络容器busybox和位于br02网络的容器httpd互相是ping不通的，因此他们的网络是隔离的。</p><h3 id="容器网络之间的路由情况"><a href="#容器网络之间的路由情况" class="headerlink" title="容器网络之间的路由情况"></a>容器网络之间的路由情况</h3><pre><code>[root@localhost ~]# ifconfig docker0docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255        inet6 fe80::42:22ff:fe51:f07e  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 02:42:22:51:f0:7e  txqueuelen 0  (Ethernet)        RX packets 312  bytes 25368 (24.7 KiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 23  bytes 1278 (1.2 KiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0[root@localhost ~]# ifconfig br-eddf353dd10abr-eddf353dd10a: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 172.20.0.1  netmask 255.255.0.0  broadcast 172.20.255.255        inet6 fe80::42:9aff:fec1:e4ec  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 02:42:9a:c1:e4:ec  txqueuelen 0  (Ethernet)        RX packets 0  bytes 0 (0.0 B)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 (0.0 B)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0[root@localhost ~]# ip routedefault via 192.168.175.2 dev ens33 proto static metric 100172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1172.20.0.0/16 dev br-eddf353dd10a proto kernel scope link src 172.20.0.1192.168.175.0/24 dev ens33 proto kernel scope link src 192.168.175.40 metric 100[root@docker ~]# cat /proc/sys/net/ipv4/ip_forward1</code></pre><p>可以看到两个容器的网段之间的路由已经定义好了，而且路由转发 ip forwarding功能已经启动了，按理说两个网段之间可以通过路由转发机制实现通信，为啥不能访问？首先想到的是主机的防火墙设置，阻断了两个网段之间的通信。</p><pre><code>[root@docker ~]# iptables-save -A DOCKER-ISOLATION -j RETURN -A DOCKER-ISOLATION -i docker0 -o br-b037f1fc0375 -j DROP -A DOCKER-ISOLATION -i br-b037f1fc0375 -o docker0 -j DROP</code></pre><p>可以看到有这样的防火墙规则阻断了docker0和br-b037f1fc0375网关的双向数据流，因此不同网段之间的容器之间的通信是隔离的，这是容器本身的机制。当我尝试删除这两条规则的时候，看看结果如何。</p><pre><code>[root@docker ~]# iptables -D DOCKER-ISOLATION -i br-b037f1fc0375 -o docker0 -j DROP[root@docker ~]# iptables -D  DOCKER-ISOLATION -i docker0 -o br-b037f1fc0375 -j DROP[root@docker ~]# docker run -it busybox/ # ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever13: eth0@if14: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue    link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff    inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0       valid_lft forever preferred_lft forever/ #root@e98fa56e7be1:/usr/local/apache2# ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever9: eth0@if10: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default    link/ether 02:42:ac:14:00:09 brd ff:ff:ff:ff:ff:ff    inet 172.20.0.9/16 brd 172.20.255.255 scope global eth0       valid_lft forever preferred_lft forever    / # ping 172.20.0.9 -c 5PING 172.20.0.9 (172.20.0.9): 56 data bytes64 bytes from 172.20.0.9: seq=0 ttl=63 time=0.579 ms64 bytes from 172.20.0.9: seq=1 ttl=63 time=0.136 ms64 bytes from 172.20.0.9: seq=2 ttl=63 time=0.204 ms64 bytes from 172.20.0.9: seq=3 ttl=63 time=0.181 ms64 bytes from 172.20.0.9: seq=4 ttl=63 time=0.175 ms--- 172.20.0.9 ping statistics ---5 packets transmitted, 5 packets received, 0% packet lossround-trip min/avg/max = 0.136/0.255/0.579 msroot@e98fa56e7be1:/usr/local/apache2# ping 172.17.0.3 -c 3PING 172.17.0.3 (172.17.0.3): 56 data bytes64 bytes from 172.17.0.3: icmp_seq=0 ttl=63 time=1.058 ms64 bytes from 172.17.0.3: icmp_seq=1 ttl=63 time=0.134 ms64 bytes from 172.17.0.3: icmp_seq=2 ttl=63 time=0.351 ms--- 172.17.0.3 ping statistics ---3 packets transmitted, 3 packets received, 0% packet lossround-trip min/avg/max/stddev = 0.134/0.514/1.058/0.395 ms</code></pre><p>发现两个网段的容器之间可以通信，看来真是防火墙阻断了他们之间的通信，这是Docker默认的机制，会隔离不同网段的容器。</p><h3 id="隔离网段的容器互相通信"><a href="#隔离网段的容器互相通信" class="headerlink" title="隔离网段的容器互相通信"></a>隔离网段的容器互相通信</h3><p>通过上面的实验，我们可以知道，两个网段之间的容器通信被防火墙规则阻断了，通过删除防火墙规则可以让其通信，接下来介绍另一种方式。</p><p>可以在httpd容器应用中添加一块docker0网桥所在的bridge网络的网卡。</p><pre><code>[root@docker ~]# docker network connect bridge 2e5ec0b10014[root@docker ~]# docker exec -it 2e5ec0b10014 /bin/bashroot@2e5ec0b10014:/usr/local/apache2# ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever21: eth0@if22: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default    link/ether 02:42:ac:14:00:02 brd ff:ff:ff:ff:ff:ff    inet 172.20.0.2/16 brd 172.20.255.255 scope global eth0       valid_lft forever preferred_lft forever25: eth1@if26: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default    link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff    inet 172.17.0.3/16 brd 172.17.255.255 scope global eth1       valid_lft forever preferred_lft foreverroot@2e5ec0b10014:/usr/local/apache2# ping 172.17.0.2 -c 3PING 172.17.0.2 (172.17.0.2): 56 data bytes64 bytes from 172.17.0.2: icmp_seq=0 ttl=64 time=0.460 ms64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.471 ms64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.171 ms--- 172.17.0.2 ping statistics ---3 packets transmitted, 3 packets received, 0% packet lossround-trip min/avg/max/stddev = 0.171/0.367/0.471/0.139 ms</code></pre><p>在httpd容器应用中就可以看到多出来了一块网卡 eth1 172.17.0.3,这样就可以实现与网桥docker0 所在的网段的busybox应用通信，因此目前的网络拓扑图变化成如下：</p><p><img src="https://s1.ax1x.com/2018/01/14/ptXyAe.png" alt="Docker网络拓扑图3"></p><h2 id="容器间通信的方式"><a href="#容器间通信的方式" class="headerlink" title="容器间通信的方式"></a>容器间通信的方式</h2><p>容器之间可通过 IP，Docker DNS Server 和 joined 容器三种方式通信。</p><h3 id="IP通信"><a href="#IP通信" class="headerlink" title="IP通信"></a>IP通信</h3><p>两个容器想要通信，由于防火墙的限制，两个网段之间的流量被Drop掉了，因此容器的通信需要使容器的网卡处于同一个网段。在创建容器的时候可以通过 <strong>–network</strong> 参数指定容器的网络；创建好的容器也可以通过 <code>docker network connect</code> 新增一块网卡，指定新的网段，来与其他网段的容器通信。</p><h3 id="Docker-DNS-Server"><a href="#Docker-DNS-Server" class="headerlink" title="Docker DNS Server"></a>Docker DNS Server</h3><p>通过IP访问容器这种方式不够灵活，往往在部署完应用后，才能知道容器的IP，部署完再指定IP比较麻烦。可以通过docker自带的DNS服务解决问题，docker daemon 实现了一个内嵌的 DNS server，使容器可以直接通过“容器名”通信。方法很简单，只要在启动时用 –name 为容器命名就可以了。</p><pre><code>[root@docker ~]# docker run -it --name=busybox01 busybox/ # ping busybox02ping: bad address &apos;busybox02&apos;[root@docker ~]# docker run -it --name=busybox02 busybox/ #/ #/ # ping busybox02</code></pre><p>这样却发生报错bad address，不能通过Docker DNS Server通信 ，一番查找后得知，<strong>docker只允许自定义网络之间通过DNS通信</strong>，我们看看下面的结果。</p><pre><code>[root@docker ~]# docker run -it --network=br02 --name=busybox03 busybox/ # ping busybox04 -c 3PING busybox04 (172.20.0.4): 56 data bytes64 bytes from 172.20.0.4: seq=0 ttl=64 time=0.624 ms64 bytes from 172.20.0.4: seq=1 ttl=64 time=0.273 ms64 bytes from 172.20.0.4: seq=2 ttl=64 time=0.257 ms--- busybox04 ping statistics ---3 packets transmitted, 3 packets received, 0% packet lossround-trip min/avg/max = 0.257/0.384/0.624 ms[root@docker ~]# docker run -it --network=br02 --name=busybox04 busybox/ # ping busybox03PING busybox03 (172.20.0.3): 56 data bytes64 bytes from 172.20.0.3: seq=0 ttl=64 time=0.422 ms64 bytes from 172.20.0.3: seq=1 ttl=64 time=0.125 ms64 bytes from 172.20.0.3: seq=2 ttl=64 time=0.273 ms</code></pre><h3 id="joined-容器"><a href="#joined-容器" class="headerlink" title="joined 容器"></a>joined 容器</h3><p>joined 容器是另一种实现容器间通信的方式。joined 容器非常特别，它可以使两个或多个容器共享一个网络栈，共享网卡和配置信息，joined 容器之间可以通过 127.0.0.1 直接通信。</p><pre><code>[root@docker ~]# docker run -it  --name busybox1 busybox/ # ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever39: eth0@if40: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0       valid_lft forever preferred_lft forever/ # wget 127.0.0.1Connecting to 127.0.0.1 (127.0.0.1:80)index.html           100% |*****************************************************************************root@e1ca2c971717:/usr/local/apache2# ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever39: eth0@if40: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0       valid_lft forever preferred_lft forever</code></pre><p>joined 容器非常适合以下场景：</p><ul><li><p>不同容器中的程序希望通过 loopback 高效快速地通信，比如 web server 与 app server。</p></li><li><p>希望监控其他容器的网络流量，比如运行在独立容器中的网络监控程序。</p></li></ul><h2 id="容器与外部网络的通信"><a href="#容器与外部网络的通信" class="headerlink" title="容器与外部网络的通信"></a>容器与外部网络的通信</h2><h3 id="容器访问外部网络"><a href="#容器访问外部网络" class="headerlink" title="容器访问外部网络"></a>容器访问外部网络</h3><p>前面介绍了容器之间如何通信，现在我们来看容器与外界之间是怎么通信的。</p><pre><code>[root@docker ~]# docker run -d   httpd[root@docker ~]# docker exec -it 4004c065d8d4  /bin/bashroot@4004c065d8d4:/usr/local/apache2# ping www.jd.com -c 5PING www.jdcdn.com (112.91.125.129): 56 data bytes64 bytes from 112.91.125.129: icmp_seq=0 ttl=127 time=19.307 ms64 bytes from 112.91.125.129: icmp_seq=1 ttl=127 time=17.492 ms64 bytes from 112.91.125.129: icmp_seq=2 ttl=127 time=21.132 ms64 bytes from 112.91.125.129: icmp_seq=3 ttl=127 time=20.274 ms64 bytes from 112.91.125.129: icmp_seq=4 ttl=127 time=19.644 ms--- www.jdcdn.com ping statistics ---5 packets transmitted, 5 packets received, 0% packet lossround-trip min/avg/max/stddev = 17.492/19.570/21.132/1.211 msroot@4004c065d8d4:/usr/local/apache2# ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever43: eth0@if44: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default    link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff    inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0       valid_lft forever preferred_lft forever</code></pre><p>可以看到我们启动的容器应用是可以ping通外网的，当前的httpd 位于docker0这个bridge私网内，ip地址为172.17.0.3/16，那它是如何与www.jd.com通信的呢？翻阅有关资料，得知是iptables NAT表进行了NAT地址转换，实现这个功能。接下来看看iptables NAT 表的相关信息。</p><pre><code>[root@docker ~]# iptables -t nat -S-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE</code></pre><p>其含义是：如果网桥 docker0 收到来自 172.17.0.0/16 网段的外出包，把它交给 MASQUERADE 处理。而 MASQUERADE 的处理方式是将包的源地址替换成 host 的地址发送出去，即做了一次网络地址转换（NAT）。</p><p>下面我们通过 tcpdump 查看地址是如何转换的,默认路由通过主机ens33 发出去，所以我们要同时监控  ens33 和 docker0 上的 icmp（ping）数据包。</p><p>当httpd容器应用ping www.jd.com的时候，tcpdump输出如下:<br><img src="https://s1.ax1x.com/2018/01/14/ptcAdU.png" alt="pingjd"><br><img src="https://s1.ax1x.com/2018/01/14/ptcEoF.png" alt="tcpdump_docker0"><br>docker0 收到 httpd 的 ping 包，源地址为容器 IP 172.17.0.3，这没问题，交给 MASQUERADE 处理。这时，在 ens333上我们看到了变化,源地址已经转换成ens33 IP地址，期间目的地址都没有发生变化。这就是 iptable NAT 规则处理的结果，从而保证数据包能够到达外网。<br><img src="https://s1.ax1x.com/2018/01/14/ptcYJH.png" alt="tcpdump_ens33"></p><p>因此整个通信过程可以总结如下几点：</p><ul><li>httpd应用向jd.com发送ping包  172.17.0.3 —&gt; 112.91.125.129(jd.com)</li><li>ping包发送到docker0网桥，发现是目的地址是外网地址，交给NAT处理</li><li>NAT将源地址转换成ens33 IP地址，发往外网 192.168.175.40 —&gt; 112.91.125.129(jd.com)</li><li>ping包从ens33发送出去，经过路由到达 jd.com</li></ul><p><strong><em>通过NAT，docker实现了对外网的访问。</em></strong></p><p>整个通信过程图如下：<br><img src="https://s1.ax1x.com/2018/01/14/ptfubq.png" alt="Docker应用于外界通信图"></p><h3 id="外部网络访问容器"><a href="#外部网络访问容器" class="headerlink" title="外部网络访问容器"></a>外部网络访问容器</h3><p>外部网络如何访问到容器,这可能是我们在学习Docker网络的时候会思考得比较多的问题,研究Docker相关的文档会发现,答案是端口映射。docker 可将容器对外提供服务的端口映射到 host 的某个端口,外网通过该端口访问容器。</p><pre><code>[root@docker ~]# docker run -d -p 80 httpd62644d0840faf368e2f136a7eac0256c9aee082417b4ebad9ef5ba46fed19293[root@docker ~]# docker psCONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS                   NAMES62644d0840fa        httpd               &quot;httpd-foreground&quot;   9 seconds ago       Up 3 seconds        0.0.0.0:32768-&gt;80/tcp   gallant_heyrovsky[root@docker ~]# docker port 62644d0840fa80/tcp -&gt; 0.0.0.0:32768[root@docker ~]# docker psCONTAINER ID        IMAGE               COMMAND              CREATED              STATUS              PORTS                   NAMES62644d0840fa        httpd               &quot;httpd-foreground&quot;   About a minute ago   Up 56 seconds       0.0.0.0:32768-&gt;80/tcp   gallant_heyrovsky</code></pre><p>这里我们通过<code>docker run -d -p 80 httpd</code>,指定了容器httpd启动的端口，而主机的端口时随机映射产生的为 <strong><em>32768</em></strong>。这样就可以通过 host ip:32768  访问容器的 web 服务了。</p><p>除了映射动态端口，也可在 -p 中指定映射到 host 某个特定端口，例如可将 80 端口映射到 host 的 8080 端口：</p><pre><code>[root@docker ~]# docker run -d -p 8080:80 httpdae101db7e11a3e04f6529b7a5e80c0fd4c03118f5a89ff777d105e7144f5d213[root@docker ~]# docker psCONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS                   NAMESae101db7e11a        httpd               &quot;httpd-foreground&quot;   8 seconds ago       Up 6 seconds        0.0.0.0:8080-&gt;80/tcp    hungry_bhaskara</code></pre><p>每一个映射的端口，host 都会启动一个 docker-proxy 进程来处理访问容器的流量：</p><pre><code>[root@docker ~]# ps -ef |grep docker-proxyroot      51380  48020  0 09:43 ?        00:00:00 /usr/bin/docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 32768 -container-ip 172.17.0.2 -container-port 80root      51530  48020  0 09:48 ?        00:00:00 /usr/bin/docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 8080 -container-ip 172.17.0.3 -container-port 80</code></pre><p>最后来看看Docker与外网的双向通信拓扑图，做一个总结。<br><img src="https://s1.ax1x.com/2018/01/14/pt4Ch8.png" alt="Docker与外网双向通信拓扑图"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Docker中自带的网络类型&quot;&gt;&lt;a href=&quot;#Docker中自带的网络类型&quot; class=&quot;headerlink&quot; title=&quot;Docker中自带的网络类型&quot;&gt;&lt;/a&gt;Docker中自带的网络类型&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在Docker容器技术中，网络部分算是比较复杂的一部分。了解Docker提供了几种原生的网络，了解容器与外界通信以及外界对容器如何进行访问，这是本文的重点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Docker 安装时会自动在 host 上创建三个网络，我们可用 docker network ls 命令查看：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost ~]# docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
39e6a520b768        bridge              bridge              local
b31da46610a3        host                host                local
7d42c5a35cce        none                null                local
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面我们可以看到三种类型的网络，包括none、host、bridge这三种原生的网络，还有一种container网络用于容器间通信的后面也会做介绍。&lt;/p&gt;
&lt;h3 id=&quot;none网络&quot;&gt;&lt;a href=&quot;#none网络&quot; class=&quot;headerlink&quot; title=&quot;none网络&quot;&gt;&lt;/a&gt;none网络&lt;/h3&gt;&lt;p&gt;none 网络就是什么都没有的网络。挂在这个网络下的容器除了 lo，没有其他任何网卡。容器创建时，可以通过 –network=none 指定使用 none 网络。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@docker ~]# docker run -it --network=none busybox
Unable to find image &amp;apos;busybox:latest&amp;apos; locally
latest: Pulling from library/busybox
fb46b04c527d: Pull complete
Digest: sha256:436bbf48aa1198ebca8eac0ad9a9c80c8929d9242e02608f76ce18334e0cfe6a
Status: Downloaded newer image for busybox:latest
/ # ifconfig
lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里我们可以看到none网络中只有一个lo，没有其他网卡，就是一个封闭的网络，不与外界通信。封闭意味着隔离，一些对安全性要求高并且不需要联网的应用可以使用 none 网络。&lt;/p&gt;
&lt;h3 id=&quot;host网络&quot;&gt;&lt;a href=&quot;#host网络&quot; class=&quot;headerlink&quot; title=&quot;host网络&quot;&gt;&lt;/a&gt;host网络&lt;/h3&gt;&lt;p&gt;连接到 host 网络的容器共享 Docker host 的网络栈，容器的网络配置与宿主机完全一样。可以通过 –network=host 指定使用 host 网络。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@docker ~]# docker run -it --network=host busybox
/ # ifconfig
docker0   Link encap:Ethernet  HWaddr 02:42:02:90:4E:49
          inet addr:172.17.0.1  Bcast:0.0.0.0  Mask:255.255.0.0
          UP BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

ens33     Link encap:Ethernet  HWaddr 00:0C:29:95:F6:22
          inet addr:192.168.175.40  Bcast:192.168.175.255  Mask:255.255.255.0
          inet6 addr: fe80::f1c9:d94d:f12b:990c/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:203380 errors:0 dropped:0 overruns:0 frame:0
          TX packets:73455 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:270648213 (258.1 MiB)  TX bytes:6886880 (6.5 MiB)

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

/ # hostname
docker
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在容器内可以看到所有宿主机的网卡，跟宿主机ifconfig看到的结果时一致的，并且hostname并不是短ID，而是宿主机的hostname。&lt;br&gt;直接使用 Docker host 的网络最大的好处就是性能，如果容器对网络传输效率有较高要求，则可以选择 host 网络。当然不便之处就是牺牲一些灵活性，比如要考虑端口冲突问题，宿主机上已经使用的端口就不能再用了。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker系列" scheme="http://www.chenfanlinux.org/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Docker" scheme="http://www.chenfanlinux.org/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门之容器管理(四)</title>
    <link href="http://www.chenfanlinux.org/2018/01/11/Docker%E5%85%A5%E9%97%A8%E4%B9%8B%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86-%E5%9B%9B/"/>
    <id>http://www.chenfanlinux.org/2018/01/11/Docker入门之容器管理-四/</id>
    <published>2018-01-11T06:45:57.000Z</published>
    <updated>2018-01-26T03:39:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><blockquote><p>docker run 是启动容器的方法。通过前面的Dockerfile 时我们已经学习到，可用三种方式指定容器启动时执行的命令。</p></blockquote><h3 id="容器运行执行的命令"><a href="#容器运行执行的命令" class="headerlink" title="容器运行执行的命令"></a>容器运行执行的命令</h3><p>通过下面三种方式，我们来执行运行在容器中的命令。</p><ul><li>CMD 指令</li><li>ENDPOINT 指令</li><li>在 docker run 命令行中指定</li></ul><h3 id="运行一个容器示例"><a href="#运行一个容器示例" class="headerlink" title="运行一个容器示例"></a>运行一个容器示例</h3><pre><code>[root@docker ~]# docker run ubuntu pwd/[root@docker ~]# docker ps -aCONTAINER ID        IMAGE                                                                      COMMAND                  CREATED              STATUS                          PORTS               NAMESe12b964641c4        ubuntu                                                                     &quot;pwd&quot;                    32 seconds ago       Exited (0) 31 seconds ago                           modest_johnson</code></pre><p><strong>说明：</strong>  此处我们运行一个ubuntu镜像,并运行pwd命令后,容器便退出了,状态为Exited。这种“一闪而过”的容器通常不是我们想要的结果，我们希望容器能够保持 runing 状态，这样才能被我们使用。</p><h3 id="让容器长久的运行"><a href="#让容器长久的运行" class="headerlink" title="让容器长久的运行"></a>让容器长久的运行</h3><p>因为容器的生命周期依赖于启动时执行的命令，只要该命令不结束，容器也就不会退出。理解了这个原理，我们就可以通过执行一个长期运行的命令来保持容器的运行状态。</p><pre><code>[root@docker ~]# docker run ubuntu /bin/bash -c &quot;while true;do sleep 1;done&quot;[root@docker ~]# docker ps -aCONTAINER ID        IMAGE                                                                      COMMAND                  CREATED             STATUS                     PORTS               NAMESd36bbcefec6b        ubuntu                                                                     &quot;/bin/bash -c &apos;while…&quot;   50 seconds ago      Up 49 seconds                                  eager_lumiere</code></pre><p>上面利用执行循环命令，让命令一直执行，容器自然就不会退出(Exited)状态,而是一直运行(Up)状态。但这样终端会被一直占用。可以利用加上参数-d 以后台方式运行容器。</p><pre><code>[root@docker ~]# docker stop d36bbcefec6bd36bbcefec6b[root@docker ~]# docker rm d36bbcefec6bd36bbcefec6b[root@docker ~]# docker run -d ubuntu /bin/bash -c &quot;while true;do sleep 1;done&quot;a141b831a16edbb94ab41553e2be2af79e2d5b68f25877db40750c49cc991649[root@docker ~]# docker ps -aCONTAINER ID        IMAGE                                                                      COMMAND                  CREATED             STATUS                      PORTS               NAMESa141b831a16e        ubuntu</code></pre><p><strong>说明事项：</strong></p><ul><li>CONTAINER ID 是容器的 “短ID”，前面启动容器时返回的是 “长ID”。短ID是长ID的前12个字符。</li><li>NAMES 字段显示容器的名字，在启动容器时可以通过 –name 参数显示地为容器命名，如果不指定，docker 会自动为容器分配名字。</li><li>我们可以利用docker stop CONTAINER ID 停止正在运行的容器，并使用docker rm CONTAINER ID 删除停止的容器;docker run -d COMMAND 以后台的方式运行容器。</li></ul><a id="more"></a><h2 id="进入容器内部"><a href="#进入容器内部" class="headerlink" title="进入容器内部"></a>进入容器内部</h2><blockquote><p>我们经常需要进到容器里去做一些工作，比如查看日志、调试、启动其他进程等。有两种方法进入容器：attach 和 exec。</p></blockquote><h3 id="docker-attach"><a href="#docker-attach" class="headerlink" title="docker attach"></a>docker attach</h3><pre><code>通过 docker attach 可以 attach 到容器启动命令的终端，例如：[root@docker ~]# docker run -d ubuntu /bin/bash -c &quot;while true;do sleep 1;echo &apos;I am in container&apos;;done&quot; 7b0dfb366bcb3259f6ec13e016e1f517b7c56cf0d406fdea4e4215e55cfd7e86</code></pre><p>这次我们通过 “长ID” attach 到了容器的启动命令终端，之后看到的是echo 每隔一秒打印的信息。</p><pre><code>[root@docker ~]# docker attach 7b0dfb366bcb3259f6ec13e016e1f517b7c56cf0d406fdea4e4215e55cfd7e86I am in containerI am in containerI am in containerI am in containerI am in container</code></pre><h3 id="docker-exec"><a href="#docker-exec" class="headerlink" title="docker exec"></a>docker exec</h3><p>通过 docker exec 进入相同的容器：</p><pre><code>[root@docker ~]# docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES7b0dfb366bcb        ubuntu              &quot;/bin/bash -c &apos;while…&quot;   4 minutes ago       Up 4 minutes                            zealous_dubinsky[root@docker ~]# docker exec -it 7b0dfb366bcb  bashroot@7b0dfb366bcb:/# lsbin   dev  home  lib64  mnt  proc  run   srv  tmp  varboot  etc  lib   media  opt  root  sbin  sys  usrroot@7b0dfb366bcb:/# ps -efUID         PID   PPID  C STIME TTY          TIME CMDroot          1      0  0 04:20 ?        00:00:00 /bin/bash -c while true;do sleroot        265      0  0 04:24 pts/0    00:00:00 bashroot        279      1  0 04:24 ?        00:00:00 sleep 1root        280    265  0 04:24 pts/0    00:00:00 ps -ef</code></pre><p><strong>说明事项：</strong></p><ul><li>-it 以交互模式打开 pseudo-TTY，执行 bash，其结果就是打开了一个 bash 终端</li><li>进入到容器中，容器的 hostname 就是其 “短ID”</li><li>可以像在普通 Linux 中一样执行命令。ps -elf 显示了容器启动进程while 以及当前的 bash 进程</li><li>执行 exit 退出容器，回到 docker host</li><li>docker exec -it <container> bash|sh 是执行 exec 最常用的方式</container></li></ul><h3 id="attach-对比-exec"><a href="#attach-对比-exec" class="headerlink" title="attach 对比 exec"></a>attach 对比 exec</h3><ul><li>attach 直接进入容器 启动命令 的终端，不会启动新的进程。</li><li>exec 则是在容器中打开新的终端，并且可以启动新的进程。</li><li>如果想直接在终端中查看启动命令的输出，用 attach；其他情况使用 exec。</li></ul><p>当然，如果只是为了查看启动命令的输出，可以使用 docker logs 命令</p><pre><code>[root@docker ~]# docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES7b0dfb366bcb        ubuntu              &quot;/bin/bash -c &apos;while…&quot;   10 minutes ago      Up 10 minutes                           zealous_dubinskya141b831a16e        ubuntu              &quot;/bin/bash -c &apos;while…&quot;   25 minutes ago      Up 25 minutes                           ecstatic_pasteur[root@docker ~]# docker logs -f 7b0dfb366bcbI am in containerI am in containerI am in containerI am in containerI am in containerI am in containerI am in containerI am in container</code></pre><h2 id="运行Docker的最佳实践"><a href="#运行Docker的最佳实践" class="headerlink" title="运行Docker的最佳实践"></a>运行Docker的最佳实践</h2><blockquote><p>按用途容器大致可分为两类：服务类容器和工具类的容器。</p></blockquote><h3 id="容器功能分类"><a href="#容器功能分类" class="headerlink" title="容器功能分类"></a>容器功能分类</h3><ul><li><p>服务类容器以 daemon 的形式运行，对外提供服务。比如 web server，数据库等。通过 -d 以后台方式启动这类容器是非常合适的。如果要排查问题，可以通过 exec -it 进入容器。</p></li><li><p>工具类容器通常给能我们提供一个临时的工作环境，工具类容器多使用基础镜像，例如 busybox、debian、ubuntu 等，通常以 run -it 方式运行。</p><p>  <code>[root@docker ~]# docker run -it busybox</code><br>  <code>/ # ping www.baidu.com</code><br>  <code>PING www.baidu.com (14.215.177.39): 56 data bytes</code><br>  <code>64 bytes from 14.215.177.39: seq=0 ttl=127 time=5.724 ms</code><br>  <code>64 bytes from 14.215.177.39: seq=1 ttl=127 time=4.829 ms</code></p></li></ul><p>运行 busybox，run -it 的作用是在容器启动后就直接进入。我们这里通过 ping 验证了在容器中访问 internet 的能力。执行 exit 退出终端，同时容器停止。</p><h3 id="容器运行小结"><a href="#容器运行小结" class="headerlink" title="容器运行小结"></a>容器运行小结</h3><p><strong>容器运行相关的知识点：</strong></p><ul><li>当 CMD 或 Entrypoint 或 docker run 命令行指定的命令运行结束时，容器停止。</li><li>通过 -d 参数在后台启动容器。</li><li>通过 exec -it 可进入容器并执行命令。</li></ul><p><strong>指定容器的三种方法：</strong></p><ul><li>短ID</li><li>长ID</li><li>容器名称，可通过 –name 为容器命名</li></ul><p><strong>容器按用途可分为两类：</strong></p><ul><li><p>服务类的容器</p></li><li><p>工具类的容器</p></li></ul><h2 id="常见的容器操作"><a href="#常见的容器操作" class="headerlink" title="常见的容器操作"></a>常见的容器操作</h2><blockquote><p>对容器的生命周期有了大致的理解，下面这张状态机很好地总结了容器各种状态之间是如何转换的。</p></blockquote><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/KLl95a" alt="docker状态转换图"></p><h3 id="create容器"><a href="#create容器" class="headerlink" title="create容器"></a>create容器</h3><p>可以先创建容器，稍后再启动。</p><pre><code>[root@docker ~]# docker create httpdUnable to find image &apos;httpd:latest&apos; locallylatest: Pulling from library/httpdf49cf87b52c1: Pull complete02ca099fb6cd: Pull completede7acb18da57: Pull complete770c8edb393d: Pull complete0e252730aeae: Pull complete6e6ca341873f: Pull complete2daffd0a6144: Pull completeDigest: sha256:fb6b4d40e0a2ab5beb7a40b440b012f49642b45163034c6eb36233b433e8e741Status: Downloaded newer image for httpd:latest910bb90c15f5bcd8976c9c43a882f49fcd781074e7999722b04f07b852f7d1d7[root@docker ~]# docker ps -a |grep httpd910bb90c15f5        httpd               &quot;httpd-foreground&quot;       4 minutes ago       Created                                 distracted_kirch</code></pre><h3 id="start容器"><a href="#start容器" class="headerlink" title="start容器"></a>start容器</h3><p>对于处于停止状态的容器，可以通过 docker start 重新启动。</p><pre><code>[root@docker ~]# docker ps -a |grep httpd910bb90c15f5        httpd               &quot;httpd-foreground&quot;       4 minutes ago       Created                                 distracted_kirch[root@docker ~]# docker start 910bb90c15f5910bb90c15f5[root@docker ~]# docker ps -a |grep httpd910bb90c15f5        httpd               &quot;httpd-foreground&quot;       6 minutes ago       Up 1 second         80/tcp              distracted_kirch</code></pre><h3 id="run容器"><a href="#run容器" class="headerlink" title="run容器"></a>run容器</h3><p>启动容器包括到容器的创建，然后启动容器两个步骤。<br>docker run = docker create + dokcer start</p><pre><code>[root@docker ~]# docker run -it busybox/ #</code></pre><h3 id="stop容器"><a href="#stop容器" class="headerlink" title="stop容器"></a>stop容器</h3><p>容器在 docker host 中实际上是一个进程，docker stop 命令本质上是向该进程发送一个 SIGTERM 信号。</p><pre><code>[root@docker ~]# docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMESf55bae074567        busybox             &quot;sh&quot;                     2 hours ago         Up 2 hours                              affectionate_ramanujan7b0dfb366bcb        ubuntu              &quot;/bin/bash -c &apos;while…&quot;   2 hours ago         Up 2 hours                              zealous_dubinskya141b831a16e        ubuntu              &quot;/bin/bash -c &apos;while…&quot;   2 hours ago         Up 2 hours                              ecstatic_pasteur[root@docker ~]# docker stop 7b0dfb366bcb7b0dfb366bcb[root@docker ~]# docker ps -aCONTAINER ID        IMAGE                                                                      COMMAND                  CREATED             STATUS                        PORTS               NAMESf55bae074567        busybox                                                                    &quot;sh&quot;                     2 hours ago         Up 2 hours                                        affectionate_ramanujan7b0dfb366bcb        ubuntu                                                                     &quot;/bin/bash -c &apos;while…&quot;   2 hours ago         Exited (137) 47 seconds ago</code></pre><h3 id="kill容器"><a href="#kill容器" class="headerlink" title="kill容器"></a>kill容器</h3><p>如果想快速停止容器，可使用 docker kill 命令，其作用是向容器进程发送 SIGKILL 信号。</p><pre><code>[root@docker ~]# docker ps -a |grep httpd910bb90c15f5        httpd               &quot;httpd-foreground&quot;       8 minutes ago       Up About a minute   80/tcp              distracted_kirch[root@docker ~]# docker kill  910bb90c15f5910bb90c15f5[root@docker ~]# docker ps -a |grep httpd910bb90c15f5        httpd               &quot;httpd-foreground&quot;       8 minutes ago       Exited (137) 5 seconds ago                       distracted_kirch</code></pre><h3 id="pause-容器"><a href="#pause-容器" class="headerlink" title="pause 容器"></a>pause 容器</h3><p>有时我们只是希望暂时让容器暂停工作一段时间，比如要对容器的文件系统打个快照，或者 dcoker host 需要使用 CPU，这时可以执行 docker pause。</p><pre><code>[root@docker ~]# docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMESf55bae074567        busybox             &quot;sh&quot;                     2 hours ago         Up 2 hours                              affectionate_ramanujan7b0dfb366bcb        ubuntu              &quot;/bin/bash -c &apos;while…&quot;   2 hours ago         Up 2 minutes                            zealous_dubinskya141b831a16e        ubuntu              &quot;/bin/bash -c &apos;while…&quot;   2 hours ago         Up 2 hours                              ecstatic_pasteur[root@docker ~]# docker pause f55bae074567f55bae074567[root@docker ~]# docker ps -a |grep f55bae074567f55bae074567        busybox                                                                    &quot;sh&quot;                     2 hours ago         Up 2 hours (Paused)                            affectionate_ramanujan</code></pre><h3 id="unpause容器"><a href="#unpause容器" class="headerlink" title="unpause容器"></a>unpause容器</h3><p>处于暂停状态的容器不会占用 CPU 资源，直到通过 docker unpause 恢复运行。</p><pre><code>[root@docker ~]# docker unpause f55bae074567f55bae074567[root@docker ~]# docker ps -a |grep f55bae074567f55bae074567        busybox                                                                    &quot;sh&quot;                     2 hours ago         Up 2 hours                                     affectionate_ramanujan</code></pre><h3 id="rm容器"><a href="#rm容器" class="headerlink" title="rm容器"></a>rm容器</h3><p>使用 docker 一段时间后，host 上可能会有大量已经退出了的容器，这些容器依然会占用 host 的文件系统资源，如果确认不会再重启此类容器，可以通过 docker rm 删除。</p><pre><code>[root@docker ~]# docker ps -a |grep &apos;Exited&apos;e12b964641c4        ubuntu                                                                     &quot;pwd&quot;                    3 hours ago         Exited (0) 3 hours ago                         modest_johnson97eb5d978d46        ubuntu                                                                     &quot;ls&quot;                     3 hours ago         Exited (0) 3 hours ago</code></pre><p>docker rm 一次可以指定多个容器，如果希望批量删除所有已经退出的容器，可以执行如下命令：</p><p><code>docker rm -v $(docker ps -aq -f status=exited)</code></p><pre><code>[root@docker ~]# docker rm -v $(docker ps -aq -f status=exited)e12b964641c497eb5d978d462f5aa14aaa655fb431cd6d5b81fede2842bf28933756a14ab6df60142950[root@docker ~]# docker ps -a |grep &apos;Exited&apos;[root@docker ~]#</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;运行容器&quot;&gt;&lt;a href=&quot;#运行容器&quot; class=&quot;headerlink&quot; title=&quot;运行容器&quot;&gt;&lt;/a&gt;运行容器&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;docker run 是启动容器的方法。通过前面的Dockerfile 时我们已经学习到，可用三种方式指定容器启动时执行的命令。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;容器运行执行的命令&quot;&gt;&lt;a href=&quot;#容器运行执行的命令&quot; class=&quot;headerlink&quot; title=&quot;容器运行执行的命令&quot;&gt;&lt;/a&gt;容器运行执行的命令&lt;/h3&gt;&lt;p&gt;通过下面三种方式，我们来执行运行在容器中的命令。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CMD 指令&lt;/li&gt;
&lt;li&gt;ENDPOINT 指令&lt;/li&gt;
&lt;li&gt;在 docker run 命令行中指定&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;运行一个容器示例&quot;&gt;&lt;a href=&quot;#运行一个容器示例&quot; class=&quot;headerlink&quot; title=&quot;运行一个容器示例&quot;&gt;&lt;/a&gt;运行一个容器示例&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;[root@docker ~]# docker run ubuntu pwd
/
[root@docker ~]# docker ps -a
CONTAINER ID        IMAGE                                                                      COMMAND                  CREATED              STATUS                          PORTS               NAMES
e12b964641c4        ubuntu                                                                     &amp;quot;pwd&amp;quot;                    32 seconds ago       Exited (0) 31 seconds ago                           modest_johnson
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;  此处我们运行一个ubuntu镜像,并运行pwd命令后,容器便退出了,状态为Exited。这种“一闪而过”的容器通常不是我们想要的结果，我们希望容器能够保持 runing 状态，这样才能被我们使用。&lt;/p&gt;
&lt;h3 id=&quot;让容器长久的运行&quot;&gt;&lt;a href=&quot;#让容器长久的运行&quot; class=&quot;headerlink&quot; title=&quot;让容器长久的运行&quot;&gt;&lt;/a&gt;让容器长久的运行&lt;/h3&gt;&lt;p&gt;因为容器的生命周期依赖于启动时执行的命令，只要该命令不结束，容器也就不会退出。理解了这个原理，我们就可以通过执行一个长期运行的命令来保持容器的运行状态。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@docker ~]# docker run ubuntu /bin/bash -c &amp;quot;while true;do sleep 1;done&amp;quot;
[root@docker ~]# docker ps -a
CONTAINER ID        IMAGE                                                                      COMMAND                  CREATED             STATUS                     PORTS               NAMES
d36bbcefec6b        ubuntu                                                                     &amp;quot;/bin/bash -c &amp;apos;while…&amp;quot;   50 seconds ago      Up 49 seconds                                  eager_lumiere
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面利用执行循环命令，让命令一直执行，容器自然就不会退出(Exited)状态,而是一直运行(Up)状态。但这样终端会被一直占用。可以利用加上参数-d 以后台方式运行容器。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@docker ~]# docker stop d36bbcefec6b
d36bbcefec6b
[root@docker ~]# docker rm d36bbcefec6b
d36bbcefec6b
[root@docker ~]# docker run -d ubuntu /bin/bash -c &amp;quot;while true;do sleep 1;done&amp;quot;
a141b831a16edbb94ab41553e2be2af79e2d5b68f25877db40750c49cc991649

[root@docker ~]# docker ps -a
CONTAINER ID        IMAGE                                                                      COMMAND                  CREATED             STATUS                      PORTS               NAMES
a141b831a16e        ubuntu
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;说明事项：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CONTAINER ID 是容器的 “短ID”，前面启动容器时返回的是 “长ID”。短ID是长ID的前12个字符。&lt;/li&gt;
&lt;li&gt;NAMES 字段显示容器的名字，在启动容器时可以通过 –name 参数显示地为容器命名，如果不指定，docker 会自动为容器分配名字。&lt;/li&gt;
&lt;li&gt;我们可以利用docker stop CONTAINER ID 停止正在运行的容器，并使用docker rm CONTAINER ID 删除停止的容器;docker run -d COMMAND 以后台的方式运行容器。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Docker系列" scheme="http://www.chenfanlinux.org/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Docker" scheme="http://www.chenfanlinux.org/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门之Dockerfile最佳实践(三)</title>
    <link href="http://www.chenfanlinux.org/2018/01/10/Docker%E5%85%A5%E9%97%A8%E4%B9%8BDockerfile%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E4%B8%89/"/>
    <id>http://www.chenfanlinux.org/2018/01/10/Docker入门之Dockerfile最佳实践-三/</id>
    <published>2018-01-10T09:21:22.000Z</published>
    <updated>2018-01-26T03:39:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="认识Dockerfile"><a href="#认识Dockerfile" class="headerlink" title="认识Dockerfile"></a>认识Dockerfile</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Dockerfile是一个文本格式的配置文件，用户可以使用Dockerfile快速构建自定义的镜像。 下面展示一个规范的DockerFile文件。</p><pre><code>## DOCKER-VERSION    1.12.6# Dockerizing ubuntu14.04: Dockerfile for building ubuntu images## 非注释首行必须指定基础镜像FROM ubuntu:14.04# 维护者信息MAINTAINER chenfan &lt;1144102576@qq.com&gt;# 指定环境变量ENV TZ &quot;Asia/Shanghai&quot;ENV TERM xterm# 拷贝文件(Dockerfile所在目录的相对路径)到容器中ADD sources.list /etc/apt/sources.listCOPY .bash_aliases /root/.bash_aliases# 在当前镜像的基础上执行指定命令并提交为新的镜像RUN \    apt-get update &amp;&amp; \    apt-get -y upgrade &amp;&amp; \    apt-get install -y build-essential &amp;&amp; \    apt-get install -y software-properties-common &amp;&amp; \    apt-get install -y curl htop unzip vim wget &amp;&amp; \    rm -rf /var/lib/apt/lists/*# 指定工作目录WORKDIR /root# 暴露的端口号(映射端口)EXPOSE 22# 指定容器启动时，默认运行的命令CMD [&quot;/bin/bash&quot;]</code></pre><a id="more"></a><h2 id="指令详解"><a href="#指令详解" class="headerlink" title="指令详解"></a>指令详解</h2><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><ul><li>描述：用于指定基础镜像，且非注释首行必须是FROM；</li><li>格式：FROM  &lt;image&gt; [:&lt;tag&gt;]</li></ul><h3 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h3><ul><li>描述：指定维护者信息；</li><li>格式：MAINTAINER &lt;name&gt; &lt;email&gt;</li></ul><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><ul><li>描述：在当前镜像基础上执行指定命令，并提交为新的镜像，当命令较长时可以使用\来换行,RUN命令经常被用作安装软件包；</li><li>格式：<ul><li>使用shell终端运行命令，即/bin/sh -c：RUN &lt;command&gt;</li><li>使用exec执行，使用其他终端时可使用：RUN [“executable”, “param”, “param”…]</li></ul></li></ul><ul><li>示例：<br><code>RUN [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;echo hello&quot;]</code></li></ul><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><ul><li>描述：指定启动容器时执行的命令，且每个Dockerfile仅能拥有一条CMD指令，若有多条，仅最后一条被执行，若用户在启动容器时指定了运行命令，则会覆盖掉CMD指定的命令；</li><li>格式：<ul><li>CMD [“executable”,”param1”,”param2”] (exec form, this is the preferred form)</li><li>CMD [“param1”,”param2”] (as default parameters to ENTRYPOINT)</li><li>CMD command param1 param2 (shell form)</li><li>第一种用法：运行一个可执行的文件并提供参数。</li><li>第二种用法：为ENTRYPOINT指定参数。</li><li>第三种用法(shell form)：是以”/bin/sh -c”的方法执行的命令。</li></ul></li></ul><p><strong>注意</strong>：CMD可以为ENTRYPOINT提供参数，ENTRYPOINT本身也可以包含参数，但是你可以把那些可能需要变动的参数写到CMD里而把那些不需要变动的参数写到ENTRYPOINT里面。把可能需要变动的参数写到CMD里面。然后你可以在docker run里指定参数，CMD里的参数就会被覆盖掉而ENTRYPOINT里的不被覆盖。</p><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><ul><li>描述：指定容器暴露的端口号，在启动容器时需要通过参数-P或-p来映射；</li><li>格式：EXPOSE &lt;port&gt;[ &lt;port&gt;…]</li><li>示例：<code>EXPOSE 22 80 443</code></li></ul><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><ul><li>描述：指定一个环境变量，供后续的RUN指令使用，并持久在容器中；</li><li>格式：ENV &lt;key&gt; &lt;value&gt;</li></ul><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><ul><li>描述：拷贝文件(Dockerfile所在目录的相对路径或是URL)到容器中，若源文件为归档文件(tar、zip、tgz等)，自动解压为目录；</li><li>格式：ADD &lt;src&gt; &lt;dest&gt;</li></ul><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><ul><li>描述：将文件从 build context 复制到镜像。</li><li>格式：COPY &lt;src&gt; &lt;dest&gt;</li><li>注意：只能复制build context内的文件或目录。</li></ul><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><ul><li>描述：指定启动容器时执行的命令，且不可被覆盖，每个Dockerfile仅能拥有一条ENTRYPOINT指令，若有多条，仅最后一条被执行；</li><li>格式：<ul><li>使用exec执行(推荐使用)：ENTRYPOINT [“executable”, “param”, “param”…]</li><li>使用shell终端运行命令，供需交互的应用使用：ENTRYPOINT &lt;command&gt; &lt;param&gt; &lt;param&gt;…</li></ul></li></ul><p>注意：</p><ul><li>ENTRYPOINT接收来自于docker run和CMD提供的额外参数,docker run会覆盖CMD的参数；将可变的参数放在CMD中,不变的参数放置于ENTRYPOINT中。</li><li>ENTRYPOINT有两种写法,推荐使用exec格式，第二种(shell form)会屏蔽掉docker run时后面加的命令和CMD里的参数。</li><li>ENTRYPOINT并不默认为[“/bin/sh -c”]</li></ul><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><ul><li>描述：创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库与持久化数据等；</li><li>格式：VOLUME [“/data”]</li></ul><h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><ul><li>描述：指定运行容器时的用户名或UID，供后续的RUN指令使用，并持久在容器中；</li><li>格式：USER daemon</li></ul><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><ul><li>描述：指定当前工作目录，相当于cd命令，供后续的RUN、CMD、ENTRYPOINT指令使用；</li><li>格式：WORKDIR &lt;path&gt;</li></ul><h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><ul><li>描述：配置当所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令；</li><li>格式：ONBUILD [INSTRUCTION]</li><li>示例：<code>ONBUILD RUN apt-get update</code></li></ul><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><h3 id="构建镜像的步骤"><a href="#构建镜像的步骤" class="headerlink" title="构建镜像的步骤"></a>构建镜像的步骤</h3><ul><li>将Dockerfile文件编写完成以后，可以通过docker build命令来创建镜像；</li><li>构建镜像时，推荐将需要使用的包及Dockerfile文件放在同一个目录中；</li><li>若需要指定镜像的标签信息，使用-t选项,系统默认从build context目录下去寻找Dockerfile，也可以通过-f选项指定Dockerfile的位置。</li></ul><h3 id="Dockerfile执行步骤"><a href="#Dockerfile执行步骤" class="headerlink" title="Dockerfile执行步骤"></a>Dockerfile执行步骤</h3><ul><li>从 base 镜像运行一个容器。</li><li>执行一条指令，对容器做修改。</li><li>执行类似 docker commit 的操作，生成一个新的镜像层。</li><li>Docker 再基于刚刚提交的镜像运行一个新容器。</li><li>重复 2-4 步，直到 Dockerfile 中的所有指令执行完毕</li></ul><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul><li>使用 RUN 指令安装应用和软件包，构建镜像。  </li><li>如果 Docker 镜像的用途是运行应用程序或服务，比如运行一个 MySQL，应该优先使用 Exec 格式的 ENTRYPOINT 指令。CMD 可为 ENTRYPOINT 提供额外的默认参数，同时可利用 docker run 命令行替换默认参数。 </li><li>如果想为容器设置默认的启动命令，可使用 CMD 指令。用户可在 docker run 命令行中替换此默认命令。  </li></ul><h3 id="构建镜像示例"><a href="#构建镜像示例" class="headerlink" title="构建镜像示例"></a>构建镜像示例</h3><p><strong>格式：</strong></p><p><code>docker build -t ubuntu:chenfan PATH -f Dockerfile_Path .</code></p><p><strong>说明：</strong><br>运行 docker build 命令，-t 将新镜像命名为 ubuntu:chenfan，命令末尾的 . 指明 build context 为当前目录。Docker 默认会从 build context 中查找 Dockerfile 文件，我们也可以通过 -f 参数指定 Dockerfile 的位置。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;认识Dockerfile&quot;&gt;&lt;a href=&quot;#认识Dockerfile&quot; class=&quot;headerlink&quot; title=&quot;认识Dockerfile&quot;&gt;&lt;/a&gt;认识Dockerfile&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;Dockerfile是一个文本格式的配置文件，用户可以使用Dockerfile快速构建自定义的镜像。 下面展示一个规范的DockerFile文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#
# DOCKER-VERSION    1.12.6
# Dockerizing ubuntu14.04: Dockerfile for building ubuntu images
#

# 非注释首行必须指定基础镜像
FROM ubuntu:14.04
# 维护者信息
MAINTAINER chenfan &amp;lt;1144102576@qq.com&amp;gt;

# 指定环境变量
ENV TZ &amp;quot;Asia/Shanghai&amp;quot;
ENV TERM xterm

# 拷贝文件(Dockerfile所在目录的相对路径)到容器中
ADD sources.list /etc/apt/sources.list
COPY .bash_aliases /root/.bash_aliases

# 在当前镜像的基础上执行指定命令并提交为新的镜像
RUN \
    apt-get update &amp;amp;&amp;amp; \
    apt-get -y upgrade &amp;amp;&amp;amp; \
    apt-get install -y build-essential &amp;amp;&amp;amp; \
    apt-get install -y software-properties-common &amp;amp;&amp;amp; \
    apt-get install -y curl htop unzip vim wget &amp;amp;&amp;amp; \
    rm -rf /var/lib/apt/lists/*

# 指定工作目录
WORKDIR /root

# 暴露的端口号(映射端口)
EXPOSE 22

# 指定容器启动时，默认运行的命令
CMD [&amp;quot;/bin/bash&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Docker系列" scheme="http://www.chenfanlinux.org/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Docker" scheme="http://www.chenfanlinux.org/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门之镜像管理(二)</title>
    <link href="http://www.chenfanlinux.org/2018/01/10/Docker%E5%85%A5%E9%97%A8%E4%B9%8B%E9%95%9C%E5%83%8F%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%AE%A1%E7%90%86-%E4%BA%8C/"/>
    <id>http://www.chenfanlinux.org/2018/01/10/Docker入门之镜像基础概念与管理-二/</id>
    <published>2018-01-10T07:35:23.000Z</published>
    <updated>2018-01-26T03:39:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="认识最小的镜像（hello-world-）"><a href="#认识最小的镜像（hello-world-）" class="headerlink" title="认识最小的镜像（hello-world ）"></a>认识最小的镜像（hello-world ）</h2><blockquote><p>镜像是 Docker 容器的基石，容器是镜像的运行实例，有了镜像才能启动容器。理解清楚镜像的内部结构,我们才能够按照需求构建符合要求的镜像。hello-world 是 Docker 官方提供的一个镜像，通常用来验证 Docker 是否安装成功。</p></blockquote><p>我们先通过 docker pull 从 Docker Hub 下载它</p><pre><code>[root@docker ~]# docker pull hello-worldUsing default tag: latestlatest: Pulling from library/hello-worldca4f61b1923c: Pull completeDigest: sha256:ca0eeb6fb05351dfc8759c20733c91def84cb8007aa89a5bf606bc8b315b9fc7Status: Downloaded newer image for hello-world:latest</code></pre><p>可以使用 docker images 命令查看镜像的信息，可以看到镜像非常的小,只有1.85k</p><pre><code>[root@docker ~]# docker images |grep hello-worldhello-world  latest       f2a91732366c     6 weeks ago         1.85kB</code></pre><p>最后通过 docker run 运行镜像</p><pre><code>[root@docker ~]# docker run hello-worldHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.    (amd64) 3. The Docker daemon created a new container from that image which runs the    executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it    to your terminal.</code></pre><p>那么该镜像运行怎么就输出上面这一串信息的呢？如果对 Docker 了解一点的话自然会去找该镜像的 Dockerfile，Dockerfile 详细描述了该镜像是如何建立的以及运行时执行的命令。从 Docker Hub 上 <a href="https://hub.docker.com/r/library/hello-world/" target="_blank" rel="noopener">hello-world</a> 的库简介 找到其 <a href="https://github.com/docker-library/hello-world/blob/b7a78b7ccca62cc478919b101f3ab1334899df2b/Dockerfile" target="_blank" rel="noopener">Dockerfile</a> 在 github 上，简简单单的三条语句。</p><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/4q6B6C" alt="hello-world Dockerfile"><br><strong>hello-world的Dockerfile如下:</strong></p><pre><code>FROM scratchADD hello /CMD [&quot;/hello&quot;]</code></pre><ul><li><p>第一条FROM指令是 Docker 用来指定该镜像是基于哪个基础镜像构建的，这里指定为 scratch，实际上 scratch 镜像是一个空镜像，用来构建基础镜像或者极小的镜像。</p></li><li><p>第二条ADD指令表示从 Dockerfile 所在目录拷贝文件到指定路径下，这里拷贝 hello 文件到根目录下，这里的hello文件是一个二进制可执行文件。</p></li><li><p>第三条CMD指令用来指示当运行 docker run 命令运行该镜像时要执行的命令，这里执行 /hello，就是执行第二步拷贝到根目录下的 hello 文件。</p><a id="more"></a></li></ul><h2 id="认识base镜像-centos"><a href="#认识base镜像-centos" class="headerlink" title="认识base镜像(centos)"></a>认识base镜像(centos)</h2><blockquote><p>hello-world 虽然是一个完整的镜像，但它并没有什么实际用途。通常来说，我们希望镜像能提供一个基本的操作系统环境，用户可以根据需要安装和配置软件。这样的镜像我们称作 base 镜像。base镜像具有两层含义,首先base镜像不依赖其他镜像，从 scratch 构建;另外其他镜像可以之为基础进行扩展。</p></blockquote><h3 id="拉取centos镜像"><a href="#拉取centos镜像" class="headerlink" title="拉取centos镜像"></a>拉取centos镜像</h3><p>能称作 base 镜像的通常都是各种 Linux 发行版的 Docker 镜像，比如 Ubuntu, Debian, CentOS 等。下面我们以centos为例,来分析一下Centos镜像是如何构建的。</p><pre><code>[root@docker ~]# docker pull centosUsing default tag: latestlatest: Pulling from library/centosDigest: sha256:3b1a65e9a05f0a77b5e8a698d3359459904c2a354dc3b25ae2e2f5c95f0b3667Status: Image is up to date for centos:latest[root@docker ~]# docker images centosREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEcentos              latest              3fa822599e10        5 weeks ago         204MB</code></pre><p>我们上面拉取到的centos大小就204M左右,而我们平时装的系统有几个GB大小,这是为啥呢？下面解释一下。对于 base 镜像来说，底层直接用 Host 的 kernel，自己只需要提供 rootfs 就行了。<br>而对于一个精简的 OS，rootfs 可以很小，只需要包括最基本的命令、工具和程序库就可以了。相比其他 Linux 发行版，CentOS 的 rootfs 已经算臃肿的了,alpine 还不到 10MB。</p><h3 id="认识Docker文件系统"><a href="#认识Docker文件系统" class="headerlink" title="认识Docker文件系统"></a>认识Docker文件系统</h3><p>典型的Linux文件系统由bootfs和rootfs两部分组成，bootfs(boot file system)主要包含 bootloader和kernel，bootloader主要是引导加载kernel，当kernel被加载到内存中后 bootfs就被umount了。 用户空间的文件系统rootfs (root file system) 包含的就是典型 Linux 系统中的/dev，/proc，/bin，/etc等标准目录和文件。Docker在启动容器的时候，需要创建文件系统，为rootfs提供挂载点。<br><img src="https://cdn-std.dprcdn.net/files/acc_582513/7MiXuC" alt="典型的文件系统"></p><p>Docker容器是建立在Aufs基础上的，Aufs是一种Union FS， 简单来说就是支持将不同的目录挂载到同一个虚拟文件系统下，并实现一种layer的概念。Aufs将挂载到同一虚拟文件系统下的多个目录分别设置成read-only，read-write以及whiteout-able权限，对read-only目录只能读，而写操作只能实施在read-write目录中。重点在于，写操作是在read-only上的一种增量操作，不影响read-only目录。当挂载目录的时候要严格按照各目录之间的这种增量关系，将被增量操作的目录优先于在它基础上增量操作的目录挂载，待所有目录挂载结束了，继续挂载一个read-write目录，如此便形成了一种层次结构。</p><p>Docker镜像的典型结构如下图。传统的Linux加载bootfs时会先将rootfs设为read-only，然后在系统自检之后将rootfs从read-only改为read-write，然后我们就可以在rootfs上进行写和读的操作了。但Docker的镜像却不是这样，它在bootfs自检完毕之后并不会把rootfs的read-only改为read-write。而是利用union mount（UnionFS的一种挂载机制）将一个或多个read-only的rootfs加载到之前的read-only的rootfs层之上。在加载了这么多层的rootfs之后，仍然让它看起来只像是一个文件系统，在Docker的体系里把union mount的这些read-only的rootfs叫做Docker的镜像。但是，此时的每一层rootfs都是read-only的，我们此时还不能对其进行操作。当我们创建一个容器，也就是将Docker镜像进行实例化，系统会在一层或是多层read-only的rootfs之上分配一层空的read-write的rootfs。</p><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/Lyk5KF" alt="Docker文件系统"></p><h2 id="认识centos镜像的Dockerfile"><a href="#认识centos镜像的Dockerfile" class="headerlink" title="认识centos镜像的Dockerfile"></a>认识centos镜像的Dockerfile</h2><blockquote><p>这些基础镜像的Dockerfile,我们可以在Docker hub上搜索到,cenots的<a href="https://github.com/CentOS/sig-cloud-instance-images/blob/37e0a7f3d98ae875dac7ae1026e99c1c04524c62/docker/Dockerfile" target="_blank" rel="noopener">dockerfile</a>如下,我们可以来分析dockerfile文件,知道整个镜像的构建过程。</p></blockquote><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/WFgiMJ" alt="ceonts_dockerfile"></p><pre><code>FROM scratchADD centos-7-docker.tar.xz /LABEL name=&quot;CentOS Base Image&quot; \    vendor=&quot;CentOS&quot; \    license=&quot;GPLv2&quot; \    build-date=&quot;20171128&quot;CMD [&quot;/bin/bash&quot;]</code></pre><p>第一行是上面我们讲到scratch最小的镜像源,第二行 ADD 指令添加到镜像的 tar 包就是 CentOS 7 的 rootfs。在制作镜像时,这个 tar 包会自动解压到 / 目录下,生成 /dev、 /porc、/bin 等目录,最后就是运行一个伪终端。</p><p><strong>支持运行多种 Linux OS</strong></p><p>不同 Linux 发行版的区别主要就是 rootfs。<br><img src="https://cdn-std.dprcdn.net/files/acc_582513/EBn4fs" alt="rootfs"><br>比如 Ubuntu 14.04 使用 upstart 管理服务，apt 管理软件包；而 CentOS 7 使用 systemd 和 yum。这些都是用户空间上的区别，Linux kernel 差别不大。所以 Docker 可以同时支持多种 Linux 镜像，模拟出多种操作系统环境,但都共用宿主机的内核，只是用户空间进行了隔离。</p><h2 id="认识镜像的分层结构"><a href="#认识镜像的分层结构" class="headerlink" title="认识镜像的分层结构"></a>认识镜像的分层结构</h2><blockquote><p>实际工作中,我们的镜像大部分都是通过在base镜像中安装与配置需要的软件构建而成。</p></blockquote><p>比如我现在构建一个新的镜像，Dockerfile如下：</p><pre><code>FROM debainRUN apt-get   install emacsRUN apt-get  install apacheCMD [&quot;/bin/bash&quot;]</code></pre><p>分层架构如下：</p><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/GwQiZh" alt=""><br>可以看到，新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层。</p><p><strong>问什么 Docker 镜像要采用这种分层结构呢？</strong><br>有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。当多个镜像共享一份基础镜像，某个容器修改基础镜像中的内容，比如/dev下面的内容，其他容器不会被修改。这是因为在容器启动后，一个新的可写层被加载到镜像顶部，这一层通常被称为”容器层”，容器层是可写的，镜像层是可读的。在容器层中，用户看到的是一个叠加之后的文件系统。</p><p><strong>容器层的细节如何？</strong><br>镜像层数量可能会很多，所有镜像层会联合在一起组成一个统一的文件系统。比如/etc/abc,上层的/etc/abc会覆盖下层的/etc/abc，用户看到的就是最上层的/etc/abc内容。只有当需要修改时才复制一份数据，这种特性被称作 <a href="https://zh.wikipedia.org/wiki/%E5%AF%AB%E5%85%A5%E6%99%82%E8%A4%87%E8%A3%BD" target="_blank" rel="noopener">Copy-on-Write</a>。可见，容器层保存的是镜像变化的部分，不会对镜像本身进行任何修改。这样就解释了我们前面提出的问题：容器层记录对镜像的修改，所有镜像层都是只读的，不会被容器修改，所以镜像可以被多个容器共享。</p><ul><li><p>添加文件<br>在容器中创建文件时，新文件被添加到容器层中。</p></li><li><p>读取文件<br>在容器中读取某个文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，打开并读入内存。</p></li><li><p>修改文件<br>在容器中修改已存在的文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，立即将其复制到容器层，然后修改之。</p></li><li><p>删除文件<br>在容器中删除文件时，Docker 也是从上往下依次在镜像层中查找此文件。找到后，会在容器层中记录下此删除操作。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;认识最小的镜像（hello-world-）&quot;&gt;&lt;a href=&quot;#认识最小的镜像（hello-world-）&quot; class=&quot;headerlink&quot; title=&quot;认识最小的镜像（hello-world ）&quot;&gt;&lt;/a&gt;认识最小的镜像（hello-world ）&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;镜像是 Docker 容器的基石，容器是镜像的运行实例，有了镜像才能启动容器。理解清楚镜像的内部结构,我们才能够按照需求构建符合要求的镜像。hello-world 是 Docker 官方提供的一个镜像，通常用来验证 Docker 是否安装成功。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们先通过 docker pull 从 Docker Hub 下载它&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@docker ~]# docker pull hello-world
Using default tag: latest
latest: Pulling from library/hello-world
ca4f61b1923c: Pull complete
Digest: sha256:ca0eeb6fb05351dfc8759c20733c91def84cb8007aa89a5bf606bc8b315b9fc7
Status: Downloaded newer image for hello-world:latest
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以使用 docker images 命令查看镜像的信息，可以看到镜像非常的小,只有1.85k&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@docker ~]# docker images |grep hello-world
hello-world  latest       f2a91732366c     6 weeks ago         1.85kB
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后通过 docker run 运行镜像&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@docker ~]# docker run hello-world

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the &amp;quot;hello-world&amp;quot; image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那么该镜像运行怎么就输出上面这一串信息的呢？如果对 Docker 了解一点的话自然会去找该镜像的 Dockerfile，Dockerfile 详细描述了该镜像是如何建立的以及运行时执行的命令。从 Docker Hub 上 &lt;a href=&quot;https://hub.docker.com/r/library/hello-world/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hello-world&lt;/a&gt; 的库简介 找到其 &lt;a href=&quot;https://github.com/docker-library/hello-world/blob/b7a78b7ccca62cc478919b101f3ab1334899df2b/Dockerfile&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dockerfile&lt;/a&gt; 在 github 上，简简单单的三条语句。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-std.dprcdn.net/files/acc_582513/4q6B6C&quot; alt=&quot;hello-world Dockerfile&quot;&gt;&lt;br&gt;&lt;strong&gt;hello-world的Dockerfile如下:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM scratch
ADD hello /
CMD [&amp;quot;/hello&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一条FROM指令是 Docker 用来指定该镜像是基于哪个基础镜像构建的，这里指定为 scratch，实际上 scratch 镜像是一个空镜像，用来构建基础镜像或者极小的镜像。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二条ADD指令表示从 Dockerfile 所在目录拷贝文件到指定路径下，这里拷贝 hello 文件到根目录下，这里的hello文件是一个二进制可执行文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第三条CMD指令用来指示当运行 docker run 命令运行该镜像时要执行的命令，这里执行 /hello，就是执行第二步拷贝到根目录下的 hello 文件。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker系列" scheme="http://www.chenfanlinux.org/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Docker" scheme="http://www.chenfanlinux.org/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Bash 编程入门之Bash特性汇总(一)</title>
    <link href="http://www.chenfanlinux.org/2018/01/05/Bash%E7%89%B9%E6%80%A7%E6%B1%87%E6%80%BB/"/>
    <id>http://www.chenfanlinux.org/2018/01/05/Bash特性汇总/</id>
    <published>2018-01-05T04:35:53.000Z</published>
    <updated>2018-01-26T03:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是shell"><a href="#什么是shell" class="headerlink" title="什么是shell?"></a>什么是shell?</h2><blockquote><p>通常,替我们工作的是”硬件”,而控制硬件的是”内核”。用户利用”shell”控制着一些内核提供的”工具”,来控制硬件替我们工作。由于内核听不懂人类语言,所以shell从本质来说就是一个UI(用户界面)应用程序,让内核控制着硬件正确无误的工作，如图1-1 硬件-内核-shell 所示，可以清晰的看到他们的关系。</p></blockquote><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/DDfPGJ" alt="硬件-内核"></p><h2 id="Bash-shell功能特性"><a href="#Bash-shell功能特性" class="headerlink" title="Bash shell功能特性"></a>Bash shell功能特性</h2><h3 id="history命令记忆功能"><a href="#history命令记忆功能" class="headerlink" title="history命令记忆功能"></a>history命令记忆功能</h3><blockquote><p>在Bash里面,我们只要在命令行按”上、下键”或者更强大的”Ctrl+r”,就可以找到之前输入的历史命令,这依赖于Bash的命令记录功能,记录的文件位于家目录下的.bash_history。登录shell后新执行的命令只会记录在缓存中,这些命令会在用户退出时追加到命令历史文件中,我们通过history命令可以查看历史命令.</p></blockquote><p><strong>命令历史相关的环境变量:</strong></p><ul><li>HISTSIZE: 命令历史记录的条数</li><li>HISTFILE: ~/.bash_history</li></ul><p><strong>命令历史调用相关的命令:</strong></p><ul><li><p>调用历史中的命令:</p><ul><li>!#: 重复执行第#条指令</li><li>!!: 重复上一条命令</li><li>!string: 匹配以string开头的命令</li></ul></li><li><p>调用上一条命令的最后一个参数:</p><ul><li>!$</li><li>ESC . （先按esc,释放然后按.）</li></ul></li></ul><a id="more"></a><h3 id="命令与文件补全功能"><a href="#命令与文件补全功能" class="headerlink" title="命令与文件补全功能"></a>命令与文件补全功能</h3><blockquote><p>常在bash中使用热键[Tab]是一个好习惯,因为它可以减少键盘的输入和保证命令的输出的正确性。</p></blockquote><ul><li>接在一串命令的第一个字后面,则为命令的补全</li><li>接在一床命令的第二个字以后时,则为文件的补全</li></ul><h3 id="命令别名的功能"><a href="#命令别名的功能" class="headerlink" title="命令别名的功能"></a>命令别名的功能</h3><blockquote><p>通过给常用命令设置别名的方式,减少命令的输出长度,提升工作效率。命令行键入alias命令,可以查看系统配置的alias命令,将命令别名记录在全局配置环境配置文件/etc/profile或~/.bashrc都是一种持久生效的方式.</p></blockquote><pre><code>[root@chenfanlinux ~]# aliasalias cp=&apos;cp -i&apos;alias egrep=&apos;egrep --color=auto&apos;alias fgrep=&apos;fgrep --color=auto&apos;alias grep=&apos;grep --color=auto&apos;alias l.=&apos;ls -d .* --color=auto&apos;alias ll=&apos;ls -l --color=auto&apos;alias ls=&apos;ls --color=auto&apos;alias mv=&apos;mv -i&apos;alias rm=&apos;rm -i&apos;alias which=&apos;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde&apos;</code></pre><p>   <strong>注意:由于shell脚本中的别名不生效，\cp的含义是脱去别名的设置。</strong></p><h3 id="命令行展开功能"><a href="#命令行展开功能" class="headerlink" title="命令行展开功能"></a>命令行展开功能</h3><blockquote><p>{}:可以承载一个以逗号分隔的列表,并将其展开为多个路径.</p></blockquote><pre><code>$ mkdir /tmp/{a,b} &lt;==&gt;  $ mkdir /tmp/a;mkdir /tmp/b$ mkdir /tmp/{tom,jerry}/hi &lt;==&gt;  $ mkidr /tmp/tom/hi;mkdir /tmp/jerry/hi</code></pre><h3 id="作业-jobs-、前台-fg-、后台-bg-控制"><a href="#作业-jobs-、前台-fg-、后台-bg-控制" class="headerlink" title="作业(jobs)、前台(fg)、后台(bg)控制"></a>作业(jobs)、前台(fg)、后台(bg)控制</h3><blockquote><p>使用前台、后台控制,可以让工作进行得更加的顺利.我们可以随时将作业放置到后台执行,不用担心使用了[Ctrl]+c键来停掉该程序。在单用户登录环境中，达到了多任务的目标。</p></blockquote><ul><li>前台作业: 通过终端启动,且启动后一直占据终端</li><li><p>后台作业: 通过终端启动,但启动后即转入后台运行(释放终端)</p></li><li><p><strong>如何让作业运行于后台?</strong></p><ul><li><p>运行中的作业<br><code>Ctrl+Z</code></p></li><li><p>尚未启动的作业<br><code>COMMAND &amp;</code><br><strong><em>此类作业虽然被送往后台运行,但其依然与终端相关,<br>因为退出登录后作业将停止运行;如果希望送往后台,剥离与终端的关系。</em></strong></p></li><li><p>剥离作业与终端的关系<br><code>nohup COMMAND &amp;</code></p></li></ul></li></ul><ul><li><p><strong>作业控制相关命令:</strong></p><ul><li>查看所有作业情况<br><code>jobs</code></li><li>指定的后台作业调回前台<br><code>fg [[%]JOB_NUM]</code></li><li>让送往后台的作业在后台继续运行<br><code>bg [[%]JOB_NUM]</code></li><li>终止指定的作业<br><code>kill [%JOB_NUM]</code></li></ul></li></ul><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><blockquote><p>除了完整的字符串之外,bash还支持许多通配符来帮助用户查询和执行命令。下表列出常见的通配符,仅供参考。</p></blockquote><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">内容</th></tr></thead><tbody><tr><td style="text-align:center">*</td><td style="text-align:center">通配符,代表0个或多个字符(或数字)</td></tr><tr><td style="text-align:center">?</td><td style="text-align:center">通配符,代表一个有一个字符</td></tr><tr><td style="text-align:center">#</td><td style="text-align:center">注释,常在脚本中,被视为说明</td></tr><tr><td style="text-align:center">\</td><td style="text-align:center">转义字符,将特殊字符或通配符还原成一般字符</td></tr><tr><td style="text-align:center">~</td><td style="text-align:center">用户的家目录</td></tr><tr><td style="text-align:center">$</td><td style="text-align:center">变量之前需要加的变量替换值</td></tr><tr><td style="text-align:center">&amp;</td><td style="text-align:center">将命令转为后台执行</td></tr><tr><td style="text-align:center">!</td><td style="text-align:center">逻辑运算符(not)意思</td></tr><tr><td style="text-align:center">/</td><td style="text-align:center">路径分隔符</td></tr><tr><td style="text-align:center">&gt; &gt;&gt;</td><td style="text-align:center">重定向与追加重定向</td></tr><tr><td style="text-align:center">‘</td><td style="text-align:center">单引号,不具有变量置换功能</td></tr><tr><td style="text-align:center">“</td><td style="text-align:center">具有变量置换功能</td></tr><tr><td style="text-align:center">``</td><td style="text-align:center">中间为可以执行的命令</td></tr><tr><td style="text-align:center">()</td><td style="text-align:center">中间为子shell的起始于结束</td></tr><tr><td style="text-align:center">[] [^]</td><td style="text-align:center">中间为字符的组合</td></tr><tr><td style="text-align:center">{}</td><td style="text-align:center">中间为命令区块的组合</td></tr></tbody></table><table><thead><tr><th style="text-align:center">组合按键</th><th style="text-align:center">执行结果</th></tr></thead><tbody><tr><td style="text-align:center">Ctrl+c</td><td style="text-align:center">终止当前的命令</td></tr><tr><td style="text-align:center">Ctrl+a</td><td style="text-align:center">跳转至命令开始处</td></tr><tr><td style="text-align:center">Ctrl+e</td><td style="text-align:center">跳转至命令结尾处</td></tr><tr><td style="text-align:center">Ctrl+u</td><td style="text-align:center">删除命令行首至光标所在处的所有内容</td></tr><tr><td style="text-align:center">Ctrl+k</td><td style="text-align:center">删除光标所在行至命令行尾部的内容</td></tr><tr><td style="text-align:center">Ctrl+z</td><td style="text-align:center">暂停当前命令的执行</td></tr><tr><td style="text-align:center">Ctrl+l</td><td style="text-align:center">清屏,相当于clear命令</td></tr></tbody></table><p><strong>匹配字符举例</strong></p><ul><li>* 任意长度的任意字符</li><li>? 任意单个字符</li><li><p>[] 只能匹配指定范围内的任意单个字符</p><ul><li>[0-9] 所有数字中挑一个</li><li>[a-z] 不分区字符大小写</li><li>[A-Z] 大写字母</li><li>[[:lower:]] 小写字母</li><li>[^0-9a-z] 特殊字符</li></ul></li><li><p>[^] 匹配指定范围外的任意单个字符</p></li><li><p>专用字符集合:</p><ul><li>[:digit:]:任意数字,相当于0-9</li><li>[:lower:]:任意小写字母</li><li>[:upper:]:任意大写字母</li><li>[:alpha:]:任意大小写字母</li><li>[:alnum:]:任意数字或字母</li><li>[:space:]:空格</li><li>[:punct:]:标点符号</li></ul></li></ul><h3 id="命令执行的判断依据-amp-amp"><a href="#命令执行的判断依据-amp-amp" class="headerlink" title="命令执行的判断依据(; &amp;&amp; ||)"></a>命令执行的判断依据(; &amp;&amp; ||)</h3><blockquote><p>通常来说命令的运行状态会返回两种结果,执行成功则返回0，执行错误则返回非0。而多个命令的执行通常,从前至后,而且命令的执行还具有一定的逻辑关系,上一个命令的执行成功与否,某种程序可用决定下一个命令的执行。</p></blockquote><p><strong>一次执行多个命令,命令之间没有关联。</strong></p><pre><code>[root@chenfanlinux ~]# toch test.txt ; echo &quot;I  touch test.txt&quot;-bash: toch: 未找到命令I touch test.txt</code></pre><p><strong>命令相互关联,上一个命令执行成功,才会执行下一个命令。</strong></p><pre><code>[root@chenfanlinux ~]# toch test.txt &amp;&amp; echo &quot;I touch test.txt&quot;-bash: toch: 未找到命令</code></pre><p><strong>命令相关关联,上一个命令执行失败,才会执行下一个命令。</strong></p><pre><code>[root@chenfanlinux ~]# toch test.txt || echo &quot;I touch test.txt&quot;-bash: toch: 未找到命令I touch test.txt[root@chenfanlinux ~]# touch test.txt || echo &quot;I touch test.txt&quot;注意:这里不会执行echo &quot;I touch test.txt&quot;</code></pre><p><strong>如果第一个命令执行成功,则执行第二个命令,否则执行第三个命令。</strong></p><pre><code>[root@chenfanlinux ~]# touch test.txt &amp;&amp;  echo &quot;我是第二个命令&quot; || echo &quot;我是第三个命令&quot;我是第二个命令[root@chenfanlinux ~]# tuch test.txt &amp;&amp;  echo &quot;我是第二个命令&quot; || echo &quot;我是第三个命令&quot;-bash: tuch: 未找到命令我是第三个命令</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是shell&quot;&gt;&lt;a href=&quot;#什么是shell&quot; class=&quot;headerlink&quot; title=&quot;什么是shell?&quot;&gt;&lt;/a&gt;什么是shell?&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;通常,替我们工作的是”硬件”,而控制硬件的是”内核”。用户利用”shell”控制着一些内核提供的”工具”,来控制硬件替我们工作。由于内核听不懂人类语言,所以shell从本质来说就是一个UI(用户界面)应用程序,让内核控制着硬件正确无误的工作，如图1-1 硬件-内核-shell 所示，可以清晰的看到他们的关系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-std.dprcdn.net/files/acc_582513/DDfPGJ&quot; alt=&quot;硬件-内核&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Bash-shell功能特性&quot;&gt;&lt;a href=&quot;#Bash-shell功能特性&quot; class=&quot;headerlink&quot; title=&quot;Bash shell功能特性&quot;&gt;&lt;/a&gt;Bash shell功能特性&lt;/h2&gt;&lt;h3 id=&quot;history命令记忆功能&quot;&gt;&lt;a href=&quot;#history命令记忆功能&quot; class=&quot;headerlink&quot; title=&quot;history命令记忆功能&quot;&gt;&lt;/a&gt;history命令记忆功能&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在Bash里面,我们只要在命令行按”上、下键”或者更强大的”Ctrl+r”,就可以找到之前输入的历史命令,这依赖于Bash的命令记录功能,记录的文件位于家目录下的.bash_history。登录shell后新执行的命令只会记录在缓存中,这些命令会在用户退出时追加到命令历史文件中,我们通过history命令可以查看历史命令.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;命令历史相关的环境变量:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HISTSIZE: 命令历史记录的条数&lt;/li&gt;
&lt;li&gt;HISTFILE: ~/.bash_history&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;命令历史调用相关的命令:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;调用历史中的命令:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;!#: 重复执行第#条指令&lt;/li&gt;
&lt;li&gt;!!: 重复上一条命令&lt;/li&gt;
&lt;li&gt;!string: 匹配以string开头的命令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;调用上一条命令的最后一个参数:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;!$&lt;/li&gt;
&lt;li&gt;ESC . （先按esc,释放然后按.）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Bash Shell编程" scheme="http://www.chenfanlinux.org/categories/Bash-Shell%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Bash" scheme="http://www.chenfanlinux.org/tags/Bash/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门之基础概念与架构(一)</title>
    <link href="http://www.chenfanlinux.org/2017/12/28/Docker%E5%85%A5%E9%97%A8%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%9E%B6%E6%9E%84-%E4%B8%80/"/>
    <id>http://www.chenfanlinux.org/2017/12/28/Docker入门之基础概念与架构-一/</id>
    <published>2017-12-28T01:11:33.000Z</published>
    <updated>2018-01-26T03:39:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="what-什么是docker"><a href="#what-什么是docker" class="headerlink" title="what 什么是docker?"></a>what 什么是docker?</h2><p><a href="https://www.docker.com" target="_blank" rel="noopener">Docker</a> 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 <a href="https://zh.wikipedia.org/wiki/Cgroups" target="_blank" rel="noopener">cgroup</a>，<a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">namespace</a>，以及 <a href="https://en.wikipedia.org/wiki/Aufs" target="_blank" rel="noopener">AUFS</a> 类的 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">Union FS</a> 等技术，对进程进行封装隔离，属于 <a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization" target="_blank" rel="noopener">操作系统层面的虚拟化技术</a>。由于隔离的进程独立于宿主和其它的隔离的进程，在容器中运行的程序只能看到容器的内容和分配给该容器的设备,因此也称其为容器。最初实现是基于 <a href="https://linuxcontainers.org/lxc/introduction/" target="_blank" rel="noopener">LXC</a>，现在基于<a href="http://www.infoq.com/cn/articles/docker-standard-container-execution-engine-runc?utm_source=articles_about_RunC&amp;utm_medium=link&amp;utm_campaign=RunC" target="_blank" rel="noopener">runc</a>等机制。Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。</p><ul><li>Docker容器本质上是宿主机上的一个进程，Docker通过namespace实现了资源隔离。</li><li>Docker有六个命名空间：Mount(挂载)、UTS(主机名)、IPC(进程间通信)、PID(进程)、Network(网络)、User(用户)，为了隔离有问题的应用，运用Namespace将进程隔离，为进程或进程组创建已隔离的运行空间，为进程提供不同的命名空间视图；这样，每一个隔离出来的进程组，对外就表现为一个container。</li><li>Namespaces充当隔离的第一级，确保一个容器中运行一个进程而且不能看到或影响容器外的其它进程。</li><li>cgroups是LXC的重要组成部分，实现了资源的限制，通过写时复制机制copy-on-write实现了高效的文件操作。</li><li>UnionFS（文件系统）作为容器的构建块。为了支持Docker的轻量级以及速度快的特性，它创建了用户层</li></ul><h2 id="why-为什么使用docker？"><a href="#why-为什么使用docker？" class="headerlink" title="why 为什么使用docker？"></a>why 为什么使用docker？</h2><p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便,而且容器使软件具备了超强的可移植能力。</p><ul><li>容器技术与传统虚拟机虚拟化方式对比：</li></ul><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/vyEvvG" alt="传统虚拟机"></p><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/hEWM0Z" alt="Docker"></p><ul><li>容器技术与传统虚拟机性能对比：</li></ul><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/6RGWHJ" alt="性能对比"></p><a id="more"></a><p><strong>Docker给DevOps带来的好处</strong></p><ul><li><p>更快速的交付和部署<br>开发人员可以使用镜像快速的构建标准开发环境；开发完成后，测试和运维人员可以使用开发人员提供的docker镜像快速部署应用，可以避免开发和测试运维人员之间的环境差异导致的部署问题。</p></li><li><p>更高效的资源利用<br>Docker容器的运行不需要额外的虚拟化管理程序支持，它是内核级的虚拟化，在占用更少资源的情况实现更高的性能。</p></li><li><p>更方便的迁移和扩展<br>Docker容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、服务器等。这种兼容使得用户可以在不同的平台之间很方便的完成应用迁移。</p></li><li><p>更简单的更新管理<br>使用Dockerfile，只需要小小的配置修改，就可以替代以往大量的更新工作，并且所有修改都以增量方式进行分发和更新。</p></li></ul><h2 id="How-容器是如何工作的"><a href="#How-容器是如何工作的" class="headerlink" title="How 容器是如何工作的?"></a>How 容器是如何工作的?</h2><p>Docker有五大核心组件,可以快速浏览下面的Docker架构图来了解核心组件,了解他们如何协作。</p><p><strong>Docker 的核心组件包括：</strong></p><ul><li>Docker 客户端 - Client</li><li>Docker 服务器 - Docker daemon</li><li>Docker 镜像 - Image</li><li>Docker 仓库 - Registry</li><li>Docker 容器 - Container</li></ul><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/uLaYib" alt="Docker架构图"><br>Docker 采用的是 Client/Server 架构。客户端向服务器发送请求，服务器负责构建、运行和分发容器。客户端和服务器可以运行在同一个 Host 上，客户端也可以通过 socket 或 REST API 与远程的服务器通信。</p><h4 id="Docker-客户端"><a href="#Docker-客户端" class="headerlink" title="Docker 客户端"></a>Docker 客户端</h4><p>最常用的 Docker 客户端是 docker 命令。通过 docker 我们可以方便地在 Host 上构建和运行容器。docker 支持很多操作（子命令），后面会逐步用到。</p><pre><code>[root@my-k8s-master01 ~]# docker -vDocker version 1.12.6, build 85d7426/1.12.6</code></pre><p>除了 docker 命令行工具，用户也可以通过 REST API 与服务器通信</p><h4 id="Docker-服务器"><a href="#Docker-服务器" class="headerlink" title="Docker 服务器"></a>Docker 服务器</h4><p>Docker daemon 是服务器组件，以 Linux 后台服务的方式运行。</p><pre><code>[root@my-k8s-master01 ~]# systemctl status docker● docker.service - Docker Application Container Engine   Loaded: loaded (/usr/lib/systemd/system/docker.service; enabled; vendor preset: disabled)   Active: active (running) since 二 2017-12-05 15:57:51 CST; 1 months 3 days ago     Docs: http://docs.docker.com Main PID: 1527 (dockerd-current)</code></pre><p>Docker daemon 运行在 Docker host 上，负责创建、运行、监控容器，构建、存储镜像。<br>默认配置下，Docker daemon 只能响应来自本地 Host 的客户端请求。如果要允许远程客户端请求，需要在配置文件中打开 TCP 监听。</p><h4 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h4><p>可将 Docker 镜像看着只读模板，通过它可以创建 Docker 容器。<br>镜像有多种生成方法：</p><ul><li>可以从无到有开始创建镜像</li><li>也可以下载并使用别人创建好的现成的镜像</li><li>还可以在现有镜像上创建新的镜像</li></ul><p>我们可以将镜像的内容和创建步骤描述在一个文本文件中，这个文件被称作 Dockerfile，通过执行 docker build <docker-file> 命令可以构建出 Docker 镜像，后面我们会讨论。</docker-file></p><h4 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h4><p>Docker 容器就是 Docker 镜像的运行实例。</p><p>用户可以通过 CLI（docker）或是 API 启动、停止、移动或删除容器。可以这么认为，对于应用软件，镜像是软件生命周期的构建和打包阶段，而容器则是启动和运行阶段</p><h4 id="Docker-仓库"><a href="#Docker-仓库" class="headerlink" title="Docker 仓库"></a>Docker 仓库</h4><p>Registry 是存放 Docker 镜像的仓库，Registry 分私有和公有两种。</p><p>Docker Hub（<a href="https://hub.docker.com/）" target="_blank" rel="noopener">https://hub.docker.com/）</a> 是默认的 Registry，由 Docker 公司维护，上面有数以万计的镜像，用户可以自由下载和使用。</p><p>出于对速度或安全的考虑，用户也可以创建自己的私有 Registry。后面我们会学习如何搭建私有 Registry。</p><p>docker pull 命令可以从 Registry 下载镜像。<br>docker run 命令则是先下载镜像（如果本地没有），然后再启动容器。</p><h2 id="Centos7开始安装Docker"><a href="#Centos7开始安装Docker" class="headerlink" title="Centos7开始安装Docker"></a>Centos7开始安装Docker</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在Linux上安装Docker并配置加速器，Docker目前被分为两个版本：</p><ul><li>Community-Edition：社区版</li><li>Enterprise-Edition：企业版</li></ul><h4 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h4><p><strong>卸载旧版本的Docker服务</strong></p><pre><code>$ yum -y remove docker \docker-common \container-selinux \docker-selinux \docker-engine</code></pre><p><strong>安装yum-utils，它提供yum-config-manager实用程序</strong></p><pre><code>$ yum install -y yum-utils</code></pre><p><strong>添加Docker的CE存储库(官网)</strong></p><pre><code>$ yum-config-manager \    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo</code></pre><p><strong>添加Docker的CE存储库(国内)</strong></p><pre><code>$ yum-config-manager \    --add-repo \    http://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo</code></pre><p><strong>更新软件包的索引列表</strong></p><pre><code>$ yum makecache fast</code></pre><p><strong>安装最新版的Docker服务</strong></p><pre><code>yum install -y docker-ce</code></pre><p><strong>启动Docker服务</strong></p><pre><code>systemctl start docker</code></pre><p><strong>Docker服务随机自启</strong></p><pre><code>systemctl enable docker</code></pre><p><strong>卸载Docker服务</strong></p><p>   # 卸载软件包</p><pre><code>$ yum remove -y docker-ce</code></pre><p>卸载Docker后,/var/lib/docker/目录下会保留原Docker的镜像,网络,存储卷等文件. 如果需要全新安装Docker,需要删除/var/lib/docker/目录.</p><pre><code>$ rm -rf /var/lib/docker</code></pre><p><strong>查看docker版本信息</strong></p><p>   # 获取版本信息的简介</p><pre><code>$ docker -v</code></pre><p>   # 获取详细的版本信息</p><pre><code>$ docker version</code></pre><h4 id="配置Docker加速器"><a href="#配置Docker加速器" class="headerlink" title="配置Docker加速器"></a>配置Docker加速器</h4><ol><li><p>由于众所周知的原因(墙)，从Docker Hub难以高效地下载镜像，除了使用VPN或代理之外，<br>最为有效的方式就是使用Docker国内镜像；</p></li><li><p>DaoCloud为首个提供国内免费Docker Hub镜像的团体，可以使用DaoCloud团队提供的<br>Docker Hub Mirror服务代替Docker官网的Docker Hub；</p></li><li><p>官网：传送门，注册用户并登录；</p></li><li><p>登录以后，在自己管理界面点击加速器标签，根据弹出页面配置加速器；</p></li></ol><blockquote><p>Copy<br>该脚本可以将 –registry-mirror 加入到你的 Docker 配置文件 /etc/docker/daemon.json 中。适用于 Ubuntu14.04、Debian、CentOS6 、CentOS7、Fedora、Arch Linux、openSUSE Leap 42.1，其他版本可能有细微不同</p></blockquote><pre><code>curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://9fa458c0.m.daocloud.io</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;what-什么是docker&quot;&gt;&lt;a href=&quot;#what-什么是docker&quot; class=&quot;headerlink&quot; title=&quot;what 什么是docker?&quot;&gt;&lt;/a&gt;what 什么是docker?&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.docker.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Docker&lt;/a&gt; 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 &lt;a href=&quot;https://zh.wikipedia.org/wiki/Cgroups&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;cgroup&lt;/a&gt;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Linux_namespaces&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;namespace&lt;/a&gt;，以及 &lt;a href=&quot;https://en.wikipedia.org/wiki/Aufs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AUFS&lt;/a&gt; 类的 &lt;a href=&quot;https://en.wikipedia.org/wiki/Union_mount&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Union FS&lt;/a&gt; 等技术，对进程进行封装隔离，属于 &lt;a href=&quot;https://en.wikipedia.org/wiki/Operating-system-level_virtualization&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;操作系统层面的虚拟化技术&lt;/a&gt;。由于隔离的进程独立于宿主和其它的隔离的进程，在容器中运行的程序只能看到容器的内容和分配给该容器的设备,因此也称其为容器。最初实现是基于 &lt;a href=&quot;https://linuxcontainers.org/lxc/introduction/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LXC&lt;/a&gt;，现在基于&lt;a href=&quot;http://www.infoq.com/cn/articles/docker-standard-container-execution-engine-runc?utm_source=articles_about_RunC&amp;amp;utm_medium=link&amp;amp;utm_campaign=RunC&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;runc&lt;/a&gt;等机制。Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Docker容器本质上是宿主机上的一个进程，Docker通过namespace实现了资源隔离。&lt;/li&gt;
&lt;li&gt;Docker有六个命名空间：Mount(挂载)、UTS(主机名)、IPC(进程间通信)、PID(进程)、Network(网络)、User(用户)，为了隔离有问题的应用，运用Namespace将进程隔离，为进程或进程组创建已隔离的运行空间，为进程提供不同的命名空间视图；这样，每一个隔离出来的进程组，对外就表现为一个container。&lt;/li&gt;
&lt;li&gt;Namespaces充当隔离的第一级，确保一个容器中运行一个进程而且不能看到或影响容器外的其它进程。&lt;/li&gt;
&lt;li&gt;cgroups是LXC的重要组成部分，实现了资源的限制，通过写时复制机制copy-on-write实现了高效的文件操作。&lt;/li&gt;
&lt;li&gt;UnionFS（文件系统）作为容器的构建块。为了支持Docker的轻量级以及速度快的特性，它创建了用户层&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;why-为什么使用docker？&quot;&gt;&lt;a href=&quot;#why-为什么使用docker？&quot; class=&quot;headerlink&quot; title=&quot;why 为什么使用docker？&quot;&gt;&lt;/a&gt;why 为什么使用docker？&lt;/h2&gt;&lt;p&gt;传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便,而且容器使软件具备了超强的可移植能力。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容器技术与传统虚拟机虚拟化方式对比：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-std.dprcdn.net/files/acc_582513/vyEvvG&quot; alt=&quot;传统虚拟机&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-std.dprcdn.net/files/acc_582513/hEWM0Z&quot; alt=&quot;Docker&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容器技术与传统虚拟机性能对比：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-std.dprcdn.net/files/acc_582513/6RGWHJ&quot; alt=&quot;性能对比&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Docker系列" scheme="http://www.chenfanlinux.org/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Docker" scheme="http://www.chenfanlinux.org/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>编辑器之神-Vim</title>
    <link href="http://www.chenfanlinux.org/2017/12/24/%E7%BC%96%E8%BE%91%E5%99%A8%E4%B9%8B%E7%A5%9E-vim/"/>
    <id>http://www.chenfanlinux.org/2017/12/24/编辑器之神-vim/</id>
    <published>2017-12-24T02:24:27.000Z</published>
    <updated>2018-01-26T03:39:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vim简介"><a href="#vim简介" class="headerlink" title="vim简介"></a>vim简介</h3><p>vi是“Visual interface”的简称，它不像Word或WPS那样可以对字体、格式、段落等其他属性进行编排，它只是一个文本编辑程序。 vi没有菜单，只有命令，且命令繁多。vim(VIM - Vi IMproved)是vi的加强版本，在vi的基础上增加了如下功能。</p><blockquote><ul><li>增加了多级撤销</li><li>多窗口操作</li><li>提高了稳定性，减少了崩溃以及崩溃后也可以恢复</li><li>关键字自动补全以及上下文相关的补全</li></ul></blockquote><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/bEfzpN" alt="vim键盘图"></p><h3 id="vim的工作模式"><a href="#vim的工作模式" class="headerlink" title="vim的工作模式"></a>vim的工作模式</h3><p>Vi有三种基本工作模式：</p><ul><li>命令模式（普通模式）</li><li>文本输入模式</li><li>末行模式(底线命令模式)</li></ul><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/SDuEA" alt="vim工作模式"></p><h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><ul><li><strong>单个字符移动</strong></li></ul><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">移动方向</th></tr></thead><tbody><tr><td style="text-align:center">h</td><td style="text-align:center">向左移动</td></tr><tr><td style="text-align:center">l</td><td style="text-align:center">向右移动</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center">向下移动</td></tr><tr><td style="text-align:center">k</td><td style="text-align:center">向上移动</td></tr></tbody></table><ul><li><strong>单词移动</strong></li></ul><table><thead><tr><th style="text-align:center">单词</th><th style="text-align:center">移动方向</th></tr></thead><tbody><tr><td style="text-align:center">w</td><td style="text-align:center">将光标移动到下一个单词开头</td></tr><tr><td style="text-align:center">b</td><td style="text-align:center">将光标移动到前一个单词的开头</td></tr><tr><td style="text-align:center">e</td><td style="text-align:center">将光标移动到下一个单词的词末</td></tr><tr><td style="text-align:center">E</td><td style="text-align:center">移动到单词的结尾(忽略标点符号)</td></tr><tr><td style="text-align:center">ge</td><td style="text-align:center">将光标移动到前一个单词的词末</td></tr></tbody></table><ul><li><strong>行移动</strong></li></ul><table><thead><tr><th style="text-align:center">单词</th><th style="text-align:center">移动方向</th></tr></thead><tbody><tr><td style="text-align:center">$</td><td style="text-align:center">将光标移动到当前行的行尾</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">将光标移动到当前行的行首</td></tr><tr><td style="text-align:center">fx</td><td style="text-align:center">将光标移动到当前行的第一个字符x上</td></tr><tr><td style="text-align:center">3fx</td><td style="text-align:center">将光标移动到航前行的第3个字符x上</td></tr><tr><td style="text-align:center">%</td><td style="text-align:center">用于符号间的移动，它会在一对()、[]、{}之间跳跃</td></tr></tbody></table><a id="more"></a><ul><li><strong>文本块移动</strong></li></ul><table><thead><tr><th style="text-align:center">单词</th><th style="text-align:center">移动方向</th></tr></thead><tbody><tr><td style="text-align:center">(</td><td style="text-align:center">移到当前句子的开头</td></tr><tr><td style="text-align:center">)</td><td style="text-align:center">移到下一个句子的开头</td></tr><tr><td style="text-align:center">{</td><td style="text-align:center">移到当前一段的开头</td></tr><tr><td style="text-align:center">}</td><td style="text-align:center">移到下一段的开头</td></tr><tr><td style="text-align:center">ge</td><td style="text-align:center">将光标移动到前一个单词的词末</td></tr></tbody></table><ul><li><strong>在屏幕中移动</strong></li></ul><table><thead><tr><th style="text-align:center">单词</th><th style="text-align:center">移动方向</th></tr></thead><tbody><tr><td style="text-align:center">H</td><td style="text-align:center">移动到当前屏幕的开头</td></tr><tr><td style="text-align:center">M</td><td style="text-align:center">移动到当前屏幕中间</td></tr><tr><td style="text-align:center">L</td><td style="text-align:center">移动当前屏幕的末尾</td></tr><tr><td style="text-align:center">gg</td><td style="text-align:center">移动到文件开头</td></tr><tr><td style="text-align:center">xG</td><td style="text-align:center">跳转到指定的第x行，G移动到文件按末尾</td></tr></tbody></table><h3 id="滚屏与跳转"><a href="#滚屏与跳转" class="headerlink" title="滚屏与跳转"></a>滚屏与跳转</h3><ul><li><strong>半屏滚动</strong></li></ul><table><thead><tr><th style="text-align:center">快捷键</th><th style="text-align:center">方向</th></tr></thead><tbody><tr><td style="text-align:center">ctrl+u</td><td style="text-align:center">向上滚动</td></tr><tr><td style="text-align:center">ctrl+d</td><td style="text-align:center">向下滚动</td></tr></tbody></table><ul><li><strong>全屏滚动</strong></li></ul><table><thead><tr><th style="text-align:center">快捷键</th><th style="text-align:center">方向</th></tr></thead><tbody><tr><td style="text-align:center">ctrl+b</td><td style="text-align:center">向上滚动</td></tr><tr><td style="text-align:center">ctrl+f</td><td style="text-align:center">向下滚动</td></tr></tbody></table><ul><li><strong>定位光标的位置</strong></li></ul><table><thead><tr><th style="text-align:center">快捷键</th><th style="text-align:center">方向</th></tr></thead><tbody><tr><td style="text-align:center">zz</td><td style="text-align:center">将光标置于屏幕的中间</td></tr><tr><td style="text-align:center">zt</td><td style="text-align:center">将光标移动到屏幕的顶部</td></tr><tr><td style="text-align:center">zb</td><td style="text-align:center">将光标移动到屏幕的底部</td></tr></tbody></table><h3 id="文本插入操作"><a href="#文本插入操作" class="headerlink" title="文本插入操作"></a>文本插入操作</h3><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">i</td><td style="text-align:center">在当前光标的前面插入字符</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">在当前光标的后面追加字符</td></tr><tr><td style="text-align:center">o</td><td style="text-align:center">在当前光标的下一行行首插入字符</td></tr><tr><td style="text-align:center">O</td><td style="text-align:center">在当前光标的上一行行首插入字符</td></tr><tr><td style="text-align:center">I</td><td style="text-align:center">在一行的开头添加文本</td></tr><tr><td style="text-align:center">A</td><td style="text-align:center">在一行的结尾处添加文本</td></tr><tr><td style="text-align:center">u</td><td style="text-align:center">撤销修改</td></tr><tr><td style="text-align:center">ctrl+r</td><td style="text-align:center">反撤销修改</td></tr></tbody></table><h3 id="文本删除"><a href="#文本删除" class="headerlink" title="文本删除"></a>文本删除</h3><ul><li><strong>字符删除</strong></li></ul><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">x</td><td style="text-align:center">删除当前光标所在处的字符</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">删除当前光标左边的字符</td></tr></tbody></table><ul><li><strong>单词删除</strong></li></ul><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">dw</td><td style="text-align:center">删除一个单词(从光标处到空格)</td></tr><tr><td style="text-align:center">d$</td><td style="text-align:center">删除从光标到一行末尾的整个文本</td></tr><tr><td style="text-align:center">d0</td><td style="text-align:center">删除从光标到一行开头的所有单词</td></tr></tbody></table><ul><li><strong>行删除</strong></li></ul><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">dd</td><td style="text-align:center">删除当前光标处的一整行=D</td></tr><tr><td style="text-align:center">5dd</td><td style="text-align:center">删除从光标到文本开头</td></tr><tr><td style="text-align:center">dG</td><td style="text-align:center">删除从光标到文本结尾</td></tr></tbody></table><h3 id="文本复制、剪切与粘贴"><a href="#文本复制、剪切与粘贴" class="headerlink" title="文本复制、剪切与粘贴"></a>文本复制、剪切与粘贴</h3><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">y</td><td style="text-align:center">复制,p:粘贴</td></tr><tr><td style="text-align:center">yw</td><td style="text-align:center">复制一个单词</td></tr><tr><td style="text-align:center">y2w</td><td style="text-align:center">复制2个单词</td></tr><tr><td style="text-align:center">y$</td><td style="text-align:center">复制从当前光标到行结尾的所有单词</td></tr><tr><td style="text-align:center">y0</td><td style="text-align:center">复制从当前光标到行首的所有单词</td></tr><tr><td style="text-align:center">&gt;&gt;</td><td style="text-align:center">文本行右移</td></tr><tr><td style="text-align:center">&lt;&lt;</td><td style="text-align:center">文本行左移</td></tr><tr><td style="text-align:center">.</td><td style="text-align:center">重复命令</td></tr></tbody></table><p><strong>可视模式</strong></p><ul><li>v: 按字符移动,选中文本    </li><li>V: 按行移动,选中文本可视模式可以配合 d, y, &gt;&gt;, &lt;&lt; 实现对文本块的删除,复制,左右移动 </li><li>Ctrl+v: 列操作模式  <ul><li>删除某一列内容：先ctrl+v,然后通过上下左右键,选择需要操作的文本，键入d,则可以删除选中的列内容。</li><li>插入操作: 先ctrl+v,然后上下左右键，选择需要操作的列,键入shift+i(在列前面插入)或shift+a(在列后面插入)指定的内容；接下来按Esc才能看到插入生效,再键入Esc,回到命令行模式,保存退出。</li></ul></li></ul><h3 id="查找命令与替换"><a href="#查找命令与替换" class="headerlink" title="查找命令与替换"></a>查找命令与替换</h3><ul><li><strong>字符串查找</strong></li></ul><table><thead><tr><th style="text-align:center">表达式</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">/string</td><td style="text-align:center">正向查找</td></tr><tr><td style="text-align:center">?string</td><td style="text-align:center">反向查找</td></tr></tbody></table><ul><li><strong>字符串替换</strong></li></ul><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">:s/old/new</td><td style="text-align:center">将当前行的第一个字符串old替换为new</td></tr><tr><td style="text-align:center">:s/old/new/g</td><td style="text-align:center">将当前行的所有字符串old替换为new</td></tr><tr><td style="text-align:center">:90s/old/new/g</td><td style="text-align:center">将指定行的所有字符串old替换为new</td></tr><tr><td style="text-align:center">:90,93s/old/new/g</td><td style="text-align:center">将90到93行的所有字符串old替换为new</td></tr><tr><td style="text-align:center">:%s/old/new/g</td><td style="text-align:center">将文本中所有的字符串old替换为new</td></tr></tbody></table><h3 id="多窗口操作"><a href="#多窗口操作" class="headerlink" title="多窗口操作"></a>多窗口操作</h3><p><strong>同时打开多个文件</strong><br>横向分割显示：<br><code>vim -o filename1 filename2</code></p><p>纵向分割显示:<br><code>vim -O filename1 filename2</code></p><p><strong>已打开的文件再开一个窗口</strong></p><p>开一个横向的窗口:<br>ctrl+w+s</p><p>开一个纵向的窗口:<br>ctrl+w+v</p><p><strong>窗口间跳转</strong></p><p>ctrl+w hjkl(左下上右)</p><p><strong>关闭窗口</strong></p><p>关闭光标所在的窗口：<br>:q 或 :close</p><p>关闭除光标所在的窗口之外的其他窗口：<br>:only</p><p>关闭所有窗口：<br>:qa</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;vim简介&quot;&gt;&lt;a href=&quot;#vim简介&quot; class=&quot;headerlink&quot; title=&quot;vim简介&quot;&gt;&lt;/a&gt;vim简介&lt;/h3&gt;&lt;p&gt;vi是“Visual interface”的简称，它不像Word或WPS那样可以对字体、格式、段落等其他属性进行编排，它只是一个文本编辑程序。 vi没有菜单，只有命令，且命令繁多。vim(VIM - Vi IMproved)是vi的加强版本，在vi的基础上增加了如下功能。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;增加了多级撤销&lt;/li&gt;
&lt;li&gt;多窗口操作&lt;/li&gt;
&lt;li&gt;提高了稳定性，减少了崩溃以及崩溃后也可以恢复&lt;/li&gt;
&lt;li&gt;关键字自动补全以及上下文相关的补全&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-std.dprcdn.net/files/acc_582513/bEfzpN&quot; alt=&quot;vim键盘图&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;vim的工作模式&quot;&gt;&lt;a href=&quot;#vim的工作模式&quot; class=&quot;headerlink&quot; title=&quot;vim的工作模式&quot;&gt;&lt;/a&gt;vim的工作模式&lt;/h3&gt;&lt;p&gt;Vi有三种基本工作模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命令模式（普通模式）&lt;/li&gt;
&lt;li&gt;文本输入模式&lt;/li&gt;
&lt;li&gt;末行模式(底线命令模式)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-std.dprcdn.net/files/acc_582513/SDuEA&quot; alt=&quot;vim工作模式&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;光标移动&quot;&gt;&lt;a href=&quot;#光标移动&quot; class=&quot;headerlink&quot; title=&quot;光标移动&quot;&gt;&lt;/a&gt;光标移动&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;单个字符移动&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;字符&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;移动方向&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;h&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;向左移动&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;l&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;向右移动&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;j&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;向下移动&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;k&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;向上移动&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;单词移动&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;单词&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;移动方向&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;w&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将光标移动到下一个单词开头&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;b&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将光标移动到前一个单词的开头&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;e&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将光标移动到下一个单词的词末&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;E&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;移动到单词的结尾(忽略标点符号)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;ge&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将光标移动到前一个单词的词末&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;行移动&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;单词&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;移动方向&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将光标移动到当前行的行尾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将光标移动到当前行的行首&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;fx&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将光标移动到当前行的第一个字符x上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;3fx&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将光标移动到航前行的第3个字符x上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;%&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;用于符号间的移动，它会在一对()、[]、{}之间跳跃&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="tools利器" scheme="http://www.chenfanlinux.org/categories/tools%E5%88%A9%E5%99%A8/"/>
    
    
      <category term="Vim" scheme="http://www.chenfanlinux.org/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>Python基础之流程控制</title>
    <link href="http://www.chenfanlinux.org/2017/12/19/python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>http://www.chenfanlinux.org/2017/12/19/python基础之流程控制/</id>
    <published>2017-12-19T14:31:23.000Z</published>
    <updated>2018-01-26T03:39:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><blockquote><p>if语句是用来检查一个条件：如果条件为真(true)，我们运行一个语句块（你为if块），否则(else)，我们执行另一个语句块（称为else块），else子语句是可选的。</p></blockquote><h3 id="单条件"><a href="#单条件" class="headerlink" title="单条件"></a>单条件</h3><p>示例：如果num变量大于1，那么就输出num大，否则就输出num小，num值为5</p><p><strong>代码：</strong></p><pre><code>#!/usr/bin/env python# -*- coding:utf-8 -*-num = 5if num &gt; 1:print(&quot;num大&quot;)else:print(&quot;num小&quot;)</code></pre><p><strong>结果：</strong></p><pre><code>python num.pynum大</code></pre><h3 id="多条件"><a href="#多条件" class="headerlink" title="多条件"></a>多条件</h3><p>示例：请输入一个整数，如果输入的为负数，负数转变为0,输出print(‘Negative changed to zero’);如果输入的为0，则输出Zero;如果输入的为1，则输出Single；输入其他则，输出More。</p><p><strong>代码：</strong></p><pre><code>#__author: Administrator#date: 2017/12/19x = int(input(&apos;Please enter an integer: &apos;))if x &lt; 0:    x = 0    print(&apos;Negative changed to zero&apos;)elif x == 0:    print(&apos;Zero&apos;)elif x == 1:    print(&apos;Single&apos;)else:    print(&apos;More&apos;)</code></pre><p><strong>结果：</strong></p><pre><code>Please enter an integer: -1Negative changed to zero</code></pre><a id="more"></a><h3 id="三元运算"><a href="#三元运算" class="headerlink" title="三元运算"></a>三元运算</h3><blockquote><p>如果条件成立，那么就把值1赋值给var，如果条件不成立，就把值2赋值给var</p></blockquote><p><strong>语法：</strong></p><p><code>var = 值1 if 条件 else 值2</code></p><p><strong>示例：</strong></p><pre><code>&gt;&gt;&gt; var = &quot;True&quot; if 1 == 1 else &quot;False&quot;&gt;&gt;&gt; var&apos;True&apos;</code></pre><h2 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h2><h3 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h3><blockquote><p>while 是Python中的循环语句. 事实它上是一个条件循环语句. 与 if 声明相比, 如果 if 后的条件为真, 就会执行一次相应的代码块. 而 while 中的代码块会一直循环执行, 直到循环条件不再为真.</p></blockquote><p><strong>语法：</strong></p><pre><code>while expression:       suite_to_repeat</code></pre><p>while 循环的suit_to_repeat子句会一直循环执行, 直到 expression 值为布尔假. 这种 类型的循环机制常常用在计数循环中。</p><p><strong>代码：</strong></p><pre><code>#__author: Administrator#date: 2017/12/19count = 0while (count &lt; 5):    print(&apos;The index is: &apos;,count)    count += 1</code></pre><p><strong>结果：</strong></p><pre><code>The index is:  0The index is:  1The index is:  2The index is:  3The index is:  4</code></pre><h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><p>你必须小心地使用 while 循环, 因为有可能它的条件永远不会为布尔假. 这样一来循环就永远不会结束. 这些”无限”的循环不一定是坏事, 许多通讯服务器的客户端/服务器系统就是通过它来工作的. 这取决于循环是否需要一直执行下去, 如果不是, 那么这个循环是否会结束; 也就是说, 条件表达式会不会计算后得到布尔假?</p><pre><code>while True:    handle, indata = wait_for_client_connect()    outdata = process_request(indata)    ack_result_to_client(handle, outdata)</code></pre><p>例如上边的代码就是故意被设置为无限循环的，因为 True 无论如何都不会变成 False. 这是因为服务器代码是用来等待客户端(可能通过网络)来连接的. 这些客户端向服务器发送请求, 服务器处理请求.<br>请求被处理后, 服务器将向客户端返回数据, 而此时客户端可能断开连接或是发送另一个请求. 对于服务器而言它已经完成了对这个客户端的任务, 它会返回最外层循环等待下一个连接.</p><h3 id="while使用-else-语句"><a href="#while使用-else-语句" class="headerlink" title="while使用 else 语句"></a>while使用 else 语句</h3><p>在 python 中，for … else 表示这样的意思，for 中的语句和普通的没有区别，else 中的语句会在循环正常执行完（即 for 不是通过 break 跳出而中断的）的情况下执行.while … else 也是一样,其在循环条件不满足的时候,会开始执行else语句,通过break中断的情况下,不会执行else.</p><p><strong>代码：</strong></p><pre><code>#__author: Administrator#date: 2017/12/19count = 0while (count &lt; 5):    print(count,&apos;is less than 5&apos;)    count += 1else:    print(count,&apos;is not less than 5&apos;)</code></pre><p><strong>结果：</strong></p><pre><code>0 is less than 51 is less than 52 is less than 53 is less than 54 is less than 55 is not less than 5</code></pre><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><h3 id="基础用法-1"><a href="#基础用法-1" class="headerlink" title="基础用法"></a>基础用法</h3><blockquote><p>Python 提供给我们的另一个循环机制就是 for 语句, 它提供了 Python 中最强大的循环结构. 它可以遍历序列成员(链表或字符串). for循环会访问一个可迭代对象(例如序列或是迭代器)中的所有元素, 并在所有条目都处理过后结束循环.</p></blockquote><p><strong>语法：</strong></p><pre><code>for iter_var in iterable:        suite_to_repeat</code></pre><p>每次循环, iter_var 迭代变量被设置为可迭代对象(序列, 迭代器, 或者是其他支持迭代的对象)的当前元素, 提供给 suite_to_repeat 语句块使用.</p><p><strong>代码：</strong></p><pre><code>#__author: Administrator#date: 2017/12/19words = [&apos;cat&apos;, &apos;window&apos;, &apos;defenestrate&apos;]for w in words:    print(w,len(w))</code></pre><p><strong>结果：</strong></p><pre><code>cat 3window 6defenestrate 12</code></pre><h3 id="for使用-else-语句"><a href="#for使用-else-语句" class="headerlink" title="for使用 else 语句"></a>for使用 else 语句</h3><blockquote><p>for 循环也可以有 else 用于循环后处理(post-processing). 它和 while 循环中的 else 处理方式相同. 只要 for 循环是正常结束的(不是通过 break ), else 子句就会执行.</p></blockquote><p>代码：</p><pre><code>#__author: Administrator#date: 2017/12/19s = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;]found = Falsefor c in s:    if c.find(&apos;c&apos;) != -1:        found = True        print(&quot;发现c&quot;)        breakif not found:    print(&quot;未发现c&quot;)</code></pre><p>等价于下面的代码:</p><pre><code>#__author: Administrator#date: 2017/12/19s = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;]for c in s:    if c.find(&apos;c&apos;) != -1:        print(&quot;发现c&quot;)        breakelse:    print(&quot;未发现c&quot;)</code></pre><h2 id="break和continue语句"><a href="#break和continue语句" class="headerlink" title="break和continue语句"></a>break和continue语句</h2><h3 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h3><blockquote><p>Python 中的 break 语句可以结束当前循环然后跳转到下条语句, 类似 C 中的传统 break . 常用在当某个外部条件被触发(一般通过 if 语句检查), 需要立即从循环中退出时. break 语句可以用在 while 和 for 循环中.</p></blockquote><p><strong>代码：</strong></p><pre><code>&gt;&gt;&gt; for i in &quot;hello&quot;:...     if i ==&apos;l&apos;:...         break...     print(i)...</code></pre><p><strong>结果：</strong></p><pre><code>he</code></pre><h3 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h3><blockquote><p>不管是 Python、 C、Java 还是其它任何支持 continue 语句的结构化语言中, 一些初学者有这样的一个误解: continue 语句”立即启动循环的下一次迭代”. 实际上, 当遇到 continue 语句时, 程序会终止当前循环, 并忽略剩余的语句, 然后回到循环的顶端. 在开始下一次迭代前, 如果是条件循环, 我们将验证条件表达式. 如果是迭代循环, 我们将验证是否还有元素可以迭代. 只有在验证成功的情况下, 我们才会开始下一次迭代.</p></blockquote><p>Python 里的 continue 语句和其他高级语言中的传统 continue 并没有什么不同. 它可以被用在 while 和 for 循环里. while 循环是条件性的, 而 for 循环是迭代的, 所以 continue 在开始下一次循环前要满足一些先决条件, 否则循环会正常结束.</p><p><strong>代码：</strong></p><pre><code>&gt;&gt;&gt; for i in &quot;hello&quot;:...     if i ==&apos;l&apos;:...         continue...     print(i)...</code></pre><p><strong>结果：</strong></p><pre><code>heo</code></pre><h2 id="总结循环中的else语句"><a href="#总结循环中的else语句" class="headerlink" title="总结循环中的else语句"></a>总结循环中的else语句</h2><blockquote><p>循环一般可以分为两种，for循环或while循环，上文都有明确的介绍。循环可以有一个 else 子句；它在循环迭代完整个列表（对于 for ）或执行条件为 false （对于 while ）不被break中止的情况下执行，循环被 break 中止的情况下不会执行else语句。</p></blockquote><p><strong>示例：</strong> 在数字2-9中搜索素数</p><p><strong>代码：</strong></p><pre><code>#__author: Administrator#date: 2017/12/19&apos;&apos;&apos;在数字2-9之间搜索素数素数的定义:除了1和它自身外，不能被其他自然数整除的数叫做质数.n 被除数x 除数&apos;&apos;&apos;for n in range(2,10):    for x in range(2,n):        if n % x == 0:            print(n,&apos;equals&apos;,x,&apos;*&apos;,n//x)            break    else:        print(n,&apos;is a prime number&apos;)</code></pre><p><strong>结果：</strong></p><pre><code>2 is a prime number3 is a prime number4 equals 2 * 25 is a prime number6 equals 2 * 37 is a prime number8 equals 2 * 49 equals 3 * 3</code></pre><h2 id="range-函数"><a href="#range-函数" class="headerlink" title="range() 函数"></a>range() 函数</h2><blockquote><p>如果你需要一个数值序列，内置函数 range() 会很方便，它生成一个等差级数链表（不包含结束的end值）</p></blockquote><p><strong>语法：</strong></p><p><code>range(start, end, step=1)</code></p><pre><code>&gt;&gt;&gt; for i in range(5):...     print(i)...01234&gt;&gt;&gt; list(range(2,2))[]range(0, 10, 3)   0, 3, 6, 9range(-10, -100, -30)  -10, -40, -70</code></pre><p>range(10) 生成了一个包含 10 个值的链表，它用链表的索引值填充了这个长度为 10 的列表，所生成的链表中不包括范围中的结束值。也可以让 range() 操作从另一个数值开始，不指定时为0,或者可以指定一个不同的步进值（甚至是负数，有时这也被称为 “步长”）</p><p><strong>如果你只是打印一个序列的话会发生奇怪的事情</strong></p><pre><code>&gt;&gt;&gt; print(range(10))range(0, 10)</code></pre><p>在不同方面 range() 函数返回的对象表现为它是一个列表，但事实上它并不是。当你迭代它时，它是一个能够像期望的序列返回连续项的对象；但为了节省空间，它并不真正构造列表。</p><p>我们称此类对象是 可迭代的，即适合作为那些期望从某些东西中获得连续项直到结束的函数或结构的一个目标（参数）。我们已经见过的 for 语句就是这样一个迭代器。list() 函数是另外一个（ 迭代器 ），它从可迭代（对象）中创建列表:</p><pre><code>&gt;&gt;&gt; list(range(5))[0, 1, 2, 3, 4]</code></pre><p>稍后我们会看到更多返回可迭代（对象）和以可迭代（对象）作为参数的函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;if语句&quot;&gt;&lt;a href=&quot;#if语句&quot; class=&quot;headerlink&quot; title=&quot;if语句&quot;&gt;&lt;/a&gt;if语句&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;if语句是用来检查一个条件：如果条件为真(true)，我们运行一个语句块（你为if块），否则(else)，我们执行另一个语句块（称为else块），else子语句是可选的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;单条件&quot;&gt;&lt;a href=&quot;#单条件&quot; class=&quot;headerlink&quot; title=&quot;单条件&quot;&gt;&lt;/a&gt;单条件&lt;/h3&gt;&lt;p&gt;示例：如果num变量大于1，那么就输出num大，否则就输出num小，num值为5&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding:utf-8 -*-
num = 5
if num &amp;gt; 1:
print(&amp;quot;num大&amp;quot;)
else:
print(&amp;quot;num小&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python num.py
num大
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;多条件&quot;&gt;&lt;a href=&quot;#多条件&quot; class=&quot;headerlink&quot; title=&quot;多条件&quot;&gt;&lt;/a&gt;多条件&lt;/h3&gt;&lt;p&gt;示例：请输入一个整数，如果输入的为负数，负数转变为0,输出print(‘Negative changed to zero’);如果输入的为0，则输出Zero;如果输入的为1，则输出Single；输入其他则，输出More。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#__author: Administrator
#date: 2017/12/19
x = int(input(&amp;apos;Please enter an integer: &amp;apos;))
if x &amp;lt; 0:
    x = 0
    print(&amp;apos;Negative changed to zero&amp;apos;)
elif x == 0:
    print(&amp;apos;Zero&amp;apos;)
elif x == 1:
    print(&amp;apos;Single&amp;apos;)
else:
    print(&amp;apos;More&amp;apos;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Please enter an integer: -1
Negative changed to zero
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="python基础知识" scheme="http://www.chenfanlinux.org/categories/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Python" scheme="http://www.chenfanlinux.org/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Zabbx基础安装</title>
    <link href="http://www.chenfanlinux.org/2017/12/11/zabbx%E5%9F%BA%E7%A1%80%E5%AE%89%E8%A3%85/"/>
    <id>http://www.chenfanlinux.org/2017/12/11/zabbx基础安装/</id>
    <published>2017-12-11T10:07:48.000Z</published>
    <updated>2018-01-26T03:38:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、安装部署zabbix-3-4"><a href="#一、安装部署zabbix-3-4" class="headerlink" title="一、安装部署zabbix 3.4"></a>一、安装部署zabbix 3.4</h1><p><a href="https://baike.baidu.com/item/zabbix/6780368?fr=aladdin" target="_blank" rel="noopener">Zabbix</a> 是由 Alexei Vladishev 开发的一种网络监视、管理系统，基于 Server-Client 架构。可用于监视各种网络服务、服务器和网络机器等状态。</p><h2 id="1-zabbix基础说明"><a href="#1-zabbix基础说明" class="headerlink" title="1.zabbix基础说明"></a>1.zabbix基础说明</h2><h3 id="1-1-zabbix使用说明"><a href="#1-1-zabbix使用说明" class="headerlink" title="1.1  zabbix使用说明"></a>1.1  zabbix使用说明</h3><ul><li><p><a href="https://www.zabbix.com/documentation/3.4/zh/manual" target="_blank" rel="noopener">zabbix3.4软件中文使用手册</a></p></li><li><p><a href="http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/" target="_blank" rel="noopener">zabbix3.4版本安装包路径</a></p></li></ul><h3 id="1-2-zabbix-3-4版本说明"><a href="#1-2-zabbix-3-4版本说明" class="headerlink" title="1.2 zabbix 3.4版本说明"></a>1.2 zabbix 3.4版本说明</h3><p>Zabbix Server端安装的软件：</p><ul><li>zabbix-server-mysql</li><li>zabbix-get</li><li>mysql</li><li>zabbix-web</li><li>zabbix-web-mysql</li></ul><p>Zabbix Clinet 端安装的软件</p><ul><li>zabbix-agent</li><li>zabbix-sender</li></ul><h2 id="2-zabbix系统环境配置"><a href="#2-zabbix系统环境配置" class="headerlink" title="2.zabbix系统环境配置"></a>2.zabbix系统环境配置</h2><h3 id="2-1-系统环境"><a href="#2-1-系统环境" class="headerlink" title="2.1 系统环境"></a>2.1 系统环境</h3><pre><code># cat /etc/redhat-releaseCentOS Linux release 7.4.1708 (Core)</code></pre><h3 id="2-2-永久修改主机名"><a href="#2-2-永久修改主机名" class="headerlink" title="2.2 永久修改主机名"></a>2.2 永久修改主机名</h3><pre><code># hostnamectl --static set-hostname zabbix-server</code></pre><h3 id="2-3-关闭防火墙及selinux"><a href="#2-3-关闭防火墙及selinux" class="headerlink" title="2.3 关闭防火墙及selinux"></a>2.3 关闭防火墙及selinux</h3><pre><code># systemctl stop firewalld.service# systemctl daemon-reload# systemctl disable firewalld.service# sed -i &apos;s/SELINUX=enforcing/SELINUX=disabled/g&apos; /etc/selinux/config# grep SELINUX=disabled /etc/selinux/config# setenforce 0# getenforce  Disabled</code></pre><a id="more"></a><h2 id="3-数据库的安装与配置"><a href="#3-数据库的安装与配置" class="headerlink" title="3.数据库的安装与配置"></a>3.数据库的安装与配置</h2><h3 id="3-1-MariaDB概述"><a href="#3-1-MariaDB概述" class="headerlink" title="3.1 MariaDB概述"></a>3.1 MariaDB概述</h3><p>MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可。<br>开发这个分支的原因是：甲骨文公司收购了MySQL后，有将MySQL闭源的潜在风险，因此社区采用分支的方式来避开这个风险。MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。</p><h3 id="3-2-安装mariadb"><a href="#3-2-安装mariadb" class="headerlink" title="3.2 安装mariadb"></a>3.2 安装mariadb</h3><pre><code># yum install mariadb-server mariadb -y# rpm -qa |grep mariamariadb-5.5.56-2.el7.x86_64mariadb-server-5.5.56-2.el7.x86_64mariadb-libs-5.5.56-2.el7.x86_64</code></pre><h3 id="3-3-配置数据库服务"><a href="#3-3-配置数据库服务" class="headerlink" title="3.3 配置数据库服务"></a>3.3 配置数据库服务</h3><pre><code># vim /etc/my.cnf添加如下两行：innodb_file_per_table=onskip_name_resolve=on</code></pre><h3 id="3-4-启动mariadb数据库并设置开机自启动"><a href="#3-4-启动mariadb数据库并设置开机自启动" class="headerlink" title="3.4 启动mariadb数据库并设置开机自启动"></a>3.4 启动mariadb数据库并设置开机自启动</h3><pre><code># systemctl start mariadb# systemctl enable mariadb</code></pre><h3 id="3-5-设置mariadb数据库的安全配置"><a href="#3-5-设置mariadb数据库的安全配置" class="headerlink" title="3.5 设置mariadb数据库的安全配置"></a>3.5 设置mariadb数据库的安全配置</h3><pre><code># mysql_secure_installation  //根据需求设置密码password:test# mysql -uroot -ptest //登录mysql</code></pre><h3 id="3-6-创建数据库zabbix数据库并授权用户"><a href="#3-6-创建数据库zabbix数据库并授权用户" class="headerlink" title="3.6 创建数据库zabbix数据库并授权用户"></a>3.6 创建数据库zabbix数据库并授权用户</h3><p>创建zabbix数据库，并创建zbuser用户具有库的访问权限。</p><pre><code>&gt; CREATE DATABASE  zabbix  DEFAULT CHARACTER SET utf8 COLLATE utf8_bin;&gt; GRANT ALL PRIVILEGES ON zabbix.* TO zbuser@localhost IDENTIFIED BY &apos;test&apos;;&gt; FLUSH PRIVILEGES ;# mysql -uzbuser -ptest zabbix //登录测试</code></pre><h2 id="4-安装配置zabbix-3-4"><a href="#4-安装配置zabbix-3-4" class="headerlink" title="4.安装配置zabbix.3.4"></a>4.安装配置zabbix.3.4</h2><h3 id="4-1-zabbix相关软件包的安装"><a href="#4-1-zabbix相关软件包的安装" class="headerlink" title="4.1 zabbix相关软件包的安装"></a>4.1 zabbix相关软件包的安装</h3><h4 id="4-1-1-安装zabbix相关的yum源"><a href="#4-1-1-安装zabbix相关的yum源" class="headerlink" title="4.1.1 安装zabbix相关的yum源"></a>4.1.1 安装zabbix相关的yum源</h4><pre><code># rpm -ivh http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/zabbix-release-3.4-1.el7.centos.noarch.rpm</code></pre><h4 id="4-1-2-安装zabbix相关包"><a href="#4-1-2-安装zabbix相关包" class="headerlink" title="4.1.2 安装zabbix相关包"></a>4.1.2 安装zabbix相关包</h4><p>zabbix服务端需要安装：zabbix-server-mysql zabbix-web-mysql  zabbix-get<br>zabbix被监控主机端安装的软件：：zabbix-agent, zabbix-sender</p><pre><code># yum install zabbix-server-mysql zabbix-web-mysql zabbix-get zabbix-agent zabbix-sender -y# rpm -qa |grep zabbix zabbix-web-mysql-3.4.4-2.el7.noarch zabbix-get-3.4.4-2.el7.x86_64 zabbix-web-3.4.4-2.el7.noarch zabbix-agent-3.4.4-2.el7.x86_64 zabbix-release-3.4-1.el7.centos.noarch zabbix-server-mysql-3.4.4-2.el7.x86_64 zabbix-sender-3.4.4-2.el7.x86_64</code></pre><h3 id="4-2-zabbix相关数据导入数据库"><a href="#4-2-zabbix相关数据导入数据库" class="headerlink" title="4.2 zabbix相关数据导入数据库"></a>4.2 zabbix相关数据导入数据库</h3><pre><code># cd /usr/share/doc/zabbix-server-mysql-3.4.4/# zcat create.sql.gz |mysql -uzbuser -ptest zabbix</code></pre><h3 id="4-3-修改数据库相关配置"><a href="#4-3-修改数据库相关配置" class="headerlink" title="4.3 修改数据库相关配置"></a>4.3 修改数据库相关配置</h3><pre><code># vim /etc/zabbix/zabbix_server.conf# grep -n &apos;^&apos;[a-Z] /etc/zabbix/zabbix_server.conf38:LogFile=/var/log/zabbix/zabbix_server.log49:LogFileSize=072:PidFile=/var/run/zabbix/zabbix_server.pid82:SocketDir=/var/run/zabbix91:DBHost=localhost101:DBName=zabbix117:DBUser=zbuser125:DBPassword=test132:DBSocket=/var/lib/mysql/mysql.sock316:SNMPTrapperFile=/var/log/snmptrap/snmptrap.log434:Timeout=4476:AlertScriptsPath=/usr/lib/zabbix/alertscripts486:ExternalScripts=/usr/lib/zabbix/externalscripts522:LogSlowQueries=3000</code></pre><h3 id="4-4-启动zabbix-server并设置开机启动"><a href="#4-4-启动zabbix-server并设置开机启动" class="headerlink" title="4.4 启动zabbix server并设置开机启动"></a>4.4 启动zabbix server并设置开机启动</h3><pre><code># systemctl enable zabbix-server# systemctl start zabbix-server</code></pre><h3 id="4-5-编辑Zabbix前端PHP配置-更改时区"><a href="#4-5-编辑Zabbix前端PHP配置-更改时区" class="headerlink" title="4.5 编辑Zabbix前端PHP配置,更改时区"></a>4.5 编辑Zabbix前端PHP配置,更改时区</h3><pre><code># vim /etc/httpd/conf.d/zabbix.confphp_value date.timezone Asia/Shanghaiphp_value date.timezone Asia/Shanghai</code></pre><h3 id="4-6-启动httpd并设置开机启动"><a href="#4-6-启动httpd并设置开机启动" class="headerlink" title="4.6 启动httpd并设置开机启动"></a>4.6 启动httpd并设置开机启动</h3><pre><code># systemctl start httpd# systemctl enable httpd</code></pre><h3 id="4-7-图形界面安装配置zabbix"><a href="#4-7-图形界面安装配置zabbix" class="headerlink" title="4.7 图形界面安装配置zabbix"></a>4.7 图形界面安装配置zabbix</h3><p>浏览器输入<a href="http://server_ip/zabbix,根据图形引导信息,配置zabbix信息。" target="_blank" rel="noopener">http://server_ip/zabbix,根据图形引导信息,配置zabbix信息。</a></p><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/nggAUz" alt="1"></p><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/TUgNnW" alt="2"></p><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/0742rj" alt="3"></p><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/Iv6t7z" alt="4"></p><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/VNlpQC" alt="5"></p><p><strong>zabbix初始登录账户和密码为： Admin  zabbix</strong></p><h2 id="5-zabbxi-agent安装及配置"><a href="#5-zabbxi-agent安装及配置" class="headerlink" title="5.zabbxi-agent安装及配置"></a>5.zabbxi-agent安装及配置</h2><h3 id="5-1-安装zabbxi-agent"><a href="#5-1-安装zabbxi-agent" class="headerlink" title="5.1 安装zabbxi-agent"></a>5.1 安装zabbxi-agent</h3><pre><code># yum install zabbix-agent  zabbix-sender -y# grep -n &apos;^&apos;[a-Z] /etc/zabbix/zabbix_agentd.conf 13:PidFile=/var/run/zabbix/zabbix_agentd.pid 32:LogFile=/var/log/zabbix/zabbix_agentd.log 43:LogFileSize=0 95:Server=127.0.0.1 136:ServerActive=127.0.0.1 147:Hostname=zabbix-server 265:Include=/etc/zabbix/zabbix_agentd.d/*.conf</code></pre><p>Server：被动模式，允许哪台服务器连接Agent。<br>ServerActive：主动模式，向哪台服务器传送数据。</p><h3 id="5-2-启动zabbix-agent"><a href="#5-2-启动zabbix-agent" class="headerlink" title="5.2 启动zabbix-agent"></a>5.2 启动zabbix-agent</h3><pre><code># systemctl start zabbix-agent# systemctl enable zabbix-agent</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、安装部署zabbix-3-4&quot;&gt;&lt;a href=&quot;#一、安装部署zabbix-3-4&quot; class=&quot;headerlink&quot; title=&quot;一、安装部署zabbix 3.4&quot;&gt;&lt;/a&gt;一、安装部署zabbix 3.4&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/zabbix/6780368?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Zabbix&lt;/a&gt; 是由 Alexei Vladishev 开发的一种网络监视、管理系统，基于 Server-Client 架构。可用于监视各种网络服务、服务器和网络机器等状态。&lt;/p&gt;
&lt;h2 id=&quot;1-zabbix基础说明&quot;&gt;&lt;a href=&quot;#1-zabbix基础说明&quot; class=&quot;headerlink&quot; title=&quot;1.zabbix基础说明&quot;&gt;&lt;/a&gt;1.zabbix基础说明&lt;/h2&gt;&lt;h3 id=&quot;1-1-zabbix使用说明&quot;&gt;&lt;a href=&quot;#1-1-zabbix使用说明&quot; class=&quot;headerlink&quot; title=&quot;1.1  zabbix使用说明&quot;&gt;&lt;/a&gt;1.1  zabbix使用说明&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.zabbix.com/documentation/3.4/zh/manual&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;zabbix3.4软件中文使用手册&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;zabbix3.4版本安装包路径&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-2-zabbix-3-4版本说明&quot;&gt;&lt;a href=&quot;#1-2-zabbix-3-4版本说明&quot; class=&quot;headerlink&quot; title=&quot;1.2 zabbix 3.4版本说明&quot;&gt;&lt;/a&gt;1.2 zabbix 3.4版本说明&lt;/h3&gt;&lt;p&gt;Zabbix Server端安装的软件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;zabbix-server-mysql&lt;/li&gt;
&lt;li&gt;zabbix-get&lt;/li&gt;
&lt;li&gt;mysql&lt;/li&gt;
&lt;li&gt;zabbix-web&lt;/li&gt;
&lt;li&gt;zabbix-web-mysql&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Zabbix Clinet 端安装的软件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;zabbix-agent&lt;/li&gt;
&lt;li&gt;zabbix-sender&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-zabbix系统环境配置&quot;&gt;&lt;a href=&quot;#2-zabbix系统环境配置&quot; class=&quot;headerlink&quot; title=&quot;2.zabbix系统环境配置&quot;&gt;&lt;/a&gt;2.zabbix系统环境配置&lt;/h2&gt;&lt;h3 id=&quot;2-1-系统环境&quot;&gt;&lt;a href=&quot;#2-1-系统环境&quot; class=&quot;headerlink&quot; title=&quot;2.1 系统环境&quot;&gt;&lt;/a&gt;2.1 系统环境&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;# cat /etc/redhat-release
CentOS Linux release 7.4.1708 (Core)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;2-2-永久修改主机名&quot;&gt;&lt;a href=&quot;#2-2-永久修改主机名&quot; class=&quot;headerlink&quot; title=&quot;2.2 永久修改主机名&quot;&gt;&lt;/a&gt;2.2 永久修改主机名&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;# hostnamectl --static set-hostname zabbix-server
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;2-3-关闭防火墙及selinux&quot;&gt;&lt;a href=&quot;#2-3-关闭防火墙及selinux&quot; class=&quot;headerlink&quot; title=&quot;2.3 关闭防火墙及selinux&quot;&gt;&lt;/a&gt;2.3 关闭防火墙及selinux&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;# systemctl stop firewalld.service
# systemctl daemon-reload
# systemctl disable firewalld.service

# sed -i &amp;apos;s/SELINUX=enforcing/SELINUX=disabled/g&amp;apos; /etc/selinux/config
# grep SELINUX=disabled /etc/selinux/config
# setenforce 0
# getenforce
  Disabled
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="linux服务" scheme="http://www.chenfanlinux.org/categories/linux%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="Zabbix" scheme="http://www.chenfanlinux.org/tags/Zabbix/"/>
    
  </entry>
  
</feed>
