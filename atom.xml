<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陈凡的博客</title>
  
  <subtitle>chenfanlinux.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.chenfanlinux.org/"/>
  <updated>2018-01-05T05:33:31.000Z</updated>
  <id>http://www.chenfanlinux.org/</id>
  
  <author>
    <name>陈凡</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Bash特性汇总</title>
    <link href="http://www.chenfanlinux.org/2018/01/05/Bash%E7%89%B9%E6%80%A7%E6%B1%87%E6%80%BB/"/>
    <id>http://www.chenfanlinux.org/2018/01/05/Bash特性汇总/</id>
    <published>2018-01-05T04:35:53.000Z</published>
    <updated>2018-01-05T05:33:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是shell"><a href="#什么是shell" class="headerlink" title="什么是shell?"></a>什么是shell?</h2><blockquote><p>通常,替我们工作的是”硬件”,而控制硬件的是”内核”。用户利用”shell”控制着一些内核提供的”工具”,来控制硬件替我们工作。由于内核听不懂人类语言,所以shell从本质来说就是一个UI(用户界面)应用程序,让内核控制着硬件正确无误的工作，如图1-1 硬件-内核-shell 所示，可以清晰的看到他们的关系。</p></blockquote><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/DDfPGJ" alt="硬件-内核"></p><h2 id="Bash-shell功能特性"><a href="#Bash-shell功能特性" class="headerlink" title="Bash shell功能特性"></a>Bash shell功能特性</h2><h3 id="history命令记忆功能"><a href="#history命令记忆功能" class="headerlink" title="history命令记忆功能"></a>history命令记忆功能</h3><blockquote><p>在Bash里面,我们只要在命令行按”上、下键”或者更强大的”Ctrl+r”,就可以找到之前输入的历史命令,这依赖于Bash的命令记录功能,记录的文件位于家目录下的.bash_history。登录shell后新执行的命令只会记录在缓存中,这些命令会在用户退出时追加到命令历史文件中,我们通过history命令可以查看历史命令.</p></blockquote><p><strong>命令历史相关的环境变量:</strong></p><ul><li>HISTSIZE: 命令历史记录的条数</li><li>HISTFILE: ~/.bash_history</li></ul><p><strong>命令历史调用相关的命令:</strong></p><ul><li><p>调用历史中的命令:</p><ul><li>!#: 重复执行第#条指令</li><li>!!: 重复上一条命令</li><li>!string: 匹配以string开头的命令</li></ul></li><li><p>调用上一条命令的最后一个参数:</p><ul><li>!$</li><li>ESC . （先按esc,释放然后按.）</li></ul></li></ul><a id="more"></a><h3 id="命令与文件补全功能"><a href="#命令与文件补全功能" class="headerlink" title="命令与文件补全功能"></a>命令与文件补全功能</h3><blockquote><p>常在bash中使用热键[Tab]是一个好习惯,因为它可以减少键盘的输入和保证命令的输出的正确性。</p></blockquote><ul><li>接在一串命令的第一个字后面,则为命令的补全</li><li>接在一床命令的第二个字以后时,则为文件的补全</li></ul><h3 id="命令别名的功能"><a href="#命令别名的功能" class="headerlink" title="命令别名的功能"></a>命令别名的功能</h3><blockquote><p>通过给常用命令设置别名的方式,减少命令的输出长度,提升工作效率。命令行键入alias命令,可以查看系统配置的alias命令,将命令别名记录在全局配置环境配置文件/etc/profile或~/.bashrc都是一种持久生效的方式.</p></blockquote><pre><code>[root@chenfanlinux ~]# aliasalias cp=&apos;cp -i&apos;alias egrep=&apos;egrep --color=auto&apos;alias fgrep=&apos;fgrep --color=auto&apos;alias grep=&apos;grep --color=auto&apos;alias l.=&apos;ls -d .* --color=auto&apos;alias ll=&apos;ls -l --color=auto&apos;alias ls=&apos;ls --color=auto&apos;alias mv=&apos;mv -i&apos;alias rm=&apos;rm -i&apos;alias which=&apos;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde&apos;</code></pre><p>   <strong>注意:由于shell脚本中的别名不生效，\cp的含义是脱去别名的设置。</strong></p><h3 id="命令行展开功能"><a href="#命令行展开功能" class="headerlink" title="命令行展开功能"></a>命令行展开功能</h3><blockquote><p>{}:可以承载一个以逗号分隔的列表,并将其展开为多个路径.</p></blockquote><pre><code>$ mkdir /tmp/{a,b} &lt;==&gt;  $ mkdir /tmp/a;mkdir /tmp/b$ mkdir /tmp/{tom,jerry}/hi &lt;==&gt;  $ mkidr /tmp/tom/hi;mkdir /tmp/jerry/hi</code></pre><h3 id="作业-jobs-、前台-fg-、后台-bg-控制"><a href="#作业-jobs-、前台-fg-、后台-bg-控制" class="headerlink" title="作业(jobs)、前台(fg)、后台(bg)控制"></a>作业(jobs)、前台(fg)、后台(bg)控制</h3><blockquote><p>使用前台、后台控制,可以让工作进行得更加的顺利.我们可以随时将作业放置到后台执行,不用担心使用了[Ctrl]+c键来停掉该程序。在单用户登录环境中，达到了多任务的目标。</p></blockquote><ul><li>前台作业: 通过终端启动,且启动后一直占据终端</li><li><p>后台作业: 通过终端启动,但启动后即转入后台运行(释放终端)</p></li><li><p><strong>如何让作业运行于后台?</strong></p><ul><li><p>运行中的作业<br><code>Ctrl+Z</code></p></li><li><p>尚未启动的作业<br><code>COMMAND &amp;</code><br><strong><em>此类作业虽然被送往后台运行,但其依然与终端相关,<br>因为退出登录后作业将停止运行;如果希望送往后台,剥离与终端的关系。</em></strong></p></li><li><p>剥离作业与终端的关系<br><code>nohup COMMAND &amp;</code></p></li></ul></li></ul><ul><li><p><strong>作业控制相关命令:</strong></p><ul><li>查看所有作业情况<br><code>jobs</code></li><li>指定的后台作业调回前台<br><code>fg [[%]JOB_NUM]</code></li><li>让送往后台的作业在后台继续运行<br><code>bg [[%]JOB_NUM]</code></li><li>终止指定的作业<br><code>kill [%JOB_NUM]</code></li></ul></li></ul><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><blockquote><p>除了完整的字符串之外,bash还支持许多通配符来帮助用户查询和执行命令。下表列出常见的通配符,仅供参考。</p></blockquote><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">内容</th></tr></thead><tbody><tr><td style="text-align:center">*</td><td style="text-align:center">通配符,代表0个或多个字符(或数字)</td></tr><tr><td style="text-align:center">?</td><td style="text-align:center">通配符,代表一个有一个字符</td></tr><tr><td style="text-align:center">#</td><td style="text-align:center">注释,常在脚本中,被视为说明</td></tr><tr><td style="text-align:center">\</td><td style="text-align:center">转义字符,将特殊字符或通配符还原成一般字符</td></tr><tr><td style="text-align:center">~</td><td style="text-align:center">用户的家目录</td></tr><tr><td style="text-align:center">$</td><td style="text-align:center">变量之前需要加的变量替换值</td></tr><tr><td style="text-align:center">&amp;</td><td style="text-align:center">将命令转为后台执行</td></tr><tr><td style="text-align:center">!</td><td style="text-align:center">逻辑运算符(not)意思</td></tr><tr><td style="text-align:center">/</td><td style="text-align:center">路径分隔符</td></tr><tr><td style="text-align:center">&gt; &gt;&gt;</td><td style="text-align:center">重定向与追加重定向</td></tr><tr><td style="text-align:center">‘</td><td style="text-align:center">单引号,不具有变量置换功能</td></tr><tr><td style="text-align:center">“</td><td style="text-align:center">具有变量置换功能</td></tr><tr><td style="text-align:center">``</td><td style="text-align:center">中间为可以执行的命令</td></tr><tr><td style="text-align:center">()</td><td style="text-align:center">中间为子shell的起始于结束</td></tr><tr><td style="text-align:center">[] [^]</td><td style="text-align:center">中间为字符的组合</td></tr><tr><td style="text-align:center">{}</td><td style="text-align:center">中间为命令区块的组合</td></tr></tbody></table><table><thead><tr><th style="text-align:center">组合按键</th><th style="text-align:center">执行结果</th></tr></thead><tbody><tr><td style="text-align:center">Ctrl+c</td><td style="text-align:center">终止当前的命令</td></tr><tr><td style="text-align:center">Ctrl+a</td><td style="text-align:center">跳转至命令开始处</td></tr><tr><td style="text-align:center">Ctrl+e</td><td style="text-align:center">跳转至命令结尾处</td></tr><tr><td style="text-align:center">Ctrl+u</td><td style="text-align:center">删除命令行首至光标所在处的所有内容</td></tr><tr><td style="text-align:center">Ctrl+k</td><td style="text-align:center">删除光标所在行至命令行尾部的内容</td></tr><tr><td style="text-align:center">Ctrl+z</td><td style="text-align:center">暂停当前命令的执行</td></tr><tr><td style="text-align:center">Ctrl+l</td><td style="text-align:center">清屏,相当于clear命令</td></tr></tbody></table><p><strong>匹配字符举例</strong></p><ul><li>* 任意长度的任意字符</li><li>? 任意单个字符</li><li><p>[] 只能匹配指定范围内的任意单个字符</p><ul><li>[0-9] 所有数字中挑一个</li><li>[a-z] 不分区字符大小写</li><li>[A-Z] 大写字母</li><li>[[:lower:]] 小写字母</li><li>[^0-9a-z] 特殊字符</li></ul></li><li><p>[^] 匹配指定范围外的任意单个字符</p></li><li><p>专用字符集合:</p><ul><li>[:digit:]:任意数字,相当于0-9</li><li>[:lower:]:任意小写字母</li><li>[:upper:]:任意大写字母</li><li>[:alpha:]:任意大小写字母</li><li>[:alnum:]:任意数字或字母</li><li>[:space:]:空格</li><li>[:punct:]:标点符号</li></ul></li></ul><h3 id="命令执行的判断依据-amp-amp"><a href="#命令执行的判断依据-amp-amp" class="headerlink" title="命令执行的判断依据(; &amp;&amp; ||)"></a>命令执行的判断依据(; &amp;&amp; ||)</h3><blockquote><p>通常来说命令的运行状态会返回两种结果,执行成功则返回0，执行错误则返回非0。而多个命令的执行通常,从前至后,而且命令的执行还具有一定的逻辑关系,上一个命令的执行成功与否,某种程序可用决定下一个命令的执行。</p></blockquote><p><strong>一次执行多个命令,命令之间没有关联。</strong></p><pre><code>[root@chenfanlinux ~]# toch test.txt ; echo &quot;I  touch test.txt&quot;-bash: toch: 未找到命令I touch test.txt</code></pre><p><strong>命令相互关联,上一个命令执行成功,才会执行下一个命令。</strong></p><pre><code>[root@chenfanlinux ~]# toch test.txt &amp;&amp; echo &quot;I touch test.txt&quot;-bash: toch: 未找到命令</code></pre><p><strong>命令相关关联,上一个命令执行失败,才会执行下一个命令。</strong></p><pre><code>[root@chenfanlinux ~]# toch test.txt || echo &quot;I touch test.txt&quot;-bash: toch: 未找到命令I touch test.txt[root@chenfanlinux ~]# touch test.txt || echo &quot;I touch test.txt&quot;注意:这里不会执行echo &quot;I touch test.txt&quot;</code></pre><p><strong>如果第一个命令执行成功,则执行第二个命令,否则执行第三个命令。</strong></p><pre><code>[root@chenfanlinux ~]# touch test.txt &amp;&amp;  echo &quot;我是第二个命令&quot; || echo &quot;我是第三个命令&quot;我是第二个命令[root@chenfanlinux ~]# tuch test.txt &amp;&amp;  echo &quot;我是第二个命令&quot; || echo &quot;我是第三个命令&quot;-bash: tuch: 未找到命令我是第三个命令</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是shell&quot;&gt;&lt;a href=&quot;#什么是shell&quot; class=&quot;headerlink&quot; title=&quot;什么是shell?&quot;&gt;&lt;/a&gt;什么是shell?&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;通常,替我们工作的是”硬件”,而控制硬件的是”内核”。用户利用”shell”控制着一些内核提供的”工具”,来控制硬件替我们工作。由于内核听不懂人类语言,所以shell从本质来说就是一个UI(用户界面)应用程序,让内核控制着硬件正确无误的工作，如图1-1 硬件-内核-shell 所示，可以清晰的看到他们的关系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-std.dprcdn.net/files/acc_582513/DDfPGJ&quot; alt=&quot;硬件-内核&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Bash-shell功能特性&quot;&gt;&lt;a href=&quot;#Bash-shell功能特性&quot; class=&quot;headerlink&quot; title=&quot;Bash shell功能特性&quot;&gt;&lt;/a&gt;Bash shell功能特性&lt;/h2&gt;&lt;h3 id=&quot;history命令记忆功能&quot;&gt;&lt;a href=&quot;#history命令记忆功能&quot; class=&quot;headerlink&quot; title=&quot;history命令记忆功能&quot;&gt;&lt;/a&gt;history命令记忆功能&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在Bash里面,我们只要在命令行按”上、下键”或者更强大的”Ctrl+r”,就可以找到之前输入的历史命令,这依赖于Bash的命令记录功能,记录的文件位于家目录下的.bash_history。登录shell后新执行的命令只会记录在缓存中,这些命令会在用户退出时追加到命令历史文件中,我们通过history命令可以查看历史命令.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;命令历史相关的环境变量:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HISTSIZE: 命令历史记录的条数&lt;/li&gt;
&lt;li&gt;HISTFILE: ~/.bash_history&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;命令历史调用相关的命令:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;调用历史中的命令:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;!#: 重复执行第#条指令&lt;/li&gt;
&lt;li&gt;!!: 重复上一条命令&lt;/li&gt;
&lt;li&gt;!string: 匹配以string开头的命令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;调用上一条命令的最后一个参数:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;!$&lt;/li&gt;
&lt;li&gt;ESC . （先按esc,释放然后按.）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Bash基础" scheme="http://www.chenfanlinux.org/categories/Bash%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Bash" scheme="http://www.chenfanlinux.org/tags/Bash/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门之基础概念与架构(一)</title>
    <link href="http://www.chenfanlinux.org/2017/12/28/Docker%E5%85%A5%E9%97%A8%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%9E%B6%E6%9E%84-%E4%B8%80/"/>
    <id>http://www.chenfanlinux.org/2017/12/28/Docker入门之基础概念与架构-一/</id>
    <published>2017-12-28T01:11:33.000Z</published>
    <updated>2017-12-28T04:15:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是docker"><a href="#什么是docker" class="headerlink" title="什么是docker?"></a>什么是docker?</h3><p><a href="https://www.docker.com" target="_blank" rel="noopener">Docker</a> 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 <a href="https://zh.wikipedia.org/wiki/Cgroups" target="_blank" rel="noopener">cgroup</a>，<a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">namespace</a>，以及 <a href="https://en.wikipedia.org/wiki/Aufs" target="_blank" rel="noopener">AUFS</a> 类的 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">Union FS</a> 等技术，对进程进行封装隔离，属于 <a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization" target="_blank" rel="noopener">操作系统层面的虚拟化技术</a>。由于隔离的进程独立于宿主和其它的隔离的进程，在容器中运行的程序只能看到容器的内容和分配给该容器的设备,因此也称其为容器。最初实现是基于 <a href="https://linuxcontainers.org/lxc/introduction/" target="_blank" rel="noopener">LXC</a>，Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。</p><ul><li>Docker容器本质上是宿主机上的一个进程，Docker通过namespace实现了资源隔离。</li><li>Docker有六个命名空间：PID(进程pid号) Network(网络空间) (User用户空间) IPC(进程间通信) UTS(主机名和域名) Mount(挂载,文件系统)。为了隔离有问题的应用，运用Namespace将进程隔离，为进程或进程组创建已隔离的运行空间，为进程提供不同的命名空间视图；这样，每一个隔离出来的进程组，对外就表现为一个container.</li><li>Namespaces充当隔离的第一级，确保一个容器中运行一个进程而且不能看到或影响容器外的其它进程.</li><li>cgroups是LXC的重要组成部分，实现了资源的限制，通过写时复制机制copy-on-write实现了高效的文件操作.</li><li>UnionFS（文件系统）作为容器的构建块,分层镜像实现的基础,为了支持Docker的轻量级以及速度快的特性，它创建了用户层.</li></ul><h3 id="为什么使用docker？"><a href="#为什么使用docker？" class="headerlink" title="为什么使用docker？"></a>为什么使用docker？</h3><p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p><ul><li>容器技术与传统虚拟机虚拟化方式对比：</li></ul><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/vyEvvG" alt="传统虚拟机"></p><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/hEWM0Z" alt="Docker"></p><ul><li>容器技术与传统虚拟机性能对比：</li></ul><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/6RGWHJ" alt="性能对比"></p><a id="more"></a><h3 id="Docker给DevOps带来的好处"><a href="#Docker给DevOps带来的好处" class="headerlink" title="Docker给DevOps带来的好处"></a>Docker给DevOps带来的好处</h3><ul><li><p>更快速的交付和部署<br>开发人员可以使用镜像快速的构建标准开发环境；开发完成后，测试和运维人员可以使用开发人员提供的docker镜像快速部署应用，可以避免开发和测试运维人员之间的环境差异导致的部署问题。</p></li><li><p>更高效的资源利用<br>Docker容器的运行不需要额外的虚拟化管理程序支持，它是内核级的虚拟化，在占用更少资源的情况实现更高的性能。</p></li><li><p>更方便的迁移和扩展<br>Docker容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、服务器等。这种兼容使得用户可以在不同的平台之间很方便的完成应用迁移。</p></li><li><p>更简单的更新管理<br>使用Dockerfile，只需要小小的配置修改，就可以替代以往大量的更新工作，并且所有修改都以增量方式进行分发和更新。</p></li></ul><h3 id="Docker的技术架构"><a href="#Docker的技术架构" class="headerlink" title="Docker的技术架构"></a>Docker的技术架构</h3><p>Docker有三个组件和三个基本元素,可以快速浏览下图来了解这些组建和元素，以及它们的关系。</p><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/AOBiup" alt="Docker技术架构"></p><p><strong>三个组件分别是：</strong></p><ul><li>Docker Client 是用户界面，它支持用户与Docker Daemon之间通信。</li><li>Docker Daemon 运行于主机上，处理服务请求。</li><li>Docker Index 是中央registry，支持拥有公有与私有访问权限的Docker容器镜像的备份。</li></ul><p><strong>三个基本要素分别是：</strong></p><ul><li><p>Docker Image<br>一个构建容器的只读模板，它包含了容器启动所需的所有信息，包括运行程序和配置数据。每个镜像都源于一个基本的镜像，然后根据Dockerfile中的指令创建模板。对于每个指令，就是在镜像上创建一个新的层面。</p></li><li><p>Docker Containers<br>负责应用程序的运行，包括操作系统、用户添加的文件以及元数据。运行容器源于我们在第一步中创建的镜像。当容器被启动后，一个读写层会被添加到镜像的顶层。当分配到合适的网络和IP地址后，需要的应用程序就可以在容器中运行了。</p></li><li><p>DockerFile是文件指令集，用来说明如何自动创建Docker镜像。</p></li></ul><h3 id="Centos7开始安装Docker"><a href="#Centos7开始安装Docker" class="headerlink" title="Centos7开始安装Docker"></a>Centos7开始安装Docker</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在Linux上安装Docker并配置加速器，Docker目前被分为两个版本：</p><ul><li>Community-Edition：社区版 </li><li>Enterprise-Edition：企业版</li></ul><h4 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h4><p><strong>卸载旧版本的Docker服务</strong></p><pre><code>$ yum remove docker \docker-common \  container-selinux \  docker-selinux \docker-engine</code></pre><p><strong>安装yum-utils，它提供yum-config-manager实用程序</strong>  </p><pre><code>$ yum install -y yum-utils</code></pre><p><strong>添加Docker的CE存储库(官网)</strong></p><pre><code>$ yum-config-manager \    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo</code></pre><p><strong>添加Docker的CE存储库(国内)</strong></p><pre><code>$ yum-config-manager \    --add-repo \    http://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo</code></pre><p><strong>更新软件包的索引列表</strong></p><pre><code>$ yum makecache fast    </code></pre><p><strong>安装最新版的Docker服务</strong></p><pre><code>yum install -y docker-ce</code></pre><p><strong>启动Docker服务</strong></p><pre><code>systemctl start docker</code></pre><p><strong>Docker服务随机自启</strong></p><pre><code>systemctl enable docker</code></pre><p><strong>卸载Docker服务</strong>  </p><p>   # 卸载软件包</p><pre><code>$ yum remove -y docker-ce</code></pre><p>卸载Docker后,/var/lib/docker/目录下会保留原Docker的镜像,网络,存储卷等文件. 如果需要全新安装Docker,需要删除/var/lib/docker/目录.    </p><pre><code>$ rm -rf /var/lib/docker</code></pre><p><strong>查看docker版本信息</strong></p><p>   # 获取版本信息的简介</p><pre><code>$ docker -v</code></pre><p>   # 获取详细的版本信息</p><pre><code>$ docker version</code></pre><h4 id="配置Docker加速器"><a href="#配置Docker加速器" class="headerlink" title="配置Docker加速器"></a>配置Docker加速器</h4><ol><li><p>由于众所周知的原因(墙)，从Docker Hub难以高效地下载镜像，除了使用VPN或代理之外，<br>最为有效的方式就是使用Docker国内镜像；  </p></li><li><p>DaoCloud为首个提供国内免费Docker Hub镜像的团体，可以使用DaoCloud团队提供的<br>Docker Hub Mirror服务代替Docker官网的Docker Hub； </p></li><li><p>官网：传送门，注册用户并登录；  </p></li><li><p>登录以后，在自己管理界面点击加速器标签，根据弹出页面配置加速器；  </p></li></ol><blockquote><p>该脚本可以将 –registry-mirror 加入到你的 Docker 配置文件 /etc/docker/daemon.json 中。适用于 Ubuntu14.04、Debian、CentOS6 、CentOS7、Fedora、Arch Linux、openSUSE Leap 42.1，其他版本可能有细微不同</p></blockquote><pre><code>curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://9fa458c0.m.daocloud.io</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是docker&quot;&gt;&lt;a href=&quot;#什么是docker&quot; class=&quot;headerlink&quot; title=&quot;什么是docker?&quot;&gt;&lt;/a&gt;什么是docker?&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.docker.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Docker&lt;/a&gt; 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 &lt;a href=&quot;https://zh.wikipedia.org/wiki/Cgroups&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;cgroup&lt;/a&gt;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Linux_namespaces&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;namespace&lt;/a&gt;，以及 &lt;a href=&quot;https://en.wikipedia.org/wiki/Aufs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AUFS&lt;/a&gt; 类的 &lt;a href=&quot;https://en.wikipedia.org/wiki/Union_mount&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Union FS&lt;/a&gt; 等技术，对进程进行封装隔离，属于 &lt;a href=&quot;https://en.wikipedia.org/wiki/Operating-system-level_virtualization&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;操作系统层面的虚拟化技术&lt;/a&gt;。由于隔离的进程独立于宿主和其它的隔离的进程，在容器中运行的程序只能看到容器的内容和分配给该容器的设备,因此也称其为容器。最初实现是基于 &lt;a href=&quot;https://linuxcontainers.org/lxc/introduction/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LXC&lt;/a&gt;，Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Docker容器本质上是宿主机上的一个进程，Docker通过namespace实现了资源隔离。&lt;/li&gt;
&lt;li&gt;Docker有六个命名空间：PID(进程pid号) Network(网络空间) (User用户空间) IPC(进程间通信) UTS(主机名和域名) Mount(挂载,文件系统)。为了隔离有问题的应用，运用Namespace将进程隔离，为进程或进程组创建已隔离的运行空间，为进程提供不同的命名空间视图；这样，每一个隔离出来的进程组，对外就表现为一个container.&lt;/li&gt;
&lt;li&gt;Namespaces充当隔离的第一级，确保一个容器中运行一个进程而且不能看到或影响容器外的其它进程.&lt;/li&gt;
&lt;li&gt;cgroups是LXC的重要组成部分，实现了资源的限制，通过写时复制机制copy-on-write实现了高效的文件操作.&lt;/li&gt;
&lt;li&gt;UnionFS（文件系统）作为容器的构建块,分层镜像实现的基础,为了支持Docker的轻量级以及速度快的特性，它创建了用户层.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;为什么使用docker？&quot;&gt;&lt;a href=&quot;#为什么使用docker？&quot; class=&quot;headerlink&quot; title=&quot;为什么使用docker？&quot;&gt;&lt;/a&gt;为什么使用docker？&lt;/h3&gt;&lt;p&gt;传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容器技术与传统虚拟机虚拟化方式对比：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-std.dprcdn.net/files/acc_582513/vyEvvG&quot; alt=&quot;传统虚拟机&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-std.dprcdn.net/files/acc_582513/hEWM0Z&quot; alt=&quot;Docker&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容器技术与传统虚拟机性能对比：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-std.dprcdn.net/files/acc_582513/6RGWHJ&quot; alt=&quot;性能对比&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Docker系列" scheme="http://www.chenfanlinux.org/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Docker" scheme="http://www.chenfanlinux.org/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>编辑器之神-vim</title>
    <link href="http://www.chenfanlinux.org/2017/12/24/%E7%BC%96%E8%BE%91%E5%99%A8%E4%B9%8B%E7%A5%9E-vim/"/>
    <id>http://www.chenfanlinux.org/2017/12/24/编辑器之神-vim/</id>
    <published>2017-12-24T02:24:27.000Z</published>
    <updated>2018-01-05T06:57:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vim简介"><a href="#vim简介" class="headerlink" title="vim简介"></a>vim简介</h3><p>vi是“Visual interface”的简称，它不像Word或WPS那样可以对字体、格式、段落等其他属性进行编排，它只是一个文本编辑程序。 vi没有菜单，只有命令，且命令繁多。vim(VIM - Vi IMproved)是vi的加强版本，在vi的基础上增加了如下功能。</p><blockquote><ul><li>增加了多级撤销</li><li>多窗口操作</li><li>提高了稳定性，减少了崩溃以及崩溃后也可以恢复</li><li>关键字自动补全以及上下文相关的补全</li></ul></blockquote><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/bEfzpN" alt="vim键盘图"></p><h3 id="vim的工作模式"><a href="#vim的工作模式" class="headerlink" title="vim的工作模式"></a>vim的工作模式</h3><p>Vi有三种基本工作模式：</p><ul><li>命令模式（普通模式）</li><li>文本输入模式</li><li>末行模式(底线命令模式)</li></ul><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/SDuEA" alt="vim工作模式"></p><h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><ul><li><strong>单个字符移动</strong></li></ul><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">移动方向</th></tr></thead><tbody><tr><td style="text-align:center">h</td><td style="text-align:center">向左移动</td></tr><tr><td style="text-align:center">l</td><td style="text-align:center">向右移动</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center">向下移动</td></tr><tr><td style="text-align:center">k</td><td style="text-align:center">向上移动</td></tr></tbody></table><ul><li><strong>单词移动</strong></li></ul><table><thead><tr><th style="text-align:center">单词</th><th style="text-align:center">移动方向</th></tr></thead><tbody><tr><td style="text-align:center">w</td><td style="text-align:center">将光标移动到下一个单词开头</td></tr><tr><td style="text-align:center">b</td><td style="text-align:center">将光标移动到前一个单词的开头</td></tr><tr><td style="text-align:center">e</td><td style="text-align:center">将光标移动到下一个单词的词末</td></tr><tr><td style="text-align:center">E</td><td style="text-align:center">移动到单词的结尾(忽略标点符号)</td></tr><tr><td style="text-align:center">ge</td><td style="text-align:center">将光标移动到前一个单词的词末</td></tr></tbody></table><ul><li><strong>行移动</strong></li></ul><table><thead><tr><th style="text-align:center">单词</th><th style="text-align:center">移动方向</th></tr></thead><tbody><tr><td style="text-align:center">$</td><td style="text-align:center">将光标移动到当前行的行尾</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">将光标移动到当前行的行首</td></tr><tr><td style="text-align:center">fx</td><td style="text-align:center">将光标移动到当前行的第一个字符x上</td></tr><tr><td style="text-align:center">3fx</td><td style="text-align:center">将光标移动到航前行的第3个字符x上</td></tr><tr><td style="text-align:center">%</td><td style="text-align:center">用于符号间的移动，它会在一对()、[]、{}之间跳跃</td></tr></tbody></table><a id="more"></a><ul><li><strong>文本块移动</strong></li></ul><table><thead><tr><th style="text-align:center">单词</th><th style="text-align:center">移动方向</th></tr></thead><tbody><tr><td style="text-align:center">(</td><td style="text-align:center">移到当前句子的开头</td></tr><tr><td style="text-align:center">)</td><td style="text-align:center">移到下一个句子的开头</td></tr><tr><td style="text-align:center">{</td><td style="text-align:center">移到当前一段的开头</td></tr><tr><td style="text-align:center">}</td><td style="text-align:center">移到下一段的开头</td></tr><tr><td style="text-align:center">ge</td><td style="text-align:center">将光标移动到前一个单词的词末</td></tr></tbody></table><ul><li><strong>在屏幕中移动</strong></li></ul><table><thead><tr><th style="text-align:center">单词</th><th style="text-align:center">移动方向</th></tr></thead><tbody><tr><td style="text-align:center">H</td><td style="text-align:center">移动到当前屏幕的开头</td></tr><tr><td style="text-align:center">M</td><td style="text-align:center">移动到当前屏幕中间</td></tr><tr><td style="text-align:center">L</td><td style="text-align:center">移动当前屏幕的末尾</td></tr><tr><td style="text-align:center">gg</td><td style="text-align:center">移动到文件开头</td></tr><tr><td style="text-align:center">xG</td><td style="text-align:center">跳转到指定的第x行，G移动到文件按末尾</td></tr></tbody></table><h3 id="滚屏与跳转"><a href="#滚屏与跳转" class="headerlink" title="滚屏与跳转"></a>滚屏与跳转</h3><ul><li><strong>半屏滚动</strong></li></ul><table><thead><tr><th style="text-align:center">快捷键</th><th style="text-align:center">方向</th></tr></thead><tbody><tr><td style="text-align:center">ctrl+u</td><td style="text-align:center">向上滚动</td></tr><tr><td style="text-align:center">ctrl+d</td><td style="text-align:center">向下滚动</td></tr></tbody></table><ul><li><strong>全屏滚动</strong></li></ul><table><thead><tr><th style="text-align:center">快捷键</th><th style="text-align:center">方向</th></tr></thead><tbody><tr><td style="text-align:center">ctrl+b</td><td style="text-align:center">向上滚动</td></tr><tr><td style="text-align:center">ctrl+f</td><td style="text-align:center">向下滚动</td></tr></tbody></table><ul><li><strong>定位光标的位置</strong></li></ul><table><thead><tr><th style="text-align:center">快捷键</th><th style="text-align:center">方向</th></tr></thead><tbody><tr><td style="text-align:center">zz</td><td style="text-align:center">将光标置于屏幕的中间</td></tr><tr><td style="text-align:center">zt</td><td style="text-align:center">将光标移动到屏幕的顶部</td></tr><tr><td style="text-align:center">zb</td><td style="text-align:center">将光标移动到屏幕的底部</td></tr></tbody></table><h3 id="文本插入操作"><a href="#文本插入操作" class="headerlink" title="文本插入操作"></a>文本插入操作</h3><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">i</td><td style="text-align:center">在当前光标的前面插入字符</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">在当前光标的后面追加字符</td></tr><tr><td style="text-align:center">o</td><td style="text-align:center">在当前光标的下一行行首插入字符</td></tr><tr><td style="text-align:center">O</td><td style="text-align:center">在当前光标的上一行行首插入字符</td></tr><tr><td style="text-align:center">I</td><td style="text-align:center">在一行的开头添加文本</td></tr><tr><td style="text-align:center">A</td><td style="text-align:center">在一行的结尾处添加文本</td></tr><tr><td style="text-align:center">u</td><td style="text-align:center">撤销修改</td></tr><tr><td style="text-align:center">ctrl+r</td><td style="text-align:center">反撤销修改</td></tr></tbody></table><h3 id="文本删除"><a href="#文本删除" class="headerlink" title="文本删除"></a>文本删除</h3><ul><li><strong>字符删除</strong></li></ul><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">x</td><td style="text-align:center">删除当前光标所在处的字符</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">删除当前光标左边的字符</td></tr></tbody></table><ul><li><strong>单词删除</strong></li></ul><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">dw</td><td style="text-align:center">删除一个单词(从光标处到空格)</td></tr><tr><td style="text-align:center">d$</td><td style="text-align:center">删除从光标到一行末尾的整个文本</td></tr><tr><td style="text-align:center">d0</td><td style="text-align:center">删除从光标到一行开头的所有单词</td></tr></tbody></table><ul><li><strong>行删除</strong></li></ul><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">dd</td><td style="text-align:center">删除当前光标处的一整行=D</td></tr><tr><td style="text-align:center">5dd</td><td style="text-align:center">删除从光标到文本开头</td></tr><tr><td style="text-align:center">dG</td><td style="text-align:center">删除从光标到文本结尾</td></tr></tbody></table><h3 id="文本复制、剪切与粘贴"><a href="#文本复制、剪切与粘贴" class="headerlink" title="文本复制、剪切与粘贴"></a>文本复制、剪切与粘贴</h3><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">y</td><td style="text-align:center">复制,p:粘贴</td></tr><tr><td style="text-align:center">yw</td><td style="text-align:center">复制一个单词</td></tr><tr><td style="text-align:center">y2w</td><td style="text-align:center">复制2个单词</td></tr><tr><td style="text-align:center">y$</td><td style="text-align:center">复制从当前光标到行结尾的所有单词</td></tr><tr><td style="text-align:center">y0</td><td style="text-align:center">复制从当前光标到行首的所有单词</td></tr><tr><td style="text-align:center">&gt;&gt;</td><td style="text-align:center">文本行右移</td></tr><tr><td style="text-align:center">&lt;&lt;</td><td style="text-align:center">文本行左移</td></tr><tr><td style="text-align:center">.</td><td style="text-align:center">重复命令</td></tr></tbody></table><p><strong>可视模式</strong></p><ul><li>v: 按字符移动,选中文本    </li><li>V: 按行移动,选中文本可视模式可以配合 d, y, &gt;&gt;, &lt;&lt; 实现对文本块的删除,复制,左右移动 </li><li>Ctrl+v: 列操作模式  <ul><li>删除某一列内容：先ctrl+v,然后通过上下左右键,选择需要操作的文本，键入d,则可以删除选中的列内容。</li><li>插入操作: 先ctrl+v,然后上下左右键，选择需要操作的列,键入shift+i(在列前面插入)或shift+a(在列后面插入)指定的内容；接下来按Esc才能看到插入生效,再键入Esc,回到命令行模式,保存退出。</li></ul></li></ul><h3 id="查找命令与替换"><a href="#查找命令与替换" class="headerlink" title="查找命令与替换"></a>查找命令与替换</h3><ul><li><strong>字符串查找</strong></li></ul><table><thead><tr><th style="text-align:center">表达式</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">/string</td><td style="text-align:center">正向查找</td></tr><tr><td style="text-align:center">?string</td><td style="text-align:center">反向查找</td></tr></tbody></table><ul><li><strong>字符串替换</strong></li></ul><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">:s/old/new</td><td style="text-align:center">将当前行的第一个字符串old替换为new</td></tr><tr><td style="text-align:center">:s/old/new/g</td><td style="text-align:center">将当前行的所有字符串old替换为new</td></tr><tr><td style="text-align:center">:90s/old/new/g</td><td style="text-align:center">将指定行的所有字符串old替换为new</td></tr><tr><td style="text-align:center">:90,93s/old/new/g</td><td style="text-align:center">将90到93行的所有字符串old替换为new</td></tr><tr><td style="text-align:center">:%s/old/new/g</td><td style="text-align:center">将文本中所有的字符串old替换为new</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;vim简介&quot;&gt;&lt;a href=&quot;#vim简介&quot; class=&quot;headerlink&quot; title=&quot;vim简介&quot;&gt;&lt;/a&gt;vim简介&lt;/h3&gt;&lt;p&gt;vi是“Visual interface”的简称，它不像Word或WPS那样可以对字体、格式、段落等其他属性进行编排，它只是一个文本编辑程序。 vi没有菜单，只有命令，且命令繁多。vim(VIM - Vi IMproved)是vi的加强版本，在vi的基础上增加了如下功能。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;增加了多级撤销&lt;/li&gt;
&lt;li&gt;多窗口操作&lt;/li&gt;
&lt;li&gt;提高了稳定性，减少了崩溃以及崩溃后也可以恢复&lt;/li&gt;
&lt;li&gt;关键字自动补全以及上下文相关的补全&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-std.dprcdn.net/files/acc_582513/bEfzpN&quot; alt=&quot;vim键盘图&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;vim的工作模式&quot;&gt;&lt;a href=&quot;#vim的工作模式&quot; class=&quot;headerlink&quot; title=&quot;vim的工作模式&quot;&gt;&lt;/a&gt;vim的工作模式&lt;/h3&gt;&lt;p&gt;Vi有三种基本工作模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命令模式（普通模式）&lt;/li&gt;
&lt;li&gt;文本输入模式&lt;/li&gt;
&lt;li&gt;末行模式(底线命令模式)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-std.dprcdn.net/files/acc_582513/SDuEA&quot; alt=&quot;vim工作模式&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;光标移动&quot;&gt;&lt;a href=&quot;#光标移动&quot; class=&quot;headerlink&quot; title=&quot;光标移动&quot;&gt;&lt;/a&gt;光标移动&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;单个字符移动&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;字符&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;移动方向&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;h&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;向左移动&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;l&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;向右移动&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;j&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;向下移动&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;k&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;向上移动&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;单词移动&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;单词&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;移动方向&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;w&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将光标移动到下一个单词开头&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;b&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将光标移动到前一个单词的开头&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;e&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将光标移动到下一个单词的词末&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;E&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;移动到单词的结尾(忽略标点符号)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;ge&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将光标移动到前一个单词的词末&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;行移动&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;单词&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;移动方向&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将光标移动到当前行的行尾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将光标移动到当前行的行首&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;fx&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将光标移动到当前行的第一个字符x上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;3fx&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将光标移动到航前行的第3个字符x上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;%&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;用于符号间的移动，它会在一对()、[]、{}之间跳跃&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="tools利器" scheme="http://www.chenfanlinux.org/categories/tools%E5%88%A9%E5%99%A8/"/>
    
    
      <category term="vim" scheme="http://www.chenfanlinux.org/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>python基础之流程控制</title>
    <link href="http://www.chenfanlinux.org/2017/12/19/python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>http://www.chenfanlinux.org/2017/12/19/python基础之流程控制/</id>
    <published>2017-12-19T14:31:23.000Z</published>
    <updated>2017-12-19T14:42:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><blockquote><p>if语句是用来检查一个条件：如果条件为真(true)，我们运行一个语句块（你为if块），否则(else)，我们执行另一个语句块（称为else块），else子语句是可选的。</p></blockquote><h3 id="单条件"><a href="#单条件" class="headerlink" title="单条件"></a>单条件</h3><p>示例：如果num变量大于1，那么就输出num大，否则就输出num小，num值为5</p><p><strong>代码：</strong></p><pre><code>#!/usr/bin/env python# -*- coding:utf-8 -*-num = 5if num &gt; 1:print(&quot;num大&quot;)else:print(&quot;num小&quot;)</code></pre><p><strong>结果：</strong></p><pre><code>python num.pynum大</code></pre><h3 id="多条件"><a href="#多条件" class="headerlink" title="多条件"></a>多条件</h3><p>示例：请输入一个整数，如果输入的为负数，负数转变为0,输出print(‘Negative changed to zero’);如果输入的为0，则输出Zero;如果输入的为1，则输出Single；输入其他则，输出More。</p><p><strong>代码：</strong></p><pre><code>#__author: Administrator#date: 2017/12/19x = int(input(&apos;Please enter an integer: &apos;))if x &lt; 0:    x = 0    print(&apos;Negative changed to zero&apos;)elif x == 0:    print(&apos;Zero&apos;)elif x == 1:    print(&apos;Single&apos;)else:    print(&apos;More&apos;)</code></pre><p><strong>结果：</strong></p><pre><code>Please enter an integer: -1Negative changed to zero</code></pre><a id="more"></a><h3 id="三元运算"><a href="#三元运算" class="headerlink" title="三元运算"></a>三元运算</h3><blockquote><p>如果条件成立，那么就把值1赋值给var，如果条件不成立，就把值2赋值给var</p></blockquote><p><strong>语法：</strong></p><p><code>var = 值1 if 条件 else 值2</code></p><p><strong>示例：</strong></p><pre><code>&gt;&gt;&gt; var = &quot;True&quot; if 1 == 1 else &quot;False&quot;&gt;&gt;&gt; var&apos;True&apos;</code></pre><h2 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h2><h3 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h3><blockquote><p>while 是Python中的循环语句. 事实它上是一个条件循环语句. 与 if 声明相比, 如果 if 后的条件为真, 就会执行一次相应的代码块. 而 while 中的代码块会一直循环执行, 直到循环条件不再为真.</p></blockquote><p><strong>语法：</strong></p><pre><code>while expression:       suite_to_repeat</code></pre><p>while 循环的suit_to_repeat子句会一直循环执行, 直到 expression 值为布尔假. 这种 类型的循环机制常常用在计数循环中。</p><p><strong>代码：</strong></p><pre><code>#__author: Administrator#date: 2017/12/19count = 0while (count &lt; 5):    print(&apos;The index is: &apos;,count)    count += 1</code></pre><p><strong>结果：</strong></p><pre><code>The index is:  0The index is:  1The index is:  2The index is:  3The index is:  4</code></pre><h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><p>你必须小心地使用 while 循环, 因为有可能它的条件永远不会为布尔假. 这样一来循环就永远不会结束. 这些”无限”的循环不一定是坏事, 许多通讯服务器的客户端/服务器系统就是通过它来工作的. 这取决于循环是否需要一直执行下去, 如果不是, 那么这个循环是否会结束; 也就是说, 条件表达式会不会计算后得到布尔假?</p><pre><code>while True:    handle, indata = wait_for_client_connect()    outdata = process_request(indata)    ack_result_to_client(handle, outdata)</code></pre><p>例如上边的代码就是故意被设置为无限循环的，因为 True 无论如何都不会变成 False. 这是因为服务器代码是用来等待客户端(可能通过网络)来连接的. 这些客户端向服务器发送请求, 服务器处理请求.<br>请求被处理后, 服务器将向客户端返回数据, 而此时客户端可能断开连接或是发送另一个请求. 对于服务器而言它已经完成了对这个客户端的任务, 它会返回最外层循环等待下一个连接.</p><h3 id="while使用-else-语句"><a href="#while使用-else-语句" class="headerlink" title="while使用 else 语句"></a>while使用 else 语句</h3><p>在 python 中，for … else 表示这样的意思，for 中的语句和普通的没有区别，else 中的语句会在循环正常执行完（即 for 不是通过 break 跳出而中断的）的情况下执行.while … else 也是一样,其在循环条件不满足的时候,会开始执行else语句,通过break中断的情况下,不会执行else.</p><p><strong>代码：</strong></p><pre><code>#__author: Administrator#date: 2017/12/19count = 0while (count &lt; 5):    print(count,&apos;is less than 5&apos;)    count += 1else:    print(count,&apos;is not less than 5&apos;)</code></pre><p><strong>结果：</strong></p><pre><code>0 is less than 51 is less than 52 is less than 53 is less than 54 is less than 55 is not less than 5</code></pre><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><h3 id="基础用法-1"><a href="#基础用法-1" class="headerlink" title="基础用法"></a>基础用法</h3><blockquote><p>Python 提供给我们的另一个循环机制就是 for 语句, 它提供了 Python 中最强大的循环结构. 它可以遍历序列成员(链表或字符串). for循环会访问一个可迭代对象(例如序列或是迭代器)中的所有元素, 并在所有条目都处理过后结束循环.</p></blockquote><p><strong>语法：</strong></p><pre><code>for iter_var in iterable:        suite_to_repeat</code></pre><p>每次循环, iter_var 迭代变量被设置为可迭代对象(序列, 迭代器, 或者是其他支持迭代的对象)的当前元素, 提供给 suite_to_repeat 语句块使用.</p><p><strong>代码：</strong></p><pre><code>#__author: Administrator#date: 2017/12/19words = [&apos;cat&apos;, &apos;window&apos;, &apos;defenestrate&apos;]for w in words:    print(w,len(w))</code></pre><p><strong>结果：</strong></p><pre><code>cat 3window 6defenestrate 12</code></pre><h3 id="for使用-else-语句"><a href="#for使用-else-语句" class="headerlink" title="for使用 else 语句"></a>for使用 else 语句</h3><blockquote><p>for 循环也可以有 else 用于循环后处理(post-processing). 它和 while 循环中的 else 处理方式相同. 只要 for 循环是正常结束的(不是通过 break ), else 子句就会执行.</p></blockquote><p>代码：</p><pre><code>#__author: Administrator#date: 2017/12/19s = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;]found = Falsefor c in s:    if c.find(&apos;c&apos;) != -1:        found = True        print(&quot;发现c&quot;)        breakif not found:    print(&quot;未发现c&quot;)</code></pre><p>等价于下面的代码:</p><pre><code>#__author: Administrator#date: 2017/12/19s = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;]for c in s:    if c.find(&apos;c&apos;) != -1:        print(&quot;发现c&quot;)        breakelse:    print(&quot;未发现c&quot;)</code></pre><h2 id="break和continue语句"><a href="#break和continue语句" class="headerlink" title="break和continue语句"></a>break和continue语句</h2><h3 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h3><blockquote><p>Python 中的 break 语句可以结束当前循环然后跳转到下条语句, 类似 C 中的传统 break . 常用在当某个外部条件被触发(一般通过 if 语句检查), 需要立即从循环中退出时. break 语句可以用在 while 和 for 循环中.</p></blockquote><p><strong>代码：</strong></p><pre><code>&gt;&gt;&gt; for i in &quot;hello&quot;:...     if i ==&apos;l&apos;:...         break...     print(i)...</code></pre><p><strong>结果：</strong></p><pre><code>he</code></pre><h3 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h3><blockquote><p>不管是 Python、 C、Java 还是其它任何支持 continue 语句的结构化语言中, 一些初学者有这样的一个误解: continue 语句”立即启动循环的下一次迭代”. 实际上, 当遇到 continue 语句时, 程序会终止当前循环, 并忽略剩余的语句, 然后回到循环的顶端. 在开始下一次迭代前, 如果是条件循环, 我们将验证条件表达式. 如果是迭代循环, 我们将验证是否还有元素可以迭代. 只有在验证成功的情况下, 我们才会开始下一次迭代.</p></blockquote><p>Python 里的 continue 语句和其他高级语言中的传统 continue 并没有什么不同. 它可以被用在 while 和 for 循环里. while 循环是条件性的, 而 for 循环是迭代的, 所以 continue 在开始下一次循环前要满足一些先决条件, 否则循环会正常结束.</p><p><strong>代码：</strong></p><pre><code>&gt;&gt;&gt; for i in &quot;hello&quot;:...     if i ==&apos;l&apos;:...         continue...     print(i)...</code></pre><p><strong>结果：</strong></p><pre><code>heo</code></pre><h2 id="总结循环中的else语句"><a href="#总结循环中的else语句" class="headerlink" title="总结循环中的else语句"></a>总结循环中的else语句</h2><blockquote><p>循环一般可以分为两种，for循环或while循环，上文都有明确的介绍。循环可以有一个 else 子句；它在循环迭代完整个列表（对于 for ）或执行条件为 false （对于 while ）不被break中止的情况下执行，循环被 break 中止的情况下不会执行else语句。</p></blockquote><p><strong>示例：</strong> 在数字2-9中搜索素数</p><p><strong>代码：</strong></p><pre><code>#__author: Administrator#date: 2017/12/19&apos;&apos;&apos;在数字2-9之间搜索素数素数的定义:除了1和它自身外，不能被其他自然数整除的数叫做质数.n 被除数x 除数&apos;&apos;&apos;for n in range(2,10):    for x in range(2,n):        if n % x == 0:            print(n,&apos;equals&apos;,x,&apos;*&apos;,n//x)            break    else:        print(n,&apos;is a prime number&apos;)</code></pre><p><strong>结果：</strong></p><pre><code>2 is a prime number3 is a prime number4 equals 2 * 25 is a prime number6 equals 2 * 37 is a prime number8 equals 2 * 49 equals 3 * 3</code></pre><h2 id="range-函数"><a href="#range-函数" class="headerlink" title="range() 函数"></a>range() 函数</h2><blockquote><p>如果你需要一个数值序列，内置函数 range() 会很方便，它生成一个等差级数链表（不包含结束的end值）</p></blockquote><p><strong>语法：</strong></p><p><code>range(start, end, step=1)</code></p><pre><code>&gt;&gt;&gt; for i in range(5):...     print(i)...01234&gt;&gt;&gt; list(range(2,2))[]range(0, 10, 3)   0, 3, 6, 9range(-10, -100, -30)  -10, -40, -70</code></pre><p>range(10) 生成了一个包含 10 个值的链表，它用链表的索引值填充了这个长度为 10 的列表，所生成的链表中不包括范围中的结束值。也可以让 range() 操作从另一个数值开始，不指定时为0,或者可以指定一个不同的步进值（甚至是负数，有时这也被称为 “步长”）</p><p><strong>如果你只是打印一个序列的话会发生奇怪的事情</strong></p><pre><code>&gt;&gt;&gt; print(range(10))range(0, 10)</code></pre><p>在不同方面 range() 函数返回的对象表现为它是一个列表，但事实上它并不是。当你迭代它时，它是一个能够像期望的序列返回连续项的对象；但为了节省空间，它并不真正构造列表。</p><p>我们称此类对象是 可迭代的，即适合作为那些期望从某些东西中获得连续项直到结束的函数或结构的一个目标（参数）。我们已经见过的 for 语句就是这样一个迭代器。list() 函数是另外一个（ 迭代器 ），它从可迭代（对象）中创建列表:</p><pre><code>&gt;&gt;&gt; list(range(5))[0, 1, 2, 3, 4]</code></pre><p>稍后我们会看到更多返回可迭代（对象）和以可迭代（对象）作为参数的函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;if语句&quot;&gt;&lt;a href=&quot;#if语句&quot; class=&quot;headerlink&quot; title=&quot;if语句&quot;&gt;&lt;/a&gt;if语句&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;if语句是用来检查一个条件：如果条件为真(true)，我们运行一个语句块（你为if块），否则(else)，我们执行另一个语句块（称为else块），else子语句是可选的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;单条件&quot;&gt;&lt;a href=&quot;#单条件&quot; class=&quot;headerlink&quot; title=&quot;单条件&quot;&gt;&lt;/a&gt;单条件&lt;/h3&gt;&lt;p&gt;示例：如果num变量大于1，那么就输出num大，否则就输出num小，num值为5&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding:utf-8 -*-
num = 5
if num &amp;gt; 1:
print(&amp;quot;num大&amp;quot;)
else:
print(&amp;quot;num小&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python num.py
num大
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;多条件&quot;&gt;&lt;a href=&quot;#多条件&quot; class=&quot;headerlink&quot; title=&quot;多条件&quot;&gt;&lt;/a&gt;多条件&lt;/h3&gt;&lt;p&gt;示例：请输入一个整数，如果输入的为负数，负数转变为0,输出print(‘Negative changed to zero’);如果输入的为0，则输出Zero;如果输入的为1，则输出Single；输入其他则，输出More。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#__author: Administrator
#date: 2017/12/19
x = int(input(&amp;apos;Please enter an integer: &amp;apos;))
if x &amp;lt; 0:
    x = 0
    print(&amp;apos;Negative changed to zero&amp;apos;)
elif x == 0:
    print(&amp;apos;Zero&amp;apos;)
elif x == 1:
    print(&amp;apos;Single&amp;apos;)
else:
    print(&amp;apos;More&amp;apos;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Please enter an integer: -1
Negative changed to zero
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="python基础知识" scheme="http://www.chenfanlinux.org/categories/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="流程控制" scheme="http://www.chenfanlinux.org/tags/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>zabbx基础安装</title>
    <link href="http://www.chenfanlinux.org/2017/12/11/zabbx%E5%9F%BA%E7%A1%80%E5%AE%89%E8%A3%85/"/>
    <id>http://www.chenfanlinux.org/2017/12/11/zabbx基础安装/</id>
    <published>2017-12-11T10:07:48.000Z</published>
    <updated>2017-12-11T10:12:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、安装部署zabbix-3-4"><a href="#一、安装部署zabbix-3-4" class="headerlink" title="一、安装部署zabbix 3.4"></a>一、安装部署zabbix 3.4</h1><p><a href="https://baike.baidu.com/item/zabbix/6780368?fr=aladdin" target="_blank" rel="noopener">Zabbix</a> 是由 Alexei Vladishev 开发的一种网络监视、管理系统，基于 Server-Client 架构。可用于监视各种网络服务、服务器和网络机器等状态。</p><h2 id="1-zabbix基础说明"><a href="#1-zabbix基础说明" class="headerlink" title="1.zabbix基础说明"></a>1.zabbix基础说明</h2><h3 id="1-1-zabbix使用说明"><a href="#1-1-zabbix使用说明" class="headerlink" title="1.1  zabbix使用说明"></a>1.1  zabbix使用说明</h3><ul><li><p><a href="https://www.zabbix.com/documentation/3.4/zh/manual" target="_blank" rel="noopener">zabbix3.4软件中文使用手册</a></p></li><li><p><a href="http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/" target="_blank" rel="noopener">zabbix3.4版本安装包路径</a></p></li></ul><h3 id="1-2-zabbix-3-4版本说明"><a href="#1-2-zabbix-3-4版本说明" class="headerlink" title="1.2 zabbix 3.4版本说明"></a>1.2 zabbix 3.4版本说明</h3><p>Zabbix Server端安装的软件：</p><ul><li>zabbix-server-mysql</li><li>zabbix-get</li><li>mysql</li><li>zabbix-web</li><li>zabbix-web-mysql</li></ul><p>Zabbix Clinet 端安装的软件</p><ul><li>zabbix-agent</li><li>zabbix-sender</li></ul><h2 id="2-zabbix系统环境配置"><a href="#2-zabbix系统环境配置" class="headerlink" title="2.zabbix系统环境配置"></a>2.zabbix系统环境配置</h2><h3 id="2-1-系统环境"><a href="#2-1-系统环境" class="headerlink" title="2.1 系统环境"></a>2.1 系统环境</h3><pre><code># cat /etc/redhat-releaseCentOS Linux release 7.4.1708 (Core)</code></pre><h3 id="2-2-永久修改主机名"><a href="#2-2-永久修改主机名" class="headerlink" title="2.2 永久修改主机名"></a>2.2 永久修改主机名</h3><pre><code># hostnamectl --static set-hostname zabbix-server</code></pre><h3 id="2-3-关闭防火墙及selinux"><a href="#2-3-关闭防火墙及selinux" class="headerlink" title="2.3 关闭防火墙及selinux"></a>2.3 关闭防火墙及selinux</h3><pre><code># systemctl stop firewalld.service# systemctl daemon-reload# systemctl disable firewalld.service# sed -i &apos;s/SELINUX=enforcing/SELINUX=disabled/g&apos; /etc/selinux/config# grep SELINUX=disabled /etc/selinux/config# setenforce 0# getenforce  Disabled</code></pre><a id="more"></a><h2 id="3-数据库的安装与配置"><a href="#3-数据库的安装与配置" class="headerlink" title="3.数据库的安装与配置"></a>3.数据库的安装与配置</h2><h3 id="3-1-MariaDB概述"><a href="#3-1-MariaDB概述" class="headerlink" title="3.1 MariaDB概述"></a>3.1 MariaDB概述</h3><p>MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可。<br>开发这个分支的原因是：甲骨文公司收购了MySQL后，有将MySQL闭源的潜在风险，因此社区采用分支的方式来避开这个风险。MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。</p><h3 id="3-2-安装mariadb"><a href="#3-2-安装mariadb" class="headerlink" title="3.2 安装mariadb"></a>3.2 安装mariadb</h3><pre><code># yum install mariadb-server mariadb -y# rpm -qa |grep mariamariadb-5.5.56-2.el7.x86_64mariadb-server-5.5.56-2.el7.x86_64mariadb-libs-5.5.56-2.el7.x86_64</code></pre><h3 id="3-3-配置数据库服务"><a href="#3-3-配置数据库服务" class="headerlink" title="3.3 配置数据库服务"></a>3.3 配置数据库服务</h3><pre><code># vim /etc/my.cnf添加如下两行：innodb_file_per_table=onskip_name_resolve=on</code></pre><h3 id="3-4-启动mariadb数据库并设置开机自启动"><a href="#3-4-启动mariadb数据库并设置开机自启动" class="headerlink" title="3.4 启动mariadb数据库并设置开机自启动"></a>3.4 启动mariadb数据库并设置开机自启动</h3><pre><code># systemctl start mariadb# systemctl enable mariadb</code></pre><h3 id="3-5-设置mariadb数据库的安全配置"><a href="#3-5-设置mariadb数据库的安全配置" class="headerlink" title="3.5 设置mariadb数据库的安全配置"></a>3.5 设置mariadb数据库的安全配置</h3><pre><code># mysql_secure_installation  //根据需求设置密码password:test# mysql -uroot -ptest //登录mysql</code></pre><h3 id="3-6-创建数据库zabbix数据库并授权用户"><a href="#3-6-创建数据库zabbix数据库并授权用户" class="headerlink" title="3.6 创建数据库zabbix数据库并授权用户"></a>3.6 创建数据库zabbix数据库并授权用户</h3><p>创建zabbix数据库，并创建zbuser用户具有库的访问权限。</p><pre><code>&gt; CREATE DATABASE  zabbix  DEFAULT CHARACTER SET utf8 COLLATE utf8_bin;&gt; GRANT ALL PRIVILEGES ON zabbix.* TO zbuser@localhost IDENTIFIED BY &apos;test&apos;;&gt; FLUSH PRIVILEGES ;# mysql -uzbuser -ptest zabbix //登录测试</code></pre><h2 id="4-安装配置zabbix-3-4"><a href="#4-安装配置zabbix-3-4" class="headerlink" title="4.安装配置zabbix.3.4"></a>4.安装配置zabbix.3.4</h2><h3 id="4-1-zabbix相关软件包的安装"><a href="#4-1-zabbix相关软件包的安装" class="headerlink" title="4.1 zabbix相关软件包的安装"></a>4.1 zabbix相关软件包的安装</h3><h4 id="4-1-1-安装zabbix相关的yum源"><a href="#4-1-1-安装zabbix相关的yum源" class="headerlink" title="4.1.1 安装zabbix相关的yum源"></a>4.1.1 安装zabbix相关的yum源</h4><pre><code># rpm -ivh http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/zabbix-release-3.4-1.el7.centos.noarch.rpm</code></pre><h4 id="4-1-2-安装zabbix相关包"><a href="#4-1-2-安装zabbix相关包" class="headerlink" title="4.1.2 安装zabbix相关包"></a>4.1.2 安装zabbix相关包</h4><p>zabbix服务端需要安装：zabbix-server-mysql zabbix-web-mysql  zabbix-get<br>zabbix被监控主机端安装的软件：：zabbix-agent, zabbix-sender</p><pre><code># yum install zabbix-server-mysql zabbix-web-mysql zabbix-get zabbix-agent zabbix-sender -y# rpm -qa |grep zabbix zabbix-web-mysql-3.4.4-2.el7.noarch zabbix-get-3.4.4-2.el7.x86_64 zabbix-web-3.4.4-2.el7.noarch zabbix-agent-3.4.4-2.el7.x86_64 zabbix-release-3.4-1.el7.centos.noarch zabbix-server-mysql-3.4.4-2.el7.x86_64 zabbix-sender-3.4.4-2.el7.x86_64</code></pre><h3 id="4-2-zabbix相关数据导入数据库"><a href="#4-2-zabbix相关数据导入数据库" class="headerlink" title="4.2 zabbix相关数据导入数据库"></a>4.2 zabbix相关数据导入数据库</h3><pre><code># cd /usr/share/doc/zabbix-server-mysql-3.4.4/# zcat create.sql.gz |mysql -uzbuser -ptest zabbix</code></pre><h3 id="4-3-修改数据库相关配置"><a href="#4-3-修改数据库相关配置" class="headerlink" title="4.3 修改数据库相关配置"></a>4.3 修改数据库相关配置</h3><pre><code># vim /etc/zabbix/zabbix_server.conf# grep -n &apos;^&apos;[a-Z] /etc/zabbix/zabbix_server.conf38:LogFile=/var/log/zabbix/zabbix_server.log49:LogFileSize=072:PidFile=/var/run/zabbix/zabbix_server.pid82:SocketDir=/var/run/zabbix91:DBHost=localhost101:DBName=zabbix117:DBUser=zbuser125:DBPassword=test132:DBSocket=/var/lib/mysql/mysql.sock316:SNMPTrapperFile=/var/log/snmptrap/snmptrap.log434:Timeout=4476:AlertScriptsPath=/usr/lib/zabbix/alertscripts486:ExternalScripts=/usr/lib/zabbix/externalscripts522:LogSlowQueries=3000</code></pre><h3 id="4-4-启动zabbix-server并设置开机启动"><a href="#4-4-启动zabbix-server并设置开机启动" class="headerlink" title="4.4 启动zabbix server并设置开机启动"></a>4.4 启动zabbix server并设置开机启动</h3><pre><code># systemctl enable zabbix-server# systemctl start zabbix-server</code></pre><h3 id="4-5-编辑Zabbix前端PHP配置-更改时区"><a href="#4-5-编辑Zabbix前端PHP配置-更改时区" class="headerlink" title="4.5 编辑Zabbix前端PHP配置,更改时区"></a>4.5 编辑Zabbix前端PHP配置,更改时区</h3><pre><code># vim /etc/httpd/conf.d/zabbix.confphp_value date.timezone Asia/Shanghaiphp_value date.timezone Asia/Shanghai</code></pre><h3 id="4-6-启动httpd并设置开机启动"><a href="#4-6-启动httpd并设置开机启动" class="headerlink" title="4.6 启动httpd并设置开机启动"></a>4.6 启动httpd并设置开机启动</h3><pre><code># systemctl start httpd# systemctl enable httpd</code></pre><h3 id="4-7-图形界面安装配置zabbix"><a href="#4-7-图形界面安装配置zabbix" class="headerlink" title="4.7 图形界面安装配置zabbix"></a>4.7 图形界面安装配置zabbix</h3><p>浏览器输入<a href="http://server_ip/zabbix,根据图形引导信息,配置zabbix信息。" target="_blank" rel="noopener">http://server_ip/zabbix,根据图形引导信息,配置zabbix信息。</a></p><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/nggAUz" alt="1"></p><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/TUgNnW" alt="2"></p><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/0742rj" alt="3"></p><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/Iv6t7z" alt="4"></p><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/VNlpQC" alt="5"></p><p><strong>zabbix初始登录账户和密码为： Admin  zabbix</strong></p><h2 id="5-zabbxi-agent安装及配置"><a href="#5-zabbxi-agent安装及配置" class="headerlink" title="5.zabbxi-agent安装及配置"></a>5.zabbxi-agent安装及配置</h2><h3 id="5-1-安装zabbxi-agent"><a href="#5-1-安装zabbxi-agent" class="headerlink" title="5.1 安装zabbxi-agent"></a>5.1 安装zabbxi-agent</h3><pre><code># yum install zabbix-agent  zabbix-sender -y# grep -n &apos;^&apos;[a-Z] /etc/zabbix/zabbix_agentd.conf 13:PidFile=/var/run/zabbix/zabbix_agentd.pid 32:LogFile=/var/log/zabbix/zabbix_agentd.log 43:LogFileSize=0 95:Server=127.0.0.1 136:ServerActive=127.0.0.1 147:Hostname=zabbix-server 265:Include=/etc/zabbix/zabbix_agentd.d/*.conf</code></pre><p>Server：被动模式，允许哪台服务器连接Agent。<br>ServerActive：主动模式，向哪台服务器传送数据。</p><h3 id="5-2-启动zabbix-agent"><a href="#5-2-启动zabbix-agent" class="headerlink" title="5.2 启动zabbix-agent"></a>5.2 启动zabbix-agent</h3><pre><code># systemctl start zabbix-agent# systemctl enable zabbix-agent</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、安装部署zabbix-3-4&quot;&gt;&lt;a href=&quot;#一、安装部署zabbix-3-4&quot; class=&quot;headerlink&quot; title=&quot;一、安装部署zabbix 3.4&quot;&gt;&lt;/a&gt;一、安装部署zabbix 3.4&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/zabbix/6780368?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Zabbix&lt;/a&gt; 是由 Alexei Vladishev 开发的一种网络监视、管理系统，基于 Server-Client 架构。可用于监视各种网络服务、服务器和网络机器等状态。&lt;/p&gt;
&lt;h2 id=&quot;1-zabbix基础说明&quot;&gt;&lt;a href=&quot;#1-zabbix基础说明&quot; class=&quot;headerlink&quot; title=&quot;1.zabbix基础说明&quot;&gt;&lt;/a&gt;1.zabbix基础说明&lt;/h2&gt;&lt;h3 id=&quot;1-1-zabbix使用说明&quot;&gt;&lt;a href=&quot;#1-1-zabbix使用说明&quot; class=&quot;headerlink&quot; title=&quot;1.1  zabbix使用说明&quot;&gt;&lt;/a&gt;1.1  zabbix使用说明&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.zabbix.com/documentation/3.4/zh/manual&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;zabbix3.4软件中文使用手册&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;zabbix3.4版本安装包路径&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-2-zabbix-3-4版本说明&quot;&gt;&lt;a href=&quot;#1-2-zabbix-3-4版本说明&quot; class=&quot;headerlink&quot; title=&quot;1.2 zabbix 3.4版本说明&quot;&gt;&lt;/a&gt;1.2 zabbix 3.4版本说明&lt;/h3&gt;&lt;p&gt;Zabbix Server端安装的软件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;zabbix-server-mysql&lt;/li&gt;
&lt;li&gt;zabbix-get&lt;/li&gt;
&lt;li&gt;mysql&lt;/li&gt;
&lt;li&gt;zabbix-web&lt;/li&gt;
&lt;li&gt;zabbix-web-mysql&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Zabbix Clinet 端安装的软件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;zabbix-agent&lt;/li&gt;
&lt;li&gt;zabbix-sender&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-zabbix系统环境配置&quot;&gt;&lt;a href=&quot;#2-zabbix系统环境配置&quot; class=&quot;headerlink&quot; title=&quot;2.zabbix系统环境配置&quot;&gt;&lt;/a&gt;2.zabbix系统环境配置&lt;/h2&gt;&lt;h3 id=&quot;2-1-系统环境&quot;&gt;&lt;a href=&quot;#2-1-系统环境&quot; class=&quot;headerlink&quot; title=&quot;2.1 系统环境&quot;&gt;&lt;/a&gt;2.1 系统环境&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;# cat /etc/redhat-release
CentOS Linux release 7.4.1708 (Core)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;2-2-永久修改主机名&quot;&gt;&lt;a href=&quot;#2-2-永久修改主机名&quot; class=&quot;headerlink&quot; title=&quot;2.2 永久修改主机名&quot;&gt;&lt;/a&gt;2.2 永久修改主机名&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;# hostnamectl --static set-hostname zabbix-server
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;2-3-关闭防火墙及selinux&quot;&gt;&lt;a href=&quot;#2-3-关闭防火墙及selinux&quot; class=&quot;headerlink&quot; title=&quot;2.3 关闭防火墙及selinux&quot;&gt;&lt;/a&gt;2.3 关闭防火墙及selinux&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;# systemctl stop firewalld.service
# systemctl daemon-reload
# systemctl disable firewalld.service

# sed -i &amp;apos;s/SELINUX=enforcing/SELINUX=disabled/g&amp;apos; /etc/selinux/config
# grep SELINUX=disabled /etc/selinux/config
# setenforce 0
# getenforce
  Disabled
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="linux服务" scheme="http://www.chenfanlinux.org/categories/linux%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="zabbix" scheme="http://www.chenfanlinux.org/tags/zabbix/"/>
    
  </entry>
  
  <entry>
    <title>hexo安装与介绍</title>
    <link href="http://www.chenfanlinux.org/2017/12/04/my-first-article/"/>
    <id>http://www.chenfanlinux.org/2017/12/04/my-first-article/</id>
    <published>2017-12-04T03:05:54.000Z</published>
    <updated>2017-12-10T14:57:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo 是高效的静态站点生成框架，她基于 Node.js。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 <a href="https://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a> 本身的语法之外，还可以使用 Hexo 提供的 标签插件 来快速的插入特定形式的内容。在这篇文章中，假定你已经成功安装了 Hexo，并使用 Hexo 提供的命令创建了一个站点。</p><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><h3 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h3><p>安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序：</p><ul><li><p><a href="https://nodejs.org/dist/v8.9.1/node-v8.9.1-x64.msi" target="_blank" rel="noopener">Node.js</a></p></li><li><p><a href="https://git-for-windows.github.io" target="_blank" rel="noopener">Git</a></p></li></ul><blockquote><p>安装git时候，由于众所周知的原因，从上面的链接下载git for windows最好挂上一个代理，否则下载速度十分缓慢。也可以参考<a href="https://github.com/waylau/git-for-win" target="_blank" rel="noopener">这个页面</a>，收录了存储于百度云的下载地址。</p></blockquote><h3 id="开始安装hexo"><a href="#开始安装hexo" class="headerlink" title="开始安装hexo"></a>开始安装hexo</h3><p>windows上安装所有必备的应用程序安装完成后，打开Git Bash命令行模式，即可使用 npm 安装 Hexo。</p><pre><code>$ cd F:\$ mkdir blog //windows下创建博客目录$ npm install -g hexo-cli    //安装hexo基础包</code></pre><h3 id="建立静态站点"><a href="#建立静态站点" class="headerlink" title="建立静态站点"></a>建立静态站点</h3><p>使用hexo建站非常的方便快捷，迅速就能在本地建立一个静态站点。安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><pre><code>$ hexo init blog  //初始化博客目录$ cd blog$ npm install    //开始安装</code></pre><p>新建完成后，指定文件夹的目录如下：</p><pre><code>.├── _config.yml  //站点配置文件├── package.json //应用程序信息├── scaffolds   //模版文件夹├── source      //资源文件夹 |   ├── _drafts|   └── _posts└── themes     //主题文件夹</code></pre><h3 id="hexo基础命令介绍"><a href="#hexo基础命令介绍" class="headerlink" title="hexo基础命令介绍"></a>hexo基础命令介绍</h3><p>hexo有一些常用的指令，明确这些指令的用途和方法，方便我们更高效的管理和构建炫酷的静态网站。</p><ul><li>init </li><li>new</li><li>generate</li><li>publish</li><li>server</li><li>deploy</li><li>clean</li><li>list</li></ul><h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><pre><code>$ hexo init [folder]</code></pre><p>新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。</p><h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><pre><code>$ hexo new [layout] &lt;title&gt;$ hexo new &quot;postName&quot; //新建文章$ hexo new page &quot;pageName&quot; //新建页面</code></pre><p>新建一篇文章。如果没有设置 layout 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">_config.yml</a> 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</p><h4 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h4><pre><code>$ hexo clean</code></pre><p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。<br>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h4 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h4><pre><code>$ hexo generate   //或者使用 hexo g </code></pre><a id="more"></a><p>生成静态文件,每次我们修改完一些配置后,可以使用hexo clean清理一下历史数据,然后再hexo g生成静态文件。</p><h4 id="server"><a href="#server" class="headerlink" title="server"></a>server</h4><p>启动服务器。默认情况下，访问网址为  <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 。</p><pre><code>$ hexo server</code></pre><blockquote><p>选项<br>描述<br>-p      重设端口<br>-s      只使用静态文件<br>-l  启动日记记录，使用覆盖记录格式 </p></blockquote><h4 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h4><p>部署网站,将本地网站推送到远程仓库。</p><pre><code>$ hexo deploy</code></pre><blockquote><p>参数<br>描述<br>-g, –generate    部署之前预先生成静态文件</p></blockquote><p>该命令可以简写为：</p><pre><code>$ hexo d</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hexo 是高效的静态站点生成框架，她基于 Node.js。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 &lt;a href=&quot;https://daringfireball.net/projects/markdown/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Markdown&lt;/a&gt; 本身的语法之外，还可以使用 Hexo 提供的 标签插件 来快速的插入特定形式的内容。在这篇文章中，假定你已经成功安装了 Hexo，并使用 Hexo 提供的命令创建了一个站点。&lt;/p&gt;
&lt;h2 id=&quot;安装hexo&quot;&gt;&lt;a href=&quot;#安装hexo&quot; class=&quot;headerlink&quot; title=&quot;安装hexo&quot;&gt;&lt;/a&gt;安装hexo&lt;/h2&gt;&lt;h3 id=&quot;安装前提&quot;&gt;&lt;a href=&quot;#安装前提&quot; class=&quot;headerlink&quot; title=&quot;安装前提&quot;&gt;&lt;/a&gt;安装前提&lt;/h3&gt;&lt;p&gt;安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://nodejs.org/dist/v8.9.1/node-v8.9.1-x64.msi&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Node.js&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://git-for-windows.github.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Git&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;安装git时候，由于众所周知的原因，从上面的链接下载git for windows最好挂上一个代理，否则下载速度十分缓慢。也可以参考&lt;a href=&quot;https://github.com/waylau/git-for-win&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这个页面&lt;/a&gt;，收录了存储于百度云的下载地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;开始安装hexo&quot;&gt;&lt;a href=&quot;#开始安装hexo&quot; class=&quot;headerlink&quot; title=&quot;开始安装hexo&quot;&gt;&lt;/a&gt;开始安装hexo&lt;/h3&gt;&lt;p&gt;windows上安装所有必备的应用程序安装完成后，打开Git Bash命令行模式，即可使用 npm 安装 Hexo。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd F:\
$ mkdir blog //windows下创建博客目录
$ npm install -g hexo-cli    //安装hexo基础包
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;建立静态站点&quot;&gt;&lt;a href=&quot;#建立静态站点&quot; class=&quot;headerlink&quot; title=&quot;建立静态站点&quot;&gt;&lt;/a&gt;建立静态站点&lt;/h3&gt;&lt;p&gt;使用hexo建站非常的方便快捷，迅速就能在本地建立一个静态站点。安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ hexo init blog  //初始化博客目录
$ cd blog
$ npm install    //开始安装
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;新建完成后，指定文件夹的目录如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.
├── _config.yml  //站点配置文件
├── package.json //应用程序信息
├── scaffolds   //模版文件夹
├── source      //资源文件夹 
|   ├── _drafts
|   └── _posts
└── themes     //主题文件夹
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;hexo基础命令介绍&quot;&gt;&lt;a href=&quot;#hexo基础命令介绍&quot; class=&quot;headerlink&quot; title=&quot;hexo基础命令介绍&quot;&gt;&lt;/a&gt;hexo基础命令介绍&lt;/h3&gt;&lt;p&gt;hexo有一些常用的指令，明确这些指令的用途和方法，方便我们更高效的管理和构建炫酷的静态网站。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;init &lt;/li&gt;
&lt;li&gt;new&lt;/li&gt;
&lt;li&gt;generate&lt;/li&gt;
&lt;li&gt;publish&lt;/li&gt;
&lt;li&gt;server&lt;/li&gt;
&lt;li&gt;deploy&lt;/li&gt;
&lt;li&gt;clean&lt;/li&gt;
&lt;li&gt;list&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;init&quot;&gt;&lt;a href=&quot;#init&quot; class=&quot;headerlink&quot; title=&quot;init&quot;&gt;&lt;/a&gt;init&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;$ hexo init [folder]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。&lt;/p&gt;
&lt;h4 id=&quot;new&quot;&gt;&lt;a href=&quot;#new&quot; class=&quot;headerlink&quot; title=&quot;new&quot;&gt;&lt;/a&gt;new&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;$ hexo new [layout] &amp;lt;title&amp;gt;
$ hexo new &amp;quot;postName&amp;quot; //新建文章
$ hexo new page &amp;quot;pageName&amp;quot; //新建页面
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;新建一篇文章。如果没有设置 layout 的话，默认使用 &lt;a href=&quot;https://hexo.io/zh-cn/docs/configuration.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;_config.yml&lt;/a&gt; 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。&lt;/p&gt;
&lt;h4 id=&quot;clean&quot;&gt;&lt;a href=&quot;#clean&quot; class=&quot;headerlink&quot; title=&quot;clean&quot;&gt;&lt;/a&gt;clean&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;$ hexo clean
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;清除缓存文件 (db.json) 和已生成的静态文件 (public)。&lt;br&gt;在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。&lt;/p&gt;
&lt;h4 id=&quot;generate&quot;&gt;&lt;a href=&quot;#generate&quot; class=&quot;headerlink&quot; title=&quot;generate&quot;&gt;&lt;/a&gt;generate&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;$ hexo generate   //或者使用 hexo g 
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://www.chenfanlinux.org/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://www.chenfanlinux.org/tags/hexo/"/>
    
  </entry>
  
</feed>
