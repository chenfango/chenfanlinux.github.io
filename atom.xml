<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陈凡的博客</title>
  
  <subtitle>chenfanlinux.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.chenfanlinux.org/"/>
  <updated>2018-01-12T11:04:04.000Z</updated>
  <id>http://www.chenfanlinux.org/</id>
  
  <author>
    <name>陈凡</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker入门之网络管理(五)</title>
    <link href="http://www.chenfanlinux.org/2018/01/12/Docker%E5%85%A5%E9%97%A8%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86-%E4%BA%94/"/>
    <id>http://www.chenfanlinux.org/2018/01/12/Docker入门之网络管理-五/</id>
    <published>2018-01-12T10:33:17.000Z</published>
    <updated>2018-01-12T11:04:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker中自带的网络类型"><a href="#Docker中自带的网络类型" class="headerlink" title="Docker中自带的网络类型"></a>Docker中自带的网络类型</h2><blockquote><p>在Docker容器技术中，网络部分算是比较复杂的一部分。了解Docker提供了几种原生的网络，了解容器与外界通信以及外界对容器如何进行访问，这是本文的重点。</p></blockquote><p>Docker 安装时会自动在 host 上创建三个网络，我们可用 docker network ls 命令查看：</p><pre><code>[root@localhost ~]# docker network ls NETWORK ID          NAME                DRIVER              SCOPE39e6a520b768        bridge              bridge              local               b31da46610a3        host                host                local               7d42c5a35cce        none                null                local </code></pre><p>上面我们可以看到三种类型的网络，包括none、host、bridge这三种原生的网络，区分这三种网络的用途，尤为重要。</p><h3 id="none网络"><a href="#none网络" class="headerlink" title="none网络"></a>none网络</h3><p>none 网络就是什么都没有的网络。挂在这个网络下的容器除了 lo，没有其他任何网卡。容器创建时，可以通过 –network=none 指定使用 none 网络。</p><pre><code>[root@docker ~]# docker run -it --network=none busyboxUnable to find image &apos;busybox:latest&apos; locallylatest: Pulling from library/busyboxfb46b04c527d: Pull complete Digest: sha256:436bbf48aa1198ebca8eac0ad9a9c80c8929d9242e02608f76ce18334e0cfe6aStatus: Downloaded newer image for busybox:latest/ # ifconfiglo        Link encap:Local Loopback            inet addr:127.0.0.1  Mask:255.0.0.0          UP LOOPBACK RUNNING  MTU:65536  Metric:1          RX packets:0 errors:0 dropped:0 overruns:0 frame:0          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1           RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</code></pre><p>这里我们可以看到none网络中只有一个lo，没有其他网卡，就是一个封闭的网络，不与外界通信。封闭意味着隔离，一些对安全性要求高并且不需要联网的应用可以使用 none 网络。</p><h3 id="host网络"><a href="#host网络" class="headerlink" title="host网络"></a>host网络</h3><p>连接到 host 网络的容器共享 Docker host 的网络栈，容器的网络配置与宿主机完全一样。可以通过 –network=host 指定使用 host 网络。</p><pre><code>[root@docker ~]# docker run -it --network=host busybox/ # ifconfig docker0   Link encap:Ethernet  HWaddr 02:42:02:90:4E:49            inet addr:172.17.0.1  Bcast:0.0.0.0  Mask:255.255.0.0          UP BROADCAST MULTICAST  MTU:1500  Metric:1          RX packets:0 errors:0 dropped:0 overruns:0 frame:0          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:0           RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)ens33     Link encap:Ethernet  HWaddr 00:0C:29:95:F6:22            inet addr:192.168.175.40  Bcast:192.168.175.255  Mask:255.255.255.0          inet6 addr: fe80::f1c9:d94d:f12b:990c/64 Scope:Link          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:203380 errors:0 dropped:0 overruns:0 frame:0          TX packets:73455 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1000           RX bytes:270648213 (258.1 MiB)  TX bytes:6886880 (6.5 MiB)lo        Link encap:Local Loopback            inet addr:127.0.0.1  Mask:255.0.0.0          inet6 addr: ::1/128 Scope:Host          UP LOOPBACK RUNNING  MTU:65536  Metric:1          RX packets:0 errors:0 dropped:0 overruns:0 frame:0          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1           RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)/ # hostnamedocker</code></pre><p>在容器内可以看到所有宿主机的网卡，跟宿主机ifconfig看到的结果时一致的，并且hostname并不是短ID，而是宿主机的hostname。<br>直接使用 Docker host 的网络最大的好处就是性能，如果容器对网络传输效率有较高要求，则可以选择 host 网络。当然不便之处就是牺牲一些灵活性，比如要考虑端口冲突问题，宿主机上已经使用的端口就不能再用了。</p><a id="more"></a><h3 id="bridge网络"><a href="#bridge网络" class="headerlink" title="bridge网络"></a>bridge网络</h3><p>bridge网络是Docker默认的网络类型，具有更广泛的使用价值。也是本文及后续探讨的重点，明确bridge网络原理，对应用Docker技术至关重要。</p><pre><code>[root@docker ~]# ifconfig docker0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500        inet 172.17.0.1  netmask 255.255.0.0  broadcast 0.0.0.0        ether 02:42:02:90:4e:49  txqueuelen 0  (Ethernet)        RX packets 0  bytes 0 (0.0 B)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 (0.0 B)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0[root@docker ~]# brctl showbridge name    bridge id        STP enabled    interfacesdocker0        8000.02425cb5b194    no    </code></pre><p>Docker 安装时会创建一个 命名为 docker0 的 linux bridge。如果不指定–network，创建的容器默认都会挂到 docker0 上。利用brctl show命令可以看到虚拟网桥上暂时是空的，当我运行一个容器的时候，接下来会发现什么变化呢？</p><pre><code>[root@docker ~]# docker run -it busybox Unable to find image &apos;busybox:latest&apos; locallylatest: Pulling from library/busyboxfb46b04c527d: Pull complete Digest: sha256:7962088087138b6cb316047648316287e110c5d46569900d332b80fbd7840a40Status: Downloaded newer image for busybox:latest[root@docker ~]# brctl showbridge name    bridge id        STP enabled    interfacesdocker0        8000.02425cb5b194    no        vetha36b044</code></pre><p>上面我们运行一个busybox后,发现docker0上多了一个网络接口 <strong><em>vetha36b044</em></strong>，这是新建容器的虚拟网卡。下面我们进入到容器内部看看网卡的信息。</p><pre><code>/ # ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever4: eth0@if5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue     link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0       valid_lft forever preferred_lft forever[root@docker ~]# ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever    inet6 ::1/128 scope host        valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000    link/ether 00:0c:29:95:f6:22 brd ff:ff:ff:ff:ff:ff    inet 192.168.175.40/24 brd 192.168.175.255 scope global ens33       valid_lft forever preferred_lft forever    inet6 fe80::f1c9:d94d:f12b:990c/64 scope link        valid_lft forever preferred_lft forever3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP     link/ether 02:42:5c:b5:b1:94 brd ff:ff:ff:ff:ff:ff    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0       valid_lft forever preferred_lft forever    inet6 fe80::42:5cff:feb5:b194/64 scope link        valid_lft forever preferred_lft forever5: vetha36b044@if4: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP     link/ether 4e:23:f7:66:08:13 brd ff:ff:ff:ff:ff:ff link-netnsid 0    inet6 fe80::4c23:f7ff:fe66:813/64 scope link        valid_lft forever preferred_lft forever</code></pre><p>通过上面的实验，我们可以发现通过brctl show看到的dokcer0上挂载网卡接口为<strong><em>vetha36b044</em></strong>，而容器的网卡为eth0@if5，他们两个居然不一样！其实他们两个是一对 <strong>veth pair</strong>，veth pair是用于不同network namespace间进行通信的方式，veth pair将一个network namespace数据发往另一个network namespace的veth。网卡的一头（eth0@if5）在容器中，另一头（vetha36b044）挂在网桥 docker0 上，其效果就是将 eth0@if34 也挂在了 docker0 上。</p><p>进一步分析busybox容器的网络地址为172.17.0.2/16,而docker0的网络地址为172.17.0.1/16，可以通过<code>docker inspect network bridge</code> 来查看bridge网络的配置情况如下。</p><pre><code>[root@docker ~]# docker network inspect bridge[    {        &quot;Name&quot;: &quot;bridge&quot;,        &quot;Id&quot;: &quot;0a38d5dc818f2d1dafce109c3aa955e6d5854f296f0fd34704decb756538c985&quot;,        &quot;Created&quot;: &quot;2018-01-12T10:25:49.592636268+08:00&quot;,        &quot;Scope&quot;: &quot;local&quot;,        &quot;Driver&quot;: &quot;bridge&quot;,        &quot;EnableIPv6&quot;: false,        &quot;IPAM&quot;: {            &quot;Driver&quot;: &quot;default&quot;,            &quot;Options&quot;: null,            &quot;Config&quot;: [                {                    &quot;Subnet&quot;: &quot;172.17.0.0/16&quot;,                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;                }            ]        },        &quot;Internal&quot;: false,        &quot;Attachable&quot;: false,        &quot;Ingress&quot;: false,        &quot;ConfigFrom&quot;: {            &quot;Network&quot;: &quot;&quot;        },        &quot;ConfigOnly&quot;: false,        &quot;Containers&quot;: {            &quot;e519d169f8d3d686245a27d0dfdd05ff3d8dc605534b48f882cd37428ef3b5af&quot;: {                &quot;Name&quot;: &quot;eager_bohr&quot;,                &quot;EndpointID&quot;: &quot;9c6abac0b5336d5415075091209e9779879579a913c00ef4dcb0ac55fca639ed&quot;,                &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,                &quot;IPv4Address&quot;: &quot;172.17.0.2/16&quot;,                &quot;IPv6Address&quot;: &quot;&quot;            }        },        &quot;Options&quot;: {            &quot;com.docker.network.bridge.default_bridge&quot;: &quot;true&quot;,            &quot;com.docker.network.bridge.enable_icc&quot;: &quot;true&quot;,            &quot;com.docker.network.bridge.enable_ip_masquerade&quot;: &quot;true&quot;,            &quot;com.docker.network.bridge.host_binding_ipv4&quot;: &quot;0.0.0.0&quot;,            &quot;com.docker.network.bridge.name&quot;: &quot;docker0&quot;,            &quot;com.docker.network.driver.mtu&quot;: &quot;1500&quot;        },        &quot;Labels&quot;: {}    }][root@docker ~]# ifconfig docker0    docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500    inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255    inet6 fe80::42:5cff:feb5:b194  prefixlen 64  scopeid 0x20&lt;link&gt;    ether 02:42:5c:b5:b1:94  txqueuelen 0  (Ethernet)    RX packets 0  bytes 0 (0.0 B)    RX errors 0  dropped 0  overruns 0  frame 0    TX packets 8  bytes 648 (648.0 B)    TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><p>可以看到bridge网络的 子网”Subnet”: “172.17.0.0/16”； 网关”Gateway”: “172.17.0.1”；容器的网络为”IPv4Address”: “172.17.0.2/16”；可以看出容器的网络由bridge子网分配一个ip地址，而网关就是dokcer0 172.17.0.1。  </p><p>因此可以得出当前docker环境下的网络拓扑图如下：</p><p><img src="https://s1.ax1x.com/2018/01/12/p8XD6U.md.png" alt="Docker网络拓扑"></p><p>容器创建时，docker 会自动从 172.17.0.0/16 中分配一个 IP，这里 16 位的掩码保证有足够多的 IP 可以供容器使用。</p><h2 id="用户自定义网络"><a href="#用户自定义网络" class="headerlink" title="用户自定义网络"></a>用户自定义网络</h2><blockquote><p>除了Docker提供的上面三种none、host、bridge网络，用户还可以根据需求自定义网络。Docker 提供三种 user-defined 网络驱动：bridge, overlay 和 macvlan。overlay 和 macvlan 用于创建跨主机的网络。</p></blockquote><h3 id="系统自动分配网络地址"><a href="#系统自动分配网络地址" class="headerlink" title="系统自动分配网络地址"></a>系统自动分配网络地址</h3><p>我们可通过 bridge 驱动创建类似前面默认的 bridge 网络，网络名为br01，例如：</p><pre><code>[root@docker ~]# docker network create --driver bridge br0151123511575b1593773727c61703ca2b2b86e6e33efe48be398c402b774811c3</code></pre><p>查看host网络网桥的情况：<br>发现多了一个 名为 <strong><em>br-51123511575b</em></strong> 的网桥，这里的 <strong>51123511575b</strong> 正好是新建的网桥 <strong>br01</strong> 的短id.</p><pre><code>[root@docker ~]# brctl showbridge name    bridge id        STP enabled    interfacesbr-51123511575b        8000.02425d1b64f0    no        docker0        8000.02425cb5b194    no        vetha36b044</code></pre><p>使用     <code>docker network inspect br01</code> 看一下具体的br01网络配置信息。使用 <code>docker network inspect br01</code> 前需要通过  <code>docker network ls</code> 看一下 网络名 </p><p>docker0（网桥名） —-&gt; bridge（网络名）<br>br-51123511575b（网桥名）—–&gt; br01（网络名）</p><pre><code>[root@docker ~]# docker network lsNETWORK ID          NAME                DRIVER              SCOPE51123511575b        br01                bridge              local0a38d5dc818f        bridge              bridge              local780f6f3484b4        host                host                local26045d3b36ad        none                null                local[root@docker ~]# docker network inspect br01[    {        &quot;Name&quot;: &quot;br01&quot;,        &quot;Id&quot;: &quot;51123511575b1593773727c61703ca2b2b86e6e33efe48be398c402b774811c3&quot;,        &quot;Created&quot;: &quot;2018-01-12T16:30:26.109384839+08:00&quot;,        &quot;Scope&quot;: &quot;local&quot;,        &quot;Driver&quot;: &quot;bridge&quot;,        &quot;EnableIPv6&quot;: false,        &quot;IPAM&quot;: {            &quot;Driver&quot;: &quot;default&quot;,            &quot;Options&quot;: {},            &quot;Config&quot;: [                {                    &quot;Subnet&quot;: &quot;172.18.0.0/16&quot;,                    &quot;Gateway&quot;: &quot;172.18.0.1&quot;                }            ]        },        &quot;Internal&quot;: false,        &quot;Attachable&quot;: false,        &quot;Ingress&quot;: false,        &quot;ConfigFrom&quot;: {            &quot;Network&quot;: &quot;&quot;        },        &quot;ConfigOnly&quot;: false,        &quot;Containers&quot;: {},        &quot;Options&quot;: {},        &quot;Labels&quot;: {}    }]</code></pre><p>刚才新建的bridge网络br01的网络配置信息如上，子网为172.18.0.0/16，网关为172.18.0.1。网络名为 <strong>br01</strong> 的网络对应的网桥名为 <strong>br-51123511575b</strong>，也是它的网关。</p><pre><code>[root@docker ~]# ifconfig br-51123511575bbr-51123511575b: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500        inet 172.18.0.1  netmask 255.255.0.0  broadcast 172.18.255.255        ether 02:42:5d:1b:64:f0  txqueuelen 0  (Ethernet)        RX packets 0  bytes 0 (0.0 B)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 (0.0 B)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><h3 id="用户自定义网络地址"><a href="#用户自定义网络地址" class="headerlink" title="用户自定义网络地址"></a>用户自定义网络地址</h3><blockquote><p>上面我们创建的bridge网络 <strong>br01</strong> 是系统给分配的子网地址和网关，在创建bridge网络的时候，用户也可以自定义网络地址，配置如下： 只需在创建网段时指定 –subnet 和 –gateway 参数</p></blockquote><pre><code>[root@docker ~]# docker network create --driver bridge --subnet=172.20.0.0/16 --gateway=172.20.0.1 br0210aea5be498f0de091bd078a640cf07d58903ac6af7c8f75d9045752414f8d6f[root@docker ~]# brctl showbridge name    bridge id        STP enabled    interfacesbr-10aea5be498f        8000.0242452b7e17    no        br-51123511575b        8000.02425d1b64f0    no        docker0        8000.02425cb5b194    no        vetha36b044</code></pre><p>可以看到我们新创建了一个网桥<strong>br-10aea5be498f</strong>，<strong>10aea5be498f</strong> 也是网桥的短id。</p><pre><code>[root@docker ~]# docker network lsNETWORK ID          NAME                DRIVER              SCOPE51123511575b        br01                bridge              local10aea5be498f        br02                bridge              local0a38d5dc818f        bridge              bridge              local780f6f3484b4        host                host                local26045d3b36ad        none                null                local[root@docker ~]# docker network inspect br02[    {        &quot;Name&quot;: &quot;br02&quot;,        &quot;Id&quot;: &quot;10aea5be498f0de091bd078a640cf07d58903ac6af7c8f75d9045752414f8d6f&quot;,        &quot;Created&quot;: &quot;2018-01-12T17:01:13.134341096+08:00&quot;,        &quot;Scope&quot;: &quot;local&quot;,        &quot;Driver&quot;: &quot;bridge&quot;,        &quot;EnableIPv6&quot;: false,        &quot;IPAM&quot;: {            &quot;Driver&quot;: &quot;default&quot;,            &quot;Options&quot;: {},            &quot;Config&quot;: [                {                    &quot;Subnet&quot;: &quot;172.20.0.0/16&quot;,                    &quot;Gateway&quot;: &quot;172.20.0.1&quot;                }            ]        },        &quot;Internal&quot;: false,        &quot;Attachable&quot;: false,        &quot;Ingress&quot;: false,        &quot;ConfigFrom&quot;: {            &quot;Network&quot;: &quot;&quot;        },        &quot;ConfigOnly&quot;: false,        &quot;Containers&quot;: {},        &quot;Options&quot;: {},        &quot;Labels&quot;: {}    }]</code></pre><p>进一步可以发现，网络名为 <strong>br02</strong>的网络地址配置为子网172.20.0.0/16，网关为172.20.0.1，对应的也就是网桥 <strong>br-10aea5be498f</strong> 的ip地址。</p><pre><code>[root@docker ~]# ifconfig br-10aea5be498fbr-10aea5be498f: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500        inet 172.20.0.1  netmask 255.255.0.0  broadcast 172.20.255.255        ether 02:42:45:2b:7e:17  txqueuelen 0  (Ethernet)        RX packets 0  bytes 0 (0.0 B)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 (0.0 B)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><h3 id="使用新的网络地址运行容器应用"><a href="#使用新的网络地址运行容器应用" class="headerlink" title="使用新的网络地址运行容器应用"></a>使用新的网络地址运行容器应用</h3><blockquote><p>刚才我们利用创建了两个bridge网络<strong>br01</strong>、<strong>br02</strong>，br01的网络地址是系统分配的,br02的网络地址是用户自定义的。下面我们运行一个容器应用，使用 <strong>br02</strong> 网络来研究当前网络的变化。</p></blockquote><pre><code>[root@docker ~]# docker run -d --network=br02 httpdUnable to find image &apos;httpd:latest&apos; locallylatest: Pulling from library/httpdf49cf87b52c1: Pull complete 02ca099fb6cd: Pull complete de7acb18da57: Pull complete 770c8edb393d: Pull complete 0e252730aeae: Pull complete 6e6ca341873f: Pull complete 2daffd0a6144: Pull complete Digest: sha256:b5f21641a9d7bbb59dc94fb6a663c43fbf3f56270ce7c7d51801ac74d2e70046Status: Downloaded newer image for httpd:latesta91d76993197d93d6757c38179b264000d26cabe4afe771a12090ef48de4f8a6[root@docker ~]# docker ps CONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS               NAMESa91d76993197        httpd               &quot;httpd-foreground&quot;   49 seconds ago      Up 38 seconds       80/tcp              happy_visvesvarayae519d169f8d3        busybox             &quot;sh&quot;                 7 hours ago         Up 7 hours                              eager_bohr[root@docker ~]# docker exec -it a91d76993197 /bin/sh/ # ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever8: eth0@if9: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default     link/ether 02:42:ac:14:00:02 brd ff:ff:ff:ff:ff:ff    inet 172.20.0.2/16 brd 172.20.255.255 scope global eth0       valid_lft forever preferred_lft forever</code></pre><p>可以看到以 <strong>br02</strong> 网络创建的新容器应用httpd，分配的IP为  172.20.0.2/16，这个IP是从 <strong>br02</strong> 网络的子网地址中随机分配的IP。如果我们想指定容器的静态IP,可以使用–ip参数指定。</p><pre><code>[root@docker ~]# docker run -d --network=br02 --ip 172.20.0.9  httpd9da4e8e73e3c3a5d19337d53dbad6d846bef63150bd76dc074642e0063a60e28[root@docker ~]# docker ps CONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS               NAMES9da4e8e73e3c        httpd               &quot;httpd-foreground&quot;   21 seconds ago      Up 19 seconds       80/tcp              upbeat_wescoffa91d76993197        httpd               &quot;httpd-foreground&quot;   7 minutes ago       Up 7 minutes        80/tcp              happy_visvesvarayae519d169f8d3        busybox             &quot;sh&quot;                 7 hours ago         Up 7 hours                              eager_bohr[root@docker ~]# docker exec -it 9da4e8e73e3c /bin/bashroot@9da4e8e73e3c:/usr/local/apache2# ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever10: eth0@if11: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default     link/ether 02:42:ac:14:00:09 brd ff:ff:ff:ff:ff:ff    inet 172.20.0.9/16 brd 172.20.255.255 scope global eth0       valid_lft forever preferred_lft forever</code></pre><p>上面就可以看到容器ID为 <strong>9da4e8e73e3c</strong> 的httpd应用的IP地址为 172.20.0.9/16 。刚才的br01网络地址是系统自动分配的，看看使用这个网络地址是否能够给容器指定静态地址。</p><pre><code>[root@docker ~]# docker  run -d --network=br01 --ip 172.18.0.9 httpdda7057c2a5f00e68d7f0017e675e25a2cbf44e086944b2d1898f70345f5ada77docker: Error response from daemon: user specified IP address is supported only when connecting to networks with user configured subnets</code></pre><p>可以看到明显的报错信息，用户自定义的IP地址需要用户自定义的网络地址的支持。</p><h3 id="当前Docker的网络拓扑"><a href="#当前Docker的网络拓扑" class="headerlink" title="当前Docker的网络拓扑"></a>当前Docker的网络拓扑</h3><blockquote><p>经过上面创建了两个bridge网络 <strong>br01</strong> 、<strong>br02</strong>。 <strong>br01</strong>是系统分配的网络地址，<strong>br02</strong>是我们指定的网络地址，并且指定 br02 为网络地址，运行了两个httpd应用。其中一个应用利用 –ip 指定了容器的静态IP，另一个是系统分配的IP地址。</p></blockquote><p><img src="https://s1.ax1x.com/2018/01/12/p8X2kR.md.png" alt="Docker网络拓扑"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Docker中自带的网络类型&quot;&gt;&lt;a href=&quot;#Docker中自带的网络类型&quot; class=&quot;headerlink&quot; title=&quot;Docker中自带的网络类型&quot;&gt;&lt;/a&gt;Docker中自带的网络类型&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在Docker容器技术中，网络部分算是比较复杂的一部分。了解Docker提供了几种原生的网络，了解容器与外界通信以及外界对容器如何进行访问，这是本文的重点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Docker 安装时会自动在 host 上创建三个网络，我们可用 docker network ls 命令查看：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost ~]# docker network ls 
NETWORK ID          NAME                DRIVER              SCOPE
39e6a520b768        bridge              bridge              local               
b31da46610a3        host                host                local               
7d42c5a35cce        none                null                local 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面我们可以看到三种类型的网络，包括none、host、bridge这三种原生的网络，区分这三种网络的用途，尤为重要。&lt;/p&gt;
&lt;h3 id=&quot;none网络&quot;&gt;&lt;a href=&quot;#none网络&quot; class=&quot;headerlink&quot; title=&quot;none网络&quot;&gt;&lt;/a&gt;none网络&lt;/h3&gt;&lt;p&gt;none 网络就是什么都没有的网络。挂在这个网络下的容器除了 lo，没有其他任何网卡。容器创建时，可以通过 –network=none 指定使用 none 网络。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@docker ~]# docker run -it --network=none busybox
Unable to find image &amp;apos;busybox:latest&amp;apos; locally
latest: Pulling from library/busybox
fb46b04c527d: Pull complete 
Digest: sha256:436bbf48aa1198ebca8eac0ad9a9c80c8929d9242e02608f76ce18334e0cfe6a
Status: Downloaded newer image for busybox:latest
/ # ifconfig
lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1 
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里我们可以看到none网络中只有一个lo，没有其他网卡，就是一个封闭的网络，不与外界通信。封闭意味着隔离，一些对安全性要求高并且不需要联网的应用可以使用 none 网络。&lt;/p&gt;
&lt;h3 id=&quot;host网络&quot;&gt;&lt;a href=&quot;#host网络&quot; class=&quot;headerlink&quot; title=&quot;host网络&quot;&gt;&lt;/a&gt;host网络&lt;/h3&gt;&lt;p&gt;连接到 host 网络的容器共享 Docker host 的网络栈，容器的网络配置与宿主机完全一样。可以通过 –network=host 指定使用 host 网络。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@docker ~]# docker run -it --network=host busybox
/ # ifconfig 
docker0   Link encap:Ethernet  HWaddr 02:42:02:90:4E:49  
          inet addr:172.17.0.1  Bcast:0.0.0.0  Mask:255.255.0.0
          UP BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

ens33     Link encap:Ethernet  HWaddr 00:0C:29:95:F6:22  
          inet addr:192.168.175.40  Bcast:192.168.175.255  Mask:255.255.255.0
          inet6 addr: fe80::f1c9:d94d:f12b:990c/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:203380 errors:0 dropped:0 overruns:0 frame:0
          TX packets:73455 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:270648213 (258.1 MiB)  TX bytes:6886880 (6.5 MiB)

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1 
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

/ # hostname
docker
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在容器内可以看到所有宿主机的网卡，跟宿主机ifconfig看到的结果时一致的，并且hostname并不是短ID，而是宿主机的hostname。&lt;br&gt;直接使用 Docker host 的网络最大的好处就是性能，如果容器对网络传输效率有较高要求，则可以选择 host 网络。当然不便之处就是牺牲一些灵活性，比如要考虑端口冲突问题，宿主机上已经使用的端口就不能再用了。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker系列" scheme="http://www.chenfanlinux.org/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Docker" scheme="http://www.chenfanlinux.org/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门之容器管理(四)</title>
    <link href="http://www.chenfanlinux.org/2018/01/11/Docker%E5%85%A5%E9%97%A8%E4%B9%8B%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86-%E5%9B%9B/"/>
    <id>http://www.chenfanlinux.org/2018/01/11/Docker入门之容器管理-四/</id>
    <published>2018-01-11T06:45:57.000Z</published>
    <updated>2018-01-11T06:48:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><blockquote><p>docker run 是启动容器的方法。通过前面的Dockerfile 时我们已经学习到，可用三种方式指定容器启动时执行的命令。</p></blockquote><h3 id="容器运行执行的命令"><a href="#容器运行执行的命令" class="headerlink" title="容器运行执行的命令"></a>容器运行执行的命令</h3><p>通过下面三种方式，我们来执行运行在容器中的命令。</p><ul><li>CMD 指令</li><li>ENDPOINT 指令</li><li>在 docker run 命令行中指定</li></ul><h3 id="运行一个容器示例"><a href="#运行一个容器示例" class="headerlink" title="运行一个容器示例"></a>运行一个容器示例</h3><pre><code>[root@docker ~]# docker run ubuntu pwd/[root@docker ~]# docker ps -aCONTAINER ID        IMAGE                                                                      COMMAND                  CREATED              STATUS                          PORTS               NAMESe12b964641c4        ubuntu                                                                     &quot;pwd&quot;                    32 seconds ago       Exited (0) 31 seconds ago                           modest_johnson</code></pre><p><strong>说明：</strong>  此处我们运行一个ubuntu镜像,并运行pwd命令后,容器便退出了,状态为Exited。这种“一闪而过”的容器通常不是我们想要的结果，我们希望容器能够保持 runing 状态，这样才能被我们使用。</p><h3 id="让容器长久的运行"><a href="#让容器长久的运行" class="headerlink" title="让容器长久的运行"></a>让容器长久的运行</h3><p>因为容器的生命周期依赖于启动时执行的命令，只要该命令不结束，容器也就不会退出。理解了这个原理，我们就可以通过执行一个长期运行的命令来保持容器的运行状态。</p><pre><code>[root@docker ~]# docker run ubuntu /bin/bash -c &quot;while true;do sleep 1;done&quot;[root@docker ~]# docker ps -aCONTAINER ID        IMAGE                                                                      COMMAND                  CREATED             STATUS                     PORTS               NAMESd36bbcefec6b        ubuntu                                                                     &quot;/bin/bash -c &apos;while…&quot;   50 seconds ago      Up 49 seconds                                  eager_lumiere</code></pre><p>上面利用执行循环命令，让命令一直执行，容器自然就不会退出(Exited)状态,而是一直运行(Up)状态。但这样终端会被一直占用。可以利用加上参数-d 以后台方式运行容器。</p><pre><code>[root@docker ~]# docker stop d36bbcefec6bd36bbcefec6b[root@docker ~]# docker rm d36bbcefec6bd36bbcefec6b[root@docker ~]# docker run -d ubuntu /bin/bash -c &quot;while true;do sleep 1;done&quot;a141b831a16edbb94ab41553e2be2af79e2d5b68f25877db40750c49cc991649[root@docker ~]# docker ps -aCONTAINER ID        IMAGE                                                                      COMMAND                  CREATED             STATUS                      PORTS               NAMESa141b831a16e        ubuntu</code></pre><p><strong>说明事项：</strong></p><ul><li>CONTAINER ID 是容器的 “短ID”，前面启动容器时返回的是 “长ID”。短ID是长ID的前12个字符。</li><li>NAMES 字段显示容器的名字，在启动容器时可以通过 –name 参数显示地为容器命名，如果不指定，docker 会自动为容器分配名字。</li><li>我们可以利用docker stop CONTAINER ID 停止正在运行的容器，并使用docker rm CONTAINER ID 删除停止的容器;docker run -d COMMAND 以后台的方式运行容器。</li></ul><a id="more"></a><h2 id="进入容器内部"><a href="#进入容器内部" class="headerlink" title="进入容器内部"></a>进入容器内部</h2><blockquote><p>我们经常需要进到容器里去做一些工作，比如查看日志、调试、启动其他进程等。有两种方法进入容器：attach 和 exec。</p></blockquote><h3 id="docker-attach"><a href="#docker-attach" class="headerlink" title="docker attach"></a>docker attach</h3><pre><code>通过 docker attach 可以 attach 到容器启动命令的终端，例如：[root@docker ~]# docker run -d ubuntu /bin/bash -c &quot;while true;do sleep 1;echo &apos;I am in container&apos;;done&quot; 7b0dfb366bcb3259f6ec13e016e1f517b7c56cf0d406fdea4e4215e55cfd7e86</code></pre><p>这次我们通过 “长ID” attach 到了容器的启动命令终端，之后看到的是echo 每隔一秒打印的信息。</p><pre><code>[root@docker ~]# docker attach 7b0dfb366bcb3259f6ec13e016e1f517b7c56cf0d406fdea4e4215e55cfd7e86I am in containerI am in containerI am in containerI am in containerI am in container</code></pre><h3 id="docker-exec"><a href="#docker-exec" class="headerlink" title="docker exec"></a>docker exec</h3><p>通过 docker exec 进入相同的容器：</p><pre><code>[root@docker ~]# docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES7b0dfb366bcb        ubuntu              &quot;/bin/bash -c &apos;while…&quot;   4 minutes ago       Up 4 minutes                            zealous_dubinsky[root@docker ~]# docker exec -it 7b0dfb366bcb  bashroot@7b0dfb366bcb:/# lsbin   dev  home  lib64  mnt  proc  run   srv  tmp  varboot  etc  lib   media  opt  root  sbin  sys  usrroot@7b0dfb366bcb:/# ps -efUID         PID   PPID  C STIME TTY          TIME CMDroot          1      0  0 04:20 ?        00:00:00 /bin/bash -c while true;do sleroot        265      0  0 04:24 pts/0    00:00:00 bashroot        279      1  0 04:24 ?        00:00:00 sleep 1root        280    265  0 04:24 pts/0    00:00:00 ps -ef</code></pre><p><strong>说明事项：</strong></p><ul><li>-it 以交互模式打开 pseudo-TTY，执行 bash，其结果就是打开了一个 bash 终端</li><li>进入到容器中，容器的 hostname 就是其 “短ID”</li><li>可以像在普通 Linux 中一样执行命令。ps -elf 显示了容器启动进程while 以及当前的 bash 进程</li><li>执行 exit 退出容器，回到 docker host</li><li>docker exec -it <container> bash|sh 是执行 exec 最常用的方式</container></li></ul><h3 id="attach-对比-exec"><a href="#attach-对比-exec" class="headerlink" title="attach 对比 exec"></a>attach 对比 exec</h3><ul><li>attach 直接进入容器 启动命令 的终端，不会启动新的进程。</li><li>exec 则是在容器中打开新的终端，并且可以启动新的进程。</li><li>如果想直接在终端中查看启动命令的输出，用 attach；其他情况使用 exec。</li></ul><p>当然，如果只是为了查看启动命令的输出，可以使用 docker logs 命令</p><pre><code>[root@docker ~]# docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES7b0dfb366bcb        ubuntu              &quot;/bin/bash -c &apos;while…&quot;   10 minutes ago      Up 10 minutes                           zealous_dubinskya141b831a16e        ubuntu              &quot;/bin/bash -c &apos;while…&quot;   25 minutes ago      Up 25 minutes                           ecstatic_pasteur[root@docker ~]# docker logs -f 7b0dfb366bcbI am in containerI am in containerI am in containerI am in containerI am in containerI am in containerI am in containerI am in container</code></pre><h2 id="运行Docker的最佳实践"><a href="#运行Docker的最佳实践" class="headerlink" title="运行Docker的最佳实践"></a>运行Docker的最佳实践</h2><blockquote><p>按用途容器大致可分为两类：服务类容器和工具类的容器。</p></blockquote><h3 id="容器功能分类"><a href="#容器功能分类" class="headerlink" title="容器功能分类"></a>容器功能分类</h3><ul><li><p>服务类容器以 daemon 的形式运行，对外提供服务。比如 web server，数据库等。通过 -d 以后台方式启动这类容器是非常合适的。如果要排查问题，可以通过 exec -it 进入容器。</p></li><li><p>工具类容器通常给能我们提供一个临时的工作环境，工具类容器多使用基础镜像，例如 busybox、debian、ubuntu 等，通常以 run -it 方式运行。</p><p>  <code>[root@docker ~]# docker run -it busybox</code><br>  <code>/ # ping www.baidu.com</code><br>  <code>PING www.baidu.com (14.215.177.39): 56 data bytes</code><br>  <code>64 bytes from 14.215.177.39: seq=0 ttl=127 time=5.724 ms</code><br>  <code>64 bytes from 14.215.177.39: seq=1 ttl=127 time=4.829 ms</code></p></li></ul><p>运行 busybox，run -it 的作用是在容器启动后就直接进入。我们这里通过 ping 验证了在容器中访问 internet 的能力。执行 exit 退出终端，同时容器停止。</p><h3 id="容器运行小结"><a href="#容器运行小结" class="headerlink" title="容器运行小结"></a>容器运行小结</h3><p><strong>容器运行相关的知识点：</strong></p><ul><li>当 CMD 或 Entrypoint 或 docker run 命令行指定的命令运行结束时，容器停止。</li><li>通过 -d 参数在后台启动容器。</li><li>通过 exec -it 可进入容器并执行命令。</li></ul><p><strong>指定容器的三种方法：</strong></p><ul><li>短ID</li><li>长ID</li><li>容器名称，可通过 –name 为容器命名</li></ul><p><strong>容器按用途可分为两类：</strong></p><ul><li><p>服务类的容器</p></li><li><p>工具类的容器</p></li></ul><h2 id="常见的容器操作"><a href="#常见的容器操作" class="headerlink" title="常见的容器操作"></a>常见的容器操作</h2><blockquote><p>对容器的生命周期有了大致的理解，下面这张状态机很好地总结了容器各种状态之间是如何转换的。</p></blockquote><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/KLl95a" alt="docker状态转换图"></p><h3 id="create容器"><a href="#create容器" class="headerlink" title="create容器"></a>create容器</h3><p>可以先创建容器，稍后再启动。</p><pre><code>[root@docker ~]# docker create httpdUnable to find image &apos;httpd:latest&apos; locallylatest: Pulling from library/httpdf49cf87b52c1: Pull complete02ca099fb6cd: Pull completede7acb18da57: Pull complete770c8edb393d: Pull complete0e252730aeae: Pull complete6e6ca341873f: Pull complete2daffd0a6144: Pull completeDigest: sha256:fb6b4d40e0a2ab5beb7a40b440b012f49642b45163034c6eb36233b433e8e741Status: Downloaded newer image for httpd:latest910bb90c15f5bcd8976c9c43a882f49fcd781074e7999722b04f07b852f7d1d7[root@docker ~]# docker ps -a |grep httpd910bb90c15f5        httpd               &quot;httpd-foreground&quot;       4 minutes ago       Created                                 distracted_kirch</code></pre><h3 id="start容器"><a href="#start容器" class="headerlink" title="start容器"></a>start容器</h3><p>对于处于停止状态的容器，可以通过 docker start 重新启动。</p><pre><code>[root@docker ~]# docker ps -a |grep httpd910bb90c15f5        httpd               &quot;httpd-foreground&quot;       4 minutes ago       Created                                 distracted_kirch[root@docker ~]# docker start 910bb90c15f5910bb90c15f5[root@docker ~]# docker ps -a |grep httpd910bb90c15f5        httpd               &quot;httpd-foreground&quot;       6 minutes ago       Up 1 second         80/tcp              distracted_kirch</code></pre><h3 id="run容器"><a href="#run容器" class="headerlink" title="run容器"></a>run容器</h3><p>启动容器包括到容器的创建，然后启动容器两个步骤。<br>docker run = docker create + dokcer start</p><pre><code>[root@docker ~]# docker run -it busybox/ #</code></pre><h3 id="stop容器"><a href="#stop容器" class="headerlink" title="stop容器"></a>stop容器</h3><p>容器在 docker host 中实际上是一个进程，docker stop 命令本质上是向该进程发送一个 SIGTERM 信号。</p><pre><code>[root@docker ~]# docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMESf55bae074567        busybox             &quot;sh&quot;                     2 hours ago         Up 2 hours                              affectionate_ramanujan7b0dfb366bcb        ubuntu              &quot;/bin/bash -c &apos;while…&quot;   2 hours ago         Up 2 hours                              zealous_dubinskya141b831a16e        ubuntu              &quot;/bin/bash -c &apos;while…&quot;   2 hours ago         Up 2 hours                              ecstatic_pasteur[root@docker ~]# docker stop 7b0dfb366bcb7b0dfb366bcb[root@docker ~]# docker ps -aCONTAINER ID        IMAGE                                                                      COMMAND                  CREATED             STATUS                        PORTS               NAMESf55bae074567        busybox                                                                    &quot;sh&quot;                     2 hours ago         Up 2 hours                                        affectionate_ramanujan7b0dfb366bcb        ubuntu                                                                     &quot;/bin/bash -c &apos;while…&quot;   2 hours ago         Exited (137) 47 seconds ago</code></pre><h3 id="kill容器"><a href="#kill容器" class="headerlink" title="kill容器"></a>kill容器</h3><p>如果想快速停止容器，可使用 docker kill 命令，其作用是向容器进程发送 SIGKILL 信号。</p><pre><code>[root@docker ~]# docker ps -a |grep httpd910bb90c15f5        httpd               &quot;httpd-foreground&quot;       8 minutes ago       Up About a minute   80/tcp              distracted_kirch[root@docker ~]# docker kill  910bb90c15f5910bb90c15f5[root@docker ~]# docker ps -a |grep httpd910bb90c15f5        httpd               &quot;httpd-foreground&quot;       8 minutes ago       Exited (137) 5 seconds ago                       distracted_kirch</code></pre><h3 id="pause-容器"><a href="#pause-容器" class="headerlink" title="pause 容器"></a>pause 容器</h3><p>有时我们只是希望暂时让容器暂停工作一段时间，比如要对容器的文件系统打个快照，或者 dcoker host 需要使用 CPU，这时可以执行 docker pause。</p><pre><code>[root@docker ~]# docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMESf55bae074567        busybox             &quot;sh&quot;                     2 hours ago         Up 2 hours                              affectionate_ramanujan7b0dfb366bcb        ubuntu              &quot;/bin/bash -c &apos;while…&quot;   2 hours ago         Up 2 minutes                            zealous_dubinskya141b831a16e        ubuntu              &quot;/bin/bash -c &apos;while…&quot;   2 hours ago         Up 2 hours                              ecstatic_pasteur[root@docker ~]# docker pause f55bae074567f55bae074567[root@docker ~]# docker ps -a |grep f55bae074567f55bae074567        busybox                                                                    &quot;sh&quot;                     2 hours ago         Up 2 hours (Paused)                            affectionate_ramanujan</code></pre><h3 id="unpause容器"><a href="#unpause容器" class="headerlink" title="unpause容器"></a>unpause容器</h3><p>处于暂停状态的容器不会占用 CPU 资源，直到通过 docker unpause 恢复运行。</p><pre><code>[root@docker ~]# docker unpause f55bae074567f55bae074567[root@docker ~]# docker ps -a |grep f55bae074567f55bae074567        busybox                                                                    &quot;sh&quot;                     2 hours ago         Up 2 hours                                     affectionate_ramanujan</code></pre><h3 id="rm容器"><a href="#rm容器" class="headerlink" title="rm容器"></a>rm容器</h3><p>使用 docker 一段时间后，host 上可能会有大量已经退出了的容器，这些容器依然会占用 host 的文件系统资源，如果确认不会再重启此类容器，可以通过 docker rm 删除。</p><pre><code>[root@docker ~]# docker ps -a |grep &apos;Exited&apos;e12b964641c4        ubuntu                                                                     &quot;pwd&quot;                    3 hours ago         Exited (0) 3 hours ago                         modest_johnson97eb5d978d46        ubuntu                                                                     &quot;ls&quot;                     3 hours ago         Exited (0) 3 hours ago</code></pre><p>docker rm 一次可以指定多个容器，如果希望批量删除所有已经退出的容器，可以执行如下命令：</p><p><code>docker rm -v $(docker ps -aq -f status=exited)</code></p><pre><code>[root@docker ~]# docker rm -v $(docker ps -aq -f status=exited)e12b964641c497eb5d978d462f5aa14aaa655fb431cd6d5b81fede2842bf28933756a14ab6df60142950[root@docker ~]# docker ps -a |grep &apos;Exited&apos;[root@docker ~]#</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;运行容器&quot;&gt;&lt;a href=&quot;#运行容器&quot; class=&quot;headerlink&quot; title=&quot;运行容器&quot;&gt;&lt;/a&gt;运行容器&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;docker run 是启动容器的方法。通过前面的Dockerfile 时我们已经学习到，可用三种方式指定容器启动时执行的命令。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;容器运行执行的命令&quot;&gt;&lt;a href=&quot;#容器运行执行的命令&quot; class=&quot;headerlink&quot; title=&quot;容器运行执行的命令&quot;&gt;&lt;/a&gt;容器运行执行的命令&lt;/h3&gt;&lt;p&gt;通过下面三种方式，我们来执行运行在容器中的命令。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CMD 指令&lt;/li&gt;
&lt;li&gt;ENDPOINT 指令&lt;/li&gt;
&lt;li&gt;在 docker run 命令行中指定&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;运行一个容器示例&quot;&gt;&lt;a href=&quot;#运行一个容器示例&quot; class=&quot;headerlink&quot; title=&quot;运行一个容器示例&quot;&gt;&lt;/a&gt;运行一个容器示例&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;[root@docker ~]# docker run ubuntu pwd
/
[root@docker ~]# docker ps -a
CONTAINER ID        IMAGE                                                                      COMMAND                  CREATED              STATUS                          PORTS               NAMES
e12b964641c4        ubuntu                                                                     &amp;quot;pwd&amp;quot;                    32 seconds ago       Exited (0) 31 seconds ago                           modest_johnson
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;  此处我们运行一个ubuntu镜像,并运行pwd命令后,容器便退出了,状态为Exited。这种“一闪而过”的容器通常不是我们想要的结果，我们希望容器能够保持 runing 状态，这样才能被我们使用。&lt;/p&gt;
&lt;h3 id=&quot;让容器长久的运行&quot;&gt;&lt;a href=&quot;#让容器长久的运行&quot; class=&quot;headerlink&quot; title=&quot;让容器长久的运行&quot;&gt;&lt;/a&gt;让容器长久的运行&lt;/h3&gt;&lt;p&gt;因为容器的生命周期依赖于启动时执行的命令，只要该命令不结束，容器也就不会退出。理解了这个原理，我们就可以通过执行一个长期运行的命令来保持容器的运行状态。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@docker ~]# docker run ubuntu /bin/bash -c &amp;quot;while true;do sleep 1;done&amp;quot;
[root@docker ~]# docker ps -a
CONTAINER ID        IMAGE                                                                      COMMAND                  CREATED             STATUS                     PORTS               NAMES
d36bbcefec6b        ubuntu                                                                     &amp;quot;/bin/bash -c &amp;apos;while…&amp;quot;   50 seconds ago      Up 49 seconds                                  eager_lumiere
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面利用执行循环命令，让命令一直执行，容器自然就不会退出(Exited)状态,而是一直运行(Up)状态。但这样终端会被一直占用。可以利用加上参数-d 以后台方式运行容器。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@docker ~]# docker stop d36bbcefec6b
d36bbcefec6b
[root@docker ~]# docker rm d36bbcefec6b
d36bbcefec6b
[root@docker ~]# docker run -d ubuntu /bin/bash -c &amp;quot;while true;do sleep 1;done&amp;quot;
a141b831a16edbb94ab41553e2be2af79e2d5b68f25877db40750c49cc991649

[root@docker ~]# docker ps -a
CONTAINER ID        IMAGE                                                                      COMMAND                  CREATED             STATUS                      PORTS               NAMES
a141b831a16e        ubuntu
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;说明事项：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CONTAINER ID 是容器的 “短ID”，前面启动容器时返回的是 “长ID”。短ID是长ID的前12个字符。&lt;/li&gt;
&lt;li&gt;NAMES 字段显示容器的名字，在启动容器时可以通过 –name 参数显示地为容器命名，如果不指定，docker 会自动为容器分配名字。&lt;/li&gt;
&lt;li&gt;我们可以利用docker stop CONTAINER ID 停止正在运行的容器，并使用docker rm CONTAINER ID 删除停止的容器;docker run -d COMMAND 以后台的方式运行容器。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Docker系列" scheme="http://www.chenfanlinux.org/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Docker" scheme="http://www.chenfanlinux.org/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门之Dockerfile最佳实践(三)</title>
    <link href="http://www.chenfanlinux.org/2018/01/10/Docker%E5%85%A5%E9%97%A8%E4%B9%8BDockerfile%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E4%B8%89/"/>
    <id>http://www.chenfanlinux.org/2018/01/10/Docker入门之Dockerfile最佳实践-三/</id>
    <published>2018-01-10T09:21:22.000Z</published>
    <updated>2018-01-11T03:01:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="认识Dockerfile"><a href="#认识Dockerfile" class="headerlink" title="认识Dockerfile"></a>认识Dockerfile</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Dockerfile是一个文本格式的配置文件，用户可以使用Dockerfile快速构建自定义的镜像。 下面展示一个规范的DockerFile文件。</p><pre><code>## DOCKER-VERSION    1.12.6# Dockerizing ubuntu14.04: Dockerfile for building ubuntu images## 非注释首行必须指定基础镜像FROM ubuntu:14.04# 维护者信息MAINTAINER chenfan &lt;1144102576@qq.com&gt;# 指定环境变量ENV TZ &quot;Asia/Shanghai&quot;ENV TERM xterm# 拷贝文件(Dockerfile所在目录的相对路径)到容器中ADD sources.list /etc/apt/sources.listCOPY .bash_aliases /root/.bash_aliases# 在当前镜像的基础上执行指定命令并提交为新的镜像RUN \    apt-get update &amp;&amp; \    apt-get -y upgrade &amp;&amp; \    apt-get install -y build-essential &amp;&amp; \    apt-get install -y software-properties-common &amp;&amp; \    apt-get install -y curl htop unzip vim wget &amp;&amp; \    rm -rf /var/lib/apt/lists/*# 指定工作目录WORKDIR /root# 暴露的端口号(映射端口)EXPOSE 22# 指定容器启动时，默认运行的命令CMD [&quot;/bin/bash&quot;]</code></pre><a id="more"></a><h2 id="指令详解"><a href="#指令详解" class="headerlink" title="指令详解"></a>指令详解</h2><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><ul><li>描述：用于指定基础镜像，且非注释首行必须是FROM；</li><li>格式：FROM  &lt;image&gt; [:&lt;tag&gt;]</li></ul><h3 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h3><ul><li>描述：指定维护者信息；</li><li>格式：MAINTAINER &lt;name&gt; &lt;email&gt;</li></ul><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><ul><li>描述：在当前镜像基础上执行指定命令，并提交为新的镜像，当命令较长时可以使用\来换行,RUN命令经常被用作安装软件包；</li><li>格式：<ul><li>使用shell终端运行命令，即/bin/sh -c：RUN &lt;command&gt;</li><li>使用exec执行，使用其他终端时可使用：RUN [“executable”, “param”, “param”…]</li></ul></li></ul><ul><li>示例：<br><code>RUN [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;echo hello&quot;]</code></li></ul><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><ul><li>描述：指定启动容器时执行的命令，且每个Dockerfile仅能拥有一条CMD指令，若有多条，仅最后一条被执行，若用户在启动容器时指定了运行命令，则会覆盖掉CMD指定的命令；</li><li>格式：<ul><li>CMD [“executable”,”param1”,”param2”] (exec form, this is the preferred form)</li><li>CMD [“param1”,”param2”] (as default parameters to ENTRYPOINT)</li><li>CMD command param1 param2 (shell form)</li><li>第一种用法：运行一个可执行的文件并提供参数。</li><li>第二种用法：为ENTRYPOINT指定参数。</li><li>第三种用法(shell form)：是以”/bin/sh -c”的方法执行的命令。</li></ul></li></ul><p><strong>注意</strong>：CMD可以为ENTRYPOINT提供参数，ENTRYPOINT本身也可以包含参数，但是你可以把那些可能需要变动的参数写到CMD里而把那些不需要变动的参数写到ENTRYPOINT里面。把可能需要变动的参数写到CMD里面。然后你可以在docker run里指定参数，CMD里的参数就会被覆盖掉而ENTRYPOINT里的不被覆盖。</p><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><ul><li>描述：指定容器暴露的端口号，在启动容器时需要通过参数-P或-p来映射；</li><li>格式：EXPOSE &lt;port&gt;[ &lt;port&gt;…]</li><li>示例：<code>EXPOSE 22 80 443</code></li></ul><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><ul><li>描述：指定一个环境变量，供后续的RUN指令使用，并持久在容器中；</li><li>格式：ENV &lt;key&gt; &lt;value&gt;</li></ul><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><ul><li>描述：拷贝文件(Dockerfile所在目录的相对路径或是URL)到容器中，若源文件为归档文件(tar、zip、tgz等)，自动解压为目录；</li><li>格式：ADD &lt;src&gt; &lt;dest&gt;</li></ul><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><ul><li>描述：将文件从 build context 复制到镜像。</li><li>格式：COPY &lt;src&gt; &lt;dest&gt;</li><li>注意：只能复制build context内的文件或目录。</li></ul><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><ul><li>描述：指定启动容器时执行的命令，且不可被覆盖，每个Dockerfile仅能拥有一条ENTRYPOINT指令，若有多条，仅最后一条被执行；</li><li>格式：<ul><li>使用exec执行(推荐使用)：ENTRYPOINT [“executable”, “param”, “param”…]</li><li>使用shell终端运行命令，供需交互的应用使用：ENTRYPOINT &lt;command&gt; &lt;param&gt; &lt;param&gt;…</li></ul></li></ul><p>注意：</p><ul><li>ENTRYPOINT接收来自于docker run和CMD提供的额外参数,docker run会覆盖CMD的参数；将可变的参数放在CMD中,不变的参数放置于ENTRYPOINT中。</li><li>ENTRYPOINT有两种写法,推荐使用exec格式，第二种(shell form)会屏蔽掉docker run时后面加的命令和CMD里的参数。</li><li>ENTRYPOINT并不默认为[“/bin/sh -c”]</li></ul><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><ul><li>描述：创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库与持久化数据等；</li><li>格式：VOLUME [“/data”]</li></ul><h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><ul><li>描述：指定运行容器时的用户名或UID，供后续的RUN指令使用，并持久在容器中；</li><li>格式：USER daemon</li></ul><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><ul><li>描述：指定当前工作目录，相当于cd命令，供后续的RUN、CMD、ENTRYPOINT指令使用；</li><li>格式：WORKDIR &lt;path&gt;</li></ul><h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><ul><li>描述：配置当所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令；</li><li>格式：ONBUILD [INSTRUCTION]</li><li>示例：<code>ONBUILD RUN apt-get update</code></li></ul><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><h3 id="构建镜像的步骤"><a href="#构建镜像的步骤" class="headerlink" title="构建镜像的步骤"></a>构建镜像的步骤</h3><ul><li>将Dockerfile文件编写完成以后，可以通过docker build命令来创建镜像；</li><li>构建镜像时，推荐将需要使用的包及Dockerfile文件放在同一个目录中；</li><li>若需要指定镜像的标签信息，使用-t选项,系统默认从build context目录下去寻找Dockerfile，也可以通过-f选项指定Dockerfile的位置。</li></ul><h3 id="Dockerfile执行步骤"><a href="#Dockerfile执行步骤" class="headerlink" title="Dockerfile执行步骤"></a>Dockerfile执行步骤</h3><ul><li>从 base 镜像运行一个容器。</li><li>执行一条指令，对容器做修改。</li><li>执行类似 docker commit 的操作，生成一个新的镜像层。</li><li>Docker 再基于刚刚提交的镜像运行一个新容器。</li><li>重复 2-4 步，直到 Dockerfile 中的所有指令执行完毕</li></ul><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul><li>使用 RUN 指令安装应用和软件包，构建镜像。  </li><li>如果 Docker 镜像的用途是运行应用程序或服务，比如运行一个 MySQL，应该优先使用 Exec 格式的 ENTRYPOINT 指令。CMD 可为 ENTRYPOINT 提供额外的默认参数，同时可利用 docker run 命令行替换默认参数。 </li><li>如果想为容器设置默认的启动命令，可使用 CMD 指令。用户可在 docker run 命令行中替换此默认命令。  </li></ul><h3 id="构建镜像示例"><a href="#构建镜像示例" class="headerlink" title="构建镜像示例"></a>构建镜像示例</h3><p><strong>格式：</strong></p><p><code>docker build -t ubuntu:chenfan PATH -f Dockerfile_Path .</code></p><p><strong>说明：</strong><br>运行 docker build 命令，-t 将新镜像命名为 ubuntu:chenfan，命令末尾的 . 指明 build context 为当前目录。Docker 默认会从 build context 中查找 Dockerfile 文件，我们也可以通过 -f 参数指定 Dockerfile 的位置。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;认识Dockerfile&quot;&gt;&lt;a href=&quot;#认识Dockerfile&quot; class=&quot;headerlink&quot; title=&quot;认识Dockerfile&quot;&gt;&lt;/a&gt;认识Dockerfile&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;Dockerfile是一个文本格式的配置文件，用户可以使用Dockerfile快速构建自定义的镜像。 下面展示一个规范的DockerFile文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#
# DOCKER-VERSION    1.12.6
# Dockerizing ubuntu14.04: Dockerfile for building ubuntu images
#

# 非注释首行必须指定基础镜像
FROM ubuntu:14.04
# 维护者信息
MAINTAINER chenfan &amp;lt;1144102576@qq.com&amp;gt;

# 指定环境变量
ENV TZ &amp;quot;Asia/Shanghai&amp;quot;
ENV TERM xterm

# 拷贝文件(Dockerfile所在目录的相对路径)到容器中
ADD sources.list /etc/apt/sources.list
COPY .bash_aliases /root/.bash_aliases

# 在当前镜像的基础上执行指定命令并提交为新的镜像
RUN \
    apt-get update &amp;amp;&amp;amp; \
    apt-get -y upgrade &amp;amp;&amp;amp; \
    apt-get install -y build-essential &amp;amp;&amp;amp; \
    apt-get install -y software-properties-common &amp;amp;&amp;amp; \
    apt-get install -y curl htop unzip vim wget &amp;amp;&amp;amp; \
    rm -rf /var/lib/apt/lists/*

# 指定工作目录
WORKDIR /root

# 暴露的端口号(映射端口)
EXPOSE 22

# 指定容器启动时，默认运行的命令
CMD [&amp;quot;/bin/bash&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Docker系列" scheme="http://www.chenfanlinux.org/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Docker" scheme="http://www.chenfanlinux.org/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门之镜像管理(二)</title>
    <link href="http://www.chenfanlinux.org/2018/01/10/Docker%E5%85%A5%E9%97%A8%E4%B9%8B%E9%95%9C%E5%83%8F%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%AE%A1%E7%90%86-%E4%BA%8C/"/>
    <id>http://www.chenfanlinux.org/2018/01/10/Docker入门之镜像基础概念与管理-二/</id>
    <published>2018-01-10T07:35:23.000Z</published>
    <updated>2018-01-11T07:25:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="认识最小的镜像（hello-world-）"><a href="#认识最小的镜像（hello-world-）" class="headerlink" title="认识最小的镜像（hello-world ）"></a>认识最小的镜像（hello-world ）</h2><blockquote><p>镜像是 Docker 容器的基石，容器是镜像的运行实例，有了镜像才能启动容器。理解清楚镜像的内部结构,我们才能够按照需求构建符合要求的镜像。hello-world 是 Docker 官方提供的一个镜像，通常用来验证 Docker 是否安装成功。</p></blockquote><p>我们先通过 docker pull 从 Docker Hub 下载它</p><pre><code>[root@docker ~]# docker pull hello-worldUsing default tag: latestlatest: Pulling from library/hello-worldca4f61b1923c: Pull completeDigest: sha256:ca0eeb6fb05351dfc8759c20733c91def84cb8007aa89a5bf606bc8b315b9fc7Status: Downloaded newer image for hello-world:latest</code></pre><p>可以使用 docker images 命令查看镜像的信息，可以看到镜像非常的小,只有1.85k</p><pre><code>[root@docker ~]# docker images |grep hello-worldhello-world  latest       f2a91732366c     6 weeks ago         1.85kB</code></pre><p>最后通过 docker run 运行镜像</p><pre><code>[root@docker ~]# docker run hello-worldHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.    (amd64) 3. The Docker daemon created a new container from that image which runs the    executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it    to your terminal.</code></pre><p>那么该镜像运行怎么就输出上面这一串信息的呢？如果对 Docker 了解一点的话自然会去找该镜像的 Dockerfile，Dockerfile 详细描述了该镜像是如何建立的以及运行时执行的命令。从 Docker Hub 上 <a href="https://hub.docker.com/r/library/hello-world/" target="_blank" rel="noopener">hello-world</a> 的库简介 找到其 <a href="https://github.com/docker-library/hello-world/blob/b7a78b7ccca62cc478919b101f3ab1334899df2b/Dockerfile" target="_blank" rel="noopener">Dockerfile</a> 在 github 上，简简单单的三条语句。</p><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/4q6B6C" alt="hello-world Dockerfile"><br><strong>hello-world的Dockerfile如下:</strong></p><pre><code>FROM scratchADD hello /CMD [&quot;/hello&quot;]</code></pre><ul><li><p>第一条FROM指令是 Docker 用来指定该镜像是基于哪个基础镜像构建的，这里指定为 scratch，实际上 scratch 镜像是一个空镜像，用来构建基础镜像或者极小的镜像。</p></li><li><p>第二条ADD指令表示从 Dockerfile 所在目录拷贝文件到指定路径下，这里拷贝 hello 文件到根目录下，这里的hello文件是一个二进制可执行文件。</p></li><li><p>第三条CMD指令用来指示当运行 docker run 命令运行该镜像时要执行的命令，这里执行 /hello，就是执行第二步拷贝到根目录下的 hello 文件。</p><a id="more"></a></li></ul><h2 id="认识base镜像-centos"><a href="#认识base镜像-centos" class="headerlink" title="认识base镜像(centos)"></a>认识base镜像(centos)</h2><blockquote><p>hello-world 虽然是一个完整的镜像，但它并没有什么实际用途。通常来说，我们希望镜像能提供一个基本的操作系统环境，用户可以根据需要安装和配置软件。这样的镜像我们称作 base 镜像。base镜像具有两层含义,首先base镜像不依赖其他镜像，从 scratch 构建;另外其他镜像可以之为基础进行扩展。</p></blockquote><h3 id="拉取centos镜像"><a href="#拉取centos镜像" class="headerlink" title="拉取centos镜像"></a>拉取centos镜像</h3><p>能称作 base 镜像的通常都是各种 Linux 发行版的 Docker 镜像，比如 Ubuntu, Debian, CentOS 等。下面我们以centos为例,来分析一下Centos镜像是如何构建的。</p><pre><code>[root@docker ~]# docker pull centosUsing default tag: latestlatest: Pulling from library/centosDigest: sha256:3b1a65e9a05f0a77b5e8a698d3359459904c2a354dc3b25ae2e2f5c95f0b3667Status: Image is up to date for centos:latest[root@docker ~]# docker images centosREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEcentos              latest              3fa822599e10        5 weeks ago         204MB</code></pre><p>我们上面拉取到的centos大小就204M左右,而我们平时装的系统有几个GB大小,这是为啥呢？下面解释一下。对于 base 镜像来说，底层直接用 Host 的 kernel，自己只需要提供 rootfs 就行了。<br>而对于一个精简的 OS，rootfs 可以很小，只需要包括最基本的命令、工具和程序库就可以了。相比其他 Linux 发行版，CentOS 的 rootfs 已经算臃肿的了,alpine 还不到 10MB。</p><h3 id="认识Docker文件系统"><a href="#认识Docker文件系统" class="headerlink" title="认识Docker文件系统"></a>认识Docker文件系统</h3><p>典型的Linux文件系统由bootfs和rootfs两部分组成，bootfs(boot file system)主要包含 bootloader和kernel，bootloader主要是引导加载kernel，当kernel被加载到内存中后 bootfs就被umount了。 用户空间的文件系统rootfs (root file system) 包含的就是典型 Linux 系统中的/dev，/proc，/bin，/etc等标准目录和文件。Docker在启动容器的时候，需要创建文件系统，为rootfs提供挂载点。<br><img src="https://cdn-std.dprcdn.net/files/acc_582513/7MiXuC" alt="典型的文件系统"></p><p>Docker容器是建立在Aufs基础上的，Aufs是一种Union FS， 简单来说就是支持将不同的目录挂载到同一个虚拟文件系统下，并实现一种layer的概念。Aufs将挂载到同一虚拟文件系统下的多个目录分别设置成read-only，read-write以及whiteout-able权限，对read-only目录只能读，而写操作只能实施在read-write目录中。重点在于，写操作是在read-only上的一种增量操作，不影响read-only目录。当挂载目录的时候要严格按照各目录之间的这种增量关系，将被增量操作的目录优先于在它基础上增量操作的目录挂载，待所有目录挂载结束了，继续挂载一个read-write目录，如此便形成了一种层次结构。</p><p>Docker镜像的典型结构如下图。传统的Linux加载bootfs时会先将rootfs设为read-only，然后在系统自检之后将rootfs从read-only改为read-write，然后我们就可以在rootfs上进行写和读的操作了。但Docker的镜像却不是这样，它在bootfs自检完毕之后并不会把rootfs的read-only改为read-write。而是利用union mount（UnionFS的一种挂载机制）将一个或多个read-only的rootfs加载到之前的read-only的rootfs层之上。在加载了这么多层的rootfs之后，仍然让它看起来只像是一个文件系统，在Docker的体系里把union mount的这些read-only的rootfs叫做Docker的镜像。但是，此时的每一层rootfs都是read-only的，我们此时还不能对其进行操作。当我们创建一个容器，也就是将Docker镜像进行实例化，系统会在一层或是多层read-only的rootfs之上分配一层空的read-write的rootfs。</p><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/Lyk5KF" alt="Docker文件系统"></p><h2 id="认识centos镜像的Dockerfile"><a href="#认识centos镜像的Dockerfile" class="headerlink" title="认识centos镜像的Dockerfile"></a>认识centos镜像的Dockerfile</h2><blockquote><p>这些基础镜像的Dockerfile,我们可以在Docker hub上搜索到,cenots的<a href="https://github.com/CentOS/sig-cloud-instance-images/blob/37e0a7f3d98ae875dac7ae1026e99c1c04524c62/docker/Dockerfile" target="_blank" rel="noopener">dockerfile</a>如下,我们可以来分析dockerfile文件,知道整个镜像的构建过程。</p></blockquote><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/WFgiMJ" alt="ceonts_dockerfile"></p><pre><code>FROM scratchADD centos-7-docker.tar.xz /LABEL name=&quot;CentOS Base Image&quot; \    vendor=&quot;CentOS&quot; \    license=&quot;GPLv2&quot; \    build-date=&quot;20171128&quot;CMD [&quot;/bin/bash&quot;]</code></pre><p>第一行是上面我们讲到scratch最小的镜像源,第二行 ADD 指令添加到镜像的 tar 包就是 CentOS 7 的 rootfs。在制作镜像时,这个 tar 包会自动解压到 / 目录下,生成 /dev、 /porc、/bin 等目录,最后就是运行一个伪终端。</p><p><strong>支持运行多种 Linux OS</strong></p><p>不同 Linux 发行版的区别主要就是 rootfs。<br><img src="https://cdn-std.dprcdn.net/files/acc_582513/EBn4fs" alt="rootfs"><br>比如 Ubuntu 14.04 使用 upstart 管理服务，apt 管理软件包；而 CentOS 7 使用 systemd 和 yum。这些都是用户空间上的区别，Linux kernel 差别不大。所以 Docker 可以同时支持多种 Linux 镜像，模拟出多种操作系统环境,但都共用宿主机的内核，只是用户空间进行了隔离。</p><h2 id="认识镜像的分层结构"><a href="#认识镜像的分层结构" class="headerlink" title="认识镜像的分层结构"></a>认识镜像的分层结构</h2><blockquote><p>实际工作中,我们的镜像大部分都是通过在base镜像中安装与配置需要的软件构建而成。</p></blockquote><p>比如我现在构建一个新的镜像，Dockerfile如下：</p><pre><code>FROM debainRUN apt-get   install emacsRUN apt-get  install apacheCMD [&quot;/bin/bash&quot;]</code></pre><p>分层架构如下：</p><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/GwQiZh" alt=""><br>可以看到，新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层。</p><p><strong>问什么 Docker 镜像要采用这种分层结构呢？</strong><br>有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。当多个镜像共享一份基础镜像，某个容器修改基础镜像中的内容，比如/dev下面的内容，其他容器不会被修改。这是因为在容器启动后，一个新的可写层被加载到镜像顶部，这一层通常被称为”容器层”，容器层是可写的，镜像层是可读的。在容器层中，用户看到的是一个叠加之后的文件系统。</p><p><strong>容器层的细节如何？</strong><br>镜像层数量可能会很多，所有镜像层会联合在一起组成一个统一的文件系统。比如/etc/abc,上层的/etc/abc会覆盖下层的/etc/abc，用户看到的就是最上层的/etc/abc内容。只有当需要修改时才复制一份数据，这种特性被称作 <a href="https://zh.wikipedia.org/wiki/%E5%AF%AB%E5%85%A5%E6%99%82%E8%A4%87%E8%A3%BD" target="_blank" rel="noopener">Copy-on-Write</a>。可见，容器层保存的是镜像变化的部分，不会对镜像本身进行任何修改。这样就解释了我们前面提出的问题：容器层记录对镜像的修改，所有镜像层都是只读的，不会被容器修改，所以镜像可以被多个容器共享。</p><ul><li><p>添加文件<br>在容器中创建文件时，新文件被添加到容器层中。</p></li><li><p>读取文件<br>在容器中读取某个文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，打开并读入内存。</p></li><li><p>修改文件<br>在容器中修改已存在的文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，立即将其复制到容器层，然后修改之。</p></li><li><p>删除文件<br>在容器中删除文件时，Docker 也是从上往下依次在镜像层中查找此文件。找到后，会在容器层中记录下此删除操作。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;认识最小的镜像（hello-world-）&quot;&gt;&lt;a href=&quot;#认识最小的镜像（hello-world-）&quot; class=&quot;headerlink&quot; title=&quot;认识最小的镜像（hello-world ）&quot;&gt;&lt;/a&gt;认识最小的镜像（hello-world ）&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;镜像是 Docker 容器的基石，容器是镜像的运行实例，有了镜像才能启动容器。理解清楚镜像的内部结构,我们才能够按照需求构建符合要求的镜像。hello-world 是 Docker 官方提供的一个镜像，通常用来验证 Docker 是否安装成功。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们先通过 docker pull 从 Docker Hub 下载它&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@docker ~]# docker pull hello-world
Using default tag: latest
latest: Pulling from library/hello-world
ca4f61b1923c: Pull complete
Digest: sha256:ca0eeb6fb05351dfc8759c20733c91def84cb8007aa89a5bf606bc8b315b9fc7
Status: Downloaded newer image for hello-world:latest
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以使用 docker images 命令查看镜像的信息，可以看到镜像非常的小,只有1.85k&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@docker ~]# docker images |grep hello-world
hello-world  latest       f2a91732366c     6 weeks ago         1.85kB
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后通过 docker run 运行镜像&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@docker ~]# docker run hello-world

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the &amp;quot;hello-world&amp;quot; image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那么该镜像运行怎么就输出上面这一串信息的呢？如果对 Docker 了解一点的话自然会去找该镜像的 Dockerfile，Dockerfile 详细描述了该镜像是如何建立的以及运行时执行的命令。从 Docker Hub 上 &lt;a href=&quot;https://hub.docker.com/r/library/hello-world/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hello-world&lt;/a&gt; 的库简介 找到其 &lt;a href=&quot;https://github.com/docker-library/hello-world/blob/b7a78b7ccca62cc478919b101f3ab1334899df2b/Dockerfile&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dockerfile&lt;/a&gt; 在 github 上，简简单单的三条语句。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-std.dprcdn.net/files/acc_582513/4q6B6C&quot; alt=&quot;hello-world Dockerfile&quot;&gt;&lt;br&gt;&lt;strong&gt;hello-world的Dockerfile如下:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM scratch
ADD hello /
CMD [&amp;quot;/hello&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一条FROM指令是 Docker 用来指定该镜像是基于哪个基础镜像构建的，这里指定为 scratch，实际上 scratch 镜像是一个空镜像，用来构建基础镜像或者极小的镜像。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二条ADD指令表示从 Dockerfile 所在目录拷贝文件到指定路径下，这里拷贝 hello 文件到根目录下，这里的hello文件是一个二进制可执行文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第三条CMD指令用来指示当运行 docker run 命令运行该镜像时要执行的命令，这里执行 /hello，就是执行第二步拷贝到根目录下的 hello 文件。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker系列" scheme="http://www.chenfanlinux.org/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Docker" scheme="http://www.chenfanlinux.org/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Bash特性汇总</title>
    <link href="http://www.chenfanlinux.org/2018/01/05/Bash%E7%89%B9%E6%80%A7%E6%B1%87%E6%80%BB/"/>
    <id>http://www.chenfanlinux.org/2018/01/05/Bash特性汇总/</id>
    <published>2018-01-05T04:35:53.000Z</published>
    <updated>2018-01-05T05:33:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是shell"><a href="#什么是shell" class="headerlink" title="什么是shell?"></a>什么是shell?</h2><blockquote><p>通常,替我们工作的是”硬件”,而控制硬件的是”内核”。用户利用”shell”控制着一些内核提供的”工具”,来控制硬件替我们工作。由于内核听不懂人类语言,所以shell从本质来说就是一个UI(用户界面)应用程序,让内核控制着硬件正确无误的工作，如图1-1 硬件-内核-shell 所示，可以清晰的看到他们的关系。</p></blockquote><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/DDfPGJ" alt="硬件-内核"></p><h2 id="Bash-shell功能特性"><a href="#Bash-shell功能特性" class="headerlink" title="Bash shell功能特性"></a>Bash shell功能特性</h2><h3 id="history命令记忆功能"><a href="#history命令记忆功能" class="headerlink" title="history命令记忆功能"></a>history命令记忆功能</h3><blockquote><p>在Bash里面,我们只要在命令行按”上、下键”或者更强大的”Ctrl+r”,就可以找到之前输入的历史命令,这依赖于Bash的命令记录功能,记录的文件位于家目录下的.bash_history。登录shell后新执行的命令只会记录在缓存中,这些命令会在用户退出时追加到命令历史文件中,我们通过history命令可以查看历史命令.</p></blockquote><p><strong>命令历史相关的环境变量:</strong></p><ul><li>HISTSIZE: 命令历史记录的条数</li><li>HISTFILE: ~/.bash_history</li></ul><p><strong>命令历史调用相关的命令:</strong></p><ul><li><p>调用历史中的命令:</p><ul><li>!#: 重复执行第#条指令</li><li>!!: 重复上一条命令</li><li>!string: 匹配以string开头的命令</li></ul></li><li><p>调用上一条命令的最后一个参数:</p><ul><li>!$</li><li>ESC . （先按esc,释放然后按.）</li></ul></li></ul><a id="more"></a><h3 id="命令与文件补全功能"><a href="#命令与文件补全功能" class="headerlink" title="命令与文件补全功能"></a>命令与文件补全功能</h3><blockquote><p>常在bash中使用热键[Tab]是一个好习惯,因为它可以减少键盘的输入和保证命令的输出的正确性。</p></blockquote><ul><li>接在一串命令的第一个字后面,则为命令的补全</li><li>接在一床命令的第二个字以后时,则为文件的补全</li></ul><h3 id="命令别名的功能"><a href="#命令别名的功能" class="headerlink" title="命令别名的功能"></a>命令别名的功能</h3><blockquote><p>通过给常用命令设置别名的方式,减少命令的输出长度,提升工作效率。命令行键入alias命令,可以查看系统配置的alias命令,将命令别名记录在全局配置环境配置文件/etc/profile或~/.bashrc都是一种持久生效的方式.</p></blockquote><pre><code>[root@chenfanlinux ~]# aliasalias cp=&apos;cp -i&apos;alias egrep=&apos;egrep --color=auto&apos;alias fgrep=&apos;fgrep --color=auto&apos;alias grep=&apos;grep --color=auto&apos;alias l.=&apos;ls -d .* --color=auto&apos;alias ll=&apos;ls -l --color=auto&apos;alias ls=&apos;ls --color=auto&apos;alias mv=&apos;mv -i&apos;alias rm=&apos;rm -i&apos;alias which=&apos;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde&apos;</code></pre><p>   <strong>注意:由于shell脚本中的别名不生效，\cp的含义是脱去别名的设置。</strong></p><h3 id="命令行展开功能"><a href="#命令行展开功能" class="headerlink" title="命令行展开功能"></a>命令行展开功能</h3><blockquote><p>{}:可以承载一个以逗号分隔的列表,并将其展开为多个路径.</p></blockquote><pre><code>$ mkdir /tmp/{a,b} &lt;==&gt;  $ mkdir /tmp/a;mkdir /tmp/b$ mkdir /tmp/{tom,jerry}/hi &lt;==&gt;  $ mkidr /tmp/tom/hi;mkdir /tmp/jerry/hi</code></pre><h3 id="作业-jobs-、前台-fg-、后台-bg-控制"><a href="#作业-jobs-、前台-fg-、后台-bg-控制" class="headerlink" title="作业(jobs)、前台(fg)、后台(bg)控制"></a>作业(jobs)、前台(fg)、后台(bg)控制</h3><blockquote><p>使用前台、后台控制,可以让工作进行得更加的顺利.我们可以随时将作业放置到后台执行,不用担心使用了[Ctrl]+c键来停掉该程序。在单用户登录环境中，达到了多任务的目标。</p></blockquote><ul><li>前台作业: 通过终端启动,且启动后一直占据终端</li><li><p>后台作业: 通过终端启动,但启动后即转入后台运行(释放终端)</p></li><li><p><strong>如何让作业运行于后台?</strong></p><ul><li><p>运行中的作业<br><code>Ctrl+Z</code></p></li><li><p>尚未启动的作业<br><code>COMMAND &amp;</code><br><strong><em>此类作业虽然被送往后台运行,但其依然与终端相关,<br>因为退出登录后作业将停止运行;如果希望送往后台,剥离与终端的关系。</em></strong></p></li><li><p>剥离作业与终端的关系<br><code>nohup COMMAND &amp;</code></p></li></ul></li></ul><ul><li><p><strong>作业控制相关命令:</strong></p><ul><li>查看所有作业情况<br><code>jobs</code></li><li>指定的后台作业调回前台<br><code>fg [[%]JOB_NUM]</code></li><li>让送往后台的作业在后台继续运行<br><code>bg [[%]JOB_NUM]</code></li><li>终止指定的作业<br><code>kill [%JOB_NUM]</code></li></ul></li></ul><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><blockquote><p>除了完整的字符串之外,bash还支持许多通配符来帮助用户查询和执行命令。下表列出常见的通配符,仅供参考。</p></blockquote><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">内容</th></tr></thead><tbody><tr><td style="text-align:center">*</td><td style="text-align:center">通配符,代表0个或多个字符(或数字)</td></tr><tr><td style="text-align:center">?</td><td style="text-align:center">通配符,代表一个有一个字符</td></tr><tr><td style="text-align:center">#</td><td style="text-align:center">注释,常在脚本中,被视为说明</td></tr><tr><td style="text-align:center">\</td><td style="text-align:center">转义字符,将特殊字符或通配符还原成一般字符</td></tr><tr><td style="text-align:center">~</td><td style="text-align:center">用户的家目录</td></tr><tr><td style="text-align:center">$</td><td style="text-align:center">变量之前需要加的变量替换值</td></tr><tr><td style="text-align:center">&amp;</td><td style="text-align:center">将命令转为后台执行</td></tr><tr><td style="text-align:center">!</td><td style="text-align:center">逻辑运算符(not)意思</td></tr><tr><td style="text-align:center">/</td><td style="text-align:center">路径分隔符</td></tr><tr><td style="text-align:center">&gt; &gt;&gt;</td><td style="text-align:center">重定向与追加重定向</td></tr><tr><td style="text-align:center">‘</td><td style="text-align:center">单引号,不具有变量置换功能</td></tr><tr><td style="text-align:center">“</td><td style="text-align:center">具有变量置换功能</td></tr><tr><td style="text-align:center">``</td><td style="text-align:center">中间为可以执行的命令</td></tr><tr><td style="text-align:center">()</td><td style="text-align:center">中间为子shell的起始于结束</td></tr><tr><td style="text-align:center">[] [^]</td><td style="text-align:center">中间为字符的组合</td></tr><tr><td style="text-align:center">{}</td><td style="text-align:center">中间为命令区块的组合</td></tr></tbody></table><table><thead><tr><th style="text-align:center">组合按键</th><th style="text-align:center">执行结果</th></tr></thead><tbody><tr><td style="text-align:center">Ctrl+c</td><td style="text-align:center">终止当前的命令</td></tr><tr><td style="text-align:center">Ctrl+a</td><td style="text-align:center">跳转至命令开始处</td></tr><tr><td style="text-align:center">Ctrl+e</td><td style="text-align:center">跳转至命令结尾处</td></tr><tr><td style="text-align:center">Ctrl+u</td><td style="text-align:center">删除命令行首至光标所在处的所有内容</td></tr><tr><td style="text-align:center">Ctrl+k</td><td style="text-align:center">删除光标所在行至命令行尾部的内容</td></tr><tr><td style="text-align:center">Ctrl+z</td><td style="text-align:center">暂停当前命令的执行</td></tr><tr><td style="text-align:center">Ctrl+l</td><td style="text-align:center">清屏,相当于clear命令</td></tr></tbody></table><p><strong>匹配字符举例</strong></p><ul><li>* 任意长度的任意字符</li><li>? 任意单个字符</li><li><p>[] 只能匹配指定范围内的任意单个字符</p><ul><li>[0-9] 所有数字中挑一个</li><li>[a-z] 不分区字符大小写</li><li>[A-Z] 大写字母</li><li>[[:lower:]] 小写字母</li><li>[^0-9a-z] 特殊字符</li></ul></li><li><p>[^] 匹配指定范围外的任意单个字符</p></li><li><p>专用字符集合:</p><ul><li>[:digit:]:任意数字,相当于0-9</li><li>[:lower:]:任意小写字母</li><li>[:upper:]:任意大写字母</li><li>[:alpha:]:任意大小写字母</li><li>[:alnum:]:任意数字或字母</li><li>[:space:]:空格</li><li>[:punct:]:标点符号</li></ul></li></ul><h3 id="命令执行的判断依据-amp-amp"><a href="#命令执行的判断依据-amp-amp" class="headerlink" title="命令执行的判断依据(; &amp;&amp; ||)"></a>命令执行的判断依据(; &amp;&amp; ||)</h3><blockquote><p>通常来说命令的运行状态会返回两种结果,执行成功则返回0，执行错误则返回非0。而多个命令的执行通常,从前至后,而且命令的执行还具有一定的逻辑关系,上一个命令的执行成功与否,某种程序可用决定下一个命令的执行。</p></blockquote><p><strong>一次执行多个命令,命令之间没有关联。</strong></p><pre><code>[root@chenfanlinux ~]# toch test.txt ; echo &quot;I  touch test.txt&quot;-bash: toch: 未找到命令I touch test.txt</code></pre><p><strong>命令相互关联,上一个命令执行成功,才会执行下一个命令。</strong></p><pre><code>[root@chenfanlinux ~]# toch test.txt &amp;&amp; echo &quot;I touch test.txt&quot;-bash: toch: 未找到命令</code></pre><p><strong>命令相关关联,上一个命令执行失败,才会执行下一个命令。</strong></p><pre><code>[root@chenfanlinux ~]# toch test.txt || echo &quot;I touch test.txt&quot;-bash: toch: 未找到命令I touch test.txt[root@chenfanlinux ~]# touch test.txt || echo &quot;I touch test.txt&quot;注意:这里不会执行echo &quot;I touch test.txt&quot;</code></pre><p><strong>如果第一个命令执行成功,则执行第二个命令,否则执行第三个命令。</strong></p><pre><code>[root@chenfanlinux ~]# touch test.txt &amp;&amp;  echo &quot;我是第二个命令&quot; || echo &quot;我是第三个命令&quot;我是第二个命令[root@chenfanlinux ~]# tuch test.txt &amp;&amp;  echo &quot;我是第二个命令&quot; || echo &quot;我是第三个命令&quot;-bash: tuch: 未找到命令我是第三个命令</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是shell&quot;&gt;&lt;a href=&quot;#什么是shell&quot; class=&quot;headerlink&quot; title=&quot;什么是shell?&quot;&gt;&lt;/a&gt;什么是shell?&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;通常,替我们工作的是”硬件”,而控制硬件的是”内核”。用户利用”shell”控制着一些内核提供的”工具”,来控制硬件替我们工作。由于内核听不懂人类语言,所以shell从本质来说就是一个UI(用户界面)应用程序,让内核控制着硬件正确无误的工作，如图1-1 硬件-内核-shell 所示，可以清晰的看到他们的关系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-std.dprcdn.net/files/acc_582513/DDfPGJ&quot; alt=&quot;硬件-内核&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Bash-shell功能特性&quot;&gt;&lt;a href=&quot;#Bash-shell功能特性&quot; class=&quot;headerlink&quot; title=&quot;Bash shell功能特性&quot;&gt;&lt;/a&gt;Bash shell功能特性&lt;/h2&gt;&lt;h3 id=&quot;history命令记忆功能&quot;&gt;&lt;a href=&quot;#history命令记忆功能&quot; class=&quot;headerlink&quot; title=&quot;history命令记忆功能&quot;&gt;&lt;/a&gt;history命令记忆功能&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在Bash里面,我们只要在命令行按”上、下键”或者更强大的”Ctrl+r”,就可以找到之前输入的历史命令,这依赖于Bash的命令记录功能,记录的文件位于家目录下的.bash_history。登录shell后新执行的命令只会记录在缓存中,这些命令会在用户退出时追加到命令历史文件中,我们通过history命令可以查看历史命令.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;命令历史相关的环境变量:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HISTSIZE: 命令历史记录的条数&lt;/li&gt;
&lt;li&gt;HISTFILE: ~/.bash_history&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;命令历史调用相关的命令:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;调用历史中的命令:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;!#: 重复执行第#条指令&lt;/li&gt;
&lt;li&gt;!!: 重复上一条命令&lt;/li&gt;
&lt;li&gt;!string: 匹配以string开头的命令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;调用上一条命令的最后一个参数:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;!$&lt;/li&gt;
&lt;li&gt;ESC . （先按esc,释放然后按.）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Bash基础" scheme="http://www.chenfanlinux.org/categories/Bash%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Bash" scheme="http://www.chenfanlinux.org/tags/Bash/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门之基础概念与架构(一)</title>
    <link href="http://www.chenfanlinux.org/2017/12/28/Docker%E5%85%A5%E9%97%A8%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%9E%B6%E6%9E%84-%E4%B8%80/"/>
    <id>http://www.chenfanlinux.org/2017/12/28/Docker入门之基础概念与架构-一/</id>
    <published>2017-12-28T01:11:33.000Z</published>
    <updated>2018-01-11T07:23:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="what-什么是docker"><a href="#what-什么是docker" class="headerlink" title="what 什么是docker?"></a>what 什么是docker?</h2><p><a href="https://www.docker.com" target="_blank" rel="noopener">Docker</a> 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 <a href="https://zh.wikipedia.org/wiki/Cgroups" target="_blank" rel="noopener">cgroup</a>，<a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">namespace</a>，以及 <a href="https://en.wikipedia.org/wiki/Aufs" target="_blank" rel="noopener">AUFS</a> 类的 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">Union FS</a> 等技术，对进程进行封装隔离，属于 <a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization" target="_blank" rel="noopener">操作系统层面的虚拟化技术</a>。由于隔离的进程独立于宿主和其它的隔离的进程，在容器中运行的程序只能看到容器的内容和分配给该容器的设备,因此也称其为容器。最初实现是基于 <a href="https://linuxcontainers.org/lxc/introduction/" target="_blank" rel="noopener">LXC</a>，现在基于<a href="http://www.infoq.com/cn/articles/docker-standard-container-execution-engine-runc?utm_source=articles_about_RunC&amp;utm_medium=link&amp;utm_campaign=RunC" target="_blank" rel="noopener">runc</a>等机制。Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。</p><ul><li>Docker容器本质上是宿主机上的一个进程，Docker通过namespace实现了资源隔离。</li><li>Docker有六个命名空间：Mount(挂载)、UTS(主机名)、IPC(进程间通信)、PID(进程)、Network(网络)、User(用户)，为了隔离有问题的应用，运用Namespace将进程隔离，为进程或进程组创建已隔离的运行空间，为进程提供不同的命名空间视图；这样，每一个隔离出来的进程组，对外就表现为一个container。</li><li>Namespaces充当隔离的第一级，确保一个容器中运行一个进程而且不能看到或影响容器外的其它进程。</li><li>cgroups是LXC的重要组成部分，实现了资源的限制，通过写时复制机制copy-on-write实现了高效的文件操作。</li><li>UnionFS（文件系统）作为容器的构建块。为了支持Docker的轻量级以及速度快的特性，它创建了用户层</li></ul><h2 id="why-为什么使用docker？"><a href="#why-为什么使用docker？" class="headerlink" title="why 为什么使用docker？"></a>why 为什么使用docker？</h2><p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便,而且容器使软件具备了超强的可移植能力。</p><ul><li>容器技术与传统虚拟机虚拟化方式对比：</li></ul><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/vyEvvG" alt="传统虚拟机"></p><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/hEWM0Z" alt="Docker"></p><ul><li>容器技术与传统虚拟机性能对比：</li></ul><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/6RGWHJ" alt="性能对比"></p><a id="more"></a><p><strong>Docker给DevOps带来的好处</strong></p><ul><li><p>更快速的交付和部署<br>开发人员可以使用镜像快速的构建标准开发环境；开发完成后，测试和运维人员可以使用开发人员提供的docker镜像快速部署应用，可以避免开发和测试运维人员之间的环境差异导致的部署问题。</p></li><li><p>更高效的资源利用<br>Docker容器的运行不需要额外的虚拟化管理程序支持，它是内核级的虚拟化，在占用更少资源的情况实现更高的性能。</p></li><li><p>更方便的迁移和扩展<br>Docker容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、服务器等。这种兼容使得用户可以在不同的平台之间很方便的完成应用迁移。</p></li><li><p>更简单的更新管理<br>使用Dockerfile，只需要小小的配置修改，就可以替代以往大量的更新工作，并且所有修改都以增量方式进行分发和更新。</p></li></ul><h2 id="How-容器是如何工作的"><a href="#How-容器是如何工作的" class="headerlink" title="How 容器是如何工作的?"></a>How 容器是如何工作的?</h2><p>Docker有五大核心组件,可以快速浏览下面的Docker架构图来了解核心组件,了解他们如何协作。</p><p><strong>Docker 的核心组件包括：</strong></p><ul><li>Docker 客户端 - Client</li><li>Docker 服务器 - Docker daemon</li><li>Docker 镜像 - Image</li><li>Docker 仓库 - Registry</li><li>Docker 容器 - Container</li></ul><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/uLaYib" alt="Docker架构图"><br>Docker 采用的是 Client/Server 架构。客户端向服务器发送请求，服务器负责构建、运行和分发容器。客户端和服务器可以运行在同一个 Host 上，客户端也可以通过 socket 或 REST API 与远程的服务器通信。</p><h4 id="Docker-客户端"><a href="#Docker-客户端" class="headerlink" title="Docker 客户端"></a>Docker 客户端</h4><p>最常用的 Docker 客户端是 docker 命令。通过 docker 我们可以方便地在 Host 上构建和运行容器。docker 支持很多操作（子命令），后面会逐步用到。</p><pre><code>[root@my-k8s-master01 ~]# docker -vDocker version 1.12.6, build 85d7426/1.12.6</code></pre><p>除了 docker 命令行工具，用户也可以通过 REST API 与服务器通信</p><h4 id="Docker-服务器"><a href="#Docker-服务器" class="headerlink" title="Docker 服务器"></a>Docker 服务器</h4><p>Docker daemon 是服务器组件，以 Linux 后台服务的方式运行。</p><pre><code>[root@my-k8s-master01 ~]# systemctl status docker● docker.service - Docker Application Container Engine   Loaded: loaded (/usr/lib/systemd/system/docker.service; enabled; vendor preset: disabled)   Active: active (running) since 二 2017-12-05 15:57:51 CST; 1 months 3 days ago     Docs: http://docs.docker.com Main PID: 1527 (dockerd-current)</code></pre><p>Docker daemon 运行在 Docker host 上，负责创建、运行、监控容器，构建、存储镜像。<br>默认配置下，Docker daemon 只能响应来自本地 Host 的客户端请求。如果要允许远程客户端请求，需要在配置文件中打开 TCP 监听。</p><h4 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h4><p>可将 Docker 镜像看着只读模板，通过它可以创建 Docker 容器。<br>镜像有多种生成方法：</p><ul><li>可以从无到有开始创建镜像</li><li>也可以下载并使用别人创建好的现成的镜像</li><li>还可以在现有镜像上创建新的镜像</li></ul><p>我们可以将镜像的内容和创建步骤描述在一个文本文件中，这个文件被称作 Dockerfile，通过执行 docker build <docker-file> 命令可以构建出 Docker 镜像，后面我们会讨论。</docker-file></p><h4 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h4><p>Docker 容器就是 Docker 镜像的运行实例。</p><p>用户可以通过 CLI（docker）或是 API 启动、停止、移动或删除容器。可以这么认为，对于应用软件，镜像是软件生命周期的构建和打包阶段，而容器则是启动和运行阶段</p><h4 id="Docker-仓库"><a href="#Docker-仓库" class="headerlink" title="Docker 仓库"></a>Docker 仓库</h4><p>Registry 是存放 Docker 镜像的仓库，Registry 分私有和公有两种。</p><p>Docker Hub（<a href="https://hub.docker.com/）" target="_blank" rel="noopener">https://hub.docker.com/）</a> 是默认的 Registry，由 Docker 公司维护，上面有数以万计的镜像，用户可以自由下载和使用。</p><p>出于对速度或安全的考虑，用户也可以创建自己的私有 Registry。后面我们会学习如何搭建私有 Registry。</p><p>docker pull 命令可以从 Registry 下载镜像。<br>docker run 命令则是先下载镜像（如果本地没有），然后再启动容器。</p><h2 id="Centos7开始安装Docker"><a href="#Centos7开始安装Docker" class="headerlink" title="Centos7开始安装Docker"></a>Centos7开始安装Docker</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在Linux上安装Docker并配置加速器，Docker目前被分为两个版本：</p><ul><li>Community-Edition：社区版</li><li>Enterprise-Edition：企业版</li></ul><h4 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h4><p><strong>卸载旧版本的Docker服务</strong></p><pre><code>$ yum -y remove docker \docker-common \container-selinux \docker-selinux \docker-engine</code></pre><p><strong>安装yum-utils，它提供yum-config-manager实用程序</strong></p><pre><code>$ yum install -y yum-utils</code></pre><p><strong>添加Docker的CE存储库(官网)</strong></p><pre><code>$ yum-config-manager \    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo</code></pre><p><strong>添加Docker的CE存储库(国内)</strong></p><pre><code>$ yum-config-manager \    --add-repo \    http://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo</code></pre><p><strong>更新软件包的索引列表</strong></p><pre><code>$ yum makecache fast</code></pre><p><strong>安装最新版的Docker服务</strong></p><pre><code>yum install -y docker-ce</code></pre><p><strong>启动Docker服务</strong></p><pre><code>systemctl start docker</code></pre><p><strong>Docker服务随机自启</strong></p><pre><code>systemctl enable docker</code></pre><p><strong>卸载Docker服务</strong></p><p>   # 卸载软件包</p><pre><code>$ yum remove -y docker-ce</code></pre><p>卸载Docker后,/var/lib/docker/目录下会保留原Docker的镜像,网络,存储卷等文件. 如果需要全新安装Docker,需要删除/var/lib/docker/目录.</p><pre><code>$ rm -rf /var/lib/docker</code></pre><p><strong>查看docker版本信息</strong></p><p>   # 获取版本信息的简介</p><pre><code>$ docker -v</code></pre><p>   # 获取详细的版本信息</p><pre><code>$ docker version</code></pre><h4 id="配置Docker加速器"><a href="#配置Docker加速器" class="headerlink" title="配置Docker加速器"></a>配置Docker加速器</h4><ol><li><p>由于众所周知的原因(墙)，从Docker Hub难以高效地下载镜像，除了使用VPN或代理之外，<br>最为有效的方式就是使用Docker国内镜像；</p></li><li><p>DaoCloud为首个提供国内免费Docker Hub镜像的团体，可以使用DaoCloud团队提供的<br>Docker Hub Mirror服务代替Docker官网的Docker Hub；</p></li><li><p>官网：传送门，注册用户并登录；</p></li><li><p>登录以后，在自己管理界面点击加速器标签，根据弹出页面配置加速器；</p></li></ol><blockquote><p>Copy<br>该脚本可以将 –registry-mirror 加入到你的 Docker 配置文件 /etc/docker/daemon.json 中。适用于 Ubuntu14.04、Debian、CentOS6 、CentOS7、Fedora、Arch Linux、openSUSE Leap 42.1，其他版本可能有细微不同</p></blockquote><pre><code>curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://9fa458c0.m.daocloud.io</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;what-什么是docker&quot;&gt;&lt;a href=&quot;#what-什么是docker&quot; class=&quot;headerlink&quot; title=&quot;what 什么是docker?&quot;&gt;&lt;/a&gt;what 什么是docker?&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.docker.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Docker&lt;/a&gt; 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 &lt;a href=&quot;https://zh.wikipedia.org/wiki/Cgroups&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;cgroup&lt;/a&gt;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Linux_namespaces&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;namespace&lt;/a&gt;，以及 &lt;a href=&quot;https://en.wikipedia.org/wiki/Aufs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AUFS&lt;/a&gt; 类的 &lt;a href=&quot;https://en.wikipedia.org/wiki/Union_mount&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Union FS&lt;/a&gt; 等技术，对进程进行封装隔离，属于 &lt;a href=&quot;https://en.wikipedia.org/wiki/Operating-system-level_virtualization&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;操作系统层面的虚拟化技术&lt;/a&gt;。由于隔离的进程独立于宿主和其它的隔离的进程，在容器中运行的程序只能看到容器的内容和分配给该容器的设备,因此也称其为容器。最初实现是基于 &lt;a href=&quot;https://linuxcontainers.org/lxc/introduction/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LXC&lt;/a&gt;，现在基于&lt;a href=&quot;http://www.infoq.com/cn/articles/docker-standard-container-execution-engine-runc?utm_source=articles_about_RunC&amp;amp;utm_medium=link&amp;amp;utm_campaign=RunC&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;runc&lt;/a&gt;等机制。Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Docker容器本质上是宿主机上的一个进程，Docker通过namespace实现了资源隔离。&lt;/li&gt;
&lt;li&gt;Docker有六个命名空间：Mount(挂载)、UTS(主机名)、IPC(进程间通信)、PID(进程)、Network(网络)、User(用户)，为了隔离有问题的应用，运用Namespace将进程隔离，为进程或进程组创建已隔离的运行空间，为进程提供不同的命名空间视图；这样，每一个隔离出来的进程组，对外就表现为一个container。&lt;/li&gt;
&lt;li&gt;Namespaces充当隔离的第一级，确保一个容器中运行一个进程而且不能看到或影响容器外的其它进程。&lt;/li&gt;
&lt;li&gt;cgroups是LXC的重要组成部分，实现了资源的限制，通过写时复制机制copy-on-write实现了高效的文件操作。&lt;/li&gt;
&lt;li&gt;UnionFS（文件系统）作为容器的构建块。为了支持Docker的轻量级以及速度快的特性，它创建了用户层&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;why-为什么使用docker？&quot;&gt;&lt;a href=&quot;#why-为什么使用docker？&quot; class=&quot;headerlink&quot; title=&quot;why 为什么使用docker？&quot;&gt;&lt;/a&gt;why 为什么使用docker？&lt;/h2&gt;&lt;p&gt;传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便,而且容器使软件具备了超强的可移植能力。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容器技术与传统虚拟机虚拟化方式对比：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-std.dprcdn.net/files/acc_582513/vyEvvG&quot; alt=&quot;传统虚拟机&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-std.dprcdn.net/files/acc_582513/hEWM0Z&quot; alt=&quot;Docker&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容器技术与传统虚拟机性能对比：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-std.dprcdn.net/files/acc_582513/6RGWHJ&quot; alt=&quot;性能对比&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Docker系列" scheme="http://www.chenfanlinux.org/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Docker" scheme="http://www.chenfanlinux.org/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>编辑器之神-Vim</title>
    <link href="http://www.chenfanlinux.org/2017/12/24/%E7%BC%96%E8%BE%91%E5%99%A8%E4%B9%8B%E7%A5%9E-vim/"/>
    <id>http://www.chenfanlinux.org/2017/12/24/编辑器之神-vim/</id>
    <published>2017-12-24T02:24:27.000Z</published>
    <updated>2018-01-11T06:55:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vim简介"><a href="#vim简介" class="headerlink" title="vim简介"></a>vim简介</h3><p>vi是“Visual interface”的简称，它不像Word或WPS那样可以对字体、格式、段落等其他属性进行编排，它只是一个文本编辑程序。 vi没有菜单，只有命令，且命令繁多。vim(VIM - Vi IMproved)是vi的加强版本，在vi的基础上增加了如下功能。</p><blockquote><ul><li>增加了多级撤销</li><li>多窗口操作</li><li>提高了稳定性，减少了崩溃以及崩溃后也可以恢复</li><li>关键字自动补全以及上下文相关的补全</li></ul></blockquote><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/bEfzpN" alt="vim键盘图"></p><h3 id="vim的工作模式"><a href="#vim的工作模式" class="headerlink" title="vim的工作模式"></a>vim的工作模式</h3><p>Vi有三种基本工作模式：</p><ul><li>命令模式（普通模式）</li><li>文本输入模式</li><li>末行模式(底线命令模式)</li></ul><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/SDuEA" alt="vim工作模式"></p><h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><ul><li><strong>单个字符移动</strong></li></ul><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">移动方向</th></tr></thead><tbody><tr><td style="text-align:center">h</td><td style="text-align:center">向左移动</td></tr><tr><td style="text-align:center">l</td><td style="text-align:center">向右移动</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center">向下移动</td></tr><tr><td style="text-align:center">k</td><td style="text-align:center">向上移动</td></tr></tbody></table><ul><li><strong>单词移动</strong></li></ul><table><thead><tr><th style="text-align:center">单词</th><th style="text-align:center">移动方向</th></tr></thead><tbody><tr><td style="text-align:center">w</td><td style="text-align:center">将光标移动到下一个单词开头</td></tr><tr><td style="text-align:center">b</td><td style="text-align:center">将光标移动到前一个单词的开头</td></tr><tr><td style="text-align:center">e</td><td style="text-align:center">将光标移动到下一个单词的词末</td></tr><tr><td style="text-align:center">E</td><td style="text-align:center">移动到单词的结尾(忽略标点符号)</td></tr><tr><td style="text-align:center">ge</td><td style="text-align:center">将光标移动到前一个单词的词末</td></tr></tbody></table><ul><li><strong>行移动</strong></li></ul><table><thead><tr><th style="text-align:center">单词</th><th style="text-align:center">移动方向</th></tr></thead><tbody><tr><td style="text-align:center">$</td><td style="text-align:center">将光标移动到当前行的行尾</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">将光标移动到当前行的行首</td></tr><tr><td style="text-align:center">fx</td><td style="text-align:center">将光标移动到当前行的第一个字符x上</td></tr><tr><td style="text-align:center">3fx</td><td style="text-align:center">将光标移动到航前行的第3个字符x上</td></tr><tr><td style="text-align:center">%</td><td style="text-align:center">用于符号间的移动，它会在一对()、[]、{}之间跳跃</td></tr></tbody></table><a id="more"></a><ul><li><strong>文本块移动</strong></li></ul><table><thead><tr><th style="text-align:center">单词</th><th style="text-align:center">移动方向</th></tr></thead><tbody><tr><td style="text-align:center">(</td><td style="text-align:center">移到当前句子的开头</td></tr><tr><td style="text-align:center">)</td><td style="text-align:center">移到下一个句子的开头</td></tr><tr><td style="text-align:center">{</td><td style="text-align:center">移到当前一段的开头</td></tr><tr><td style="text-align:center">}</td><td style="text-align:center">移到下一段的开头</td></tr><tr><td style="text-align:center">ge</td><td style="text-align:center">将光标移动到前一个单词的词末</td></tr></tbody></table><ul><li><strong>在屏幕中移动</strong></li></ul><table><thead><tr><th style="text-align:center">单词</th><th style="text-align:center">移动方向</th></tr></thead><tbody><tr><td style="text-align:center">H</td><td style="text-align:center">移动到当前屏幕的开头</td></tr><tr><td style="text-align:center">M</td><td style="text-align:center">移动到当前屏幕中间</td></tr><tr><td style="text-align:center">L</td><td style="text-align:center">移动当前屏幕的末尾</td></tr><tr><td style="text-align:center">gg</td><td style="text-align:center">移动到文件开头</td></tr><tr><td style="text-align:center">xG</td><td style="text-align:center">跳转到指定的第x行，G移动到文件按末尾</td></tr></tbody></table><h3 id="滚屏与跳转"><a href="#滚屏与跳转" class="headerlink" title="滚屏与跳转"></a>滚屏与跳转</h3><ul><li><strong>半屏滚动</strong></li></ul><table><thead><tr><th style="text-align:center">快捷键</th><th style="text-align:center">方向</th></tr></thead><tbody><tr><td style="text-align:center">ctrl+u</td><td style="text-align:center">向上滚动</td></tr><tr><td style="text-align:center">ctrl+d</td><td style="text-align:center">向下滚动</td></tr></tbody></table><ul><li><strong>全屏滚动</strong></li></ul><table><thead><tr><th style="text-align:center">快捷键</th><th style="text-align:center">方向</th></tr></thead><tbody><tr><td style="text-align:center">ctrl+b</td><td style="text-align:center">向上滚动</td></tr><tr><td style="text-align:center">ctrl+f</td><td style="text-align:center">向下滚动</td></tr></tbody></table><ul><li><strong>定位光标的位置</strong></li></ul><table><thead><tr><th style="text-align:center">快捷键</th><th style="text-align:center">方向</th></tr></thead><tbody><tr><td style="text-align:center">zz</td><td style="text-align:center">将光标置于屏幕的中间</td></tr><tr><td style="text-align:center">zt</td><td style="text-align:center">将光标移动到屏幕的顶部</td></tr><tr><td style="text-align:center">zb</td><td style="text-align:center">将光标移动到屏幕的底部</td></tr></tbody></table><h3 id="文本插入操作"><a href="#文本插入操作" class="headerlink" title="文本插入操作"></a>文本插入操作</h3><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">i</td><td style="text-align:center">在当前光标的前面插入字符</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">在当前光标的后面追加字符</td></tr><tr><td style="text-align:center">o</td><td style="text-align:center">在当前光标的下一行行首插入字符</td></tr><tr><td style="text-align:center">O</td><td style="text-align:center">在当前光标的上一行行首插入字符</td></tr><tr><td style="text-align:center">I</td><td style="text-align:center">在一行的开头添加文本</td></tr><tr><td style="text-align:center">A</td><td style="text-align:center">在一行的结尾处添加文本</td></tr><tr><td style="text-align:center">u</td><td style="text-align:center">撤销修改</td></tr><tr><td style="text-align:center">ctrl+r</td><td style="text-align:center">反撤销修改</td></tr></tbody></table><h3 id="文本删除"><a href="#文本删除" class="headerlink" title="文本删除"></a>文本删除</h3><ul><li><strong>字符删除</strong></li></ul><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">x</td><td style="text-align:center">删除当前光标所在处的字符</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">删除当前光标左边的字符</td></tr></tbody></table><ul><li><strong>单词删除</strong></li></ul><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">dw</td><td style="text-align:center">删除一个单词(从光标处到空格)</td></tr><tr><td style="text-align:center">d$</td><td style="text-align:center">删除从光标到一行末尾的整个文本</td></tr><tr><td style="text-align:center">d0</td><td style="text-align:center">删除从光标到一行开头的所有单词</td></tr></tbody></table><ul><li><strong>行删除</strong></li></ul><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">dd</td><td style="text-align:center">删除当前光标处的一整行=D</td></tr><tr><td style="text-align:center">5dd</td><td style="text-align:center">删除从光标到文本开头</td></tr><tr><td style="text-align:center">dG</td><td style="text-align:center">删除从光标到文本结尾</td></tr></tbody></table><h3 id="文本复制、剪切与粘贴"><a href="#文本复制、剪切与粘贴" class="headerlink" title="文本复制、剪切与粘贴"></a>文本复制、剪切与粘贴</h3><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">y</td><td style="text-align:center">复制,p:粘贴</td></tr><tr><td style="text-align:center">yw</td><td style="text-align:center">复制一个单词</td></tr><tr><td style="text-align:center">y2w</td><td style="text-align:center">复制2个单词</td></tr><tr><td style="text-align:center">y$</td><td style="text-align:center">复制从当前光标到行结尾的所有单词</td></tr><tr><td style="text-align:center">y0</td><td style="text-align:center">复制从当前光标到行首的所有单词</td></tr><tr><td style="text-align:center">&gt;&gt;</td><td style="text-align:center">文本行右移</td></tr><tr><td style="text-align:center">&lt;&lt;</td><td style="text-align:center">文本行左移</td></tr><tr><td style="text-align:center">.</td><td style="text-align:center">重复命令</td></tr></tbody></table><p><strong>可视模式</strong></p><ul><li>v: 按字符移动,选中文本    </li><li>V: 按行移动,选中文本可视模式可以配合 d, y, &gt;&gt;, &lt;&lt; 实现对文本块的删除,复制,左右移动 </li><li>Ctrl+v: 列操作模式  <ul><li>删除某一列内容：先ctrl+v,然后通过上下左右键,选择需要操作的文本，键入d,则可以删除选中的列内容。</li><li>插入操作: 先ctrl+v,然后上下左右键，选择需要操作的列,键入shift+i(在列前面插入)或shift+a(在列后面插入)指定的内容；接下来按Esc才能看到插入生效,再键入Esc,回到命令行模式,保存退出。</li></ul></li></ul><h3 id="查找命令与替换"><a href="#查找命令与替换" class="headerlink" title="查找命令与替换"></a>查找命令与替换</h3><ul><li><strong>字符串查找</strong></li></ul><table><thead><tr><th style="text-align:center">表达式</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">/string</td><td style="text-align:center">正向查找</td></tr><tr><td style="text-align:center">?string</td><td style="text-align:center">反向查找</td></tr></tbody></table><ul><li><strong>字符串替换</strong></li></ul><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">:s/old/new</td><td style="text-align:center">将当前行的第一个字符串old替换为new</td></tr><tr><td style="text-align:center">:s/old/new/g</td><td style="text-align:center">将当前行的所有字符串old替换为new</td></tr><tr><td style="text-align:center">:90s/old/new/g</td><td style="text-align:center">将指定行的所有字符串old替换为new</td></tr><tr><td style="text-align:center">:90,93s/old/new/g</td><td style="text-align:center">将90到93行的所有字符串old替换为new</td></tr><tr><td style="text-align:center">:%s/old/new/g</td><td style="text-align:center">将文本中所有的字符串old替换为new</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;vim简介&quot;&gt;&lt;a href=&quot;#vim简介&quot; class=&quot;headerlink&quot; title=&quot;vim简介&quot;&gt;&lt;/a&gt;vim简介&lt;/h3&gt;&lt;p&gt;vi是“Visual interface”的简称，它不像Word或WPS那样可以对字体、格式、段落等其他属性进行编排，它只是一个文本编辑程序。 vi没有菜单，只有命令，且命令繁多。vim(VIM - Vi IMproved)是vi的加强版本，在vi的基础上增加了如下功能。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;增加了多级撤销&lt;/li&gt;
&lt;li&gt;多窗口操作&lt;/li&gt;
&lt;li&gt;提高了稳定性，减少了崩溃以及崩溃后也可以恢复&lt;/li&gt;
&lt;li&gt;关键字自动补全以及上下文相关的补全&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-std.dprcdn.net/files/acc_582513/bEfzpN&quot; alt=&quot;vim键盘图&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;vim的工作模式&quot;&gt;&lt;a href=&quot;#vim的工作模式&quot; class=&quot;headerlink&quot; title=&quot;vim的工作模式&quot;&gt;&lt;/a&gt;vim的工作模式&lt;/h3&gt;&lt;p&gt;Vi有三种基本工作模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命令模式（普通模式）&lt;/li&gt;
&lt;li&gt;文本输入模式&lt;/li&gt;
&lt;li&gt;末行模式(底线命令模式)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-std.dprcdn.net/files/acc_582513/SDuEA&quot; alt=&quot;vim工作模式&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;光标移动&quot;&gt;&lt;a href=&quot;#光标移动&quot; class=&quot;headerlink&quot; title=&quot;光标移动&quot;&gt;&lt;/a&gt;光标移动&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;单个字符移动&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;字符&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;移动方向&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;h&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;向左移动&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;l&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;向右移动&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;j&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;向下移动&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;k&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;向上移动&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;单词移动&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;单词&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;移动方向&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;w&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将光标移动到下一个单词开头&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;b&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将光标移动到前一个单词的开头&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;e&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将光标移动到下一个单词的词末&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;E&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;移动到单词的结尾(忽略标点符号)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;ge&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将光标移动到前一个单词的词末&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;行移动&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;单词&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;移动方向&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将光标移动到当前行的行尾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将光标移动到当前行的行首&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;fx&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将光标移动到当前行的第一个字符x上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;3fx&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将光标移动到航前行的第3个字符x上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;%&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;用于符号间的移动，它会在一对()、[]、{}之间跳跃&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="Tools利器" scheme="http://www.chenfanlinux.org/categories/Tools%E5%88%A9%E5%99%A8/"/>
    
    
      <category term="Vim" scheme="http://www.chenfanlinux.org/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>Python基础之流程控制</title>
    <link href="http://www.chenfanlinux.org/2017/12/19/python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>http://www.chenfanlinux.org/2017/12/19/python基础之流程控制/</id>
    <published>2017-12-19T14:31:23.000Z</published>
    <updated>2018-01-11T07:04:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><blockquote><p>if语句是用来检查一个条件：如果条件为真(true)，我们运行一个语句块（你为if块），否则(else)，我们执行另一个语句块（称为else块），else子语句是可选的。</p></blockquote><h3 id="单条件"><a href="#单条件" class="headerlink" title="单条件"></a>单条件</h3><p>示例：如果num变量大于1，那么就输出num大，否则就输出num小，num值为5</p><p><strong>代码：</strong></p><pre><code>#!/usr/bin/env python# -*- coding:utf-8 -*-num = 5if num &gt; 1:print(&quot;num大&quot;)else:print(&quot;num小&quot;)</code></pre><p><strong>结果：</strong></p><pre><code>python num.pynum大</code></pre><h3 id="多条件"><a href="#多条件" class="headerlink" title="多条件"></a>多条件</h3><p>示例：请输入一个整数，如果输入的为负数，负数转变为0,输出print(‘Negative changed to zero’);如果输入的为0，则输出Zero;如果输入的为1，则输出Single；输入其他则，输出More。</p><p><strong>代码：</strong></p><pre><code>#__author: Administrator#date: 2017/12/19x = int(input(&apos;Please enter an integer: &apos;))if x &lt; 0:    x = 0    print(&apos;Negative changed to zero&apos;)elif x == 0:    print(&apos;Zero&apos;)elif x == 1:    print(&apos;Single&apos;)else:    print(&apos;More&apos;)</code></pre><p><strong>结果：</strong></p><pre><code>Please enter an integer: -1Negative changed to zero</code></pre><a id="more"></a><h3 id="三元运算"><a href="#三元运算" class="headerlink" title="三元运算"></a>三元运算</h3><blockquote><p>如果条件成立，那么就把值1赋值给var，如果条件不成立，就把值2赋值给var</p></blockquote><p><strong>语法：</strong></p><p><code>var = 值1 if 条件 else 值2</code></p><p><strong>示例：</strong></p><pre><code>&gt;&gt;&gt; var = &quot;True&quot; if 1 == 1 else &quot;False&quot;&gt;&gt;&gt; var&apos;True&apos;</code></pre><h2 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h2><h3 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h3><blockquote><p>while 是Python中的循环语句. 事实它上是一个条件循环语句. 与 if 声明相比, 如果 if 后的条件为真, 就会执行一次相应的代码块. 而 while 中的代码块会一直循环执行, 直到循环条件不再为真.</p></blockquote><p><strong>语法：</strong></p><pre><code>while expression:       suite_to_repeat</code></pre><p>while 循环的suit_to_repeat子句会一直循环执行, 直到 expression 值为布尔假. 这种 类型的循环机制常常用在计数循环中。</p><p><strong>代码：</strong></p><pre><code>#__author: Administrator#date: 2017/12/19count = 0while (count &lt; 5):    print(&apos;The index is: &apos;,count)    count += 1</code></pre><p><strong>结果：</strong></p><pre><code>The index is:  0The index is:  1The index is:  2The index is:  3The index is:  4</code></pre><h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><p>你必须小心地使用 while 循环, 因为有可能它的条件永远不会为布尔假. 这样一来循环就永远不会结束. 这些”无限”的循环不一定是坏事, 许多通讯服务器的客户端/服务器系统就是通过它来工作的. 这取决于循环是否需要一直执行下去, 如果不是, 那么这个循环是否会结束; 也就是说, 条件表达式会不会计算后得到布尔假?</p><pre><code>while True:    handle, indata = wait_for_client_connect()    outdata = process_request(indata)    ack_result_to_client(handle, outdata)</code></pre><p>例如上边的代码就是故意被设置为无限循环的，因为 True 无论如何都不会变成 False. 这是因为服务器代码是用来等待客户端(可能通过网络)来连接的. 这些客户端向服务器发送请求, 服务器处理请求.<br>请求被处理后, 服务器将向客户端返回数据, 而此时客户端可能断开连接或是发送另一个请求. 对于服务器而言它已经完成了对这个客户端的任务, 它会返回最外层循环等待下一个连接.</p><h3 id="while使用-else-语句"><a href="#while使用-else-语句" class="headerlink" title="while使用 else 语句"></a>while使用 else 语句</h3><p>在 python 中，for … else 表示这样的意思，for 中的语句和普通的没有区别，else 中的语句会在循环正常执行完（即 for 不是通过 break 跳出而中断的）的情况下执行.while … else 也是一样,其在循环条件不满足的时候,会开始执行else语句,通过break中断的情况下,不会执行else.</p><p><strong>代码：</strong></p><pre><code>#__author: Administrator#date: 2017/12/19count = 0while (count &lt; 5):    print(count,&apos;is less than 5&apos;)    count += 1else:    print(count,&apos;is not less than 5&apos;)</code></pre><p><strong>结果：</strong></p><pre><code>0 is less than 51 is less than 52 is less than 53 is less than 54 is less than 55 is not less than 5</code></pre><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><h3 id="基础用法-1"><a href="#基础用法-1" class="headerlink" title="基础用法"></a>基础用法</h3><blockquote><p>Python 提供给我们的另一个循环机制就是 for 语句, 它提供了 Python 中最强大的循环结构. 它可以遍历序列成员(链表或字符串). for循环会访问一个可迭代对象(例如序列或是迭代器)中的所有元素, 并在所有条目都处理过后结束循环.</p></blockquote><p><strong>语法：</strong></p><pre><code>for iter_var in iterable:        suite_to_repeat</code></pre><p>每次循环, iter_var 迭代变量被设置为可迭代对象(序列, 迭代器, 或者是其他支持迭代的对象)的当前元素, 提供给 suite_to_repeat 语句块使用.</p><p><strong>代码：</strong></p><pre><code>#__author: Administrator#date: 2017/12/19words = [&apos;cat&apos;, &apos;window&apos;, &apos;defenestrate&apos;]for w in words:    print(w,len(w))</code></pre><p><strong>结果：</strong></p><pre><code>cat 3window 6defenestrate 12</code></pre><h3 id="for使用-else-语句"><a href="#for使用-else-语句" class="headerlink" title="for使用 else 语句"></a>for使用 else 语句</h3><blockquote><p>for 循环也可以有 else 用于循环后处理(post-processing). 它和 while 循环中的 else 处理方式相同. 只要 for 循环是正常结束的(不是通过 break ), else 子句就会执行.</p></blockquote><p>代码：</p><pre><code>#__author: Administrator#date: 2017/12/19s = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;]found = Falsefor c in s:    if c.find(&apos;c&apos;) != -1:        found = True        print(&quot;发现c&quot;)        breakif not found:    print(&quot;未发现c&quot;)</code></pre><p>等价于下面的代码:</p><pre><code>#__author: Administrator#date: 2017/12/19s = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;]for c in s:    if c.find(&apos;c&apos;) != -1:        print(&quot;发现c&quot;)        breakelse:    print(&quot;未发现c&quot;)</code></pre><h2 id="break和continue语句"><a href="#break和continue语句" class="headerlink" title="break和continue语句"></a>break和continue语句</h2><h3 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h3><blockquote><p>Python 中的 break 语句可以结束当前循环然后跳转到下条语句, 类似 C 中的传统 break . 常用在当某个外部条件被触发(一般通过 if 语句检查), 需要立即从循环中退出时. break 语句可以用在 while 和 for 循环中.</p></blockquote><p><strong>代码：</strong></p><pre><code>&gt;&gt;&gt; for i in &quot;hello&quot;:...     if i ==&apos;l&apos;:...         break...     print(i)...</code></pre><p><strong>结果：</strong></p><pre><code>he</code></pre><h3 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h3><blockquote><p>不管是 Python、 C、Java 还是其它任何支持 continue 语句的结构化语言中, 一些初学者有这样的一个误解: continue 语句”立即启动循环的下一次迭代”. 实际上, 当遇到 continue 语句时, 程序会终止当前循环, 并忽略剩余的语句, 然后回到循环的顶端. 在开始下一次迭代前, 如果是条件循环, 我们将验证条件表达式. 如果是迭代循环, 我们将验证是否还有元素可以迭代. 只有在验证成功的情况下, 我们才会开始下一次迭代.</p></blockquote><p>Python 里的 continue 语句和其他高级语言中的传统 continue 并没有什么不同. 它可以被用在 while 和 for 循环里. while 循环是条件性的, 而 for 循环是迭代的, 所以 continue 在开始下一次循环前要满足一些先决条件, 否则循环会正常结束.</p><p><strong>代码：</strong></p><pre><code>&gt;&gt;&gt; for i in &quot;hello&quot;:...     if i ==&apos;l&apos;:...         continue...     print(i)...</code></pre><p><strong>结果：</strong></p><pre><code>heo</code></pre><h2 id="总结循环中的else语句"><a href="#总结循环中的else语句" class="headerlink" title="总结循环中的else语句"></a>总结循环中的else语句</h2><blockquote><p>循环一般可以分为两种，for循环或while循环，上文都有明确的介绍。循环可以有一个 else 子句；它在循环迭代完整个列表（对于 for ）或执行条件为 false （对于 while ）不被break中止的情况下执行，循环被 break 中止的情况下不会执行else语句。</p></blockquote><p><strong>示例：</strong> 在数字2-9中搜索素数</p><p><strong>代码：</strong></p><pre><code>#__author: Administrator#date: 2017/12/19&apos;&apos;&apos;在数字2-9之间搜索素数素数的定义:除了1和它自身外，不能被其他自然数整除的数叫做质数.n 被除数x 除数&apos;&apos;&apos;for n in range(2,10):    for x in range(2,n):        if n % x == 0:            print(n,&apos;equals&apos;,x,&apos;*&apos;,n//x)            break    else:        print(n,&apos;is a prime number&apos;)</code></pre><p><strong>结果：</strong></p><pre><code>2 is a prime number3 is a prime number4 equals 2 * 25 is a prime number6 equals 2 * 37 is a prime number8 equals 2 * 49 equals 3 * 3</code></pre><h2 id="range-函数"><a href="#range-函数" class="headerlink" title="range() 函数"></a>range() 函数</h2><blockquote><p>如果你需要一个数值序列，内置函数 range() 会很方便，它生成一个等差级数链表（不包含结束的end值）</p></blockquote><p><strong>语法：</strong></p><p><code>range(start, end, step=1)</code></p><pre><code>&gt;&gt;&gt; for i in range(5):...     print(i)...01234&gt;&gt;&gt; list(range(2,2))[]range(0, 10, 3)   0, 3, 6, 9range(-10, -100, -30)  -10, -40, -70</code></pre><p>range(10) 生成了一个包含 10 个值的链表，它用链表的索引值填充了这个长度为 10 的列表，所生成的链表中不包括范围中的结束值。也可以让 range() 操作从另一个数值开始，不指定时为0,或者可以指定一个不同的步进值（甚至是负数，有时这也被称为 “步长”）</p><p><strong>如果你只是打印一个序列的话会发生奇怪的事情</strong></p><pre><code>&gt;&gt;&gt; print(range(10))range(0, 10)</code></pre><p>在不同方面 range() 函数返回的对象表现为它是一个列表，但事实上它并不是。当你迭代它时，它是一个能够像期望的序列返回连续项的对象；但为了节省空间，它并不真正构造列表。</p><p>我们称此类对象是 可迭代的，即适合作为那些期望从某些东西中获得连续项直到结束的函数或结构的一个目标（参数）。我们已经见过的 for 语句就是这样一个迭代器。list() 函数是另外一个（ 迭代器 ），它从可迭代（对象）中创建列表:</p><pre><code>&gt;&gt;&gt; list(range(5))[0, 1, 2, 3, 4]</code></pre><p>稍后我们会看到更多返回可迭代（对象）和以可迭代（对象）作为参数的函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;if语句&quot;&gt;&lt;a href=&quot;#if语句&quot; class=&quot;headerlink&quot; title=&quot;if语句&quot;&gt;&lt;/a&gt;if语句&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;if语句是用来检查一个条件：如果条件为真(true)，我们运行一个语句块（你为if块），否则(else)，我们执行另一个语句块（称为else块），else子语句是可选的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;单条件&quot;&gt;&lt;a href=&quot;#单条件&quot; class=&quot;headerlink&quot; title=&quot;单条件&quot;&gt;&lt;/a&gt;单条件&lt;/h3&gt;&lt;p&gt;示例：如果num变量大于1，那么就输出num大，否则就输出num小，num值为5&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding:utf-8 -*-
num = 5
if num &amp;gt; 1:
print(&amp;quot;num大&amp;quot;)
else:
print(&amp;quot;num小&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python num.py
num大
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;多条件&quot;&gt;&lt;a href=&quot;#多条件&quot; class=&quot;headerlink&quot; title=&quot;多条件&quot;&gt;&lt;/a&gt;多条件&lt;/h3&gt;&lt;p&gt;示例：请输入一个整数，如果输入的为负数，负数转变为0,输出print(‘Negative changed to zero’);如果输入的为0，则输出Zero;如果输入的为1，则输出Single；输入其他则，输出More。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#__author: Administrator
#date: 2017/12/19
x = int(input(&amp;apos;Please enter an integer: &amp;apos;))
if x &amp;lt; 0:
    x = 0
    print(&amp;apos;Negative changed to zero&amp;apos;)
elif x == 0:
    print(&amp;apos;Zero&amp;apos;)
elif x == 1:
    print(&amp;apos;Single&amp;apos;)
else:
    print(&amp;apos;More&amp;apos;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Please enter an integer: -1
Negative changed to zero
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Python基础知识" scheme="http://www.chenfanlinux.org/categories/Python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Python" scheme="http://www.chenfanlinux.org/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Zabbx基础安装</title>
    <link href="http://www.chenfanlinux.org/2017/12/11/zabbx%E5%9F%BA%E7%A1%80%E5%AE%89%E8%A3%85/"/>
    <id>http://www.chenfanlinux.org/2017/12/11/zabbx基础安装/</id>
    <published>2017-12-11T10:07:48.000Z</published>
    <updated>2018-01-11T06:54:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、安装部署zabbix-3-4"><a href="#一、安装部署zabbix-3-4" class="headerlink" title="一、安装部署zabbix 3.4"></a>一、安装部署zabbix 3.4</h1><p><a href="https://baike.baidu.com/item/zabbix/6780368?fr=aladdin" target="_blank" rel="noopener">Zabbix</a> 是由 Alexei Vladishev 开发的一种网络监视、管理系统，基于 Server-Client 架构。可用于监视各种网络服务、服务器和网络机器等状态。</p><h2 id="1-zabbix基础说明"><a href="#1-zabbix基础说明" class="headerlink" title="1.zabbix基础说明"></a>1.zabbix基础说明</h2><h3 id="1-1-zabbix使用说明"><a href="#1-1-zabbix使用说明" class="headerlink" title="1.1  zabbix使用说明"></a>1.1  zabbix使用说明</h3><ul><li><p><a href="https://www.zabbix.com/documentation/3.4/zh/manual" target="_blank" rel="noopener">zabbix3.4软件中文使用手册</a></p></li><li><p><a href="http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/" target="_blank" rel="noopener">zabbix3.4版本安装包路径</a></p></li></ul><h3 id="1-2-zabbix-3-4版本说明"><a href="#1-2-zabbix-3-4版本说明" class="headerlink" title="1.2 zabbix 3.4版本说明"></a>1.2 zabbix 3.4版本说明</h3><p>Zabbix Server端安装的软件：</p><ul><li>zabbix-server-mysql</li><li>zabbix-get</li><li>mysql</li><li>zabbix-web</li><li>zabbix-web-mysql</li></ul><p>Zabbix Clinet 端安装的软件</p><ul><li>zabbix-agent</li><li>zabbix-sender</li></ul><h2 id="2-zabbix系统环境配置"><a href="#2-zabbix系统环境配置" class="headerlink" title="2.zabbix系统环境配置"></a>2.zabbix系统环境配置</h2><h3 id="2-1-系统环境"><a href="#2-1-系统环境" class="headerlink" title="2.1 系统环境"></a>2.1 系统环境</h3><pre><code># cat /etc/redhat-releaseCentOS Linux release 7.4.1708 (Core)</code></pre><h3 id="2-2-永久修改主机名"><a href="#2-2-永久修改主机名" class="headerlink" title="2.2 永久修改主机名"></a>2.2 永久修改主机名</h3><pre><code># hostnamectl --static set-hostname zabbix-server</code></pre><h3 id="2-3-关闭防火墙及selinux"><a href="#2-3-关闭防火墙及selinux" class="headerlink" title="2.3 关闭防火墙及selinux"></a>2.3 关闭防火墙及selinux</h3><pre><code># systemctl stop firewalld.service# systemctl daemon-reload# systemctl disable firewalld.service# sed -i &apos;s/SELINUX=enforcing/SELINUX=disabled/g&apos; /etc/selinux/config# grep SELINUX=disabled /etc/selinux/config# setenforce 0# getenforce  Disabled</code></pre><a id="more"></a><h2 id="3-数据库的安装与配置"><a href="#3-数据库的安装与配置" class="headerlink" title="3.数据库的安装与配置"></a>3.数据库的安装与配置</h2><h3 id="3-1-MariaDB概述"><a href="#3-1-MariaDB概述" class="headerlink" title="3.1 MariaDB概述"></a>3.1 MariaDB概述</h3><p>MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可。<br>开发这个分支的原因是：甲骨文公司收购了MySQL后，有将MySQL闭源的潜在风险，因此社区采用分支的方式来避开这个风险。MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。</p><h3 id="3-2-安装mariadb"><a href="#3-2-安装mariadb" class="headerlink" title="3.2 安装mariadb"></a>3.2 安装mariadb</h3><pre><code># yum install mariadb-server mariadb -y# rpm -qa |grep mariamariadb-5.5.56-2.el7.x86_64mariadb-server-5.5.56-2.el7.x86_64mariadb-libs-5.5.56-2.el7.x86_64</code></pre><h3 id="3-3-配置数据库服务"><a href="#3-3-配置数据库服务" class="headerlink" title="3.3 配置数据库服务"></a>3.3 配置数据库服务</h3><pre><code># vim /etc/my.cnf添加如下两行：innodb_file_per_table=onskip_name_resolve=on</code></pre><h3 id="3-4-启动mariadb数据库并设置开机自启动"><a href="#3-4-启动mariadb数据库并设置开机自启动" class="headerlink" title="3.4 启动mariadb数据库并设置开机自启动"></a>3.4 启动mariadb数据库并设置开机自启动</h3><pre><code># systemctl start mariadb# systemctl enable mariadb</code></pre><h3 id="3-5-设置mariadb数据库的安全配置"><a href="#3-5-设置mariadb数据库的安全配置" class="headerlink" title="3.5 设置mariadb数据库的安全配置"></a>3.5 设置mariadb数据库的安全配置</h3><pre><code># mysql_secure_installation  //根据需求设置密码password:test# mysql -uroot -ptest //登录mysql</code></pre><h3 id="3-6-创建数据库zabbix数据库并授权用户"><a href="#3-6-创建数据库zabbix数据库并授权用户" class="headerlink" title="3.6 创建数据库zabbix数据库并授权用户"></a>3.6 创建数据库zabbix数据库并授权用户</h3><p>创建zabbix数据库，并创建zbuser用户具有库的访问权限。</p><pre><code>&gt; CREATE DATABASE  zabbix  DEFAULT CHARACTER SET utf8 COLLATE utf8_bin;&gt; GRANT ALL PRIVILEGES ON zabbix.* TO zbuser@localhost IDENTIFIED BY &apos;test&apos;;&gt; FLUSH PRIVILEGES ;# mysql -uzbuser -ptest zabbix //登录测试</code></pre><h2 id="4-安装配置zabbix-3-4"><a href="#4-安装配置zabbix-3-4" class="headerlink" title="4.安装配置zabbix.3.4"></a>4.安装配置zabbix.3.4</h2><h3 id="4-1-zabbix相关软件包的安装"><a href="#4-1-zabbix相关软件包的安装" class="headerlink" title="4.1 zabbix相关软件包的安装"></a>4.1 zabbix相关软件包的安装</h3><h4 id="4-1-1-安装zabbix相关的yum源"><a href="#4-1-1-安装zabbix相关的yum源" class="headerlink" title="4.1.1 安装zabbix相关的yum源"></a>4.1.1 安装zabbix相关的yum源</h4><pre><code># rpm -ivh http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/zabbix-release-3.4-1.el7.centos.noarch.rpm</code></pre><h4 id="4-1-2-安装zabbix相关包"><a href="#4-1-2-安装zabbix相关包" class="headerlink" title="4.1.2 安装zabbix相关包"></a>4.1.2 安装zabbix相关包</h4><p>zabbix服务端需要安装：zabbix-server-mysql zabbix-web-mysql  zabbix-get<br>zabbix被监控主机端安装的软件：：zabbix-agent, zabbix-sender</p><pre><code># yum install zabbix-server-mysql zabbix-web-mysql zabbix-get zabbix-agent zabbix-sender -y# rpm -qa |grep zabbix zabbix-web-mysql-3.4.4-2.el7.noarch zabbix-get-3.4.4-2.el7.x86_64 zabbix-web-3.4.4-2.el7.noarch zabbix-agent-3.4.4-2.el7.x86_64 zabbix-release-3.4-1.el7.centos.noarch zabbix-server-mysql-3.4.4-2.el7.x86_64 zabbix-sender-3.4.4-2.el7.x86_64</code></pre><h3 id="4-2-zabbix相关数据导入数据库"><a href="#4-2-zabbix相关数据导入数据库" class="headerlink" title="4.2 zabbix相关数据导入数据库"></a>4.2 zabbix相关数据导入数据库</h3><pre><code># cd /usr/share/doc/zabbix-server-mysql-3.4.4/# zcat create.sql.gz |mysql -uzbuser -ptest zabbix</code></pre><h3 id="4-3-修改数据库相关配置"><a href="#4-3-修改数据库相关配置" class="headerlink" title="4.3 修改数据库相关配置"></a>4.3 修改数据库相关配置</h3><pre><code># vim /etc/zabbix/zabbix_server.conf# grep -n &apos;^&apos;[a-Z] /etc/zabbix/zabbix_server.conf38:LogFile=/var/log/zabbix/zabbix_server.log49:LogFileSize=072:PidFile=/var/run/zabbix/zabbix_server.pid82:SocketDir=/var/run/zabbix91:DBHost=localhost101:DBName=zabbix117:DBUser=zbuser125:DBPassword=test132:DBSocket=/var/lib/mysql/mysql.sock316:SNMPTrapperFile=/var/log/snmptrap/snmptrap.log434:Timeout=4476:AlertScriptsPath=/usr/lib/zabbix/alertscripts486:ExternalScripts=/usr/lib/zabbix/externalscripts522:LogSlowQueries=3000</code></pre><h3 id="4-4-启动zabbix-server并设置开机启动"><a href="#4-4-启动zabbix-server并设置开机启动" class="headerlink" title="4.4 启动zabbix server并设置开机启动"></a>4.4 启动zabbix server并设置开机启动</h3><pre><code># systemctl enable zabbix-server# systemctl start zabbix-server</code></pre><h3 id="4-5-编辑Zabbix前端PHP配置-更改时区"><a href="#4-5-编辑Zabbix前端PHP配置-更改时区" class="headerlink" title="4.5 编辑Zabbix前端PHP配置,更改时区"></a>4.5 编辑Zabbix前端PHP配置,更改时区</h3><pre><code># vim /etc/httpd/conf.d/zabbix.confphp_value date.timezone Asia/Shanghaiphp_value date.timezone Asia/Shanghai</code></pre><h3 id="4-6-启动httpd并设置开机启动"><a href="#4-6-启动httpd并设置开机启动" class="headerlink" title="4.6 启动httpd并设置开机启动"></a>4.6 启动httpd并设置开机启动</h3><pre><code># systemctl start httpd# systemctl enable httpd</code></pre><h3 id="4-7-图形界面安装配置zabbix"><a href="#4-7-图形界面安装配置zabbix" class="headerlink" title="4.7 图形界面安装配置zabbix"></a>4.7 图形界面安装配置zabbix</h3><p>浏览器输入<a href="http://server_ip/zabbix,根据图形引导信息,配置zabbix信息。" target="_blank" rel="noopener">http://server_ip/zabbix,根据图形引导信息,配置zabbix信息。</a></p><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/nggAUz" alt="1"></p><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/TUgNnW" alt="2"></p><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/0742rj" alt="3"></p><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/Iv6t7z" alt="4"></p><p><img src="https://cdn-std.dprcdn.net/files/acc_582513/VNlpQC" alt="5"></p><p><strong>zabbix初始登录账户和密码为： Admin  zabbix</strong></p><h2 id="5-zabbxi-agent安装及配置"><a href="#5-zabbxi-agent安装及配置" class="headerlink" title="5.zabbxi-agent安装及配置"></a>5.zabbxi-agent安装及配置</h2><h3 id="5-1-安装zabbxi-agent"><a href="#5-1-安装zabbxi-agent" class="headerlink" title="5.1 安装zabbxi-agent"></a>5.1 安装zabbxi-agent</h3><pre><code># yum install zabbix-agent  zabbix-sender -y# grep -n &apos;^&apos;[a-Z] /etc/zabbix/zabbix_agentd.conf 13:PidFile=/var/run/zabbix/zabbix_agentd.pid 32:LogFile=/var/log/zabbix/zabbix_agentd.log 43:LogFileSize=0 95:Server=127.0.0.1 136:ServerActive=127.0.0.1 147:Hostname=zabbix-server 265:Include=/etc/zabbix/zabbix_agentd.d/*.conf</code></pre><p>Server：被动模式，允许哪台服务器连接Agent。<br>ServerActive：主动模式，向哪台服务器传送数据。</p><h3 id="5-2-启动zabbix-agent"><a href="#5-2-启动zabbix-agent" class="headerlink" title="5.2 启动zabbix-agent"></a>5.2 启动zabbix-agent</h3><pre><code># systemctl start zabbix-agent# systemctl enable zabbix-agent</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、安装部署zabbix-3-4&quot;&gt;&lt;a href=&quot;#一、安装部署zabbix-3-4&quot; class=&quot;headerlink&quot; title=&quot;一、安装部署zabbix 3.4&quot;&gt;&lt;/a&gt;一、安装部署zabbix 3.4&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/zabbix/6780368?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Zabbix&lt;/a&gt; 是由 Alexei Vladishev 开发的一种网络监视、管理系统，基于 Server-Client 架构。可用于监视各种网络服务、服务器和网络机器等状态。&lt;/p&gt;
&lt;h2 id=&quot;1-zabbix基础说明&quot;&gt;&lt;a href=&quot;#1-zabbix基础说明&quot; class=&quot;headerlink&quot; title=&quot;1.zabbix基础说明&quot;&gt;&lt;/a&gt;1.zabbix基础说明&lt;/h2&gt;&lt;h3 id=&quot;1-1-zabbix使用说明&quot;&gt;&lt;a href=&quot;#1-1-zabbix使用说明&quot; class=&quot;headerlink&quot; title=&quot;1.1  zabbix使用说明&quot;&gt;&lt;/a&gt;1.1  zabbix使用说明&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.zabbix.com/documentation/3.4/zh/manual&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;zabbix3.4软件中文使用手册&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;zabbix3.4版本安装包路径&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-2-zabbix-3-4版本说明&quot;&gt;&lt;a href=&quot;#1-2-zabbix-3-4版本说明&quot; class=&quot;headerlink&quot; title=&quot;1.2 zabbix 3.4版本说明&quot;&gt;&lt;/a&gt;1.2 zabbix 3.4版本说明&lt;/h3&gt;&lt;p&gt;Zabbix Server端安装的软件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;zabbix-server-mysql&lt;/li&gt;
&lt;li&gt;zabbix-get&lt;/li&gt;
&lt;li&gt;mysql&lt;/li&gt;
&lt;li&gt;zabbix-web&lt;/li&gt;
&lt;li&gt;zabbix-web-mysql&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Zabbix Clinet 端安装的软件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;zabbix-agent&lt;/li&gt;
&lt;li&gt;zabbix-sender&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-zabbix系统环境配置&quot;&gt;&lt;a href=&quot;#2-zabbix系统环境配置&quot; class=&quot;headerlink&quot; title=&quot;2.zabbix系统环境配置&quot;&gt;&lt;/a&gt;2.zabbix系统环境配置&lt;/h2&gt;&lt;h3 id=&quot;2-1-系统环境&quot;&gt;&lt;a href=&quot;#2-1-系统环境&quot; class=&quot;headerlink&quot; title=&quot;2.1 系统环境&quot;&gt;&lt;/a&gt;2.1 系统环境&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;# cat /etc/redhat-release
CentOS Linux release 7.4.1708 (Core)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;2-2-永久修改主机名&quot;&gt;&lt;a href=&quot;#2-2-永久修改主机名&quot; class=&quot;headerlink&quot; title=&quot;2.2 永久修改主机名&quot;&gt;&lt;/a&gt;2.2 永久修改主机名&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;# hostnamectl --static set-hostname zabbix-server
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;2-3-关闭防火墙及selinux&quot;&gt;&lt;a href=&quot;#2-3-关闭防火墙及selinux&quot; class=&quot;headerlink&quot; title=&quot;2.3 关闭防火墙及selinux&quot;&gt;&lt;/a&gt;2.3 关闭防火墙及selinux&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;# systemctl stop firewalld.service
# systemctl daemon-reload
# systemctl disable firewalld.service

# sed -i &amp;apos;s/SELINUX=enforcing/SELINUX=disabled/g&amp;apos; /etc/selinux/config
# grep SELINUX=disabled /etc/selinux/config
# setenforce 0
# getenforce
  Disabled
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Linux服务" scheme="http://www.chenfanlinux.org/categories/Linux%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="Zabbix" scheme="http://www.chenfanlinux.org/tags/Zabbix/"/>
    
  </entry>
  
  <entry>
    <title>Hexo安装与介绍</title>
    <link href="http://www.chenfanlinux.org/2017/12/04/my-first-article/"/>
    <id>http://www.chenfanlinux.org/2017/12/04/my-first-article/</id>
    <published>2017-12-04T03:05:54.000Z</published>
    <updated>2018-01-11T06:54:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo 是高效的静态站点生成框架，她基于 Node.js。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 <a href="https://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a> 本身的语法之外，还可以使用 Hexo 提供的 标签插件 来快速的插入特定形式的内容。在这篇文章中，假定你已经成功安装了 Hexo，并使用 Hexo 提供的命令创建了一个站点。</p><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><h3 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h3><p>安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序：</p><ul><li><p><a href="https://nodejs.org/dist/v8.9.1/node-v8.9.1-x64.msi" target="_blank" rel="noopener">Node.js</a></p></li><li><p><a href="https://git-for-windows.github.io" target="_blank" rel="noopener">Git</a></p></li></ul><blockquote><p>安装git时候，由于众所周知的原因，从上面的链接下载git for windows最好挂上一个代理，否则下载速度十分缓慢。也可以参考<a href="https://github.com/waylau/git-for-win" target="_blank" rel="noopener">这个页面</a>，收录了存储于百度云的下载地址。</p></blockquote><h3 id="开始安装hexo"><a href="#开始安装hexo" class="headerlink" title="开始安装hexo"></a>开始安装hexo</h3><p>windows上安装所有必备的应用程序安装完成后，打开Git Bash命令行模式，即可使用 npm 安装 Hexo。</p><pre><code>$ cd F:\$ mkdir blog //windows下创建博客目录$ npm install -g hexo-cli    //安装hexo基础包</code></pre><h3 id="建立静态站点"><a href="#建立静态站点" class="headerlink" title="建立静态站点"></a>建立静态站点</h3><p>使用hexo建站非常的方便快捷，迅速就能在本地建立一个静态站点。安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><pre><code>$ hexo init blog  //初始化博客目录$ cd blog$ npm install    //开始安装</code></pre><p>新建完成后，指定文件夹的目录如下：</p><pre><code>.├── _config.yml  //站点配置文件├── package.json //应用程序信息├── scaffolds   //模版文件夹├── source      //资源文件夹 |   ├── _drafts|   └── _posts└── themes     //主题文件夹</code></pre><h3 id="hexo基础命令介绍"><a href="#hexo基础命令介绍" class="headerlink" title="hexo基础命令介绍"></a>hexo基础命令介绍</h3><p>hexo有一些常用的指令，明确这些指令的用途和方法，方便我们更高效的管理和构建炫酷的静态网站。</p><ul><li>init </li><li>new</li><li>generate</li><li>publish</li><li>server</li><li>deploy</li><li>clean</li><li>list</li></ul><h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><pre><code>$ hexo init [folder]</code></pre><p>新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。</p><h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><pre><code>$ hexo new [layout] &lt;title&gt;$ hexo new &quot;postName&quot; //新建文章$ hexo new page &quot;pageName&quot; //新建页面</code></pre><p>新建一篇文章。如果没有设置 layout 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">_config.yml</a> 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</p><h4 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h4><pre><code>$ hexo clean</code></pre><p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。<br>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h4 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h4><pre><code>$ hexo generate   //或者使用 hexo g </code></pre><a id="more"></a><p>生成静态文件,每次我们修改完一些配置后,可以使用hexo clean清理一下历史数据,然后再hexo g生成静态文件。</p><h4 id="server"><a href="#server" class="headerlink" title="server"></a>server</h4><p>启动服务器。默认情况下，访问网址为  <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 。</p><pre><code>$ hexo server</code></pre><blockquote><p>选项<br>描述<br>-p      重设端口<br>-s      只使用静态文件<br>-l  启动日记记录，使用覆盖记录格式 </p></blockquote><h4 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h4><p>部署网站,将本地网站推送到远程仓库。</p><pre><code>$ hexo deploy</code></pre><blockquote><p>参数<br>描述<br>-g, –generate    部署之前预先生成静态文件</p></blockquote><p>该命令可以简写为：</p><pre><code>$ hexo d</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hexo 是高效的静态站点生成框架，她基于 Node.js。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 &lt;a href=&quot;https://daringfireball.net/projects/markdown/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Markdown&lt;/a&gt; 本身的语法之外，还可以使用 Hexo 提供的 标签插件 来快速的插入特定形式的内容。在这篇文章中，假定你已经成功安装了 Hexo，并使用 Hexo 提供的命令创建了一个站点。&lt;/p&gt;
&lt;h2 id=&quot;安装hexo&quot;&gt;&lt;a href=&quot;#安装hexo&quot; class=&quot;headerlink&quot; title=&quot;安装hexo&quot;&gt;&lt;/a&gt;安装hexo&lt;/h2&gt;&lt;h3 id=&quot;安装前提&quot;&gt;&lt;a href=&quot;#安装前提&quot; class=&quot;headerlink&quot; title=&quot;安装前提&quot;&gt;&lt;/a&gt;安装前提&lt;/h3&gt;&lt;p&gt;安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://nodejs.org/dist/v8.9.1/node-v8.9.1-x64.msi&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Node.js&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://git-for-windows.github.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Git&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;安装git时候，由于众所周知的原因，从上面的链接下载git for windows最好挂上一个代理，否则下载速度十分缓慢。也可以参考&lt;a href=&quot;https://github.com/waylau/git-for-win&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这个页面&lt;/a&gt;，收录了存储于百度云的下载地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;开始安装hexo&quot;&gt;&lt;a href=&quot;#开始安装hexo&quot; class=&quot;headerlink&quot; title=&quot;开始安装hexo&quot;&gt;&lt;/a&gt;开始安装hexo&lt;/h3&gt;&lt;p&gt;windows上安装所有必备的应用程序安装完成后，打开Git Bash命令行模式，即可使用 npm 安装 Hexo。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd F:\
$ mkdir blog //windows下创建博客目录
$ npm install -g hexo-cli    //安装hexo基础包
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;建立静态站点&quot;&gt;&lt;a href=&quot;#建立静态站点&quot; class=&quot;headerlink&quot; title=&quot;建立静态站点&quot;&gt;&lt;/a&gt;建立静态站点&lt;/h3&gt;&lt;p&gt;使用hexo建站非常的方便快捷，迅速就能在本地建立一个静态站点。安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ hexo init blog  //初始化博客目录
$ cd blog
$ npm install    //开始安装
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;新建完成后，指定文件夹的目录如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.
├── _config.yml  //站点配置文件
├── package.json //应用程序信息
├── scaffolds   //模版文件夹
├── source      //资源文件夹 
|   ├── _drafts
|   └── _posts
└── themes     //主题文件夹
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;hexo基础命令介绍&quot;&gt;&lt;a href=&quot;#hexo基础命令介绍&quot; class=&quot;headerlink&quot; title=&quot;hexo基础命令介绍&quot;&gt;&lt;/a&gt;hexo基础命令介绍&lt;/h3&gt;&lt;p&gt;hexo有一些常用的指令，明确这些指令的用途和方法，方便我们更高效的管理和构建炫酷的静态网站。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;init &lt;/li&gt;
&lt;li&gt;new&lt;/li&gt;
&lt;li&gt;generate&lt;/li&gt;
&lt;li&gt;publish&lt;/li&gt;
&lt;li&gt;server&lt;/li&gt;
&lt;li&gt;deploy&lt;/li&gt;
&lt;li&gt;clean&lt;/li&gt;
&lt;li&gt;list&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;init&quot;&gt;&lt;a href=&quot;#init&quot; class=&quot;headerlink&quot; title=&quot;init&quot;&gt;&lt;/a&gt;init&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;$ hexo init [folder]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。&lt;/p&gt;
&lt;h4 id=&quot;new&quot;&gt;&lt;a href=&quot;#new&quot; class=&quot;headerlink&quot; title=&quot;new&quot;&gt;&lt;/a&gt;new&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;$ hexo new [layout] &amp;lt;title&amp;gt;
$ hexo new &amp;quot;postName&amp;quot; //新建文章
$ hexo new page &amp;quot;pageName&amp;quot; //新建页面
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;新建一篇文章。如果没有设置 layout 的话，默认使用 &lt;a href=&quot;https://hexo.io/zh-cn/docs/configuration.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;_config.yml&lt;/a&gt; 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。&lt;/p&gt;
&lt;h4 id=&quot;clean&quot;&gt;&lt;a href=&quot;#clean&quot; class=&quot;headerlink&quot; title=&quot;clean&quot;&gt;&lt;/a&gt;clean&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;$ hexo clean
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;清除缓存文件 (db.json) 和已生成的静态文件 (public)。&lt;br&gt;在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。&lt;/p&gt;
&lt;h4 id=&quot;generate&quot;&gt;&lt;a href=&quot;#generate&quot; class=&quot;headerlink&quot; title=&quot;generate&quot;&gt;&lt;/a&gt;generate&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;$ hexo generate   //或者使用 hexo g 
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://www.chenfanlinux.org/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://www.chenfanlinux.org/tags/Hexo/"/>
    
  </entry>
  
</feed>
