<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陈凡的个人站点</title>
  
  <subtitle>chenfanlinux.org</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.chenfanlinux.org/"/>
  <updated>2018-05-28T03:47:32.000Z</updated>
  <id>http://www.chenfanlinux.org/</id>
  
  <author>
    <name>陈凡</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python操作MongoDB</title>
    <link href="http://www.chenfanlinux.org/2018/05/28/Python%E6%93%8D%E4%BD%9CMongoDB/"/>
    <id>http://www.chenfanlinux.org/2018/05/28/Python操作MongoDB/</id>
    <published>2018-05-28T03:37:40.000Z</published>
    <updated>2018-05-28T03:47:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>MongoDB是由C++语言编写的非关系型数据库，是一个基于分布式文件存储的开源数据库系统，其内容存储形式类似JSON对象，它的字段值可以包含其他文档、数组及文档数组，非常灵活。 在开始之前，请确保已经安装好了MongoDB并启动了其服务，并且安装好了Python的PyMongo库。</p><ul><li>Python 3.6</li><li><a href="[win32/mongodb-win32-x86_64-2008plus-ssl-v3.4-latest.zip](http://downloads.mongodb.org/win32/mongodb-win32-x86_64-2008plus-ssl-v3.4-latest.zip">mongodb3.4</a> )</li><li>pymongo 3.4.0</li></ul><h3 id="连接MongDB"><a href="#连接MongDB" class="headerlink" title="连接MongDB"></a>连接MongDB</h3><p>连接MongoDB时，我们需要使用PyMongo库里面的<code>MongoClient</code>。一般来说，传入MongoDB的IP及端口即可，其中第一个参数为地址<code>host</code>，第二个参数为端口<code>port</code>（如果不给它传递参数，默认是27017） 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pymongo</span><br><span class="line"><span class="comment"># 创建MongoDB的连接对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>client = pymongo.MongoClient(host=<span class="string">'localhost'</span>, port=<span class="number">27017</span>)</span><br></pre></td></tr></table></figure><h3 id="指定数据库和集合"><a href="#指定数据库和集合" class="headerlink" title="指定数据库和集合"></a>指定数据库和集合</h3><p>MongoDB中可以建立多个数据库，接下来我们需要指定操作哪个数据库；MongoDB的每个数据库又包含许多集合（collection），它们类似于关系型数据库中的表。下一步需要指定要操作的集合，这里指定一个集合名称为students。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建或者指定数据库db</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db = client[<span class="string">'test'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db = client.test <span class="comment"># 这种方式也可以指定数据库db</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建或者指定集合</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>collection = db[<span class="string">'students'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>collection = db.students <span class="comment"># 这种方式也可以指定集合</span></span><br><span class="line"><span class="comment"># 这样我们便声明了一个Collection对象。</span></span><br></pre></td></tr></table></figure><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><h4 id="插入单条数据"><a href="#插入单条数据" class="headerlink" title="插入单条数据"></a>插入单条数据</h4><p>直接调用<code>collection</code>的<code>insert()</code>方法即可插入数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建一条学生数据，这条数据以字典形式表示</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>student = &#123;</span><br><span class="line">    <span class="string">'id'</span>: <span class="string">'20170101'</span>,</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'Jordan'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">'gender'</span>: <span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 往集合中插入数据</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result = collection.insert(student)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(result) <span class="comment"># 返回insert后的 _id</span></span><br><span class="line"><span class="number">5</span>b02a3868c08d32b90ff9954</span><br></pre></td></tr></table></figure><p>在MongoDB中，每条数据其实都有一个<code>_id</code>属性来唯一标识。如果没有显式指明该属性，MongoDB会自动产生一个<code>ObjectId</code>类型的<code>_id</code>属性。<code>insert()</code>方法会在执行后返回<code>_id</code>值。</p><h4 id="插入多条数据"><a href="#插入多条数据" class="headerlink" title="插入多条数据"></a>插入多条数据</h4><p>当然，我们也可以同时插入多条数据，只需要以列表形式传递即可 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>student1 = &#123;</span><br><span class="line">    <span class="string">'id'</span>: <span class="string">'20170101'</span>,</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'Jordan'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">'gender'</span>: <span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>student2 = &#123;</span><br><span class="line">    <span class="string">'id'</span>: <span class="string">'20170202'</span>,</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'Mike'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">21</span>,</span><br><span class="line">    <span class="string">'gender'</span>: <span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result = collection.insert([student1, student2])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(result)</span><br><span class="line">[ObjectId(<span class="string">'5b037d818c08d31574a6bd21'</span>), ObjectId(<span class="string">'5b037d818c08d31574a6bd22'</span>)]</span><br></pre></td></tr></table></figure><p>实际上，在PyMongo 3.x版本中，官方已经不推荐使用<code>insert()</code>方法了。当然，继续使用也没有什么问题。官方推荐使用<code>insert_one()</code>和<code>insert_many()</code>方法来分别插入单条记录和多条记录 。</p><a id="more"></a><h4 id="insert-one"><a href="#insert-one" class="headerlink" title="insert_one()"></a>insert_one()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>student = &#123;</span><br><span class="line">    <span class="string">'id'</span>: <span class="string">'20170101'</span>,</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'Jordan'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">'gender'</span>: <span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入单条数据 insert_one</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result = collection.insert_one(student)</span><br><span class="line">print(result)</span><br><span class="line">&lt;pymongo.results.InsertOneResult object at <span class="number">0x0000000003AF8090</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(result.inserted_id)</span><br><span class="line"><span class="number">5</span>b037e428c08d31574a6bd23</span><br><span class="line"></span><br><span class="line"><span class="comment"># 与insert()方法不同，这次返回的是InsertOneResult对象，我们可以调用其inserted_id属性获取ObjectId</span></span><br></pre></td></tr></table></figure><h4 id="insert-many"><a href="#insert-many" class="headerlink" title="insert_many()"></a>insert_many()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>student1 = &#123;     <span class="string">'id'</span>: <span class="string">'20170101'</span>,     <span class="string">'name'</span>: <span class="string">'Jordan'</span>,     <span class="string">'age'</span>: <span class="number">20</span>,     <span class="string">'gender'</span>: <span class="string">'male'</span> &#125;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>student2 = &#123;     <span class="string">'id'</span>: <span class="string">'20170202'</span>,     <span class="string">'name'</span>: <span class="string">'Mike'</span>,     <span class="string">'age'</span>: <span class="number">21</span>,</span><br><span class="line">     <span class="string">'gender'</span>: <span class="string">'male'</span> &#125;</span><br><span class="line"><span class="comment"># insert_many 插入多条数据</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result = collection.insert_many([student1, student2])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(result)</span><br><span class="line">&lt;pymongo.results.InsertManyResult object at <span class="number">0x0000000003AF82D0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(result.inserted_ids)</span><br><span class="line">[ObjectId(<span class="string">'5b037fab8c08d31574a6bd24'</span>), ObjectId(<span class="string">'5b037fab8c08d31574a6bd25'</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 该方法返回的类型是InsertManyResult，调用inserted_ids属性可以获取插入数据的_id列表。</span></span><br></pre></td></tr></table></figure><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><p>插入数据后，我们可以利用<code>find_one()</code>或<code>find()</code>方法进行查询，其中<code>find_one()</code>查询得到的是单个结果，<code>find()</code>则返回一个生成器对象。</p><h4 id="find-one"><a href="#find-one" class="headerlink" title="find_one()"></a>find_one()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>result = collection.find_one(&#123;<span class="string">'name'</span>: <span class="string">'Mike'</span>&#125;) <span class="comment"># 查询单个结果</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(result)) <span class="comment"># 类型为字典</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">dict</span>'&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"># 这里我们查询<span class="title">name</span>为<span class="title">Mike</span>的数据，它的返回结果是字典类型</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(result)</span></span></span><br><span class="line">&#123;'_id': ObjectId('5b037d818c08d31574a6bd22'), 'id': '20170202', 'name': 'Mike', 'age': 21, 'gender': 'male'&#125;</span><br><span class="line"><span class="comment"># 可以发现，它多了_id属性，这就是MongoDB在插入过程中自动添加的。</span></span><br></pre></td></tr></table></figure><p>此外，我们也可以根据<code>ObjectId</code>来查询，此时需要使用bson库里面的<code>objectid</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> bson.objectid <span class="keyword">import</span> ObjectId</span><br><span class="line"><span class="comment"># 根据ObjectId来查找</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result = collection.find_one(&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5b037fab8c08d31574a6bd24'</span>)&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(result)</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5b037fab8c08d31574a6bd24'</span>), <span class="string">'id'</span>: <span class="string">'20170101'</span>, <span class="string">'name'</span>: <span class="string">'Jordan'</span>, <span class="string">'age'</span>: <span class="number">20</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br><span class="line"><span class="comment"># 当然，如果查询结果不存在，则会返回None。</span></span><br></pre></td></tr></table></figure><h4 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h4><p>对于多条数据的查询，我们可以使用<code>find()</code>方法。例如，这里查找年龄为20的数据，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>results = collection.find(&#123;<span class="string">'age'</span>: <span class="number">20</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(results)</span><br><span class="line">&lt;pymongo.cursor.Cursor object at <span class="number">0x00000000038D1E48</span>&gt;</span><br><span class="line"><span class="comment"># 返回结果是Cursor类型，它相当于一个生成器，我们需要遍历取到所有的结果，其中每个结果都是字典类型。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line"><span class="meta">... </span>    print(result)</span><br><span class="line">...</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5b037d008c08d31574a6bd20'</span>), <span class="string">'id'</span>: <span class="string">'20170101'</span>, <span class="string">'name'</span>: <span class="string">'Jordan'</span>, <span class="string">'age'</span>: <span class="number">20</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5b037d818c08d31574a6bd21'</span>), <span class="string">'id'</span>: <span class="string">'20170101'</span>, <span class="string">'name'</span>: <span class="string">'Jordan'</span>, <span class="string">'age'</span>: <span class="number">20</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5b037e428c08d31574a6bd23'</span>), <span class="string">'id'</span>: <span class="string">'20170101'</span>, <span class="string">'name'</span>: <span class="string">'Jordan'</span>, <span class="string">'age'</span>: <span class="number">20</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5b037fab8c08d31574a6bd24'</span>), <span class="string">'id'</span>: <span class="string">'20170101'</span>, <span class="string">'name'</span>: <span class="string">'Jordan'</span>, <span class="string">'age'</span>: <span class="number">20</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br></pre></td></tr></table></figure><p>如果要查询年龄大于20的数据，则写法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里查询的条件键值已经不是单纯的数字了，而是一个字典，其键名为比较符号$gt，意思是大于，键值为20。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>results = collection.find(&#123;<span class="string">'age'</span>: &#123;<span class="string">'$gt'</span>: <span class="number">20</span>&#125;&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line"><span class="meta">... </span>    print(result)</span><br><span class="line">...</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5b037d818c08d31574a6bd22'</span>), <span class="string">'id'</span>: <span class="string">'20170202'</span>, <span class="string">'name'</span>: <span class="string">'Mike'</span>, <span class="string">'age'</span>: <span class="number">21</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5b037fab8c08d31574a6bd25'</span>), <span class="string">'id'</span>: <span class="string">'20170202'</span>, <span class="string">'name'</span>: <span class="string">'Mike'</span>, <span class="string">'age'</span>: <span class="number">21</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br></pre></td></tr></table></figure><p>这里将比较符号归纳为下表 :</p><p><img src="https://s1.ax1x.com/2018/05/22/C2LcxH.png" alt="比较符合归纳表"></p><p>还可以进行正则匹配查询。例如，查询名字以M开头的学生数据，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里使用$regex来指定正则匹配，^M.*代表以M开头的正则表达式。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>results = collection.find(&#123;<span class="string">'name'</span>: &#123;<span class="string">'$regex'</span>: <span class="string">'^M.*'</span>&#125;&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line"><span class="meta">... </span>    print(result)</span><br><span class="line">...</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5b037d818c08d31574a6bd22'</span>), <span class="string">'id'</span>: <span class="string">'20170202'</span>, <span class="string">'name'</span>: <span class="string">'Mike'</span>, <span class="string">'age'</span>: <span class="number">21</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5b037fab8c08d31574a6bd25'</span>), <span class="string">'id'</span>: <span class="string">'20170202'</span>, <span class="string">'name'</span>: <span class="string">'Mike'</span>, <span class="string">'age'</span>: <span class="number">21</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br></pre></td></tr></table></figure><p>这里将一些功能符号再归类为下表 :</p><p><img src="https://s1.ax1x.com/2018/05/22/C2LjZq.png" alt="功能符号表"></p><h3 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h3><p>要统计查询结果有多少条数据，可以调用<code>count()</code>方法。比如，统计所有数据条数 ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>count = collection.find().count()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(count)</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p>统计符合某个条件的数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>count = collection.find(&#123;<span class="string">'age'</span>: <span class="number">20</span>&#125;).count()</span><br><span class="line"><span class="comment"># 运行结果是一个数值，即符合条件的数据条数。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(count)</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>排序时，直接调用<code>sort()</code>方法，并在其中传入排序的字段及升降序标志即可。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>results = collection.find().sort(<span class="string">'name'</span>, pymongo.ASCENDING)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print([result[<span class="string">'name'</span>] <span class="keyword">for</span> result <span class="keyword">in</span> results])</span><br><span class="line">[<span class="string">'Jordan'</span>, <span class="string">'Jordan'</span>, <span class="string">'Jordan'</span>, <span class="string">'Jordan'</span>, <span class="string">'Mike'</span>, <span class="string">'Mike'</span>]</span><br></pre></td></tr></table></figure><p>这里我们调用<code>pymongo.ASCENDING</code>指定升序。如果要降序排列，可以传入<code>pymongo.DESCENDING</code>。</p><h3 id="偏移"><a href="#偏移" class="headerlink" title="偏移"></a>偏移</h3><p>在某些情况下，我们可能想只取某几个元素，这时可以利用<code>skip()</code>方法偏移几个位置，比如偏移2，就忽略前两个元素，得到第三个及以后的元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 忽略前两个</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>results = collection.find().sort(<span class="string">'name'</span>, pymongo.ASCENDING).skip(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print([result[<span class="string">'name'</span>] <span class="keyword">for</span> result <span class="keyword">in</span> results])</span><br><span class="line">[<span class="string">'Jordan'</span>, <span class="string">'Jordan'</span>, <span class="string">'Mike'</span>, <span class="string">'Mike'</span>]</span><br></pre></td></tr></table></figure><p>另外，还可以用<code>limit()</code>方法指定要取的结果个数，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>results = collection.find().sort(<span class="string">'name'</span>, pymongo.ASCENDING).skip(<span class="number">2</span>).limit(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print([result[<span class="string">'name'</span>] <span class="keyword">for</span> result <span class="keyword">in</span> results])</span><br><span class="line">[<span class="string">'Jordan'</span>, <span class="string">'Jordan'</span>]</span><br></pre></td></tr></table></figure><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>对于数据更新，我们可以使用<code>update()</code>方法，指定更新的条件和更新后的数据即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>condition = &#123;<span class="string">'name'</span>: <span class="string">'Jordan'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>student = collection.find_one(condition)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>student</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5b037d008c08d31574a6bd20'</span>), <span class="string">'id'</span>: <span class="string">'20170101'</span>, <span class="string">'name'</span>: <span class="string">'</span></span><br><span class="line"><span class="string">Jordan'</span>, <span class="string">'age'</span>: <span class="number">20</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>student[<span class="string">'age'</span>] = <span class="number">25</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>student</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5b037d008c08d31574a6bd20'</span>), <span class="string">'id'</span>: <span class="string">'20170101'</span>, <span class="string">'name'</span>: <span class="string">'</span></span><br><span class="line"><span class="string">Jordan'</span>, <span class="string">'age'</span>: <span class="number">25</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result = collection.update(condition, student)</span><br><span class="line"><span class="comment"># 返回结果是字典形式，ok代表执行成功，nModified代表影响的数据条数。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result</span><br><span class="line">&#123;<span class="string">'n'</span>: <span class="number">1</span>, <span class="string">'nModified'</span>: <span class="number">1</span>, <span class="string">'ok'</span>: <span class="number">1.0</span>, <span class="string">'updatedExisting'</span>: <span class="keyword">True</span>&#125;</span><br></pre></td></tr></table></figure><p>这里我们要更新<code>name</code>为<code>Kevin</code>的数据的年龄：首先指定查询条件，然后将数据查询出来，修改年龄后调用<code>update()</code>方法将原条件和修改后的数据传入 。</p><p>另外，我们也可以使用<code>$set</code>操作符对数据进行更新，代码如下 ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这样只会更新字段，不会删除字段，这里即使stundent的数据被pop调用,也不会删除掉原数据。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result = collection.update(condition, &#123;<span class="string">'$set'</span>: student&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(result)</span><br><span class="line">&#123;<span class="string">'n'</span>: <span class="number">1</span>, <span class="string">'nModified'</span>: <span class="number">0</span>, <span class="string">'ok'</span>: <span class="number">1.0</span>, <span class="string">'updatedExisting'</span>: <span class="keyword">True</span>&#125;</span><br></pre></td></tr></table></figure><p>这样可以只更新<code>student</code>字典内存在的字段。如果原先还有其他字段，则不会更新，也不会删除。而如果不用<code>$set</code>的话，则会把之前的数据全部用<code>student</code>字典替换；如果原本存在其他字段，则会被删除。</p><h4 id="update-one"><a href="#update-one" class="headerlink" title="update_one()"></a>update_one()</h4><p>另外，<code>update()</code>方法其实也是官方不推荐使用的方法。这里也分为<code>update_one()</code>方法和<code>update_many()</code>方法，用法更加严格，它们的第二个参数需要使用<code>$</code>类型操作符作为字典的键名 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>condition = &#123;<span class="string">'name'</span>: <span class="string">'Jordan'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>student = collection.find_one(condition)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>student</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'5b037d008c08d31574a6bd20'</span>), <span class="string">'id'</span>: <span class="string">'20170102'</span>, <span class="string">'name'</span>: <span class="string">'Jordan'</span>, <span class="string">'age'</span>: <span class="number">25</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>student[<span class="string">'age'</span>] = <span class="number">26</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result = collection.update_one(condition, &#123;<span class="string">'$set'</span>: student&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(result)</span><br><span class="line">&lt;pymongo.results.UpdateResult object at <span class="number">0x0000000003AF8C60</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(result.matched_count, result.modified_count)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里调用了update_one()方法，第二个参数不能再直接传入修改后的字典，而是需要使用&#123;'$set': student&#125;这样的形式，其返回结果是UpdateResult类型。然后分别调用matched_count和modified_count属性，可以获得匹配的数据条数和影响的数据条数。</span></span><br></pre></td></tr></table></figure><p>我们再看一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询条件年龄大于20岁</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>condition = &#123;<span class="string">'age'</span>: &#123;<span class="string">'$gt'</span>: <span class="number">20</span>&#125;&#125;</span><br><span class="line"><span class="comment"># 然后更新条件为&#123;'$inc': &#123;'age': 1&#125;&#125;, 年龄加1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result = collection.update_one(condition, &#123;<span class="string">'$inc'</span>: &#123;<span class="string">'age'</span>: <span class="number">1</span>&#125;&#125;)</span><br><span class="line"><span class="comment"># 执行之后会将第一条符合条件的数据年龄加1。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(result)</span><br><span class="line">&lt;pymongo.results.UpdateResult object at <span class="number">0x0000000003AF8EA0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(result.matched_count, result.modified_count)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="update-many"><a href="#update-many" class="headerlink" title="update_many()"></a>update_many()</h4><p>如果调用<code>update_many()</code>方法，则会将所有符合条件的数据都更新，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>condition = &#123;<span class="string">'age'</span>: &#123;<span class="string">'$gt'</span>: <span class="number">20</span>&#125;&#125;</span><br><span class="line"><span class="comment"># 更新多条数据</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result = collection.update_many(condition, &#123;<span class="string">'$inc'</span>: &#123;<span class="string">'age'</span>: <span class="number">1</span>&#125;&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(result)</span><br><span class="line">&lt;pymongo.results.UpdateResult object at <span class="number">0x0000000003AF8090</span>&gt;</span><br><span class="line"><span class="comment"># 可以看到，这时所有匹配到的数据都会被更新。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(result.matched_count, result.modified_count)</span><br><span class="line"><span class="number">3</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除操作比较简单，直接调用<code>remove()</code>方法指定删除的条件即可，此时符合条件的所有数据均会被删除。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>result = collection.remove(&#123;<span class="string">'name'</span>: <span class="string">'Mike'</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(result)</span><br><span class="line">&#123;<span class="string">'n'</span>: <span class="number">2</span>, <span class="string">'ok'</span>: <span class="number">1.0</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="delete-one"><a href="#delete-one" class="headerlink" title="delete_one( )"></a>delete_one( )</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>result = collection.delete_one(&#123;<span class="string">'name'</span>: <span class="string">'Jordan'</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result</span><br><span class="line">&lt;pymongo.results.DeleteResult object at <span class="number">0x0000000003AF8BD0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(result.deleted_count)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h4 id="delete-many"><a href="#delete-many" class="headerlink" title="delete_many()"></a>delete_many()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除年龄小于25岁的多条记录</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result = collection.delete_many(&#123;<span class="string">'age'</span>: &#123;<span class="string">'$lt'</span>: <span class="number">25</span>&#125;&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(result.deleted_count)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h3&gt;&lt;p&gt;MongoDB是由C++语言编写的非关系型数据库，是一个基于分布式文件存储的开源数据库系统，其内容存储形式类似JSON对象，它的字段值可以包含其他文档、数组及文档数组，非常灵活。 在开始之前，请确保已经安装好了MongoDB并启动了其服务，并且安装好了Python的PyMongo库。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python 3.6&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;[win32/mongodb-win32-x86_64-2008plus-ssl-v3.4-latest.zip](http://downloads.mongodb.org/win32/mongodb-win32-x86_64-2008plus-ssl-v3.4-latest.zip&quot;&gt;mongodb3.4&lt;/a&gt; )&lt;/li&gt;
&lt;li&gt;pymongo 3.4.0&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;连接MongDB&quot;&gt;&lt;a href=&quot;#连接MongDB&quot; class=&quot;headerlink&quot; title=&quot;连接MongDB&quot;&gt;&lt;/a&gt;连接MongDB&lt;/h3&gt;&lt;p&gt;连接MongoDB时，我们需要使用PyMongo库里面的&lt;code&gt;MongoClient&lt;/code&gt;。一般来说，传入MongoDB的IP及端口即可，其中第一个参数为地址&lt;code&gt;host&lt;/code&gt;，第二个参数为端口&lt;code&gt;port&lt;/code&gt;（如果不给它传递参数，默认是27017） 。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; pymongo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 创建MongoDB的连接对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;client = pymongo.MongoClient(host=&lt;span class=&quot;string&quot;&gt;&#39;localhost&#39;&lt;/span&gt;, port=&lt;span class=&quot;number&quot;&gt;27017&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;指定数据库和集合&quot;&gt;&lt;a href=&quot;#指定数据库和集合&quot; class=&quot;headerlink&quot; title=&quot;指定数据库和集合&quot;&gt;&lt;/a&gt;指定数据库和集合&lt;/h3&gt;&lt;p&gt;MongoDB中可以建立多个数据库，接下来我们需要指定操作哪个数据库；MongoDB的每个数据库又包含许多集合（collection），它们类似于关系型数据库中的表。下一步需要指定要操作的集合，这里指定一个集合名称为students。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 创建或者指定数据库db&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;db = client[&lt;span class=&quot;string&quot;&gt;&#39;test&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;db = client.test &lt;span class=&quot;comment&quot;&gt;# 这种方式也可以指定数据库db&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 创建或者指定集合&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;collection = db[&lt;span class=&quot;string&quot;&gt;&#39;students&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;collection = db.students &lt;span class=&quot;comment&quot;&gt;# 这种方式也可以指定集合&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 这样我们便声明了一个Collection对象。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;插入数据&quot;&gt;&lt;a href=&quot;#插入数据&quot; class=&quot;headerlink&quot; title=&quot;插入数据&quot;&gt;&lt;/a&gt;插入数据&lt;/h3&gt;&lt;h4 id=&quot;插入单条数据&quot;&gt;&lt;a href=&quot;#插入单条数据&quot; class=&quot;headerlink&quot; title=&quot;插入单条数据&quot;&gt;&lt;/a&gt;插入单条数据&lt;/h4&gt;&lt;p&gt;直接调用&lt;code&gt;collection&lt;/code&gt;的&lt;code&gt;insert()&lt;/code&gt;方法即可插入数据&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 新建一条学生数据，这条数据以字典形式表示&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;student = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;id&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;20170101&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;name&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;Jordan&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;age&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;gender&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;male&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 往集合中插入数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;result = collection.insert(student)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;print(result) &lt;span class=&quot;comment&quot;&gt;# 返回insert后的 _id&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;b02a3868c08d32b90ff9954&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在MongoDB中，每条数据其实都有一个&lt;code&gt;_id&lt;/code&gt;属性来唯一标识。如果没有显式指明该属性，MongoDB会自动产生一个&lt;code&gt;ObjectId&lt;/code&gt;类型的&lt;code&gt;_id&lt;/code&gt;属性。&lt;code&gt;insert()&lt;/code&gt;方法会在执行后返回&lt;code&gt;_id&lt;/code&gt;值。&lt;/p&gt;
&lt;h4 id=&quot;插入多条数据&quot;&gt;&lt;a href=&quot;#插入多条数据&quot; class=&quot;headerlink&quot; title=&quot;插入多条数据&quot;&gt;&lt;/a&gt;插入多条数据&lt;/h4&gt;&lt;p&gt;当然，我们也可以同时插入多条数据，只需要以列表形式传递即可 。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;student1 = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;id&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;20170101&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;name&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;Jordan&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;age&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;gender&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;male&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;student2 = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;id&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;20170202&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;name&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;Mike&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;age&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;21&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;gender&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;male&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;result = collection.insert([student1, student2])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;print(result)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[ObjectId(&lt;span class=&quot;string&quot;&gt;&#39;5b037d818c08d31574a6bd21&#39;&lt;/span&gt;), ObjectId(&lt;span class=&quot;string&quot;&gt;&#39;5b037d818c08d31574a6bd22&#39;&lt;/span&gt;)]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实际上，在PyMongo 3.x版本中，官方已经不推荐使用&lt;code&gt;insert()&lt;/code&gt;方法了。当然，继续使用也没有什么问题。官方推荐使用&lt;code&gt;insert_one()&lt;/code&gt;和&lt;code&gt;insert_many()&lt;/code&gt;方法来分别插入单条记录和多条记录 。&lt;/p&gt;
    
    </summary>
    
      <category term="MongDB" scheme="http://www.chenfanlinux.org/categories/MongDB/"/>
    
    
      <category term="MongDB" scheme="http://www.chenfanlinux.org/tags/MongDB/"/>
    
  </entry>
  
  <entry>
    <title>如何提升你的记忆力</title>
    <link href="http://www.chenfanlinux.org/2018/05/27/%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E4%BD%A0%E7%9A%84%E8%AE%B0%E5%BF%86%E5%8A%9B/"/>
    <id>http://www.chenfanlinux.org/2018/05/27/如何提升你的记忆力/</id>
    <published>2018-05-27T05:36:57.000Z</published>
    <updated>2018-05-27T05:45:11.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>刚放在手里的东西，转身就找不到了。明明话就在嘴边，但怎么都想不起来，别人一次就能记住的事情，你却要默背好多遍。别埋怨自己记性不好，其实记忆力也可以通过锻炼提高的。下面介绍这20个方法，挽救一下你的记忆力！</p></blockquote><h3 id="1-经常大笑"><a href="#1-经常大笑" class="headerlink" title="1. 经常大笑"></a>1. 经常大笑</h3><p>笑能保持大脑活力，让思维更明捷。定期与亲友聚会，给老友打个电话，晚餐后与家人聊天，都能让大脑感觉快乐。</p><h3 id="2-听不同类型的歌曲"><a href="#2-听不同类型的歌曲" class="headerlink" title="2. 听不同类型的歌曲"></a>2. 听不同类型的歌曲</h3><p>积极的接受不熟悉的音乐，听歌时除了关注旋律，还要认真琢磨歌词，这样不仅可以锻炼右脑，还会用到掌管语言的左脑。</p><h3 id="3-学习新技能"><a href="#3-学习新技能" class="headerlink" title="3. 学习新技能"></a>3. 学习新技能</h3><p>学习任何一项新技能都能促进大脑健康，例如学习新乐器、做手工、下棋等。</p><h3 id="4-多和他人交流"><a href="#4-多和他人交流" class="headerlink" title="4.多和他人交流"></a>4.多和他人交流</h3><p>与朋友交往，彼此分享经历、沟通情感、增加信任，思路变得更广，新想法也会更多，这些都是大脑的润滑剂。</p><h3 id="5-保证充足的睡眠"><a href="#5-保证充足的睡眠" class="headerlink" title="5.保证充足的睡眠"></a>5.保证充足的睡眠</h3><p>睡觉时，脑脊液在脑细胞间的循环比清醒时快很多，帮助大脑排出 “垃圾”,因为尽量避免熬夜，让大脑充分休息。</p><a id="more"></a><h3 id="6-给大脑出个难题"><a href="#6-给大脑出个难题" class="headerlink" title="6.给大脑出个难题"></a>6.给大脑出个难题</h3><p>“用进废退” 是大脑的使用原理，试着记忆路线、背一些电话号码、努力回忆想不起的事情，让大脑保持工作状态。</p><h3 id="7-大声朗读"><a href="#7-大声朗读" class="headerlink" title="7. 大声朗读"></a>7. 大声朗读</h3><p>朗读能把视觉的刺激反馈给听觉，还会用到唇、舌、喉等多个部位，这样带给大脑的刺激比默读大很多，记忆也更深刻。</p><h3 id="8-多回忆细节"><a href="#8-多回忆细节" class="headerlink" title="8. 多回忆细节"></a>8. 多回忆细节</h3><p>读书或者听讲时，要不时挺下来回想刚才读到或者听到的内容，越详细越好。大脑存储这些信息时，细节越多，以及效果越好。</p><h3 id="9-锻炼观察力"><a href="#9-锻炼观察力" class="headerlink" title="9. 锻炼观察力"></a>9. 锻炼观察力</h3><p>这是对抗健忘的最好方式之一，每次去一个新地方，在心中一下房间内物品的摆放位置，等离开时再试着回想，锻炼自己的观察力。</p><h3 id="10-将信息图像化"><a href="#10-将信息图像化" class="headerlink" title="10. 将信息图像化"></a>10. 将信息图像化</h3><p>运用视觉或者语言上的连续，可以帮助提升记忆。</p><h3 id="11-去陌生的地方散步"><a href="#11-去陌生的地方散步" class="headerlink" title="11. 去陌生的地方散步"></a>11. 去陌生的地方散步</h3><p>在不认识的地方散步时，右脑中会形成一幅地图。通过接触不了解的世界，可以使脑保持新鲜的状态。</p><h3 id="12-做个倾听者"><a href="#12-做个倾听者" class="headerlink" title="12.做个倾听者"></a>12.做个倾听者</h3><p>专心听别人说话，控制住自己插嘴发表意见的冲动。作为听众，不但能够增加信息输入，还可以对已有的信息进行整理。</p><h3 id="13-让大脑偶尔无聊一下"><a href="#13-让大脑偶尔无聊一下" class="headerlink" title="13. 让大脑偶尔无聊一下"></a>13. 让大脑偶尔无聊一下</h3><p>无聊的时候大脑的活动也会 “停滞” ，设定这样一个充电时期，让大脑进行充分的休息。你的记忆力就可能取得更大的飞跃。</p><h3 id="14-亲身体验是脑最宝贵的财富"><a href="#14-亲身体验是脑最宝贵的财富" class="headerlink" title="14. 亲身体验是脑最宝贵的财富"></a>14. 亲身体验是脑最宝贵的财富</h3><p>无论什么事，都要积极的投入。本来不感兴趣的事情，经过尝试后可能会获取意想不到的乐趣。好奇心是让大脑恢复年轻的第一步。</p><h3 id="15-吃早餐能活化大脑"><a href="#15-吃早餐能活化大脑" class="headerlink" title="15. 吃早餐能活化大脑"></a>15. 吃早餐能活化大脑</h3><p>研究表明，吃早餐的人群图像记忆，单词记忆能力更好。早餐中提取一天所需要的许多能量，会提高计算能力和创造力。</p><h3 id="16-多咀嚼可以提高记忆力"><a href="#16-多咀嚼可以提高记忆力" class="headerlink" title="16.多咀嚼可以提高记忆力"></a>16.多咀嚼可以提高记忆力</h3><p>研究显示，咀嚼时大脑感觉运动领域的血流量会增加25-28%，味觉中枢的血流量会增加9-17%。</p><h3 id="17-跳舞、游泳是最佳的运动"><a href="#17-跳舞、游泳是最佳的运动" class="headerlink" title="17.跳舞、游泳是最佳的运动"></a>17.跳舞、游泳是最佳的运动</h3><p>定期的锻炼可以促进负责记忆的脑细胞生长。游泳时大脑中的血液流量增加14%，而跳舞能让人们患认知障碍症的风险降低76%。</p><h3 id="18-小心盐伤大脑"><a href="#18-小心盐伤大脑" class="headerlink" title="18.小心盐伤大脑"></a>18.小心盐伤大脑</h3><p>高盐饮食加速认知能力退化。此外，咖啡因、味精、防腐剂、反式脂肪酸都是大脑的“杀手”。</p><h3 id="19-每天静心30分钟"><a href="#19-每天静心30分钟" class="headerlink" title="19. 每天静心30分钟"></a>19. 每天静心30分钟</h3><p>冥想能改善认知与心智作用，还能减缓衰老、缓解压力。每天30-60分钟静下心来冥想，是最好的“大脑澡”。</p><h3 id="20-勤动手指"><a href="#20-勤动手指" class="headerlink" title="20. 勤动手指"></a>20. 勤动手指</h3><p>学做针线活，练习绘画，或者用手握两个健身球，让健身球在手中旋转，长期坚持都会有健脑作用。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;刚放在手里的东西，转身就找不到了。明明话就在嘴边，但怎么都想不起来，别人一次就能记住的事情，你却要默背好多遍。别埋怨自己记性不好，其实记忆力也可以通过锻炼提高的。下面介绍这20个方法，挽救一下你的记忆力！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-经常大笑&quot;&gt;&lt;a href=&quot;#1-经常大笑&quot; class=&quot;headerlink&quot; title=&quot;1. 经常大笑&quot;&gt;&lt;/a&gt;1. 经常大笑&lt;/h3&gt;&lt;p&gt;笑能保持大脑活力，让思维更明捷。定期与亲友聚会，给老友打个电话，晚餐后与家人聊天，都能让大脑感觉快乐。&lt;/p&gt;
&lt;h3 id=&quot;2-听不同类型的歌曲&quot;&gt;&lt;a href=&quot;#2-听不同类型的歌曲&quot; class=&quot;headerlink&quot; title=&quot;2. 听不同类型的歌曲&quot;&gt;&lt;/a&gt;2. 听不同类型的歌曲&lt;/h3&gt;&lt;p&gt;积极的接受不熟悉的音乐，听歌时除了关注旋律，还要认真琢磨歌词，这样不仅可以锻炼右脑，还会用到掌管语言的左脑。&lt;/p&gt;
&lt;h3 id=&quot;3-学习新技能&quot;&gt;&lt;a href=&quot;#3-学习新技能&quot; class=&quot;headerlink&quot; title=&quot;3. 学习新技能&quot;&gt;&lt;/a&gt;3. 学习新技能&lt;/h3&gt;&lt;p&gt;学习任何一项新技能都能促进大脑健康，例如学习新乐器、做手工、下棋等。&lt;/p&gt;
&lt;h3 id=&quot;4-多和他人交流&quot;&gt;&lt;a href=&quot;#4-多和他人交流&quot; class=&quot;headerlink&quot; title=&quot;4.多和他人交流&quot;&gt;&lt;/a&gt;4.多和他人交流&lt;/h3&gt;&lt;p&gt;与朋友交往，彼此分享经历、沟通情感、增加信任，思路变得更广，新想法也会更多，这些都是大脑的润滑剂。&lt;/p&gt;
&lt;h3 id=&quot;5-保证充足的睡眠&quot;&gt;&lt;a href=&quot;#5-保证充足的睡眠&quot; class=&quot;headerlink&quot; title=&quot;5.保证充足的睡眠&quot;&gt;&lt;/a&gt;5.保证充足的睡眠&lt;/h3&gt;&lt;p&gt;睡觉时，脑脊液在脑细胞间的循环比清醒时快很多，帮助大脑排出 “垃圾”,因为尽量避免熬夜，让大脑充分休息。&lt;/p&gt;
    
    </summary>
    
      <category term="生活技巧" scheme="http://www.chenfanlinux.org/categories/%E7%94%9F%E6%B4%BB%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="记忆力" scheme="http://www.chenfanlinux.org/tags/%E8%AE%B0%E5%BF%86%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>Python数据分析之Pandas入门修订版(四)</title>
    <link href="http://www.chenfanlinux.org/2018/05/01/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas%E5%85%A5%E9%97%A8%E4%BF%AE%E8%AE%A2%E7%89%88-%E5%9B%9B/"/>
    <id>http://www.chenfanlinux.org/2018/05/01/Python数据分析之Pandas入门修订版-四/</id>
    <published>2018-05-01T12:32:42.000Z</published>
    <updated>2018-05-01T12:34:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Pandas的数据结构"><a href="#Pandas的数据结构" class="headerlink" title="Pandas的数据结构"></a>Pandas的数据结构</h2><blockquote><p>Pandas 的数据结构：Pandas 主要有 Series（一维数组），DataFrame（二维数组），Panel（三维数组），Panel4D（四维数组），PanelND（更多维数组）等数据结构。其中 Series 和 DataFrame 应用的最为广泛。</p></blockquote><h3 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h3><p>Series是一种类似于一维数组的对象，它由一组数据（各种NumPy数据类型）以及一组与之相关的数据索引组成。仅由一组数据即可产生最简单的Series。 Series看成是一个定长的有序字典，因为它是索引值到数据值的一个映射，这种数据结构相对于数组来说，使用起来更加的灵活。</p><p><img src="https://s1.ax1x.com/2018/04/28/C8mNSx.png" alt="Series"></p><h4 id="通过list构建Series"><a href="#通过list构建Series" class="headerlink" title="通过list构建Series"></a>通过list构建Series</h4><pre><code>&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; from pandas import Series,DataFrame&gt;&gt;&gt; s1= Series(range(10, 20))&gt;&gt;&gt; print(type(s1)) &lt;class &apos;pandas.core.series.Series&apos;&gt;</code></pre><p>由于我们没有为数据指定索引，于是会自动创建一个0到N-1（N为数据的长度）的整数型索引。</p><a id="more"></a><h4 id="指定Series的索引"><a href="#指定Series的索引" class="headerlink" title="指定Series的索引"></a>指定Series的索引</h4><p>我们希望所创建的Series带有一个可以对各个数据点进行标记的索引，<br>创建 Series 语法： <code>s = pd.Series(data, index=index)</code></p><pre><code>&gt;&gt;&gt; s2 = Series([4, 7, -5, 3], index=[&apos;d&apos;, &apos;b&apos;, &apos;a&apos;, &apos;c&apos;])&gt;&gt;&gt; s2d    4b    7a   -5c    3dtype: int64&gt;&gt;&gt; # 通过字典的方式创建Series，就可以指定Series的索引，键值即为索引。&gt;&gt;&gt; sdata = {&apos;Ohio&apos;: 35000, &apos;Texas&apos;: 71000, &apos;Oregon&apos;: 16000, &apos;Utah&apos;: 5000}&gt;&gt;&gt; s3 = Series(sdata)&gt;&gt;&gt; s3Ohio      35000Oregon    16000Texas     71000Utah       5000dtype: int64</code></pre><h4 id="获取Series-index及value信息"><a href="#获取Series-index及value信息" class="headerlink" title="获取Series index及value信息"></a>获取Series index及value信息</h4><pre><code>&gt;&gt;&gt; s1.valuesarray([10, 11, 12, 13, 14, 15, 16, 17, 18, 19], dtype=int64)&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; s1.index  # 这里的索引也是一种不可变的数据类型RangeIndex(start=0, stop=10, step=1)</code></pre><h4 id="Series-的简单运算"><a href="#Series-的简单运算" class="headerlink" title="Series 的简单运算"></a>Series 的简单运算</h4><p>如根据布尔型数组进行过滤、标量乘法、应用数学函数等）都会保留索引值的链接，索引与数据的对应关系仍保持在数组运算的结果中。</p><pre><code>&gt;&gt;&gt; s1[s1&gt;10]  # 布尔型数组进行过滤1    112    123    134    145    156    167    178    189    19&gt;&gt;&gt; s1 * 2 # 标量乘法0    201    222    243    264    285    306    327    348    369    38&gt;&gt;&gt; np.exp(s2) # 应用数学函数d      54.598150b    1096.633158a       0.006738c      20.085537</code></pre><h4 id="用于检测缺失数据"><a href="#用于检测缺失数据" class="headerlink" title="用于检测缺失数据"></a>用于检测缺失数据</h4><pre><code>&gt;&gt;&gt; states = [&apos;California&apos;, &apos;Ohio&apos;, &apos;Oregon&apos;, &apos;Texas&apos;] # 自定义索引&gt;&gt;&gt; sdata{&apos;Ohio&apos;: 35000, &apos;Texas&apos;: 71000, &apos;Oregon&apos;: 16000, &apos;Utah&apos;: 5000}&gt;&gt;&gt; s4 = Series(sdata,index=states) # 自定义的索引，如果找不到数据，则用np.nan填充&gt;&gt;&gt; s4California        NaNOhio          35000.0Oregon        16000.0Texas         71000.0&gt;&gt;&gt; s4.isnull()  #  any(s4.isnull()),判断是否存在空值,为True则存在空值California     TrueOhio          FalseOregon        FalseTexas         Falsedtype: bool&gt;&gt;&gt; s4.notnull()  # all(s4.notnull()),判断是否不存在空值,为True则不存在空值California    FalseOhio           TrueOregon         TrueTexas          True</code></pre><h4 id="根据运算的索引标签自动对齐数据"><a href="#根据运算的索引标签自动对齐数据" class="headerlink" title="根据运算的索引标签自动对齐数据"></a>根据运算的索引标签自动对齐数据</h4><pre><code>&gt;&gt;&gt; s3Ohio      35000Oregon    16000Texas     71000Utah       5000dtype: int64&gt;&gt;&gt; s4California        NaNOhio          35000.0Oregon        16000.0Texas         71000.0dtype: float64&gt;&gt;&gt; s3 + s4California         NaNOhio           70000.0Oregon         32000.0Texas         142000.0Utah               NaN</code></pre><h4 id="Series对象本身及其索引都有一个name属性"><a href="#Series对象本身及其索引都有一个name属性" class="headerlink" title="Series对象本身及其索引都有一个name属性"></a>Series对象本身及其索引都有一个name属性</h4><pre><code>&gt;&gt;&gt; s4.name = &apos;population&apos;&gt;&gt;&gt; s4.index.name = &apos;state&apos;&gt;&gt;&gt; s4stateCalifornia        NaNOhio          35000.0Oregon        16000.0Texas         71000.0Name: population, dtype: float64</code></pre><h3 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h3><p>DataFrame是一个表格型的数据结构，它含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔值等）。DataFrame既有行索引也有列索引，它可以被看做由Series组成的字典（共用同一个索引）。DataFrame中的数据是以一个或多个二维块存放的（而不是列表、字典或别的一维数据结构）。</p><p><img src="https://s1.ax1x.com/2018/04/28/C81029.png" alt="DataFrame"></p><h4 id="通过ndarray构建DataFrame"><a href="#通过ndarray构建DataFrame" class="headerlink" title="通过ndarray构建DataFrame"></a>通过ndarray构建DataFrame</h4><pre><code>&gt;&gt;&gt; array = np.random.randn(5,4) # 创建一个二维随机数组&gt;&gt;&gt; arrayarray([[ 0.65841573, -1.07248869,  0.30964663,  1.21059912],       [-1.86075076, -0.54301326, -0.86993544,  0.1258058 ],       [-1.44156445, -1.26253688,  1.31982877,  0.07189273],       [ 0.65928548,  0.22667447,  0.57582044,  0.05462809],       [-0.47716718,  0.08947818, -0.91467834,  2.59116919]])&gt;&gt;&gt; df1 = DataFrame(array) # 通过ndarray构建DataFrame&gt;&gt;&gt; df1          0         1         2         30  0.658416 -1.072489  0.309647  1.2105991 -1.860751 -0.543013 -0.869935  0.1258062 -1.441564 -1.262537  1.319829  0.0718933  0.659285  0.226674  0.575820  0.0546284 -0.477167  0.089478 -0.914678  2.591169</code></pre><h4 id="通过字典嵌套列表方式创建DataFrame"><a href="#通过字典嵌套列表方式创建DataFrame" class="headerlink" title="通过字典嵌套列表方式创建DataFrame"></a>通过字典嵌套列表方式创建DataFrame</h4><pre><code>data = {&apos;state&apos;: [&apos;Ohio&apos;, &apos;Ohio&apos;, &apos;Ohio&apos;, &apos;Nevada&apos;, &apos;Nevada&apos;, &apos;Nevada&apos;],        &apos;year&apos;: [2000, 2001, 2002, 2001, 2002, 2003],        &apos;pop&apos;: [1.5, 1.7, 3.6, 2.4, 2.9, 3.2]}&gt;&gt;&gt; df2 = DataFrame(data)&gt;&gt;&gt; df2   pop   state  year0  1.5    Ohio  20001  1.7    Ohio  20012  3.6    Ohio  20023  2.4  Nevada  20014  2.9  Nevada  20025  3.2  Nevada  2003&gt;&gt;&gt; data1 # 数据某一列只填充一个值，这时会发生广播，补全。{&apos;pop&apos;: [1.5, 1.7, 3.6, 2.4, 2.9, 3.2], &apos;year&apos;: 2000, &apos;state&apos;: [&apos;Ohio&apos;, &apos;Ohio&apos;, &apos;Ohio&apos;, &apos;Nevada&apos;, &apos;Nevada&apos;, &apos;Nevada&apos;]}&gt;&gt;&gt; DataFrame(data1)   pop   state  year0  1.5    Ohio  20001  1.7    Ohio  20002  3.6    Ohio  20003  2.4  Nevada  20004  2.9  Nevada  20005  3.2  Nevada  2000</code></pre><h4 id="通过嵌套的字典创建DataFrame"><a href="#通过嵌套的字典创建DataFrame" class="headerlink" title="通过嵌套的字典创建DataFrame"></a>通过嵌套的字典创建DataFrame</h4><pre><code>&gt;&gt;&gt; pop = {&apos;Nevada&apos;: {2001: 2.4, 2002: 2.9},&apos;Ohio&apos;: {2000: 1.5, 2001: 1.7, 2002: 3.6}}&gt;&gt;&gt; df3 = DataFrame(pop)&gt;&gt;&gt; df3      Nevada  Ohio2000     NaN   1.52001     2.4   1.72002     2.9   3.6</code></pre><p><strong><em>注意：这里外层字典的键作为列，内层键则作为行索引</em></strong></p><h4 id="设置DataFrame的index和columns的name属性"><a href="#设置DataFrame的index和columns的name属性" class="headerlink" title="设置DataFrame的index和columns的name属性"></a>设置DataFrame的index和columns的name属性</h4><pre><code>&gt;&gt;&gt; df3.index.name =&apos;year&apos;;df3.columns.name =&apos;state&apos;&gt;&gt;&gt; df3state  Nevada  Ohioyear2000      NaN   1.52001      2.4   1.72002      2.9   3.6</code></pre><h4 id="获取DataFrame的index-columns及values信息"><a href="#获取DataFrame的index-columns及values信息" class="headerlink" title="获取DataFrame的index,columns及values信息"></a>获取DataFrame的index,columns及values信息</h4><pre><code>&gt;&gt;&gt; df3.index # 不可变数据类型Int64Index([2000, 2001, 2002], dtype=&apos;int64&apos;, name=&apos;year&apos;)&gt;&gt;&gt; df3.index[0] = 2017&gt;&gt;&gt; df3.columns # 不可变数据类型Index([&apos;Nevada&apos;, &apos;Ohio&apos;], dtype=&apos;object&apos;, name=&apos;state&apos;)&gt;&gt;&gt; df3.valuesarray([[nan, 1.5],       [2.4, 1.7],       [2.9, 3.6]])</code></pre><h3 id="索引对象"><a href="#索引对象" class="headerlink" title="索引对象"></a>索引对象</h3><p>pandas的索引对象负责管理轴标签和其他元数据（比如轴名称等）。构建Series或DataFrame时，所用到的任何数组或其他序列的标签都会被转换成一个Index。Series和DataFrame中的索引都是index对象。</p><ul><li>Index      普通索引</li><li>Int64Index 整形索引</li><li>MultiIndex 层级索引 </li><li>DatetimeIndex  时间戳索引</li></ul><p>理解索引对象的原理很重要。</p><pre><code>&gt;&gt;&gt; obj = pd.Series(range(3), index=[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;])&gt;&gt;&gt; index = obj.index&gt;&gt;&gt; index[1:]Index([&apos;b&apos;, &apos;c&apos;], dtype=&apos;object&apos;)</code></pre><p>index对象是不可变的，因此用户不能对其进行修改</p><pre><code>&gt;&gt;&gt; index[1] = &apos;d&apos; Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;  File &quot;F:\Python35\lib\site-packages\pandas\core\indexes\base.py&quot;, line 1724, in __setitem__    raise TypeError(&quot;Index does not support mutable operations&quot;)TypeError: Index does not support mutable operations</code></pre><p>不可变可以使Index对象在多个数据结构之间安全共享,防止被修改</p><pre><code>&gt;&gt;&gt; labels = pd.Index(np.arange(3))&gt;&gt;&gt; labelsInt64Index([0, 1, 2], dtype=&apos;int64&apos;)&gt;&gt;&gt; obj2 = Series([1.5,2.5,0],index=labels)&gt;&gt;&gt; obj20    1.51    2.52    0.0&gt;&gt;&gt; obj2.index is labelsTrue</code></pre><p>与python的集合不同，pandas的Index可以包含重复的标签：</p><pre><code>&gt;&gt;&gt; dup_labels = pd.Index([&apos;foo&apos;, &apos;foo&apos;, &apos;bar&apos;, &apos;bar&apos;])&gt;&gt;&gt; dup_labelsIndex([&apos;foo&apos;, &apos;foo&apos;, &apos;bar&apos;, &apos;bar&apos;], dtype=&apos;object&apos;)&gt;&gt;&gt; obj3 = Series([1,2,3,4],index=dup_labels)&gt;&gt;&gt; obj3[&apos;bar&apos;]bar    3bar    4</code></pre><h2 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h2><h3 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h3><h4 id="Series索引"><a href="#Series索引" class="headerlink" title="Series索引"></a>Series索引</h4><ul><li>行索引   s1[‘label’],s1[pos]</li><li>切片索引  s1[‘lab1’:’lab3’],s1[pos1:pos2] 按索引名切片是，是包括终止索引的</li><li>不连续索引  s1[[‘lab1,lab3,lab4’]],s1[[pos1,pos3]]</li><li>布尔索引</li></ul><p>example:</p><pre><code>&gt;&gt;&gt; s1 = Series(np.arange(5),index=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;])&gt;&gt;&gt; s1a    0b    1c    2d    3e    4dtype: int32&gt;&gt;&gt; # 1. 行索引&gt;&gt;&gt; s1[0] # 通过索引位置0&gt;&gt;&gt;&gt;&gt;&gt; s1[&apos;a&apos;] # 通过索引名label0&gt;&gt;&gt; &gt;&gt;&gt; # 2. 切片索引&gt;&gt;&gt; s1[0:3] # 通过位置切片a    0b    1c    2&gt;&gt;&gt; s1[&apos;a&apos;:&apos;c&apos;] # 通过索引名切片，不包括终止索引a    0b    1c    2&gt;&gt;&gt; # 3. 不连续索引&gt;&gt;&gt; s1[[0,3]] # 通过位置不连续索引a    0d    3&gt;&gt;&gt; s1[[&apos;a&apos;,&apos;d&apos;]] # 通过索引名不连续索引a    0d    3&gt;&gt;&gt; # 4. 布尔型索引&gt;&gt;&gt; s1[s1&gt;2] # 布尔型数组d    3e    4</code></pre><h4 id="DataFrame索引"><a href="#DataFrame索引" class="headerlink" title="DataFrame索引"></a>DataFrame索引</h4><p>DataFrame默认对列先进行操作，用一个值或序列对DataFrame进行索引其实就是获取一个或多个列。在一开始设计pandas时，我觉得用frame[:, col]选取列过于繁琐（也容易出错），因为列的选择是非常常见的操作。</p><ul><li>列索引 df[‘lab1’]</li><li>不连续列索引 df[[‘lab1’,’lab2’]]</li></ul><p>example:</p><pre><code>&gt;&gt;&gt; df1 = DataFrame(np.arange(16).reshape((4, 4)),index=[&apos;Ohio&apos;, &apos;Colorado&apos;, &apos;Utah&apos;, &apos;New York&apos;], columns=[&apos;one&apos;, &apos;two&apos;, &apos;three&apos;, &apos;four&apos;])&gt;&gt;&gt; df1          one  two  three  fourOhio        0    1      2     3Colorado    4    5      6     7Utah        8    9     10    11New York   12   13     14    15&gt;&gt;&gt; df1[&apos;two&apos;] # 访问一列 Ohio         1Colorado     5Utah         9New York    13Name: two, dtype: int32&gt;&gt;&gt; df1[[&apos;three&apos;,&apos;one&apos;]] # 访问多列          three  oneOhio          2    0Colorado      6    4Utah         10    8New York     14   12</code></pre><p>这种索引方式有几个特殊的情况。首先通过切片或布尔型数组选取数据</p><pre><code>&gt;&gt;&gt; df1[:2] # 切片          one  two  three  fourOhio        0    1      2     3Colorado    4    5      6     7&gt;&gt;&gt; df1[data[&apos;three&apos;] &gt; 5] # 布尔型数组          one  two  three  fourColorado    4    5      6     7Utah        8    9     10    11New York   12   13     14    15</code></pre><h4 id="使用iloc和loc"><a href="#使用iloc和loc" class="headerlink" title="使用iloc和loc"></a>使用iloc和loc</h4><p>对于DataFrame的行的标签索引，我引入了特殊的标签运算符loc和iloc。它们可以让你用类似NumPy的标记，使用轴标签（loc）或整数索引（iloc），从DataFrame选择行和列的子集。</p><ul><li>.loc(标签索引)</li><li>.iloc(位置索引)</li><li>.ix(混合索引) 标签和位置混合索引,先按标签索引尝试操作,再按位置索引操作</li></ul><p>注意:  </p><ul><li>DataFrame索引时，可以将其看作成ndarray</li><li>标签索引的索引时包含末尾位置的</li></ul><p>example:</p><pre><code>&gt;&gt;&gt; s1 = pd.Series(range(5), index = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;])&gt;&gt;&gt;&gt;&gt;&gt; df1= pd.DataFrame(np.random.randn(5,4), columns = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;])&gt;&gt;&gt; s1a    0b    1c    2d    3e    4dtype: int64&gt;&gt;&gt; df1          a         b         c         d0 -2.014533 -0.397137  1.437047 -0.2124871 -2.163297 -0.345989 -0.629438 -1.1099842 -1.710392 -0.676153  1.026213 -1.3691193  0.703873 -0.368941 -0.279216 -1.4148994 -1.685372  1.783007 -0.182695 -0.059630</code></pre><p><strong>1. 标签索引 loc</strong></p><pre><code>&gt;&gt;&gt; # Series&gt;&gt;&gt; s1[&apos;b&apos;:&apos;d&apos;]b    1c    2d    3dtype: int64&gt;&gt;&gt; s1.loc[&apos;b&apos;:&apos;d&apos;]b    1c    2d    3&gt;&gt;&gt; # DataFrame&gt;&gt;&gt; df1[&apos;a&apos;]0   -2.0145331   -2.1632972   -1.7103923    0.7038734   -1.685372Name: a, dtype: float64&gt;&gt;&gt; df1.loc[0:2,&apos;a&apos;]0   -2.0145331   -2.1632972   -1.710392</code></pre><p><strong>2. 整型位置索引 iloc</strong> </p><pre><code>&gt;&gt;&gt; #  Series&gt;&gt;&gt; s1[1:3]b    1c    2dtype: int64&gt;&gt;&gt; s1.iloc[1:3]b    1c    2&gt;&gt;&gt; #  DataFrame&gt;&gt;&gt; df1.iloc[0:2,0] # 注意与 df1.loc[0:2,&apos;a&apos;]的区别0   -2.0145331   -2.163297</code></pre><p><strong>3. 混合索引 ix</strong> </p><p>当不清楚索引方式的时候，可以采用混合索引。</p><pre><code>&gt;&gt;&gt; #  Series&gt;&gt;&gt; s1.ix[1:3]b    1c    2dtype: int64&gt;&gt;&gt; s1.ix[&apos;b&apos;:&apos;c&apos;]b    1c    2&gt;&gt;&gt; #  DataFrame&gt;&gt;&gt; df1.ix[0:2,0] # # 先按标签索引尝试操作，然后再按位置索引尝试操作0   -2.0145331   -2.1632972   -1.710392</code></pre><p><img src="https://s1.ax1x.com/2018/05/01/CJdNmF.png" alt=""></p><h3 id="对齐运算与填充值"><a href="#对齐运算与填充值" class="headerlink" title="对齐运算与填充值"></a>对齐运算与填充值</h3><h4 id="对齐运算"><a href="#对齐运算" class="headerlink" title="对齐运算"></a>对齐运算</h4><p>按索引对齐运算，对齐操作在不重叠的索引处引入了NA值</p><pre><code>&gt;&gt;&gt; s1 = pd.Series(range(10, 20), index = range(10))&gt;&gt;&gt; s2 = pd.Series(range(20, 25), index = range(5))&gt;&gt;&gt; s10    101    112    123    134    145    156    167    178    189    19&gt;&gt;&gt; s20    201    212    223    234    24&gt;&gt;&gt; # Series 对齐运算&gt;&gt;&gt; s1 + s20    30.01    32.02    34.03    36.04    38.05     NaN6     NaN7     NaN8     NaN9     NaN</code></pre><p>对于DataFrame,对齐操作会同时发生在行和列上,如果DataFrame对象相加,没有共用的列或行标签，结果都会是空。</p><pre><code>&gt;&gt;&gt; # Pandas 对齐运算&gt;&gt;&gt; df1 = pd.DataFrame(np.ones((2,2)), columns = [&apos;a&apos;, &apos;b&apos;])&gt;&gt;&gt; df2 = pd.DataFrame(np.ones((3,3)), columns = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]) &gt;&gt;&gt; df1     a    b0  1.0  1.01  1.0  1.0&gt;&gt;&gt; df2     a    b    c0  1.0  1.0  1.01  1.0  1.0  1.02  1.0  1.0  1.0&gt;&gt;&gt; df1 + df2     a    b   c0  2.0  2.0 NaN1  2.0  2.0 NaN2  NaN  NaN NaN</code></pre><h4 id="填充值"><a href="#填充值" class="headerlink" title="填充值"></a>填充值</h4><pre><code>&gt;&gt;&gt; s1.add(s2,fill_value=0) # fill_value=0会用原来的s1的数据去填充0    30.01    32.02    34.03    36.04    38.05    15.06    16.07    17.08    18.09    19.0&gt;&gt;&gt; s3 = s1 + s2&gt;&gt;&gt; s30    30.01    32.02    34.03    36.04    38.05     NaN6     NaN7     NaN8     NaN9     NaN&gt;&gt;&gt; s3.fillna(-1) # 全部都填充一个值0    30.01    32.02    34.03    36.04    38.05    -1.06    -1.07    -1.08    -1.09    -1.0</code></pre><h3 id="函数应用和映射"><a href="#函数应用和映射" class="headerlink" title="函数应用和映射"></a>函数应用和映射</h3><ul><li>NumPy的ufuncs（元素级数组方法）也可用于操作pandas对象</li><li>通过apply将函数应用到行或列上,注意轴方向,默认axis=0</li><li>通applymap将函数应用到每个数据上</li></ul><h4 id="Numpy-ufuncs-函数"><a href="#Numpy-ufuncs-函数" class="headerlink" title="Numpy ufuncs 函数"></a>Numpy ufuncs 函数</h4><pre><code>&gt;&gt;&gt; df = pd.DataFrame(np.random.randn(5,4) - 1)&gt;&gt;&gt; df          0         1         2         30 -2.345628  0.099349 -1.081593 -0.4365341 -1.825629 -0.603085 -0.151743 -0.6573112  0.010755 -0.761262 -1.859229 -0.4685873 -0.464764 -1.316331 -1.531675 -0.9990454 -1.283275 -1.631468 -2.359166  0.175304&gt;&gt;&gt; np.abs(df)          0         1         2         30  2.345628  0.099349  1.081593  0.4365341  1.825629  0.603085  0.151743  0.6573112  0.010755  0.761262  1.859229  0.4685873  0.464764  1.316331  1.531675  0.9990454  1.283275  1.631468  2.359166  0.175304</code></pre><h4 id="使用apply应用行或列数据"><a href="#使用apply应用行或列数据" class="headerlink" title="使用apply应用行或列数据"></a>使用apply应用行或列数据</h4><pre><code>&gt;&gt;&gt; f = lambda x:x.max() # x为一行或者一列数据&gt;&gt;&gt; df          0         1         2         30 -2.345628  0.099349 -1.081593 -0.4365341 -1.825629 -0.603085 -0.151743 -0.6573112  0.010755 -0.761262 -1.859229 -0.4685873 -0.464764 -1.316331 -1.531675 -0.9990454 -1.283275 -1.631468 -2.359166  0.175304&gt;&gt;&gt; df.apply(f)0    0.0107551    0.0993492   -0.1517433    0.175304&gt;&gt;&gt; df.apply(f,axis=0) # 默认axis=0,每一列的最大值0    0.0107551    0.0993492   -0.1517433    0.175304dtype: float64&gt;&gt;&gt; df.apply(f,axis=1) # 每一行的最大值0    0.0993491   -0.1517432    0.0107553   -0.4647644    0.175304</code></pre><h4 id="使用applymap应用到每个数据"><a href="#使用applymap应用到每个数据" class="headerlink" title="使用applymap应用到每个数据"></a>使用applymap应用到每个数据</h4><pre><code>&gt;&gt;&gt; f2 = lambda x : &apos;%.2f&apos; % x&gt;&gt;&gt; df.applymap(f2)       0      1      2      30  -2.35   0.10  -1.08  -0.441  -1.83  -0.60  -0.15  -0.662   0.01  -0.76  -1.86  -0.473  -0.46  -1.32  -1.53  -1.004  -1.28  -1.63  -2.36   0.18</code></pre><p>之所以叫做applymap，是因为Series有一个用于应用元素级函数的map方法</p><pre><code>&gt;&gt;&gt; df[2].map(f2)0    -1.081    -0.152    -1.863    -1.534    -2.36</code></pre><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>根据条件对数据集排序（sorting）也是一种重要的内置运算。要对行或列索引进行排序（按字典顺序），可使用sort_index方法，它将返回一个已排序的新对象。</p><h4 id="sort-index"><a href="#sort-index" class="headerlink" title="sort_index"></a>sort_index</h4><pre><code>&gt;&gt;&gt; s1 = pd.Series(range(4), index=[&apos;d&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;])&gt;&gt;&gt; s1d    0a    1b    2c    3dtype: int64&gt;&gt;&gt; s1.sort_index()a    1b    2c    3d    0</code></pre><p>对于DataFrame，则可以根据任意一个轴上的索引进行排序</p><pre><code>&gt;&gt;&gt; df = pd.DataFrame(np.arange(8).reshape((2, 4)),index=[&apos;three&apos;, &apos;one&apos;], columns=[&apos;d&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;])&gt;&gt;&gt; df       d  a  b  cthree  0  1  2  3one    4  5  6  7&gt;&gt;&gt; df.sort_index() # axis=0        d  a  b  cone    4  5  6  7three  0  1  2  3&gt;&gt;&gt; df.sort_index(axis=1)       a  b  c  dthree  1  2  3  0one    5  6  7  4</code></pre><p>数据默认是按升序排序的，但也可以降序排序：</p><pre><code>&gt;&gt;&gt; df.sort_index(axis=1, ascending=False)</code></pre><h4 id="sort-values"><a href="#sort-values" class="headerlink" title="sort_values"></a>sort_values</h4><p>若要按值对Series进行排序，可使用其sort_values方法：</p><pre><code>&gt;&gt;&gt; s1.sort_values()d    0a    1b    2c    3</code></pre><p>当排序一个DataFrame时，你可能希望根据一个或多个列中的值进行排序。将一个或多个列的名字传递给sort_values的by选项即可达到该目的：</p><pre><code>&gt;&gt;&gt; df1.sort_values(by=[&apos;a&apos;])   a  b0  0  42  0 -31  1  73  1  2&gt;&gt;&gt; df1.sort_values(by=[&apos;a&apos;,&apos;b&apos;])   a  b2  0 -30  0  43  1  21  1  7</code></pre><h3 id="统计计算与描述"><a href="#统计计算与描述" class="headerlink" title="统计计算与描述"></a>统计计算与描述</h3><h4 id="统计计算"><a href="#统计计算" class="headerlink" title="统计计算"></a>统计计算</h4><ul><li>sum, mean, max, min…</li><li>axis=0 按列统计, axis=1按行统计</li><li>skipna 排除缺失值， 默认为True</li><li>idmax, idmin, cumsum</li></ul><p>example:</p><pre><code>&gt;&gt;&gt; df1 = DataFrame(np.random.randn(5,4),columns=[&apos;a&apos;, &apos;b&apos;,&apos;c&apos;, &apos;d&apos;])&gt;&gt;&gt; df1          a         b         c         d0  0.053924 -0.322160 -1.534288  1.2490841  0.393977 -0.861401  0.195511 -0.6968182  1.859970 -0.907963 -1.615231 -1.6223803 -0.160392  0.381193  0.188679  0.4225874 -0.114821 -0.814193 -1.017537  1.439799&gt;&gt;&gt; df1.sum() # 默认按axis=0,列进行统计a    2.032658b   -2.524524c   -3.782867d    0.792273dtype: float64&gt;&gt;&gt; df1.max()a    1.859970b    0.381193c    0.195511d    1.439799dtype: float64&gt;&gt;&gt; df1.min(axis=1)0   -1.5342881   -0.8614012   -1.6223803   -0.1603924   -1.017537</code></pre><h4 id="统计描述"><a href="#统计描述" class="headerlink" title="统计描述"></a>统计描述</h4><p>describe产生多个统计数据</p><pre><code>&gt;&gt;&gt; df1.describe()              a         b         c         dcount  5.000000  5.000000  5.000000  5.000000mean   0.406532 -0.504905 -0.756573  0.158455std    0.841158  0.548582  0.895852  1.304219min   -0.160392 -0.907963 -1.615231 -1.62238025%   -0.114821 -0.861401 -1.534288 -0.69681850%    0.053924 -0.814193 -1.017537  0.42258775%    0.393977 -0.322160  0.188679  1.249084max    1.859970  0.381193  0.195511  1.439799</code></pre><p><img src="https://s1.ax1x.com/2018/05/01/CJcgn1.md.png" alt="describe"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Pandas的数据结构&quot;&gt;&lt;a href=&quot;#Pandas的数据结构&quot; class=&quot;headerlink&quot; title=&quot;Pandas的数据结构&quot;&gt;&lt;/a&gt;Pandas的数据结构&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Pandas 的数据结构：Pandas 主要有 Series（一维数组），DataFrame（二维数组），Panel（三维数组），Panel4D（四维数组），PanelND（更多维数组）等数据结构。其中 Series 和 DataFrame 应用的最为广泛。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Series&quot;&gt;&lt;a href=&quot;#Series&quot; class=&quot;headerlink&quot; title=&quot;Series&quot;&gt;&lt;/a&gt;Series&lt;/h3&gt;&lt;p&gt;Series是一种类似于一维数组的对象，它由一组数据（各种NumPy数据类型）以及一组与之相关的数据索引组成。仅由一组数据即可产生最简单的Series。 Series看成是一个定长的有序字典，因为它是索引值到数据值的一个映射，这种数据结构相对于数组来说，使用起来更加的灵活。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/04/28/C8mNSx.png&quot; alt=&quot;Series&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;通过list构建Series&quot;&gt;&lt;a href=&quot;#通过list构建Series&quot; class=&quot;headerlink&quot; title=&quot;通过list构建Series&quot;&gt;&lt;/a&gt;通过list构建Series&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import numpy as np
&amp;gt;&amp;gt;&amp;gt; import pandas as pd
&amp;gt;&amp;gt;&amp;gt; from pandas import Series,DataFrame
&amp;gt;&amp;gt;&amp;gt; s1= Series(range(10, 20))
&amp;gt;&amp;gt;&amp;gt; print(type(s1)) 
&amp;lt;class &amp;apos;pandas.core.series.Series&amp;apos;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于我们没有为数据指定索引，于是会自动创建一个0到N-1（N为数据的长度）的整数型索引。&lt;/p&gt;
    
    </summary>
    
      <category term="python数据分析" scheme="http://www.chenfanlinux.org/categories/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Pandas" scheme="http://www.chenfanlinux.org/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>Python数据分析之Pandas入门(三)</title>
    <link href="http://www.chenfanlinux.org/2018/04/26/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas%E5%85%A5%E9%97%A8-%E4%B8%89/"/>
    <id>http://www.chenfanlinux.org/2018/04/26/Python数据分析之Pandas入门-三/</id>
    <published>2018-04-26T07:35:44.000Z</published>
    <updated>2018-04-26T07:38:33.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Pandas 是基于 NumPy 的一种数据处理工具，该工具为了解决数据分析任务而创建。Pandas 纳入了大量库和一些标准的数据模型，提供了高效地操作大型数据集所需的函数和方法。</p></blockquote><h2 id="Pandas的常用数据结构"><a href="#Pandas的常用数据结构" class="headerlink" title="Pandas的常用数据结构"></a>Pandas的常用数据结构</h2><p>Pandas 的数据结构：Pandas 主要有 Series（一维数组），DataFrame（二维数组），Panel（三维数组），Panel4D（四维数组），PanelND（更多维数组）等数据结构。其中 Series 和 DataFrame 应用的最为广泛。</p><ul><li>Series 是一维带标签的数组，它可以包含任何数据类型。包括整数，字符串，浮点数，Python 对象等。Series 可以通过标签来定位。</li><li>DataFrame 是二维的带标签的数据结构。我们可以通过标签来定位数据。这是 NumPy 所没有的。</li></ul><h2 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h2><blockquote><p>Pandas 中，Series 可以被看作由 1 列数据组成的数据集。</p></blockquote><h3 id="创建-Series数据类型"><a href="#创建-Series数据类型" class="headerlink" title="创建 Series数据类型"></a>创建 Series数据类型</h3><p>创建 Series 语法： <code>s = pd.Series(data, index=index)</code>，可以通过多种方式进行创建, 这里的data的数据类型只要是序列都可以。</p><a id="more"></a><h4 id="从列表创建-Series"><a href="#从列表创建-Series" class="headerlink" title="从列表创建 Series"></a>从列表创建 Series</h4><pre><code>&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; arr = [0, 1, 2, 3, 4]&gt;&gt;&gt; s1 = pd.Series(arr) # 如果不指定索引，则默认从 0 开始&gt;&gt;&gt; s10    01    12    23    34    4dtype: int64</code></pre><p>注意：前面的 0,1,2,3,4 为当前 Series 的索引，后面的 0,1,2,3,4 为 Series 的值。</p><h4 id="从-Ndarray-创建-Series"><a href="#从-Ndarray-创建-Series" class="headerlink" title="从 Ndarray 创建 Series"></a>从 Ndarray 创建 Series</h4><pre><code>&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; n = np.random.randn(5)&gt;&gt;&gt; narray([ 0.39925835,  1.65144475, -0.72621788,  0.180224  , -0.99682087])&gt;&gt;&gt; index = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]&gt;&gt;&gt; s2 = pd.Series(n,index=index)&gt;&gt;&gt; s2a    0.399258b    1.651445c   -0.726218d    0.180224e   -0.996821</code></pre><h4 id="从字典创建-Series"><a href="#从字典创建-Series" class="headerlink" title="从字典创建 Series"></a>从字典创建 Series</h4><pre><code>&gt;&gt;&gt; d = {&apos;a&apos;:1,&apos;b&apos;:2,&apos;c&apos;:3,&apos;d&apos;:4,&apos;e&apos;:5}&gt;&gt;&gt; s3 = pd.Series(d)&gt;&gt;&gt; s3a    1b    2c    3d    4e    5</code></pre><h3 id="Series-基本操作"><a href="#Series-基本操作" class="headerlink" title="Series 基本操作"></a>Series 基本操作</h3><h4 id="修改-Series-索引"><a href="#修改-Series-索引" class="headerlink" title="修改 Series 索引"></a>修改 Series 索引</h4><pre><code>&gt;&gt;&gt; print(s1) # 以s1为例0    01    12    23    34    4&gt;&gt;&gt; s1.index = [&apos;A&apos;,&apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;] # 修改后的索引&gt;&gt;&gt; s1A    0B    1C    2D    3E    4</code></pre><h4 id="Series-修改指定索引元素"><a href="#Series-修改指定索引元素" class="headerlink" title="Series 修改指定索引元素"></a>Series 修改指定索引元素</h4><pre><code>&gt;&gt;&gt; s1A    0B    1C    2D    3E    4dtype: int64&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; s1[&apos;A&apos;] = 5&gt;&gt;&gt; s1A    5B    1C    2D    3E    4</code></pre><h4 id="Series-按指定索引删除元素"><a href="#Series-按指定索引删除元素" class="headerlink" title="Series 按指定索引删除元素"></a>Series 按指定索引删除元素</h4><pre><code>&gt;&gt;&gt; s1 = s1.drop(&apos;A&apos;)B    1C    2D    3E    4&gt;&gt;&gt; s1B    1C    2D    3E    4</code></pre><h4 id="Series-纵向拼接"><a href="#Series-纵向拼接" class="headerlink" title="Series 纵向拼接"></a>Series 纵向拼接</h4><pre><code>&gt;&gt;&gt; s4 = s3.append(s1)&gt;&gt;&gt; s4a    1b    2c    3d    4e    5B    1C    2D    3E    4</code></pre><h4 id="Series-按指定索引查找元素"><a href="#Series-按指定索引查找元素" class="headerlink" title="Series 按指定索引查找元素"></a>Series 按指定索引查找元素</h4><pre><code>&gt;&gt;&gt; s4.index  # s4的索引Index([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;], dtype=&apos;object&apos;)&gt;&gt;&gt; s4.values # s4的值array([1, 2, 3, 4, 5, 1, 2, 3, 4], dtype=int64)&gt;&gt;&gt; s4[&apos;B&apos;] # 指定单个索引1&gt;&gt;&gt; s4[[&apos;a&apos;,&apos;B&apos;]] # 指定多个索引a    1B    1&gt;&gt;&gt; s4&gt;3a    Falseb    Falsec    Falsed     Truee     TrueB    FalseC    FalseD    FalseE     True&gt;&gt;&gt; s4[s4&gt;3]  # 利用布尔型数组进行过滤Seriesd    4e    5E    4</code></pre><h4 id="Series-切片操作"><a href="#Series-切片操作" class="headerlink" title="Series 切片操作"></a>Series 切片操作</h4><pre><code>&gt;&gt;&gt; s4[:3] # 对s4的前 3 个数据访问a    1b    2c    3</code></pre><h4 id="判断值是否为空"><a href="#判断值是否为空" class="headerlink" title="判断值是否为空"></a>判断值是否为空</h4><pre><code>&gt;&gt;&gt; pd.isnull(s3)  # 看Series的值为空a    Falseb    Falsec    Falsed    Falsee    False&gt;&gt;&gt; pd.notnull(s3)  # 看Series的值不为空a    Trueb    Truec    Trued    Truee    True&gt;&gt;&gt; all(pd.notnull(s1 + s4)) # 所有为True才为真False&gt;&gt;&gt; any(pd.notnull(s1 + s4)) # 有一个为True就为真True</code></pre><h4 id="给Series及其index取名"><a href="#给Series及其index取名" class="headerlink" title="给Series及其index取名"></a>给Series及其index取名</h4><pre><code>&gt;&gt;&gt; s4.name = &apos;demo&apos; # 给Series取名&gt;&gt;&gt; s4a    1b    2c    3d    4e    5B    1C    2D    3E    4Name: demo, dtype: int64&gt;&gt;&gt; s4.index.name = &apos;demo&apos; # 给Series的索引取名&gt;&gt;&gt; s4demoa    1b    2c    3d    4e    5B    1C    2D    3E    4Name: demo, dtype: int64</code></pre><h3 id="Series-运算"><a href="#Series-运算" class="headerlink" title="Series 运算"></a>Series 运算</h3><h4 id="Series-加法运算"><a href="#Series-加法运算" class="headerlink" title="Series 加法运算"></a>Series 加法运算</h4><p>Series 的加法运算是按照索引计算，如果索引不同则填充为 NaN（空值）。</p><pre><code>&gt;&gt;&gt; s4a    1b    2c    3d    4e    5B    1C    2D    3E    4dtype: int64&gt;&gt;&gt; s3a    1b    2c    3d    4e    5dtype: int64&gt;&gt;&gt; s4.add(s3)B     NaNC     NaND     NaNE     NaNa     2.0b     4.0c     6.0d     8.0e    10.0</code></pre><h4 id="Series-减法运算"><a href="#Series-减法运算" class="headerlink" title="Series 减法运算"></a>Series 减法运算</h4><p>Series的减法运算是按照索引对应计算，如果不同则填充为 <code>NaN</code>（空值）。</p><pre><code>&gt;&gt;&gt; s4.sub(s3)B    NaNC    NaND    NaNE    NaNa    0.0b    0.0c    0.0d    0.0e    0.0</code></pre><h4 id="Series-乘法运算"><a href="#Series-乘法运算" class="headerlink" title="Series 乘法运算"></a>Series 乘法运算</h4><p>Series 的乘法运算是按照索引对应计算，如果索引不同则填充为 NaN（空值）。</p><pre><code>&gt;&gt;&gt; s4.mul(s3)B     NaNC     NaND     NaNE     NaNa     1.0b     4.0c     9.0d    16.0e    25.0dtype: float64&gt;&gt;&gt; s3.mul(s3)a     1b     4c     9d    16e    25</code></pre><h4 id="Series-除法运算"><a href="#Series-除法运算" class="headerlink" title="Series 除法运算"></a>Series 除法运算</h4><p>Series 的除法运算是按照索引对应计算，如果索引不同则填充为 NaN（空值）。</p><pre><code>&gt;&gt;&gt; s4.div(s3)B    NaNC    NaND    NaNE    NaNa    1.0b    1.0c    1.0d    1.0e    1.0</code></pre><h4 id="Series-求均值"><a href="#Series-求均值" class="headerlink" title="Series 求均值"></a>Series 求均值</h4><pre><code>&gt;&gt;&gt; s4.median()3.0</code></pre><h4 id="Series-求和"><a href="#Series-求和" class="headerlink" title="Series 求和"></a>Series 求和</h4><pre><code>&gt;&gt;&gt; s4.sum()25</code></pre><h4 id="Series-求最大值"><a href="#Series-求最大值" class="headerlink" title="Series 求最大值"></a>Series 求最大值</h4><pre><code>&gt;&gt;&gt; s4.max()5</code></pre><h4 id="Series-求最小值"><a href="#Series-求最小值" class="headerlink" title="Series 求最小值"></a>Series 求最小值</h4><pre><code>&gt;&gt;&gt; s4.min()1</code></pre><h2 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h2><blockquote><p>与 Sereis 不同，DataFrame 可以存在多列数据。一般情况下，DataFrame 也更加常用。</p></blockquote><h3 id="创建-DataFrame-数据类型"><a href="#创建-DataFrame-数据类型" class="headerlink" title="创建 DataFrame 数据类型"></a>创建 DataFrame 数据类型</h3><h4 id="通过-NumPy-数组创建-DataFrame"><a href="#通过-NumPy-数组创建-DataFrame" class="headerlink" title="通过 NumPy 数组创建 DataFrame"></a>通过 NumPy 数组创建 DataFrame</h4><pre><code>&gt;&gt;&gt; dates = pd.date_range(&apos;today&apos;,periods=6) # 定义时间序列作为 index&gt;&gt;&gt; datesDatetimeIndex([&apos;2018-04-26 11:37:07.705264&apos;, &apos;2018-04-27 11:37:07.705264&apos;,               &apos;2018-04-28 11:37:07.705264&apos;, &apos;2018-04-29 11:37:07.705264&apos;,               &apos;2018-04-30 11:37:07.705264&apos;, &apos;2018-05-01 11:37:07.705264&apos;],              dtype=&apos;datetime64[ns]&apos;, freq=&apos;D&apos;)&gt;&gt;&gt; num_arr = np.random.randn(6,4) # 传入 numpy 随机数组&gt;&gt;&gt;&gt;&gt;&gt; columns = [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;] # 将列表作为列名&gt;&gt;&gt;&gt;&gt;&gt; df1 = pd.DataFrame(num_arr,index=dates,columns=columns)&gt;&gt;&gt;&gt;&gt;&gt; df1                                   A         B         C         D2018-04-26 11:37:07.705264 -0.400285  0.951334  0.385495  0.9558692018-04-27 11:37:07.705264 -0.462783  1.237563  0.083758  0.1109432018-04-28 11:37:07.705264 -0.763846  1.085889  0.541877  0.9612612018-04-29 11:37:07.705264  0.308832  2.252399  0.882554  0.0265902018-04-30 11:37:07.705264 -0.007068  0.028647  0.155501 -0.2429962018-05-01 11:37:07.705264  0.047310  0.797592  1.203195 -0.236018</code></pre><h4 id="通过字典数组创建-DataFrame"><a href="#通过字典数组创建-DataFrame" class="headerlink" title="通过字典数组创建 DataFrame"></a>通过字典数组创建 DataFrame</h4><pre><code>&gt;&gt;&gt; data = {&apos;animal&apos;: [&apos;cat&apos;, &apos;cat&apos;, &apos;snake&apos;, &apos;dog&apos;, &apos;dog&apos;, &apos;cat&apos;, &apos;snake&apos;, &apos;cat&apos;, &apos;dog&apos;, &apos;dog&apos;],         &apos;age&apos;: [2.5, 3, 0.5, np.nan, 5, 2, 4.5, np.nan, 7, 3], &apos;visits&apos;: [1, 3, 2, 3, 2, 3, 1, 1, 2, 1],         &apos;priority&apos;: [&apos;yes&apos;, &apos;yes&apos;, &apos;no&apos;, &apos;yes&apos;, &apos;no&apos;, &apos;no&apos;, &apos;no&apos;, &apos;yes&apos;, &apos;no&apos;, &apos;no&apos;]}&gt;&gt;&gt; labels = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;]&gt;&gt;&gt; df2 = pd.DataFrame(data, index=labels)&gt;&gt;&gt; df2   age animal priority  visitsa  2.5    cat      yes       1b  3.0    cat      yes       3c  0.5  snake       no       2d  NaN    dog      yes       3e  5.0    dog       no       2f  2.0    cat       no       3g  4.5  snake       no       1h  NaN    cat      yes       1i  7.0    dog       no       2j  3.0    dog       no       1</code></pre><h3 id="DataFrame-基本操作"><a href="#DataFrame-基本操作" class="headerlink" title="DataFrame 基本操作"></a>DataFrame 基本操作</h3><h4 id="查看-DataFrame-属性"><a href="#查看-DataFrame-属性" class="headerlink" title="查看 DataFrame 属性"></a>查看 DataFrame 属性</h4><pre><code>&gt;&gt;&gt; df2.dtypes # 数据类型age         float64animal       objectpriority     objectvisits        int64&gt;&gt;&gt; df2.index # 行索引(行标签)Index([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;], dtype=&apos;object&apos;)&gt;&gt;&gt; df2.columns  # 列标签Index([&apos;age&apos;, &apos;animal&apos;, &apos;priority&apos;, &apos;visits&apos;], dtype=&apos;object&apos;)&gt;&gt;&gt; df2.values # DataFrame 数据array([[2.5, &apos;cat&apos;, &apos;yes&apos;, 1],       [3.0, &apos;cat&apos;, &apos;yes&apos;, 3],       [0.5, &apos;snake&apos;, &apos;no&apos;, 2],       [nan, &apos;dog&apos;, &apos;yes&apos;, 3],       [5.0, &apos;dog&apos;, &apos;no&apos;, 2],       [2.0, &apos;cat&apos;, &apos;no&apos;, 3],       [4.5, &apos;snake&apos;, &apos;no&apos;, 1],       [nan, &apos;cat&apos;, &apos;yes&apos;, 1],       [7.0, &apos;dog&apos;, &apos;no&apos;, 2],       [3.0, &apos;dog&apos;, &apos;no&apos;, 1]], dtype=object)&gt;&gt;&gt; df2.shape # DataFrame 形状(10, 4)&gt;&gt;&gt; df2.size # DataFrame 元素个数40&gt;&gt;&gt; len(df2) # DataFrame 行数10</code></pre><h4 id="查看-DataFrame-的统计数据"><a href="#查看-DataFrame-的统计数据" class="headerlink" title="查看 DataFrame 的统计数据"></a>查看 DataFrame 的统计数据</h4><pre><code>&gt;&gt;&gt; df2   age animal priority  visitsa  2.5    cat      yes       1b  3.0    cat      yes       3c  0.5  snake       no       2d  NaN    dog      yes       3e  5.0    dog       no       2f  2.0    cat       no       3g  4.5  snake       no       1h  NaN    cat      yes       1i  7.0    dog       no       2j  3.0    dog       no       1</code></pre><h4 id="DataFrame-转置操作"><a href="#DataFrame-转置操作" class="headerlink" title="DataFrame 转置操作"></a>DataFrame 转置操作</h4><pre><code>&gt;&gt;&gt; df2.T            a    b      c    d    e    f      g    h    i    jage       2.5    3    0.5  NaN    5    2    4.5  NaN    7    3animal    cat  cat  snake  dog  dog  cat  snake  cat  dog  dogpriority  yes  yes     no  yes   no   no     no  yes   no   novisits      1    3      2    3    2    3      1    1    2    1</code></pre><h4 id="DataFrame-求平均值操作"><a href="#DataFrame-求平均值操作" class="headerlink" title="DataFrame 求平均值操作"></a>DataFrame 求平均值操作</h4><pre><code>&gt;&gt;&gt; df3.mean()age       3.25visits    1.90No.       4.50dtype: float64</code></pre><h4 id="对-DataFrame-中任意列做求和操作"><a href="#对-DataFrame-中任意列做求和操作" class="headerlink" title="对 DataFrame 中任意列做求和操作"></a>对 DataFrame 中任意列做求和操作</h4><pre><code>&gt;&gt;&gt; df3[&apos;visits&apos;].sum()19</code></pre><h4 id="对-DataFrame-进行排序"><a href="#对-DataFrame-进行排序" class="headerlink" title="对 DataFrame 进行排序"></a>对 DataFrame 进行排序</h4><pre><code>&gt;&gt;&gt; df2.sort_values(&apos;age&apos;，ascending=True)  # 按 age 升序排列,默认ascending为True   age animal priority  visitsc  0.5  snake       no       2f  2.0    cat       no       3a  2.5    cat      yes       1b  3.0    cat      yes       3j  3.0    dog       no       1g  4.5  snake       no       1e  5.0    dog       no       2i  7.0    dog       no       2d  NaN    dog      yes       3h  NaN    cat      yes       1&gt;&gt;&gt; df2.sort_index() # 按索引进行排序   age animal priority  visitsa  2.5    cat      yes       1b  3.0    cat      yes       3c  0.5  snake       no       2d  NaN    dog      yes       3e  5.0    dog       no       2f  2.0    cat       no       3g  4.5  snake       no       1h  NaN    cat      yes       1i  7.0    dog       no       2j  3.0    dog       no       1</code></pre><h4 id="DataFrame-副本拷贝"><a href="#DataFrame-副本拷贝" class="headerlink" title="DataFrame 副本拷贝"></a>DataFrame 副本拷贝</h4><pre><code>&gt;&gt;&gt; df3 = df2.copy()&gt;&gt;&gt; df3   age animal priority  visitsa  2.5    cat      yes       1b  3.0    cat      yes       3c  0.5  snake       no       2d  NaN    dog      yes       3e  5.0    dog       no       2f  2.0    cat       no       3g  4.5  snake       no       1h  NaN    cat      yes       1i  7.0    dog       no       2j  3.0    dog       no       1</code></pre><h4 id="判断-DataFrame-元素是否为空"><a href="#判断-DataFrame-元素是否为空" class="headerlink" title="判断 DataFrame 元素是否为空"></a>判断 DataFrame 元素是否为空</h4><pre><code>&gt;&gt;&gt; df3.isnull()  # 如果为空则返回为 True     age  animal  priority  visitsa  False   False     False   Falseb  False   False     False   Falsec  False   False     False   Falsed   True   False     False   Falsee  False   False     False   Falsef  False   False     False   Falseg  False   False     False   Falseh   True   False     False   Falsei  False   False     False   Falsej  False   False     False   False</code></pre><h3 id="查询与索引切片"><a href="#查询与索引切片" class="headerlink" title="查询与索引切片"></a>查询与索引切片</h3><h4 id="预览-DataFrame-的前-5-行数据"><a href="#预览-DataFrame-的前-5-行数据" class="headerlink" title="预览 DataFrame 的前 5 行数据"></a>预览 DataFrame 的前 5 行数据</h4><pre><code>&gt;&gt;&gt; df2.head() # 默认为显示 5 行，可根据需要在括号中填入希望预览的行数   age animal priority  visitsa  2.5    cat      yes       1b  3.0    cat      yes       3c  0.5  snake       no       2d  NaN    dog      yes       3e  5.0    dog       no       2</code></pre><h4 id="查看-DataFrame-的后-3-行数据"><a href="#查看-DataFrame-的后-3-行数据" class="headerlink" title="查看 DataFrame 的后 3 行数据"></a>查看 DataFrame 的后 3 行数据</h4><pre><code>&gt;&gt;&gt; df2.tail(3)   age animal priority  visitsh  NaN    cat      yes       1i  7.0    dog       no       2j  3.0    dog       no</code></pre><h4 id="对-DataFrame-数据切片-相当于多行-依据索引切片"><a href="#对-DataFrame-数据切片-相当于多行-依据索引切片" class="headerlink" title="对 DataFrame 数据切片(相当于多行,依据索引切片)"></a>对 DataFrame 数据切片(相当于多行,依据索引切片)</h4><pre><code>&gt;&gt;&gt; df2[1:3]   age animal priority  visitsb  3.0    cat      yes       3c  0.5  snake       no       2</code></pre><h4 id="对-DataFrame-通过标签查询（单列）"><a href="#对-DataFrame-通过标签查询（单列）" class="headerlink" title="对 DataFrame 通过标签查询（单列）"></a>对 DataFrame 通过标签查询（单列）</h4><pre><code>&gt;&gt;&gt; df2[&apos;age&apos;]a    2.5b    3.0c    0.5d    NaNe    5.0f    2.0g    4.5h    NaNi    7.0j    3.0&gt;&gt;&gt; df2.age # 等价于 df2[&apos;age&apos;]a    2.5b    3.0c    0.5d    NaNe    5.0f    2.0g    4.5h    NaNi    7.0j    3.0</code></pre><h4 id="对-DataFrame-通过标签查询-多列"><a href="#对-DataFrame-通过标签查询-多列" class="headerlink" title="对 DataFrame 通过标签查询(多列)"></a>对 DataFrame 通过标签查询(多列)</h4><pre><code>&gt;&gt;&gt; df2[[&apos;age&apos;,&apos;animal&apos;]] # 传入一个列名组成的列表   age animala  2.5    catb  3.0    catc  0.5  snaked  NaN    doge  5.0    dogf  2.0    catg  4.5  snakeh  NaN    cati  7.0    dogj  3.0    dog</code></pre><h4 id="对-DataFrame-通过索引位置查询"><a href="#对-DataFrame-通过索引位置查询" class="headerlink" title="对 DataFrame 通过索引位置查询"></a>对 DataFrame 通过索引位置查询</h4><pre><code>&gt;&gt;&gt; df2.iloc[1:3,0:2]  # [行索引,列索引] age animal priority  visits b  3.0    cat      yes       3 c  0.5  snake       no       2</code></pre><h4 id="对-DataFrame-通过标签-label-name"><a href="#对-DataFrame-通过标签-label-name" class="headerlink" title="对 DataFrame 通过标签 label_name"></a>对 DataFrame 通过标签 label_name</h4><pre><code>&gt;&gt;&gt; df2.loc[&apos;a&apos;:&apos;f&apos;,&apos;age&apos;:&apos;visits&apos;]   age animal priority  visitsa  2.5    cat      yes       1b  3.0    cat      yes       3c  0.5  snake       no       2d  NaN    dog      yes       3e  5.0    dog       no       2f  2.0    cat       no       3</code></pre><h3 id="数据填充修改与删除"><a href="#数据填充修改与删除" class="headerlink" title="数据填充修改与删除"></a>数据填充修改与删除</h3><h4 id="添加列数据"><a href="#添加列数据" class="headerlink" title="添加列数据"></a>添加列数据</h4><pre><code>&gt;&gt;&gt; num=pd.Series([0,1,2,3,4,5,6,7,8,9],index=df3.index)&gt;&gt;&gt; numa    0b    1c    2d    3e    4f    5g    6h    7i    8j    9dtype: int64&gt;&gt;&gt; df3[&apos;No.&apos;] = num   # 添加以 &apos;No.&apos; 为列名的新数据列&gt;&gt;&gt; df3   age animal priority  visits  No.a  2.5    cat      yes       1    0b  3.0    cat      yes       3    1c  0.5  snake       no       2    2d  NaN    dog      yes       3    3e  5.0    dog       no       2    4f  2.0    cat       no       3    5g  4.5  snake       no       1    6h  NaN    cat      yes       1    7i  7.0    dog       no       2    8j  3.0    dog       no       1    9</code></pre><h4 id="只给某列的某些数据赋值-指定索引"><a href="#只给某列的某些数据赋值-指定索引" class="headerlink" title="只给某列的某些数据赋值,指定索引"></a>只给某列的某些数据赋值,指定索引</h4><pre><code>&gt;&gt;&gt; df3[&apos;new&apos;] = pd.Series([500,600],index=[&apos;a&apos;,&apos;b&apos;])&gt;&gt;&gt; df3   age animal priority  visits  No.    newa  2.5    cat      yes       1    0  500.0b  2.0    cat      yes       3    1  600.0c  0.5  snake       no       2    2    NaNd  NaN    dog      yes       3    3    NaNe  5.0    dog       no       2    4    NaNf  1.5    cat       no       3    5    NaNg  4.5  snake       no       1    6    NaNh  NaN    cat      yes       1    7    NaNi  7.0    dog       no       2    8    NaNj  3.0    dog       no       1    9    NaN</code></pre><h4 id="删除指定的列’new’"><a href="#删除指定的列’new’" class="headerlink" title="删除指定的列’new’"></a>删除指定的列’new’</h4><pre><code>&gt;&gt;&gt; df3.drop(&apos;new&apos;,axis=1)   age animal priority  visits  No.a  2.5    cat      yes       1    0b  2.0    cat      yes       3    1c  0.5  snake       no       2    2d  NaN    dog      yes       3    3e  5.0    dog       no       2    4f  1.5    cat       no       3    5g  4.5  snake       no       1    6h  NaN    cat      yes       1    7i  7.0    dog       no       2    8j  3.0    dog       no       1    9</code></pre><h4 id="删除指定的行’j’"><a href="#删除指定的行’j’" class="headerlink" title="删除指定的行’j’"></a>删除指定的行’j’</h4><pre><code>&gt;&gt;&gt; df3.drop(&apos;j&apos;,axis=0)   age animal priority  visits  No.a  2.5    cat      yes       1    0b  2.0    cat      yes       3    1c  0.5  snake       no       2    2d  NaN    dog      yes       3    3e  5.0    dog       no       2    4f  1.5    cat       no       3    5g  4.5  snake       no       1    6h  NaN    cat      yes       1    7i  7.0    dog       no       2    8</code></pre><h4 id="根据-DataFrame-的下标值进行更改。"><a href="#根据-DataFrame-的下标值进行更改。" class="headerlink" title="根据 DataFrame 的下标值进行更改。"></a>根据 DataFrame 的下标值进行更改。</h4><pre><code>&gt;&gt;&gt; # 修改第 2 行与第 1 列对应的值 3.0 → 2.0&gt;&gt;&gt; df3.iat[1,0] = 2  # 索引序号从 0 开始，这里为 1, 0&gt;&gt;&gt; df3   age animal priority  visits  No.a  2.5    cat      yes       1    0b  2.0    cat      yes       3    1c  0.5  snake       no       2    2d  NaN    dog      yes       3    3e  5.0    dog       no       2    4f  2.0    cat       no       3    5g  4.5  snake       no       1    6h  NaN    cat      yes       1    7i  7.0    dog       no       2    8j  3.0    dog       no       1    9</code></pre><h4 id="根据-DataFrame-的标签对数据进行修改"><a href="#根据-DataFrame-的标签对数据进行修改" class="headerlink" title="根据 DataFrame 的标签对数据进行修改"></a>根据 DataFrame 的标签对数据进行修改</h4><pre><code>&gt;&gt;&gt; df3.loc[&apos;f&apos;,&apos;age&apos;]=1.5&gt;&gt;&gt; df3   age animal priority  visits  No.a  2.5    cat      yes       1    0b  2.0    cat      yes       3    1c  0.5  snake       no       2    2d  NaN    dog      yes       3    3e  5.0    dog       no       2    4f  1.5    cat       no       3    5g  4.5  snake       no       1    6h  NaN    cat      yes       1    7i  7.0    dog       no       2    8j  3.0    dog       no       1    9</code></pre><h3 id="DataFrame-缺失值操作"><a href="#DataFrame-缺失值操作" class="headerlink" title="DataFrame 缺失值操作"></a>DataFrame 缺失值操作</h3><h4 id="对缺失值进行填充"><a href="#对缺失值进行填充" class="headerlink" title="对缺失值进行填充"></a>对缺失值进行填充</h4><pre><code>&gt;&gt;&gt; df4=df3.copy()&gt;&gt;&gt; print(df4)   age animal priority  visits  No.a  2.5    cat      yes       1    0b  2.0    cat      yes       3    1c  0.5  snake       no       2    2d  NaN    dog      yes       3    3e  5.0    dog       no       2    4f  1.5    cat       no       3    5g  4.5  snake       no       1    6h  NaN    cat      yes       1    7i  7.0    dog       no       2    8j  3.0    dog       no       1    9&gt;&gt;&gt; df4.fillna(value=3)   age animal priority  visits  No.a  2.5    cat      yes       1    0b  2.0    cat      yes       3    1c  0.5  snake       no       2    2d  3.0    dog      yes       3    3e  5.0    dog       no       2    4f  1.5    cat       no       3    5g  4.5  snake       no       1    6h  3.0    cat      yes       1    7i  7.0    dog       no       2    8j  3.0    dog       no       1    9</code></pre><h4 id="删除存在缺失值的行"><a href="#删除存在缺失值的行" class="headerlink" title="删除存在缺失值的行"></a>删除存在缺失值的行</h4><pre><code>&gt;&gt;&gt; df5.dropna(how=&apos;any&apos;) # 任何存在 NaN 的行都将被删除   age animal priority  visits  No.a  2.5    cat      yes       1    0b  2.0    cat      yes       3    1c  0.5  snake       no       2    2e  5.0    dog       no       2    4f  1.5    cat       no       3    5g  4.5  snake       no       1    6i  7.0    dog       no       2    8j  3.0    dog       no       1    9</code></pre><h3 id="多级index-Series-amp-amp-DataFrame"><a href="#多级index-Series-amp-amp-DataFrame" class="headerlink" title="多级index Series &amp;&amp; DataFrame"></a>多级index Series &amp;&amp; DataFrame</h3><h4 id="多级index-Series"><a href="#多级index-Series" class="headerlink" title="多级index Series"></a>多级index Series</h4><pre><code>&gt;&gt;&gt; s1 = Series(np.random.randn(6), index=[[&apos;1&apos;,&apos;1&apos;,&apos;1&apos;,&apos;2&apos;,&apos;2&apos;,&apos;2&apos;],[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]])  # 创建一个多级index的Series&gt;&gt;&gt; print(s1)1  a   -1.690157   b    0.835443   c    1.1870042  a    1.130990   b   -0.167736   c   -0.062882&gt;&gt;&gt; s1[&apos;1&apos;] # 访问第一级a   -1.690157b    0.835443c    1.187004&gt;&gt;&gt; s1[:,&apos;a&apos;] # 访问每一级的&apos;a&apos;1   -1.6901572    1.130990&gt;&gt;&gt; df1 = s1.unstack() # 多级index的 series转换为 DataFrame&gt;&gt;&gt; df1          a         b         c1 -1.690157  0.835443  1.1870042  1.130990 -0.167736 -0.062882&gt;&gt;&gt; df2 = DataFrame([s1[&apos;1&apos;],s1[&apos;2&apos;]]) # 多级index的 series转换为 DataFrame&gt;&gt;&gt; df2          a         b         c0 -1.690157  0.835443  1.1870041  1.130990 -0.167736 -0.062882&gt;&gt;&gt; s2 = df1.unstack() # DataFrame转换成多级索引的Series&gt;&gt;&gt; s2a  1   -1.690157   2    1.130990b  1    0.835443   2   -0.167736c  1    1.187004   2   -0.062882</code></pre><h4 id="多级索引的DataFrame"><a href="#多级索引的DataFrame" class="headerlink" title="多级索引的DataFrame"></a>多级索引的DataFrame</h4><pre><code>&gt;&gt;&gt; df = DataFrame(np.arange(16).reshape(4,4),index = [[&apos;a&apos;,&apos;a&apos;,&apos;b&apos;,&apos;b&apos;],[&apos;1&apos;,&apos;2&apos;,&apos;1&apos;,&apos;2&apos;]])&gt;&gt;&gt; df      0   1   2   3a 1   0   1   2   3  2   4   5   6   7b 1   8   9  10  11  2  12  13  14  15&gt;&gt;&gt; df = DataFrame(np.arange(20).reshape(5,4),index = [[&apos;a&apos;,&apos;a&apos;,&apos;b&apos;,&apos;b&apos;,&apos;c&apos;],[&apos;1&apos;,&apos;2&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;]], columns = [[&apos;BJ&apos;,&apos;BJ&apos;,&apos;SH&apos;,&apos;GZ&apos;],[8,9,8,8]])&gt;&gt;&gt; df     BJ      SH  GZ      8   9   8   8a 1   0   1   2   3  2   4   5   6   7b 1   8   9  10  11  2  12  13  14  15c 3  16  17  18  19&gt;&gt;&gt; df[&apos;BJ&apos;][8]a  1     0   2     4b  1     8   2    12c  3    16&gt;&gt;&gt; df[&apos;BJ&apos;][9][&apos;a&apos;][&apos;1&apos;]1</code></pre><h3 id="DataFrame-文件操作"><a href="#DataFrame-文件操作" class="headerlink" title="DataFrame 文件操作"></a>DataFrame 文件操作</h3><h4 id="CSV-文件写入"><a href="#CSV-文件写入" class="headerlink" title="CSV 文件写入"></a>CSV 文件写入</h4><pre><code>&gt;&gt;&gt; df3.to_csv(&apos;animal.csv&apos;)</code></pre><h4 id="CSV-文件读取"><a href="#CSV-文件读取" class="headerlink" title="CSV 文件读取"></a>CSV 文件读取</h4><pre><code>&gt;&gt;&gt; df_animal=pd.read_csv(&apos;animal.csv&apos;)</code></pre><h4 id="Excel-写入操作"><a href="#Excel-写入操作" class="headerlink" title="Excel 写入操作"></a>Excel 写入操作</h4><pre><code>&gt;&gt;&gt; df3.to_excel(&apos;animal.xlsx&apos;, sheet_name=&apos;Sheet1&apos;)</code></pre><h4 id="Excel-读取操作"><a href="#Excel-读取操作" class="headerlink" title="Excel 读取操作"></a>Excel 读取操作</h4><pre><code>&gt;&gt;&gt; pd.read_excel(&apos;animal.xlsx&apos;, &apos;Sheet1&apos;, index_col=None, na_values=[&apos;NA&apos;])   age animal priority  visits  No.a  2.5    cat      yes       1    0b  2.0    cat      yes       3    1c  0.5  snake       no       2    2d  NaN    dog      yes       3    3e  5.0    dog       no       2    4f  1.5    cat       no       3    5g  4.5  snake       no       1    6h  NaN    cat      yes       1    7i  7.0    dog       no       2    8j  3.0    dog       no       1    9</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Pandas 是基于 NumPy 的一种数据处理工具，该工具为了解决数据分析任务而创建。Pandas 纳入了大量库和一些标准的数据模型，提供了高效地操作大型数据集所需的函数和方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Pandas的常用数据结构&quot;&gt;&lt;a href=&quot;#Pandas的常用数据结构&quot; class=&quot;headerlink&quot; title=&quot;Pandas的常用数据结构&quot;&gt;&lt;/a&gt;Pandas的常用数据结构&lt;/h2&gt;&lt;p&gt;Pandas 的数据结构：Pandas 主要有 Series（一维数组），DataFrame（二维数组），Panel（三维数组），Panel4D（四维数组），PanelND（更多维数组）等数据结构。其中 Series 和 DataFrame 应用的最为广泛。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Series 是一维带标签的数组，它可以包含任何数据类型。包括整数，字符串，浮点数，Python 对象等。Series 可以通过标签来定位。&lt;/li&gt;
&lt;li&gt;DataFrame 是二维的带标签的数据结构。我们可以通过标签来定位数据。这是 NumPy 所没有的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Series&quot;&gt;&lt;a href=&quot;#Series&quot; class=&quot;headerlink&quot; title=&quot;Series&quot;&gt;&lt;/a&gt;Series&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Pandas 中，Series 可以被看作由 1 列数据组成的数据集。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;创建-Series数据类型&quot;&gt;&lt;a href=&quot;#创建-Series数据类型&quot; class=&quot;headerlink&quot; title=&quot;创建 Series数据类型&quot;&gt;&lt;/a&gt;创建 Series数据类型&lt;/h3&gt;&lt;p&gt;创建 Series 语法： &lt;code&gt;s = pd.Series(data, index=index)&lt;/code&gt;，可以通过多种方式进行创建, 这里的data的数据类型只要是序列都可以。&lt;/p&gt;
    
    </summary>
    
      <category term="python数据分析" scheme="http://www.chenfanlinux.org/categories/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Pandas" scheme="http://www.chenfanlinux.org/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>Python数据分析之Numpy(二)</title>
    <link href="http://www.chenfanlinux.org/2018/04/25/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BNumpy-%E4%BA%8C/"/>
    <id>http://www.chenfanlinux.org/2018/04/25/Python数据分析之Numpy-二/</id>
    <published>2018-04-25T09:16:24.000Z</published>
    <updated>2018-04-25T09:20:56.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>NumPy 是 Python 语言的一个扩充程序库。支持大量高维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。机器学习涉及到大量对数组的变换和运算，NumPy 就成了必不可少的工具之一。</p></blockquote><h2 id="矩阵的基本概念"><a href="#矩阵的基本概念" class="headerlink" title="矩阵的基本概念"></a>矩阵的基本概念</h2><ul><li>矩阵：矩形的数组，即二维数组，其中向量和标量都是矩阵的特例</li><li>向量: 是指1 x n或n x 1的矩阵</li><li>标量：是指1 x 1的矩阵</li><li>数组：N维的数组，是矩阵的延伸</li><li>特殊的矩阵: 全0全1的矩阵,单位矩阵</li><li>矩阵的运算:<ul><li>相加或相减的两个矩阵必须有相同的行和列</li><li>矩阵元素间乘法运算 A * B</li><li>矩阵乘法运算 np.dot(A, B)</li></ul></li></ul><a id="more"></a><h2 id="数组的创建"><a href="#数组的创建" class="headerlink" title="数组的创建"></a>数组的创建</h2><h3 id="通过列表创建一维数组"><a href="#通过列表创建一维数组" class="headerlink" title="通过列表创建一维数组"></a>通过列表创建一维数组</h3><pre><code>&gt;&gt;&gt; np.array([1,2,3])array([1, 2, 3])</code></pre><h3 id="通过列表创建二维数组"><a href="#通过列表创建二维数组" class="headerlink" title="通过列表创建二维数组"></a>通过列表创建二维数组</h3><pre><code>&gt;&gt;&gt; np.array([(1,2,3),(4,5,6)])array([[1, 2, 3],       [4, 5, 6]])&gt;&gt;&gt; np.array([[1,2,3],[4,5,6]])array([[1, 2, 3],       [4, 5, 6]])</code></pre><h3 id="创建全为-0-的二维数组"><a href="#创建全为-0-的二维数组" class="headerlink" title="创建全为 0 的二维数组"></a>创建全为 0 的二维数组</h3><pre><code>&gt;&gt;&gt; np.zeros((3,3))array([[0., 0., 0.],       [0., 0., 0.],       [0., 0., 0.]])</code></pre><h3 id="创建全为-1-的三维数组"><a href="#创建全为-1-的三维数组" class="headerlink" title="创建全为 1 的三维数组"></a>创建全为 1 的三维数组</h3><pre><code>&gt;&gt;&gt; np.ones((2,3,4))array([[[1., 1., 1., 1.],        [1., 1., 1., 1.],        [1., 1., 1., 1.]],       [[1., 1., 1., 1.],        [1., 1., 1., 1.],        [1., 1., 1., 1.]]])</code></pre><h3 id="创建单位矩阵（二维数组）"><a href="#创建单位矩阵（二维数组）" class="headerlink" title="创建单位矩阵（二维数组）"></a>创建单位矩阵（二维数组）</h3><pre><code>&gt;&gt;&gt; np.eye(3)array([[1., 0., 0.],       [0., 1., 0.],       [0., 0., 1.]])</code></pre><h3 id="创建一维等差数组"><a href="#创建一维等差数组" class="headerlink" title="创建一维等差数组"></a>创建一维等差数组</h3><pre><code>&gt;&gt;&gt; np.arange(5)array([0, 1, 2, 3, 4])</code></pre><h3 id="创建等间隔一维数组"><a href="#创建等间隔一维数组" class="headerlink" title="创建等间隔一维数组"></a>创建等间隔一维数组</h3><pre><code>&gt;&gt;&gt; np.linspace(1, 10, num=6)array([ 1. ,  2.8,  4.6,  6.4,  8.2, 10. ])</code></pre><h3 id="创建二维等差数组"><a href="#创建二维等差数组" class="headerlink" title="创建二维等差数组"></a>创建二维等差数组</h3><pre><code>&gt;&gt;&gt; np.arange(6).reshape(2,3)array([[0, 1, 2],       [3, 4, 5]])</code></pre><h3 id="创建二维随机数组"><a href="#创建二维随机数组" class="headerlink" title="创建二维随机数组"></a>创建二维随机数组</h3><pre><code>&gt;&gt;&gt; np.random.rand(2,3)array([[0.14663311, 0.43875376, 0.16008493],       [0.43601096, 0.2819745 , 0.9210588 ]])</code></pre><h3 id="创建二维随机整数数组（数值小于-5）"><a href="#创建二维随机整数数组（数值小于-5）" class="headerlink" title="创建二维随机整数数组（数值小于 5）"></a>创建二维随机整数数组（数值小于 5）</h3><pre><code>&gt;&gt;&gt; np.random.randint(5, size=(2,3))array([[4, 4, 4],       [4, 1, 0]])</code></pre><h3 id="依据自定义函数创建数组"><a href="#依据自定义函数创建数组" class="headerlink" title="依据自定义函数创建数组"></a>依据自定义函数创建数组</h3><pre><code>&gt;&gt;&gt; np.fromfunction(lambda i, j: i + j, (3, 3))array([[0., 1., 2.],       [1., 2., 3.],       [2., 3., 4.]])</code></pre><h3 id="查看数组的属性"><a href="#查看数组的属性" class="headerlink" title="查看数组的属性"></a>查看数组的属性</h3><pre><code>&gt;&gt;&gt; arr1 = np.arange(6).reshape(2,3)&gt;&gt;&gt; arr1.shape  # 查看数组的形状(2, 3)&gt;&gt;&gt; arr1.size # 查看元素的个数6&gt;&gt;&gt; arr1.dtype # 查看数组的类型dtype(&apos;int32&apos;)&gt;&gt;&gt; len(arr1)2  # 行数</code></pre><h2 id="数组的运算"><a href="#数组的运算" class="headerlink" title="数组的运算"></a>数组的运算</h2><h3 id="一维数组减法运算"><a href="#一维数组减法运算" class="headerlink" title="一维数组减法运算"></a>一维数组减法运算</h3><pre><code>&gt;&gt;&gt; aarray([10, 20, 30, 40, 50])&gt;&gt;&gt; barray([1, 2, 3, 4, 5])&gt;&gt;&gt; a + barray([11, 22, 33, 44, 55])&gt;&gt;&gt; a - barray([ 9, 18, 27, 36, 45])</code></pre><h3 id="一维数组乘法运算"><a href="#一维数组乘法运算" class="headerlink" title="一维数组乘法运算"></a>一维数组乘法运算</h3><pre><code>&gt;&gt;&gt; a * barray([ 10,  40,  90, 160, 250])</code></pre><h3 id="一维数组除法运算"><a href="#一维数组除法运算" class="headerlink" title="一维数组除法运算"></a>一维数组除法运算</h3><pre><code>&gt;&gt;&gt; a / barray([10., 10., 10., 10., 10.])</code></pre><h3 id="矩阵加法运算"><a href="#矩阵加法运算" class="headerlink" title="矩阵加法运算"></a>矩阵加法运算</h3><pre><code>&gt;&gt;&gt; A = np.array([[1,2],[3,4]])&gt;&gt;&gt;&gt;&gt;&gt; B = np.array([[5,6],[7,8]])&gt;&gt;&gt; Aarray([[1, 2],       [3, 4]])&gt;&gt;&gt; Barray([[5, 6],       [7, 8]])&gt;&gt;&gt; A + Barray([[ 6,  8],       [10, 12]])</code></pre><h3 id="矩阵减法运算"><a href="#矩阵减法运算" class="headerlink" title="矩阵减法运算"></a>矩阵减法运算</h3><pre><code>&gt;&gt;&gt; A - Barray([[-4, -4],       [-4, -4]])</code></pre><h3 id="矩阵元素间乘法运算"><a href="#矩阵元素间乘法运算" class="headerlink" title="矩阵元素间乘法运算"></a>矩阵元素间乘法运算</h3><pre><code>&gt;&gt;&gt; A * Barray([[ 5, 12],       [21, 32]])</code></pre><h3 id="矩阵乘法运算（注意与上题的区别）"><a href="#矩阵乘法运算（注意与上题的区别）" class="headerlink" title="矩阵乘法运算（注意与上题的区别）"></a>矩阵乘法运算（注意与上题的区别）</h3><pre><code>&gt;&gt;&gt; np.dot(A, B)array([[19, 22],       [43, 50]])</code></pre><p>如果使用 np.mat 将二维数组准确定义为矩阵，就可以直接使用 * 完成矩阵乘法计算</p><pre><code>&gt;&gt;&gt; np.mat(A) * np.mat(B)</code></pre><h3 id="数乘矩阵"><a href="#数乘矩阵" class="headerlink" title="数乘矩阵"></a>数乘矩阵</h3><pre><code>&gt;&gt;&gt; 2 * Aarray([[2, 4],       [6, 8]])</code></pre><h3 id="矩阵的转置"><a href="#矩阵的转置" class="headerlink" title="矩阵的转置"></a>矩阵的转置</h3><pre><code>&gt;&gt;&gt; A.Tarray([[1, 3],       [2, 4]])</code></pre><h2 id="数组切片和索引-访问"><a href="#数组切片和索引-访问" class="headerlink" title="数组切片和索引(访问)"></a>数组切片和索引(访问)</h2><h3 id="一维数组索引"><a href="#一维数组索引" class="headerlink" title="一维数组索引"></a>一维数组索引</h3><pre><code>&gt;&gt;&gt; a = np.array([1, 2, 3, 4, 5])&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a[0],a[-1](1, 5)</code></pre><h3 id="一维数组切片"><a href="#一维数组切片" class="headerlink" title="一维数组切片"></a>一维数组切片</h3><pre><code>&gt;&gt;&gt; a[0:2], a[:-1](array([1, 2]), array([1, 2, 3, 4]))</code></pre><h3 id="二维数组索引"><a href="#二维数组索引" class="headerlink" title="二维数组索引"></a>二维数组索引</h3><pre><code>&gt;&gt;&gt; a[0], a[-1](array([1, 2, 3]), array([7, 8, 9]))</code></pre><h3 id="二维数组切片（取第-2-列）"><a href="#二维数组切片（取第-2-列）" class="headerlink" title="二维数组切片（取第 2 列）"></a>二维数组切片（取第 2 列）</h3><pre><code>&gt;&gt;&gt; print(a)[[1 2 3] [4 5 6] [7 8 9]]&gt;&gt;&gt; a[:,1]array([2, 5, 8])</code></pre><h3 id="二维数组切片（取第-2，3-行）"><a href="#二维数组切片（取第-2，3-行）" class="headerlink" title="二维数组切片（取第 2，3 行）"></a>二维数组切片（取第 2，3 行）</h3><pre><code>&gt;&gt;&gt; a[1:3, :]array([[4, 5, 6],       [7, 8, 9]])</code></pre><h2 id="数组形状操作"><a href="#数组形状操作" class="headerlink" title="数组形状操作"></a>数组形状操作</h2><h3 id="生成二维示例数组"><a href="#生成二维示例数组" class="headerlink" title="生成二维示例数组"></a>生成二维示例数组</h3><pre><code>&gt;&gt;&gt; a = np.random.random((3, 2))&gt;&gt;&gt; aarray([[0.19934535, 0.16189321],       [0.55116486, 0.47949279],       [0.04765736, 0.44019839]])</code></pre><h3 id="查看数组形状"><a href="#查看数组形状" class="headerlink" title="查看数组形状"></a>查看数组形状</h3><pre><code>&gt;&gt;&gt; a.shape(3, 2)</code></pre><h3 id="更改数组形状（不改变原始数组）"><a href="#更改数组形状（不改变原始数组）" class="headerlink" title="更改数组形状（不改变原始数组）"></a>更改数组形状（不改变原始数组）</h3><pre><code>&gt;&gt;&gt; a.reshape(2,3)array([[0.19934535, 0.16189321, 0.55116486],       [0.47949279, 0.04765736, 0.44019839]])&gt;&gt;&gt; aarray([[0.19934535, 0.16189321],       [0.55116486, 0.47949279],       [0.04765736, 0.44019839]])</code></pre><h3 id="更改数组形状（改变原始数组）"><a href="#更改数组形状（改变原始数组）" class="headerlink" title="更改数组形状（改变原始数组）"></a>更改数组形状（改变原始数组）</h3><pre><code>&gt;&gt;&gt; a.resize(2,3)&gt;&gt;&gt; aarray([[0.19934535, 0.16189321, 0.55116486],       [0.47949279, 0.04765736, 0.44019839]])</code></pre><h3 id="展平数组"><a href="#展平数组" class="headerlink" title="展平数组"></a>展平数组</h3><pre><code>&gt;&gt;&gt; a.ravel()array([0.19934535, 0.16189321, 0.55116486, 0.47949279, 0.04765736,0.44019839]</code></pre><h3 id="垂直拼合数组"><a href="#垂直拼合数组" class="headerlink" title="垂直拼合数组"></a>垂直拼合数组</h3><pre><code>&gt;&gt;&gt; a = np.random.randint(10, size=(3, 3))&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; b = np.random.randint(10, size=(3, 3))&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; aarray([[1, 4, 9],       [6, 6, 9],       [0, 0, 3]])&gt;&gt;&gt; barray([[1, 6, 2],       [7, 7, 7],       [7, 1, 4]])&gt;&gt;&gt; np.vstack((a, b))   array([[1, 4, 9],   [6, 6, 9],   [0, 0, 3],   [1, 6, 2],   [7, 7, 7],   [7, 1, 4]])</code></pre><h3 id="水平拼合数组"><a href="#水平拼合数组" class="headerlink" title="水平拼合数组"></a>水平拼合数组</h3><pre><code>&gt;&gt;&gt; np.hstack((a, b))array([[1, 4, 9, 1, 6, 2],       [6, 6, 9, 7, 7, 7],       [0, 0, 3, 7, 1, 4]])</code></pre><h3 id="沿横轴分割数组"><a href="#沿横轴分割数组" class="headerlink" title="沿横轴分割数组"></a>沿横轴分割数组</h3><pre><code>&gt;&gt;&gt; np.hsplit(a,3)[array([[1],       [6],       [0]]), array([[4],       [6],       [0]]), array([[9],       [9],       [3]])]</code></pre><h3 id="沿纵轴分割数组"><a href="#沿纵轴分割数组" class="headerlink" title="沿纵轴分割数组"></a>沿纵轴分割数组</h3><pre><code>&gt;&gt;&gt; np.vsplit(a,3)[array([[1, 4, 9]]), array([[6, 6, 9]]), array([[0, 0, 3]])]</code></pre><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><h3 id="返回每列最大值"><a href="#返回每列最大值" class="headerlink" title="返回每列最大值"></a>返回每列最大值</h3><pre><code>&gt;&gt;&gt; a = np.array(([1,4,3],[6,2,9],[4,7,2]))&gt;&gt;&gt;&gt; np.max(a, axis=0)array([6, 7, 9])</code></pre><h3 id="返回每行最小值"><a href="#返回每行最小值" class="headerlink" title="返回每行最小值"></a>返回每行最小值</h3><pre><code>&gt;&gt;&gt; np.min(a, axis=1)array([1, 2, 2])</code></pre><h3 id="返回每列最大值索引"><a href="#返回每列最大值索引" class="headerlink" title="返回每列最大值索引"></a>返回每列最大值索引</h3><pre><code>&gt;&gt;&gt; np.argmax(a, axis=0)array([1, 2, 1], dtype=int64)</code></pre><h3 id="返回每行最小值索引"><a href="#返回每行最小值索引" class="headerlink" title="返回每行最小值索引"></a>返回每行最小值索引</h3><pre><code>&gt;&gt;&gt; np.argmin(a, axis=1)array([0, 1, 2], dtype=int64)</code></pre><h2 id="数组统计"><a href="#数组统计" class="headerlink" title="数组统计"></a>数组统计</h2><h3 id="统计数组各列的中位数"><a href="#统计数组各列的中位数" class="headerlink" title="统计数组各列的中位数"></a>统计数组各列的中位数</h3><pre><code>&gt;&gt;&gt; np.median(a, axis=0)array([4., 4., 3.])</code></pre><h3 id="统计数组各行的算术平均值"><a href="#统计数组各行的算术平均值" class="headerlink" title="统计数组各行的算术平均值"></a>统计数组各行的算术平均值</h3><pre><code>&gt;&gt;&gt; np.mean(a, axis=1)array([2.66666667, 5.66666667, 4.33333333])</code></pre><h3 id="统计数组各列的加权平均值"><a href="#统计数组各列的加权平均值" class="headerlink" title="统计数组各列的加权平均值"></a>统计数组各列的加权平均值</h3><pre><code>&gt;&gt;&gt; np.average(a, axis=0)array([3.66666667, 4.33333333, 4.66666667])</code></pre><h3 id="统计数组各列的标准偏差"><a href="#统计数组各列的标准偏差" class="headerlink" title="统计数组各列的标准偏差"></a>统计数组各列的标准偏差</h3><pre><code>&gt;&gt;&gt; np.std(a, axis=0)array([2.05480467, 2.05480467, 3.09120617])</code></pre><h3 id="统计数组各行的方差"><a href="#统计数组各行的方差" class="headerlink" title="统计数组各行的方差"></a>统计数组各行的方差</h3><pre><code>&gt;&gt;&gt; np.var(a, axis=1)array([1.55555556, 8.22222222, 4.22222222])</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;NumPy 是 Python 语言的一个扩充程序库。支持大量高维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。机器学习涉及到大量对数组的变换和运算，NumPy 就成了必不可少的工具之一。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;矩阵的基本概念&quot;&gt;&lt;a href=&quot;#矩阵的基本概念&quot; class=&quot;headerlink&quot; title=&quot;矩阵的基本概念&quot;&gt;&lt;/a&gt;矩阵的基本概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;矩阵：矩形的数组，即二维数组，其中向量和标量都是矩阵的特例&lt;/li&gt;
&lt;li&gt;向量: 是指1 x n或n x 1的矩阵&lt;/li&gt;
&lt;li&gt;标量：是指1 x 1的矩阵&lt;/li&gt;
&lt;li&gt;数组：N维的数组，是矩阵的延伸&lt;/li&gt;
&lt;li&gt;特殊的矩阵: 全0全1的矩阵,单位矩阵&lt;/li&gt;
&lt;li&gt;矩阵的运算:&lt;ul&gt;
&lt;li&gt;相加或相减的两个矩阵必须有相同的行和列&lt;/li&gt;
&lt;li&gt;矩阵元素间乘法运算 A * B&lt;/li&gt;
&lt;li&gt;矩阵乘法运算 np.dot(A, B)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="python数据分析" scheme="http://www.chenfanlinux.org/categories/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Numpy" scheme="http://www.chenfanlinux.org/tags/Numpy/"/>
    
  </entry>
  
  <entry>
    <title>Python数据分析之开发工具Anaconda(一)</title>
    <link href="http://www.chenfanlinux.org/2018/04/18/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8B%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Anaconda-%E4%B8%80/"/>
    <id>http://www.chenfanlinux.org/2018/04/18/Python数据分析之开发工具Anaconda-一/</id>
    <published>2018-04-18T03:05:38.000Z</published>
    <updated>2018-04-18T03:08:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Anaconda概述"><a href="#Anaconda概述" class="headerlink" title="Anaconda概述"></a>Anaconda概述</h2><p>Anaconda  是一个用于科学计算的Python发行版，支持 Linux, Mac, Windows系统，提供了包管理与环境管理的功能，可以很方便地解决多版本python并存、切换以及各种第三方包安装问题。Anaconda利用工具/命令conda来进行package和environment的管理，并且已经包含了Python和相关的配套工具。<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/" target="_blank" rel="noopener">下载Anaconda地址</a></p><h2 id="设置国内镜像"><a href="#设置国内镜像" class="headerlink" title="设置国内镜像"></a>设置国内镜像</h2><p>如果你现在就猴急猴急地去安装很多packages，你会被conda的龟速感动得声泪俱下，因为Anaconda.org的服务器在国外。所幸的是，清华TUNA镜像源有Anaconda仓库的镜像，我们将其加入conda的配置即可。</p><p>请在cmd中运行以下代码：TUNA 还提供了 Anaconda 仓库的镜像，运行以下命令:</p><pre><code>$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/$ conda config --set show_channel_urls yes</code></pre><a id="more"></a><h2 id="environment管理"><a href="#environment管理" class="headerlink" title="environment管理"></a>environment管理</h2><h3 id="创建一个新的environment"><a href="#创建一个新的environment" class="headerlink" title="创建一个新的environment"></a>创建一个新的environment</h3><pre><code>$ conda create --name python34 python=3.4</code></pre><h3 id="激活一个environment"><a href="#激活一个environment" class="headerlink" title="激活一个environment"></a>激活一个environment</h3><pre><code>$ activate python34 # for windows$ source activate python36 # for linux &amp; mac</code></pre><h3 id="退出一个environment"><a href="#退出一个environment" class="headerlink" title="退出一个environment"></a>退出一个environment</h3><pre><code>$ deactivate python34 # for windows$ source deactivate python36 # for linux</code></pre><h3 id="删除一个environment"><a href="#删除一个environment" class="headerlink" title="删除一个environment"></a>删除一个environment</h3><pre><code>$ conda remove --name python36 --all</code></pre><h2 id="package管理"><a href="#package管理" class="headerlink" title="package管理"></a>package管理</h2><h3 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h3><pre><code>$ conda install -n python36 numpy # 指定环境安装</code></pre><h3 id="查看已安装的包"><a href="#查看已安装的包" class="headerlink" title="查看已安装的包"></a>查看已安装的包</h3><pre><code>$ conda list$ conda list -n python36 # 查看指定环境安装的Python包</code></pre><h3 id="删除一个包"><a href="#删除一个包" class="headerlink" title="删除一个包"></a>删除一个包</h3><pre><code>$ conda remove -n python36 numpy</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Anaconda概述&quot;&gt;&lt;a href=&quot;#Anaconda概述&quot; class=&quot;headerlink&quot; title=&quot;Anaconda概述&quot;&gt;&lt;/a&gt;Anaconda概述&lt;/h2&gt;&lt;p&gt;Anaconda  是一个用于科学计算的Python发行版，支持 Linux, Mac, Windows系统，提供了包管理与环境管理的功能，可以很方便地解决多版本python并存、切换以及各种第三方包安装问题。Anaconda利用工具/命令conda来进行package和environment的管理，并且已经包含了Python和相关的配套工具。&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;下载Anaconda地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;设置国内镜像&quot;&gt;&lt;a href=&quot;#设置国内镜像&quot; class=&quot;headerlink&quot; title=&quot;设置国内镜像&quot;&gt;&lt;/a&gt;设置国内镜像&lt;/h2&gt;&lt;p&gt;如果你现在就猴急猴急地去安装很多packages，你会被conda的龟速感动得声泪俱下，因为Anaconda.org的服务器在国外。所幸的是，清华TUNA镜像源有Anaconda仓库的镜像，我们将其加入conda的配置即可。&lt;/p&gt;
&lt;p&gt;请在cmd中运行以下代码：TUNA 还提供了 Anaconda 仓库的镜像，运行以下命令:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/
$ conda config --set show_channel_urls yes
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="python数据分析" scheme="http://www.chenfanlinux.org/categories/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Anaconda" scheme="http://www.chenfanlinux.org/tags/Anaconda/"/>
    
  </entry>
  
  <entry>
    <title>python时间处理模块</title>
    <link href="http://www.chenfanlinux.org/2018/04/13/python%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E6%A8%A1%E5%9D%97/"/>
    <id>http://www.chenfanlinux.org/2018/04/13/python时间处理模块/</id>
    <published>2018-04-13T02:37:38.000Z</published>
    <updated>2018-04-13T02:41:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文注意讲解datetime模块，注意到datetime是模块，datetime模块还包含一个datetime类，通过from datetime import datetime导入的才是datetime这个类。<br>如果仅导入import datetime，则必须引用全名datetime.datetime。<br>datetime.now()返回当前日期和时间，其类型是datetime。</p></blockquote><p>参考文档：<a href="https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior" target="_blank" rel="noopener">datetime</a></p><h3 id="获取当前日期和时间"><a href="#获取当前日期和时间" class="headerlink" title="获取当前日期和时间"></a>获取当前日期和时间</h3><pre><code>&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; now = datetime.now() # 获取当前datetime&gt;&gt;&gt; print(now)2018-04-12 18:30:31.311945&gt;&gt;&gt; print(type(now))&lt;class &apos;datetime.datetime&apos;&gt;</code></pre><h3 id="获取指定日期和时间"><a href="#获取指定日期和时间" class="headerlink" title="获取指定日期和时间"></a>获取指定日期和时间</h3><p>要指定某个日期和时间，我们直接用参数构造一个datetime</p><pre><code>&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; dt = datetime(2018,4,12,18,32)  # 用指定日期时间创建datetime&gt;&gt;&gt; print(dt)2018-04-12 18:32:00</code></pre><h3 id="datetime转换为timestamp"><a href="#datetime转换为timestamp" class="headerlink" title="datetime转换为timestamp"></a>datetime转换为timestamp</h3><p>timestamp的值与时区毫无关系，因为timestamp一旦确定，其UTC时间就确定了，转换到任意时区的时间也是完全确定的，这就是为什么计算机存储的当前时间是以timestamp表示的，因为全球各地的计算机在任意时刻的timestamp都是完全相同的（假定时间已校准）。</p><pre><code>&gt;&gt;&gt; dt = datetime(2018,4,12,18,40)&gt;&gt;&gt; dt.timestamp()1523529600.0</code></pre><a id="more"></a><h3 id="timestamp转换为datetime"><a href="#timestamp转换为datetime" class="headerlink" title="timestamp转换为datetime"></a>timestamp转换为datetime</h3><p>要把timestamp转换为datetime，使用datetime提供的fromtimestamp()方法</p><pre><code>&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; t = 1523529600.0&gt;&gt;&gt; print(datetime.fromtimestamp(t))2018-04-12 18:40:00</code></pre><p>注意到timestamp是一个浮点数，它没有时区的概念，而datetime是有时区的。上述转换是在timestamp和本地时间做转换。</p><p>本地时间是指当前操作系统设定的时区。例如北京时区是东8区，则本地时间：</p><pre><code>2018-04-12 18:40:00</code></pre><p>实际上就是UTC+8:00时区的时间：</p><pre><code>2015-04-19 12:20:00 UTC+8:00</code></pre><p>而此刻的格林威治标准时间与北京时间差了8小时，也就是UTC+0:00时区的时间应该是：</p><pre><code>2015-04-19 4:20:00 UTC+0:00</code></pre><p>timestamp也可以直接被转换到UTC标准时区的时间：</p><pre><code>&gt;&gt;&gt; t = 1523529600.0&gt;&gt;&gt; print(datetime.fromtimestamp(t))2018-04-12 18:40:00&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; t = 1523529600.0   # 本地时间&gt;&gt;&gt; print(datetime.fromtimestamp(t))2018-04-12 18:40:00  # UTC时间&gt;&gt;&gt; print(datetime.utcfromtimestamp(t))2018-04-12 10:40:00</code></pre><h3 id="str转换为datetime"><a href="#str转换为datetime" class="headerlink" title="str转换为datetime"></a>str转换为datetime</h3><p>很多时候要处理日期和时间字符串，首先必须把str转换为datetime。转换方法是通过datetime.strptime()实现，需要一个日期和时间的格式化字符串：</p><pre><code>&gt;&gt;&gt; cday = datetime.strptime(&apos;2018-4-13 10:10:10&apos;,&apos;%Y-%m-%d %H:%M:%S&apos;)&gt;&gt;&gt; print(type(cday))&lt;class &apos;datetime.datetime&apos;&gt;&gt;&gt;&gt; print(cday)2018-04-13 10:10:10</code></pre><p>字符串’%Y-%m-%d %H:%M:%S’规定了日期和时间部分的格式。详细的说明请参考<a href="https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior" target="_blank" rel="noopener">官方文档</a></p><h3 id="datetime转换为str"><a href="#datetime转换为str" class="headerlink" title="datetime转换为str"></a>datetime转换为str</h3><p>如果已经有了datetime对象，要把它格式化为字符串显示给用户，就需要转换为str，转换方法是通过strftime()实现的，同样需要一个日期和时间的格式化字符串。</p><pre><code>&gt;&gt;&gt; now = datetime.now()&gt;&gt;&gt; print(now.strftime(&apos;%a %b %d %H:%M&apos;))Fri Apr 13 10:16</code></pre><h3 id="datetime加减"><a href="#datetime加减" class="headerlink" title="datetime加减"></a>datetime加减</h3><p>对日期和时间进行加减实际上就是把datetime往后或往前计算，得到新的datetime。加减可以直接用+和-运算符，不过需要导入timedelta这个类。</p><pre><code>&gt;&gt;&gt; from datetime import datetime, timedelta&gt;&gt;&gt; now = datetime.now()&gt;&gt;&gt; nowdatetime.datetime(2018, 4, 13, 10, 20, 33, 99527)&gt;&gt;&gt; now + timedelta(hours=10)datetime.datetime(2018, 4, 13, 20, 20, 33, 99527)&gt;&gt;&gt; now + timedelta(days=1)datetime.datetime(2018, 4, 14, 10, 20, 33, 99527)&gt;&gt;&gt; now + timedelta(days=1,hours=12)datetime.datetime(2018, 4, 14, 22, 20, 33, 99527)</code></pre><h3 id="本地时间转换为UTC时间"><a href="#本地时间转换为UTC时间" class="headerlink" title="本地时间转换为UTC时间"></a>本地时间转换为UTC时间</h3><p>本地时间是指系统设定时区的时间，例如北京时间是UTC+8:00时区的时间，而UTC时间指UTC+0:00时区的时间。一个datetime类型有一个时区属性tzinfo，但是默认为None，所以无法区分这个datetime到底是哪个时区，除非强行给datetime设置一个时区。</p><pre><code>&gt;&gt;&gt; from datetime import datetime, timedelta, timezone&gt;&gt;&gt; tz_utc_8 = timezone(timedelta(hours=8))&gt;&gt;&gt; now = datetime.now()&gt;&gt;&gt; nowdatetime.datetime(2018, 4, 13, 10, 24, 41, 639742)&gt;&gt;&gt; dt = now.replace(tzinfo=tz_utc_8)&gt;&gt;&gt; dtdatetime.datetime(2018, 4, 13, 10, 24, 41, 639742, tzinfo=datetime.timezone(datetime.timedelta(0, 28800)))&gt;&gt;&gt; dtdatetime.datetime(2018, 4, 13, 10, 24, 41, 639742, tzinfo=datetime.timezone(datetime.timedelta(0, 28800)))</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文注意讲解datetime模块，注意到datetime是模块，datetime模块还包含一个datetime类，通过from datetime import datetime导入的才是datetime这个类。&lt;br&gt;如果仅导入import datetime，则必须引用全名datetime.datetime。&lt;br&gt;datetime.now()返回当前日期和时间，其类型是datetime。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考文档：&lt;a href=&quot;https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;datetime&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;获取当前日期和时间&quot;&gt;&lt;a href=&quot;#获取当前日期和时间&quot; class=&quot;headerlink&quot; title=&quot;获取当前日期和时间&quot;&gt;&lt;/a&gt;获取当前日期和时间&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from datetime import datetime
&amp;gt;&amp;gt;&amp;gt; now = datetime.now() # 获取当前datetime
&amp;gt;&amp;gt;&amp;gt; print(now)
2018-04-12 18:30:31.311945
&amp;gt;&amp;gt;&amp;gt; print(type(now))
&amp;lt;class &amp;apos;datetime.datetime&amp;apos;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;获取指定日期和时间&quot;&gt;&lt;a href=&quot;#获取指定日期和时间&quot; class=&quot;headerlink&quot; title=&quot;获取指定日期和时间&quot;&gt;&lt;/a&gt;获取指定日期和时间&lt;/h3&gt;&lt;p&gt;要指定某个日期和时间，我们直接用参数构造一个datetime&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from datetime import datetime
&amp;gt;&amp;gt;&amp;gt; dt = datetime(2018,4,12,18,32)  # 用指定日期时间创建datetime
&amp;gt;&amp;gt;&amp;gt; print(dt)
2018-04-12 18:32:00
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;datetime转换为timestamp&quot;&gt;&lt;a href=&quot;#datetime转换为timestamp&quot; class=&quot;headerlink&quot; title=&quot;datetime转换为timestamp&quot;&gt;&lt;/a&gt;datetime转换为timestamp&lt;/h3&gt;&lt;p&gt;timestamp的值与时区毫无关系，因为timestamp一旦确定，其UTC时间就确定了，转换到任意时区的时间也是完全确定的，这就是为什么计算机存储的当前时间是以timestamp表示的，因为全球各地的计算机在任意时刻的timestamp都是完全相同的（假定时间已校准）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; dt = datetime(2018,4,12,18,40)
&amp;gt;&amp;gt;&amp;gt; dt.timestamp()
1523529600.0
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="python基础知识" scheme="http://www.chenfanlinux.org/categories/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="python模块" scheme="http://www.chenfanlinux.org/tags/python%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>python版本管理工具-pyenv</title>
    <link href="http://www.chenfanlinux.org/2018/04/11/python%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-pyenv/"/>
    <id>http://www.chenfanlinux.org/2018/04/11/python版本管理工具-pyenv/</id>
    <published>2018-04-11T03:35:24.000Z</published>
    <updated>2018-04-11T03:42:13.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Python版本管理工具<a href="https://github.com/pyenv/pyenv" target="_blank" rel="noopener">pyenv</a>，pyenv让你轻松切换多个版本的Python。它很简单，不引人注意，并且遵循UNIX的单一目的工具的传统，可以很好地完成一件事。</p></blockquote><p>相关地址：</p><ul><li>pyenv github地址: <a href="http://github.com/yyuu/pyenv" target="_blank" rel="noopener">http://github.com/yyuu/pyenv</a></li><li>pyenv 安装器: <a href="https://github.com/pyenv/pyenv-installer" target="_blank" rel="noopener">https://github.com/pyenv/pyenv-installer</a></li></ul><h2 id="安装pyenv"><a href="#安装pyenv" class="headerlink" title="安装pyenv"></a>安装pyenv</h2><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><pre><code>$ yum -y install  git</code></pre><a id="more"></a><h3 id="安装pyenv-1"><a href="#安装pyenv-1" class="headerlink" title="安装pyenv"></a>安装pyenv</h3><pre><code>$ curl -L https://github.com/pyenv/pyenv-installer/raw/master/bin/pyenv-installer | bash</code></pre><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><pre><code>$ vim /etc/profile.d/pyenv.shexport PATH=&quot;/root/.pyenv/bin:$PATH&quot;eval &quot;$(pyenv init -)&quot;eval &quot;$(pyenv virtualenv-init -)&quot;$ source /etc/profile</code></pre><h2 id="安装python"><a href="#安装python" class="headerlink" title="安装python"></a>安装python</h2><h3 id="安装编译工具"><a href="#安装编译工具" class="headerlink" title="安装编译工具"></a>安装编译工具</h3><pre><code>$ yum install -y   gcc make patch</code></pre><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><pre><code>$ yum install -y  gdbm-devel openssl-devel sqlite-devel zlib-devel bzip2-devel readline-devel</code></pre><h3 id="安装python-3-5-2"><a href="#安装python-3-5-2" class="headerlink" title="安装python 3.5.2"></a>安装python 3.5.2</h3><pre><code>$ pyenv install 3.5.2 # 这种方式会下载官方源，可能会比较慢$ mkdir   ~/.pyenv/cache/ # 解决下载慢的问题:将包放在cache路径(~/.pyenv/cache/)下</code></pre><h2 id="使用pyenv"><a href="#使用pyenv" class="headerlink" title="使用pyenv"></a>使用pyenv</h2><h3 id="local命令"><a href="#local命令" class="headerlink" title="local命令"></a>local命令</h3><p>local命令切换当前目录及其子目录的python版本, 可以通过删除.python-verson恢复默认的python版本</p><h3 id="global命令"><a href="#global命令" class="headerlink" title="global命令"></a>global命令</h3><p>global命名切换全局默认的Python版本,永远不要使用!!</p><h3 id="virtualenv命令"><a href="#virtualenv命令" class="headerlink" title="virtualenv命令"></a>virtualenv命令</h3><pre><code>$ pyenv virtualenv 3.5.2 chenfanlinux # 创建虚拟环境$ pyenv versions # 查看python版本 * system (set by /root/.pyenv/version)  3.5.2  3.5.2/envs/chenfanlinux  chenfanlinux$ pyenv local chenfanlinux # 切换环境</code></pre><h3 id="uninstall命令"><a href="#uninstall命令" class="headerlink" title="uninstall命令"></a>uninstall命令</h3><pre><code>$ pyenv uninstall chenfanlinux # 卸载某个版本(包括虚拟环境)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Python版本管理工具&lt;a href=&quot;https://github.com/pyenv/pyenv&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pyenv&lt;/a&gt;，pyenv让你轻松切换多个版本的Python。它很简单，不引人注意，并且遵循UNIX的单一目的工具的传统，可以很好地完成一件事。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;相关地址：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pyenv github地址: &lt;a href=&quot;http://github.com/yyuu/pyenv&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://github.com/yyuu/pyenv&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;pyenv 安装器: &lt;a href=&quot;https://github.com/pyenv/pyenv-installer&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/pyenv/pyenv-installer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;安装pyenv&quot;&gt;&lt;a href=&quot;#安装pyenv&quot; class=&quot;headerlink&quot; title=&quot;安装pyenv&quot;&gt;&lt;/a&gt;安装pyenv&lt;/h2&gt;&lt;h3 id=&quot;安装git&quot;&gt;&lt;a href=&quot;#安装git&quot; class=&quot;headerlink&quot; title=&quot;安装git&quot;&gt;&lt;/a&gt;安装git&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;$ yum -y install  git
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="python基础知识" scheme="http://www.chenfanlinux.org/categories/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="pyenv" scheme="http://www.chenfanlinux.org/tags/pyenv/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes-1.9.1-HA生产环境实践</title>
    <link href="http://www.chenfanlinux.org/2018/04/06/Kubernetes-1-9-1-HA%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%AE%9E%E8%B7%B5/"/>
    <id>http://www.chenfanlinux.org/2018/04/06/Kubernetes-1-9-1-HA生产环境实践/</id>
    <published>2018-04-06T05:41:21.000Z</published>
    <updated>2018-04-08T08:20:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="集群环境说明"><a href="#集群环境说明" class="headerlink" title="集群环境说明"></a>集群环境说明</h2><h3 id="服务器信息"><a href="#服务器信息" class="headerlink" title="服务器信息"></a>服务器信息</h3><p>这里配置2Master 2个node, k8s-master01只做 Master, k8s-node01即是Master也是Node, k8s-node02单纯做Node。</p><p><img src="https://s1.ax1x.com/2018/04/02/9z62xH.png" alt="服务器信息"></p><h3 id="集群详情"><a href="#集群详情" class="headerlink" title="集群详情"></a>集群详情</h3><ul><li>Kubernetes 1.9.1</li><li>Docker-17.03.1-ce</li><li>Etcd-v3.2.14</li><li>Flanneld-v0.10.0 vxlan</li><li>TLS 认证通信</li><li>RBAC 授权</li><li>Kublet TLS BootStrapping</li><li>Coredns:1.0.4</li><li>Registry-2.6</li></ul><a id="more"></a><h3 id="网络环境说明"><a href="#网络环境说明" class="headerlink" title="网络环境说明"></a>网络环境说明</h3><ul><li>服务器网络（10.173.36.214/21）</li><li>Clutser网络（10.253.0.0/16)</li><li>Flannel网络（10.254.0.0/16）</li></ul><h3 id="集群拓扑图"><a href="#集群拓扑图" class="headerlink" title="集群拓扑图"></a>集群拓扑图</h3><p><img src="https://s1.ax1x.com/2018/04/03/CpAs9s.png" alt="集群拓扑图"></p><h2 id="集群环境初始化"><a href="#集群环境初始化" class="headerlink" title="集群环境初始化"></a>集群环境初始化</h2><table><tr><td bgcolor="#008000"> master和node </td></tr></table><h3 id="设置主机名-永久生效）"><a href="#设置主机名-永久生效）" class="headerlink" title="设置主机名(永久生效）"></a>设置主机名(永久生效）</h3><pre><code>$ hostnamectl --static set-hostname k8s-master01$ hostnamectl --static set-hostname k8s-node01$ hostnamectl --static set-hostname k8s-node02</code></pre><h3 id="配置epel7-yum源"><a href="#配置epel7-yum源" class="headerlink" title="配置epel7 yum源"></a>配置epel7 yum源</h3><pre><code>$ yum install  epel-release</code></pre><h3 id="配置ntp时间同步"><a href="#配置ntp时间同步" class="headerlink" title="配置ntp时间同步"></a>配置ntp时间同步</h3><pre><code>$ yum -y install ntp$ vim /etc/ntp.confserver time.pool.aliyun.com        # 向阿里云的ntp服务器进行校准$ systemctl start ntpd$ systemctl enable ntpd</code></pre><h3 id="配置密钥对"><a href="#配置密钥对" class="headerlink" title="配置密钥对"></a>配置密钥对</h3><pre><code>$ ssh-keygen -t rsa -P &quot;&quot; -f /root/.ssh/id_rsa #  把生成的公钥拷贝到其他节点的 authorized_keys 即可</code></pre><h3 id="修改-etc-hosts"><a href="#修改-etc-hosts" class="headerlink" title="修改/etc/hosts"></a>修改/etc/hosts</h3><pre><code>$ vim /etc/hosts 10.173.36.214 k8s-master01 10.173.36.215 k8s-node02 10.173.36.216 k8s-node01$ scp /etc/hosts root@10.173.36.216:/etc$ scp /etc/hosts root@10.173.36.215:/etc</code></pre><h3 id="打开路由转发"><a href="#打开路由转发" class="headerlink" title="打开路由转发"></a>打开路由转发</h3><pre><code>$ echo &quot;net.ipv4.ip_forward = 1&quot; &gt;&gt;/etc/sysctl.conf$ sysctl -p</code></pre><h3 id="关闭NetworkManager"><a href="#关闭NetworkManager" class="headerlink" title="关闭NetworkManager"></a>关闭NetworkManager</h3><pre><code>$ systemctl stop NetworkManager$ systemctl disable NetworkManager # 此服务会接管nameserver,导致修改不成功</code></pre><p><strong><em>这是网易云平台特有的配置，其他云平台可以忽略！</em></strong></p><h3 id="关闭-firewall"><a href="#关闭-firewall" class="headerlink" title="关闭 firewall"></a>关闭 firewall</h3><pre><code>$ systemctl stop firewalld$ systemctl disable firewalld</code></pre><h2 id="安装并配置Docker"><a href="#安装并配置Docker" class="headerlink" title="安装并配置Docker"></a>安装并配置Docker</h2><table><tr><td bgcolor="#008000"> master和node </td></tr></table><h3 id="安装yum管理工具并添加Docker官方源"><a href="#安装yum管理工具并添加Docker官方源" class="headerlink" title="安装yum管理工具并添加Docker官方源"></a>安装yum管理工具并添加Docker官方源</h3><pre><code>$ yum install -y yum-utils$ yum-config-manager  --add-repo  https://download.docker.com/linux/centos/docker-ce.repo$ yum makecache</code></pre><h3 id="查看yum版本"><a href="#查看yum版本" class="headerlink" title="查看yum版本"></a>查看yum版本</h3><pre><code>$ yum list docker-ce.x86_64  --showduplicates |sort -r</code></pre><h3 id="安装docker-ce的依赖-docker-ce-selinux"><a href="#安装docker-ce的依赖-docker-ce-selinux" class="headerlink" title="安装docker-ce的依赖 docker-ce-selinux"></a>安装docker-ce的依赖 docker-ce-selinux</h3><p>安装这个docker-ce-selinux，需要保持selinux的enforcing状态，安装完记得关闭。</p><pre><code>$ wget https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-selinux-17.03.1.ce-1.el7.centos.noarch.rpm$ rpm -ivh docker-ce-selinux-17.03.1.ce-1.el7.centos.noarch.rpm</code></pre><h3 id="关闭开启的selinux，并安装docker-ce-17-03-1-ce"><a href="#关闭开启的selinux，并安装docker-ce-17-03-1-ce" class="headerlink" title="关闭开启的selinux，并安装docker-ce-17.03.1.ce"></a>关闭开启的selinux，并安装docker-ce-17.03.1.ce</h3><pre><code>$ yum -y install docker-ce-17.03.1.ce$ docker version   # 查看docker版本信息</code></pre><h3 id="Docker使用overlay2"><a href="#Docker使用overlay2" class="headerlink" title="Docker使用overlay2"></a>Docker使用overlay2</h3><pre><code>$ lsmod |grep overlay   # 检查overlay是否存在$ modprobe overlay     #  加载overlay模块$ mkdir /etc/docker$ vi /etc/docker/daemon.json  # 修改存储引擎为overlay{  &quot;storage-driver&quot;: &quot;overlay2&quot;,  &quot;storage-opts&quot;: [    &quot;overlay2.override_kernel_check=true&quot;  ]}$ systemctl start docker$ docker info # 查看docker使用的引擎</code></pre><h3 id="增加docker-配置"><a href="#增加docker-配置" class="headerlink" title="增加docker 配置"></a>增加docker 配置</h3><pre><code>$ vim  /etc/systemd/system/docker.service[Unit]Description=Docker Application Container EngineDocumentation=http://docs.docker.comAfter=network.target docker-storage-setup.serviceWants=docker-storage-setup.service[Service]Type=notifyEnvironment=GOTRACEBACK=crashExecReload=/bin/kill -s HUP $MAINPIDDelegate=yesKillMode=processExecStart=/usr/bin/dockerd \          $DOCKER_OPTS \          $DOCKER_STORAGE_OPTIONS \          $DOCKER_NETWORK_OPTIONS \          $DOCKER_DNS_OPTIONS \          $INSECURE_REGISTRYLimitNOFILE=1048576LimitNPROC=1048576LimitCORE=infinityTimeoutStartSec=1minRestart=on-abnormal[Install]WantedBy=multi-user.target$ mkdir -p /etc/systemd/system/docker.service.d   # 后续还需要增加的配置放置目录$ vi /etc/systemd/system/docker.service.d/docker-dns.conf  # 增加docker的dns配置,后续配置好dns再增加$ vi /etc/systemd/system/docker.service.d/docker-options.conf  # 后续再这个配置文件中加入私有仓库信息配置[Service]Environment=&quot;DOCKER_OPTS=  --graph=/opt/docker --log-opt max-size=50m --log-opt max-file=5&quot;</code></pre><h3 id="重新读取配置，启动-docker"><a href="#重新读取配置，启动-docker" class="headerlink" title="重新读取配置，启动 docker"></a>重新读取配置，启动 docker</h3><pre><code>$ systemctl daemon-reload$ systemctl start docker$ systemctl enable docker$ journalctl -f -t docker  和 journalctl -u docker # 定位问题日志</code></pre><h2 id="安装私有仓库-Registry"><a href="#安装私有仓库-Registry" class="headerlink" title="安装私有仓库 Registry"></a>安装私有仓库 Registry</h2><table><tr><td bgcolor="#008000"> master </td></tr></table><h3 id="运行Registry容器"><a href="#运行Registry容器" class="headerlink" title="运行Registry容器"></a>运行Registry容器</h3><pre><code>$ mkdir -p /opt/docker-data/repos     # 创建registry的挂载目录$ docker run -d -p 8001:5000 --restart=always --privileged --name registry -v /opt/docker-data/repos:/var/lib/registry registry:2.6    # 运行registry最新容器</code></pre><p><strong>参数说明：</strong></p><ul><li>-d表示守护进程，-p表示本地的8001端口映射到容器的5000端口， restart表示容器挂了是否自启， -v表示本地的目录映射到容器的目录</li><li>–privileged 使用该参数，container内的root拥有真正的root权限。否则container内的root只是外部的一个普通用户权限。privileged启动的容器，可以看到很多host上的设备，并且可以执行mount。甚至允许你在docker容器中启动docker容器。</li></ul><h3 id="测试可用性"><a href="#测试可用性" class="headerlink" title="测试可用性"></a>测试可用性</h3><pre><code>$ docker pull  index.tenxcloud.com/google_containers/pause:3.0  # 拉取一个镜像做测试$ docker tag index.tenxcloud.com/google_containers/pause:3.0  k8s-master01:8001/google_containers/pause:3.0  # 改为本地镜像的存储名(镜像仓库地址:/项目地址/镜像名:版本号)$ docker push k8s-master01:8001/google_containers/pause:3.0 # 推送到本地镜像仓库</code></pre><h3 id="master和node-都需要修改的docker关于registry的配置"><a href="#master和node-都需要修改的docker关于registry的配置" class="headerlink" title="master和node 都需要修改的docker关于registry的配置"></a>master和node 都需要修改的docker关于registry的配置</h3><pre><code>$ vi /etc/systemd/system/docker.service.d/docker-options.conf  # 增加私有仓库地址的配置[Service]Environment=&quot;DOCKER_OPTS=--insecure-registry=k8s-master01:8001 \--graph=/opt/docker --log-opt max-size=50m --log-opt max-file=5&quot;$ systemctl daemon-reload   # 重启加载配置$ systemctl restart docker$ k8s-master01:8001/google_containers/pause:3.0    # node 节点测试一下是否可以拉取镜像</code></pre><h2 id="安装cfssl并创建CA"><a href="#安装cfssl并创建CA" class="headerlink" title="安装cfssl并创建CA"></a>安装cfssl并创建CA</h2><table><tr><td bgcolor="#008000"> master </td></tr></table><h3 id="安装-cfssl"><a href="#安装-cfssl" class="headerlink" title="安装 cfssl"></a>安装 cfssl</h3><pre><code>$ mkdir /opt/tools/cfssl -p$ cd /opt/tools/cfssl$ wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64$ wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64$ wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64$ mv cfssl_linux-amd64 cfssl$ mv cfssljson_linux-amd64 cfssljson$ mv cfssl-certinfo_linux-amd64 cfssl-certinfo$ chmod +x *$ mv cfssl/* /usr/local/bin</code></pre><h3 id="创建-CA-证书配置"><a href="#创建-CA-证书配置" class="headerlink" title="创建 CA 证书配置"></a>创建 CA 证书配置</h3><pre><code>$ mkdir /opt/ssl$ cd /opt/ssl$  vi csr.json{  &quot;CN&quot;: &quot;kubernetes&quot;,  &quot;key&quot;: {    &quot;algo&quot;: &quot;rsa&quot;,    &quot;size&quot;: 2048  },  &quot;names&quot;: [    {      &quot;C&quot;: &quot;CN&quot;,      &quot;ST&quot;: &quot;GuangZhou&quot;,      &quot;L&quot;: &quot;GuangZhou&quot;,      &quot;O&quot;: &quot;k8s&quot;,      &quot;OU&quot;: &quot;System&quot;    }  ],  &quot;ca&quot;: {      &quot;expiry&quot;: &quot;262880h&quot;  }}</code></pre><p><strong><em>这里的CA证书期限很多教程都是一个炕，应该如上配置才是正确的，不然都是5年期限！</em></strong></p><h3 id="生成-CA-证书和私钥"><a href="#生成-CA-证书和私钥" class="headerlink" title="生成 CA 证书和私钥"></a>生成 CA 证书和私钥</h3><pre><code>$ cd /opt/ssl/$ cfssl  gencert -initca csr.json | cfssljson -bare ca$ ls -lca.csr          # 证书请求文件ca-key.pem  # ca私钥ca.pem    # ca证书csr.jsonconfig.json</code></pre><p><strong><em>注意： 将会生成 ca-key.pem，ca.csr，ca.pem 这三个文件，请务必保证 ca-key.pem 文件的安全，</em>.csr 文件在整个过程中不会使用。*</strong></p><h3 id="分发证书"><a href="#分发证书" class="headerlink" title="分发证书"></a>分发证书</h3><table><tr><td bgcolor="#008000"> master和node </td></tr></table><pre><code>$ mkdir -p /etc/kubernetes/ssl  # 创建证书目录$ cp *.pem /etc/kubernetes/ssl  # 拷贝所有文件到目录下$ cp ca.csr /etc/kubernetes/ssl$  ls /etc/kubernetes/sslca.csr  ca-key.pem  ca.pem$ scp -a /etc/kubernetes/ssl/*  root@k8s-node01: /etc/kubernetes/ssl$ scp -a /etc/kubernetes/ssl/*  root@k8s-node02: /etc/kubernetes/ssl</code></pre><h2 id="etcd-集群"><a href="#etcd-集群" class="headerlink" title="etcd 集群"></a>etcd 集群</h2><blockquote><p>etcd是k8s非常重要的组件，因此这里采用etcd集群，三个节点都安装etcd，etcd开选举模式。</p></blockquote><h3 id="安装-etcd"><a href="#安装-etcd" class="headerlink" title="安装 etcd"></a>安装 etcd</h3><pre><code>$ cd /opt/tools$ wget https://github.com/coreos/etcd/releases/download/v3.2.14/etcd-v3.2.14-linux-amd64.tar.gz$ tar zxvf etcd-v3.2.14-linux-amd64.tar.gz$ cd etcd-v3.2.14-linux-amd64$ mv etcd  etcdctl /usr/bin/$ scp /usr/bin/etcd*  root@k8s-node01:/usr/bin/$ scp /usr/bin/etcd* root@k8s-node02:/usr/bin/</code></pre><h3 id="创建-etcd-证书"><a href="#创建-etcd-证书" class="headerlink" title="创建 etcd 证书"></a>创建 etcd 证书</h3><pre><code>$ cd /opt/ssl/$ vi etcd-csr.json  # 创建etcd的证书请求配置{  &quot;CN&quot;: &quot;etcd&quot;,  &quot;hosts&quot;: [    &quot;127.0.0.1&quot;,    &quot;10.173.36.214&quot;,    &quot;10.173.36.215&quot;,    &quot;10.173.36.216&quot;  ],  &quot;key&quot;: {    &quot;algo&quot;: &quot;rsa&quot;,    &quot;size&quot;: 2048  },  &quot;names&quot;: [    {      &quot;C&quot;: &quot;CN&quot;,      &quot;ST&quot;: &quot;GuangZhou&quot;,      &quot;L&quot;: &quot;GuangZhou&quot;,      &quot;O&quot;: &quot;k8s&quot;,      &quot;OU&quot;: &quot;System&quot;    }  ]}$ vim config.json{  &quot;signing&quot;: {       &quot;default&quot;: {        &quot;expiry&quot;: &quot;87600h&quot;    },    &quot;profiles&quot;: {      &quot;kubernetes&quot;: {        &quot;usages&quot;: [            &quot;signing&quot;,            &quot;key encipherment&quot;,            &quot;server auth&quot;,            &quot;client auth&quot;        ],        &quot;expiry&quot;: &quot;87600h&quot;       }     }   }}</code></pre><p><strong><em>注意：上面的证书请求配置，不能使用hostname,要使用ip,建议多预留几个IP。</em></strong></p><pre><code>$ cfssl gencert -ca=/opt/ssl/ca.pem \  -ca-key=/opt/ssl/ca-key.pem \  -config=/opt/ssl/config.json \  -profile=kubernetes etcd-csr.json | cfssljson -bare etcd$ ls etcd*.pem # 生成etcd的证书和私钥etcd-key.pem  # etcd私钥etcd.pem       # etcd证书</code></pre><h3 id="etcd证书分发-三个节点均为etcd"><a href="#etcd证书分发-三个节点均为etcd" class="headerlink" title="etcd证书分发(三个节点均为etcd)"></a>etcd证书分发(三个节点均为etcd)</h3><pre><code>$ cp -a etcd*.pem /etc/kubernetes/ssl          # etcd1$ scp -p etcd*.pem root@k8s-node01:/etc/kubernetes/ssl    # etcd2$ scp -p etcd*.pem root@k8s-node02:/etc/kubernetes/ssl    # etcd3</code></pre><h3 id="增加etcd-配置"><a href="#增加etcd-配置" class="headerlink" title="增加etcd 配置"></a>增加etcd 配置</h3><table><tr><td bgcolor="#008000"> master和node </td></tr></table><pre><code>$ mkdir /opt/etcd$ vi /etc/systemd/system/etcd.service     # etcd1[Unit]Description=Etcd ServerAfter=network.targetAfter=network-online.targetWants=network-online.target[Service]Type=notifyWorkingDirectory=/opt/etcd/User=rootExecStart=/usr/bin/etcd \  --name=etcd1 \  --cert-file=/etc/kubernetes/ssl/etcd.pem \  --key-file=/etc/kubernetes/ssl/etcd-key.pem \  --peer-cert-file=/etc/kubernetes/ssl/etcd.pem \  --peer-key-file=/etc/kubernetes/ssl/etcd-key.pem \  --trusted-ca-file=/etc/kubernetes/ssl/ca.pem \  --peer-trusted-ca-file=/etc/kubernetes/ssl/ca.pem \  --initial-advertise-peer-urls=https://10.173.36.214:2380 \  --listen-peer-urls=https://10.173.36.214:2380 \  --listen-client-urls=https://10.173.36.214:2379,http://127.0.0.1:2379 \  --advertise-client-urls=https://10.173.36.214:2379 \  --initial-cluster-token=k8s-etcd-cluster \  --initial-cluster=etcd1=https://10.173.36.214:2380,etcd2=https://10.173.36.216:2380,etcd3=https://10.173.36.215:2380 \  --initial-cluster-state=new \  --data-dir=/opt/etcd/Restart=on-failureRestartSec=5LimitNOFILE=65536[Install]WantedBy=multi-user.target$ mkdir /opt/etcd$ vi /etc/systemd/system/etcd.service  # etcd2[Unit]Description=Etcd ServerAfter=network.targetAfter=network-online.targetWants=network-online.target[Service]Type=notifyWorkingDirectory=/opt/etcd/User=rootExecStart=/usr/bin/etcd \  --name=etcd2 \  --cert-file=/etc/kubernetes/ssl/etcd.pem \  --key-file=/etc/kubernetes/ssl/etcd-key.pem \  --peer-cert-file=/etc/kubernetes/ssl/etcd.pem \  --peer-key-file=/etc/kubernetes/ssl/etcd-key.pem \  --trusted-ca-file=/etc/kubernetes/ssl/ca.pem \  --peer-trusted-ca-file=/etc/kubernetes/ssl/ca.pem \  --initial-advertise-peer-urls=https://10.173.36.216:2380 \  --listen-peer-urls=https://10.173.36.216:2380 \  --listen-client-urls=https://10.173.36.216:2379,http://127.0.0.1:2379 \  --advertise-client-urls=https://10.173.36.216:2379 \  --initial-cluster-token=k8s-etcd-cluster \  --initial-cluster=etcd1=https://10.173.36.214:2380,etcd2=https://10.173.36.216:2380,etcd3=https://10.173.36.215:2380 \  --initial-cluster-state=new \  --data-dir=/opt/etcd/Restart=on-failureRestartSec=5LimitNOFILE=65536[Install]WantedBy=multi-user.target$ mkdir /opt/etcd$ vi /etc/systemd/system/etcd.service   # etcd3[Unit]Description=Etcd ServerAfter=network.targetAfter=network-online.targetWants=network-online.target[Service]Type=notifyWorkingDirectory=/opt/etcd/User=rootExecStart=/usr/bin/etcd \  --name=etcd3 \  --cert-file=/etc/kubernetes/ssl/etcd.pem \  --key-file=/etc/kubernetes/ssl/etcd-key.pem \  --peer-cert-file=/etc/kubernetes/ssl/etcd.pem \  --peer-key-file=/etc/kubernetes/ssl/etcd-key.pem \  --trusted-ca-file=/etc/kubernetes/ssl/ca.pem \  --peer-trusted-ca-file=/etc/kubernetes/ssl/ca.pem \  --initial-advertise-peer-urls=https://10.173.36.215:2380 \  --listen-peer-urls=https://10.173.36.215:2380 \  --listen-client-urls=https://10.173.36.215:2379,http://127.0.0.1:2379 \  --advertise-client-urls=https://10.173.36.215:2379 \  --initial-cluster-token=k8s-etcd-cluster \  --initial-cluster=etcd1=https://10.173.36.214:2380,etcd2=https://10.173.36.216:2380,etcd3=https://10.173.36.215:2380 \  --initial-cluster-state=new \  --data-dir=/opt/etcd/Restart=on-failureRestartSec=5LimitNOFILE=65536[Install]WantedBy=multi-user.target</code></pre><h3 id="启动etcd"><a href="#启动etcd" class="headerlink" title="启动etcd"></a>启动etcd</h3><pre><code>$ systemctl daemon-reload$ systemctl enable etcd$ systemctl start etcd$ systemctl status etcd</code></pre><h3 id="验证-etcd-集群状态"><a href="#验证-etcd-集群状态" class="headerlink" title="验证 etcd 集群状态"></a>验证 etcd 集群状态</h3><p><strong>查看集群状态：</strong></p><pre><code>$ etcdctl --endpoints=https://10.173.36.214:2379,https://10.173.36.215:2379,https://10.173.36.216:2379\        --cert-file=/etc/kubernetes/ssl/etcd.pem \        --ca-file=/etc/kubernetes/ssl/ca.pem \        --key-file=/etc/kubernetes/ssl/etcd-key.pem \        cluster-healthmember 3f2cd58f2041fd0c is healthy: got healthy result from https://10.173.36.215:2379member 81779624411cd53c is healthy: got healthy result from https://10.173.36.216:2379member 87fb8e044eab3dee is healthy: got healthy result from https://10.173.36.214:2379</code></pre><p><strong>查看集群成员:</strong><br>可以看到集群节点的选举情况</p><pre><code>$ etcdctl --endpoints=https://10.173.36.214:2379,https://10.173.36.215:2379,https://10.173.36.216:2379\        --cert-file=/etc/kubernetes/ssl/etcd.pem \        --ca-file=/etc/kubernetes/ssl/ca.pem \        --key-file=/etc/kubernetes/ssl/etcd-key.pem \        member list3f2cd58f2041fd0c: name=etcd3 peerURLs=https://10.173.36.215:2380 clientURLs=https://10.173.36.215:2379 isLeader=false81779624411cd53c: name=etcd2 peerURLs=https://10.173.36.216:2380 clientURLs=https://10.173.36.216:2379 isLeader=true   // 被选中87fb8e044eab3dee: name=etcd1 peerURLs=https://10.173.36.214:2380 clientURLs=https://10.173.36.214:2379 isLeader=false</code></pre><p><strong>etcd查看报错:</strong></p><pre><code>$ journalctl -f -t etcd</code></pre><h2 id="Kubernetes-集群（Master）"><a href="#Kubernetes-集群（Master）" class="headerlink" title="Kubernetes 集群（Master）"></a>Kubernetes 集群（Master）</h2><blockquote><p>kubectl 安装在所有需要进行操作的机器上,一般放在master节点上；Master 需要部署 kube-apiserver , kube-scheduler , kube-controller-manager 这三个组件。Node需要部署kubelet,kubeproxy这两个组件。</p></blockquote><table><tr><td bgcolor="#008000"> master </td></tr></table><h3 id="安装kubernetes组件"><a href="#安装kubernetes组件" class="headerlink" title="安装kubernetes组件"></a>安装kubernetes组件</h3><pre><code>$ cd /opt/tools$ wget https://dl.k8s.io/v1.9.1/kubernetes-server-linux-amd64.tar.gz$ tar -xzvf kubernetes-server-linux-amd64.tar.gz$ cd kubernetes$ cp -r server/bin/{kube-apiserver,kube-controller-manager,kube-scheduler,kubectl} /usr/local/bin$ scp -r server/bin/{kube-apiserver,kube-controller-manager,kube-scheduler,kubectl,kube-proxy,kubelet} k8s-node01:/usr/local/bin$ scp -r server/bin/{kubelet,kube-proxy} k8s-node02:/usr/local/bin</code></pre><h3 id="kubeclt"><a href="#kubeclt" class="headerlink" title="kubeclt"></a>kubeclt</h3><h4 id="创建-admin-证书-client证书"><a href="#创建-admin-证书-client证书" class="headerlink" title="创建 admin 证书(client证书)"></a>创建 admin 证书(client证书)</h4><blockquote><p>kubectl的客户端证书，用于kubectl 与 kube-apiserver 的安全端口通信，需要为安全通信提供 TLS 证书和秘钥。</p></blockquote><pre><code>$ cd /opt/ssl/$ vim  admin-csr.json #  证书请求配置{  &quot;CN&quot;: &quot;admin&quot;,  &quot;hosts&quot;: [],  &quot;key&quot;: {    &quot;algo&quot;: &quot;rsa&quot;,    &quot;size&quot;: 2048  },  &quot;names&quot;: [    {      &quot;C&quot;: &quot;CN&quot;,      &quot;ST&quot;: &quot;GuangZhou&quot;,      &quot;L&quot;: &quot;GuangZhou&quot;,      &quot;O&quot;: &quot;system:masters&quot;,      &quot;OU&quot;: &quot;System&quot;    }  ]}$ cfssl gencert -ca=/etc/kubernetes/ssl/ca.pem -ca-key=/etc/kubernetes/ssl/ca-key.pem -config=/opt/ssl/config.json -profile=kubernetes admin-csr.json | cfssljson -bare admin  # 生成admin证书$ ls admin* # 查看证书和私钥的生成admin.csr  admin-csr.json  admin-key.pem  admin.pem$ cp admin*.pem /etc/kubernetes/ssl/$ scp -r admin*.pem  k8s-node01:/etc/kubernetes/ssl/  # 实际上这一步可以不做,拷贝后续的 kubectl kubeconfig文件即可！！</code></pre><h4 id="配置-kubectl-kubeconfig-文件"><a href="#配置-kubectl-kubeconfig-文件" class="headerlink" title="配置 kubectl kubeconfig 文件"></a>配置 kubectl kubeconfig 文件</h4><blockquote><p>生成证书相关的配置文件存储与 /root/.kube 目录中,这里的kubectl与apiserver通信，都是nginx-proxy将通过本地的16443转发到集群apiserver的6443端口。</p></blockquote><pre><code>$ kubectl config set-cluster kubernetes   \   --certificate-authority=/etc/kubernetes/ssl/ca.pem   --embed-certs=true   --server=https://127.0.0.1:16443$ kubectl config set-credentials admin   \   --client-certificate=/etc/kubernetes/ssl/admin.pem   --embed-certs=true   --client-key=/etc/kubernetes/ssl/admin-key.pem$ kubectl config set-context kubernetes  \ --cluster=kubernetes   --user=admin$ kubectl config use-context kubernetes$ scp -a /root/.kube/config root@k8s-node01:/root/.kube # 要保证k8s-node01上存在/root/.kube目录</code></pre><p><strong><em>注意：上面的步骤会生成在/root/.kube/下生成一个config文件,将这个config文件拷贝到安装kubectl节点上即可！！！</em></strong></p><h3 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h3><h4 id="创建-kubernetes-证书（server端"><a href="#创建-kubernetes-证书（server端" class="headerlink" title="创建 kubernetes 证书（server端)"></a>创建 kubernetes 证书（server端)</h4><blockquote><p>kube-apiserver的服务端证书，无论是kubectl,kubelet,kube-proxy的客户端证书，都需要跟此证书进行双向的TLS通信！</p></blockquote><pre><code>$ cd /opt/ssl$ vi kubernetes-csr.json # 生成证书请求配置{  &quot;CN&quot;: &quot;kubernetes&quot;,  &quot;hosts&quot;: [    &quot;127.0.0.1&quot;,    &quot;10.173.36.214&quot;,    &quot;10.173.36.216&quot;,    &quot;10.254.0.1&quot;,    &quot;kubernetes&quot;,    &quot;kubernetes.default&quot;,    &quot;kubernetes.default.svc&quot;,    &quot;kubernetes.default.svc.cluster&quot;,    &quot;kubernetes.default.svc.cluster.local&quot;  ],  &quot;key&quot;: {    &quot;algo&quot;: &quot;rsa&quot;,    &quot;size&quot;: 2048  },  &quot;names&quot;: [    {      &quot;C&quot;: &quot;CN&quot;,      &quot;ST&quot;: &quot;GuangZhou&quot;,      &quot;L&quot;: &quot;GuangZhou&quot;,      &quot;O&quot;: &quot;k8s&quot;,      &quot;OU&quot;: &quot;System&quot;    }  ]}</code></pre><p><strong><em>注意： 由于本集群采用HA apiserver方式，所以客户端组件在跟apiserver通信的时候，都是通过nginx-proxy将本地的16443转发到集群的apiserver的6443端口，所以这里的证书请求hosts配置，实际上配置成127.0.0.1即可，加kube-apiserver的ip是为了使连接更灵活，可以不适用nginx-proxy转发。</em></strong></p><h4 id="生成-kubernetes-证书和私钥"><a href="#生成-kubernetes-证书和私钥" class="headerlink" title="生成 kubernetes 证书和私钥"></a>生成 kubernetes 证书和私钥</h4><pre><code>$ cfssl gencert -ca=/etc/kubernetes/ssl/ca.pem \   -ca-key=/etc/kubernetes/ssl/ca-key.pem \   config=/opt/ssl/config.json \   -profile=kubernetes kubernetes-csr.json | cfssljson -bare kubernetes $ ls -lt kubernetes* kubernetes.csr kubernetes-key.pem kubernetes.pem kubernetes-csr.json $ cp kubernetes*.pem /etc/kubernetes/ssl/ $ scp -p  kubernetes*.pem root@k8s-node01:/etc/kubernetes/ssl/ # 拷贝到所有的master节点</code></pre><h4 id="配置-kube-apiserver"><a href="#配置-kube-apiserver" class="headerlink" title="配置 kube-apiserver"></a>配置 kube-apiserver</h4><blockquote><p>kubelet 首次启动时向 kube-apiserver 发送 TLS Bootstrapping 请求，kube-apiserver 验证 kubelet 请求中的 token 是否与它配置的 token 一致，如果一致则自动为 kubelet生成证书和秘钥。TLS bootstrapping 功能就是让 kubelet 先使用一个预定的低权限用户连接到 apiserver，然后向 apiserver 申请证书，kubelet 的证书由 apiserver 动态签署；RBAC判定是否有权限创建CSR请求。</p></blockquote><pre><code>$ head -c 16 /dev/urandom | od -An -t x | tr -d &apos; &apos;  # 生成 tokena0a5d162e00fff4420406defaae32e17$ cd /opt/ssl    # 创建 token.csv 文件a0a5d162e00fff4420406defaae32e17,kubelet-bootstrap,10001,&quot;system:kubelet-bootstrap&quot;$ cd /etc/kubernetes$ cat &gt;&gt; audit-policy.yaml &lt;&lt;EOF# Log all requests at the Metadata levelapiVersion: audit.k8s.io/v1beta1kind: Policyrules:- level: MetadataEOF$ cp token.csv /etc/kubernetes$ scp token.csv root@k8s-node01:/etc/kubernetes/$ scp audit-policy.yaml root@k8s-node01:/etc/kubernetes   # 拷贝token和审核文件到另外的apiserver上</code></pre><h4 id="配置-kube-apiserver并启动"><a href="#配置-kube-apiserver并启动" class="headerlink" title="配置 kube-apiserver并启动"></a>配置 kube-apiserver并启动</h4><blockquote><p>自定义 系统 service 文件一般存于 /etc/systemd/system/ 下</p></blockquote><pre><code>$ vim /etc/systemd/system/kube-apiserver.service[Unit]Description=Kubernetes API ServerDocumentation=https://github.com/GoogleCloudPlatform/kubernetesAfter=network.target[Service]User=rootExecStart=/usr/local/bin/kube-apiserver \  --admission-control=NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,ResourceQuota,NodeRestriction \  --advertise-address=10.173.36.214 \  --allow-privileged=true \  --apiserver-count=3 \  --audit-policy-file=/etc/kubernetes/audit-policy.yaml \  --audit-log-maxage=30 \  --audit-log-maxbackup=3 \  --audit-log-maxsize=100 \  --audit-log-path=/var/log/kubernetes/audit.log \  --authorization-mode=Node,RBAC \  --bind-address=0.0.0.0 \  --secure-port=6443 \  --client-ca-file=/etc/kubernetes/ssl/ca.pem \  --enable-swagger-ui=true \  --etcd-cafile=/etc/kubernetes/ssl/ca.pem \  --etcd-certfile=/etc/kubernetes/ssl/etcd.pem \  --etcd-keyfile=/etc/kubernetes/ssl/etcd-key.pem \  --etcd-servers=https://10.173.36.214:2379,https://10.173.36.215:2379,https://10.173.36.216:2379 \  --event-ttl=1h \  --kubelet-https=true \  --insecure-bind-address=127.0.0.1 \  --insecure-port=8080 \  --service-account-key-file=/etc/kubernetes/ssl/ca-key.pem \  --service-cluster-ip-range=10.254.0.0/16 \  --service-node-port-range=30000-32000 \  --tls-cert-file=/etc/kubernetes/ssl/kubernetes.pem \  --tls-private-key-file=/etc/kubernetes/ssl/kubernetes-key.pem \  --enable-bootstrap-token-auth \  --token-auth-file=/etc/kubernetes/token.csv \  --v=1Restart=on-failureRestartSec=5Type=notifyLimitNOFILE=65536[Install]WantedBy=multi-user.target$ systemctl daemon-reload$ systemctl enable kube-apiserver$ systemctl start kube-apiserver$ systemctl status kube-apiserver</code></pre><h3 id="kube-controller-manager"><a href="#kube-controller-manager" class="headerlink" title="kube-controller-manager"></a>kube-controller-manager</h3><h4 id="配置-kube-controller-manager"><a href="#配置-kube-controller-manager" class="headerlink" title="配置 kube-controller-manager"></a>配置 kube-controller-manager</h4><pre><code>$ vi /etc/systemd/system/kube-controller-manager.service[Unit]Description=Kubernetes Controller ManagerDocumentation=https://github.com/GoogleCloudPlatform/kubernetes[Service]ExecStart=/usr/local/bin/kube-controller-manager \  --address=0.0.0.0 \  --master=http://127.0.0.1:8080 \  --allocate-node-cidrs=true \  --service-cluster-ip-range=10.254.0.0/16 \  --cluster-cidr=10.253.0.0/16 \  --cluster-name=kubernetes \  --cluster-signing-cert-file=/etc/kubernetes/ssl/ca.pem \  --cluster-signing-key-file=/etc/kubernetes/ssl/ca-key.pem \  --service-account-private-key-file=/etc/kubernetes/ssl/ca-key.pem \  --root-ca-file=/etc/kubernetes/ssl/ca.pem \  --leader-elect=true \  --v=1Restart=on-failureRestartSec=5[Install]WantedBy=multi-user.target</code></pre><h4 id="启动kube-controller-manager"><a href="#启动kube-controller-manager" class="headerlink" title="启动kube-controller-manager"></a>启动kube-controller-manager</h4><pre><code>$ systemctl daemon-reload$ systemctl enable kube-controller-manager$ systemctl start kube-controller-manager$ systemctl status kube-controller-manager</code></pre><h3 id="kube-scheduler"><a href="#kube-scheduler" class="headerlink" title="kube-scheduler"></a>kube-scheduler</h3><h4 id="配置-kube-scheduler"><a href="#配置-kube-scheduler" class="headerlink" title="配置 kube-scheduler"></a>配置 kube-scheduler</h4><pre><code>$ vi /etc/systemd/system/kube-scheduler.service[Unit]Description=Kubernetes SchedulerDocumentation=https://github.com/GoogleCloudPlatform/kubernetes[Service]ExecStart=/usr/local/bin/kube-scheduler \  --address=0.0.0.0 \  --master=http://127.0.0.1:8080 \  --leader-elect=true \  --v=1Restart=on-failureRestartSec=5[Install]WantedBy=multi-user.target</code></pre><h4 id="启动kube-scheduler"><a href="#启动kube-scheduler" class="headerlink" title="启动kube-scheduler"></a>启动kube-scheduler</h4><pre><code>$ systemctl daemon-reload$ systemctl enable kube-scheduler$ systemctl start kube-scheduler$ systemctl status kube-scheduler</code></pre><p><strong><em>注意： kube-controller-manager和 kube-scheduler 跟 apiserver 通信都是采用的非安全端口127.0.0.1:8080</em></strong></p><h3 id="配置nginx-proxy"><a href="#配置nginx-proxy" class="headerlink" title="配置nginx-proxy"></a>配置nginx-proxy</h3><blockquote><p>根据具体需要配置nginx-proxy,我这里所有节点都配置了。</p></blockquote><table><tr><td bgcolor="#008000"> master和node </td></tr></table><h4 id="生成nginx配置文件"><a href="#生成nginx配置文件" class="headerlink" title="生成nginx配置文件"></a>生成nginx配置文件</h4><pre><code>$ docker pull nginx:1.13.7-alpine$ mkdir -p /etc/nginx$ cat &lt;&lt; EOF &gt;&gt; /etc/nginx/nginx.conferror_log stderr notice;worker_processes auto;events {  multi_accept on;  use epoll;  worker_connections 1024;}stream {    upstream kube_apiserver {        least_conn;        server 10.173.36.214:6443;        server 10.173.36.216:6443;    }    server {        listen        0.0.0.0:16443;        proxy_pass    kube_apiserver;        proxy_timeout 10m;        proxy_connect_timeout 1s;    }}EOF$ chmod +r /etc/nginx/nginx.conf</code></pre><h4 id="启动nginx-proxy"><a href="#启动nginx-proxy" class="headerlink" title="启动nginx-proxy"></a>启动nginx-proxy</h4><pre><code>$ cat &lt;&lt; EOF &gt;&gt; /etc/systemd/system/nginx-proxy.service # 配置 Nginx 基于 docker 进程，然后配置 systemd 来启动[Unit]Description=kubernetes apiserver docker wrapperWants=docker.socketAfter=docker.service[Service]User=rootPermissionsStartOnly=trueExecStart=/usr/bin/docker run -p 127.0.0.1:16443:16443 \\                              -v /etc/nginx:/etc/nginx \\                              --name nginx-proxy \\                              --net=host \\                              --restart=on-failure:5 \\                              --memory=512M \\                              nginx:1.13.7-alpineExecStartPre=-/usr/bin/docker rm -f nginx-proxyExecStop=/usr/bin/docker stop nginx-proxyRestart=alwaysRestartSec=15sTimeoutStartSec=30s[Install]WantedBy=multi-user.targetEOF$ systemctl daemon-reload$ systemctl start nginx-proxy$ systemctl enable nginx-proxy$ systemctl status nginx-proxy</code></pre><h3 id="查看集群信息"><a href="#查看集群信息" class="headerlink" title="查看集群信息"></a>查看集群信息</h3><h4 id="查看各组件信息"><a href="#查看各组件信息" class="headerlink" title="查看各组件信息"></a>查看各组件信息</h4><pre><code>$ kubectl get componentstatuses  # 查看各组件信息NAME                 STATUS    MESSAGE              ERRORcontroller-manager   Healthy   okscheduler            Healthy   oketcd-2               Healthy   {&quot;health&quot;: &quot;true&quot;}etcd-1               Healthy   {&quot;health&quot;: &quot;true&quot;}etcd-0               Healthy   {&quot;health&quot;: &quot;true&quot;}</code></pre><h4 id="查看集群状态信息"><a href="#查看集群状态信息" class="headerlink" title="查看集群状态信息"></a>查看集群状态信息</h4><pre><code>$ kubectl cluster-info # 查看集群信息Kubernetes master is running at https://127.0.0.1:16443CoreDNS is running at https://127.0.0.1:16443/api/v1/namespaces/kube-system/services/coredns:dns/proxykubernetes-dashboard is running at https://127.0.0.1:16443/api/v1/namespaces/kube-system/services/kubernetes-dashboard/proxy</code></pre><h2 id="Kubernetes-集群（Node）"><a href="#Kubernetes-集群（Node）" class="headerlink" title="Kubernetes 集群（Node）"></a>Kubernetes 集群（Node）</h2><blockquote><p>k8s的工作节点只需要运行kubelet及kube-proxy即可，kubelet的证书由Master端自动生成。</p><table><tr><td bgcolor="#008000"> master </td></tr></table></blockquote><h3 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h3><blockquote><p>kubelet 启动时向 kube-apiserver 发送 TLS bootstrapping 请求，需要先将 bootstrap token 文件中的 kubelet-bootstrap 用户赋予 system:node-bootstrapper 角色，然后 kubelet 才有权限创建认证请求(certificatesigningrequests)。</p></blockquote><h4 id="RBAC授权"><a href="#RBAC授权" class="headerlink" title="RBAC授权"></a>RBAC授权</h4><pre><code>$ kubectl create clusterrolebinding kubelet-bootstrap -- \clusterrole=system:node-bootstrapper --user=kubelet-bootstrap</code></pre><p><strong><em>注意：创建一个集群授权用户 kubelet-bootstrap，用户首次与apiserver通信使用！定义了kubelet进程的权限RBAC中用户和资源之间的连接权限。</em></strong></p><h4 id="生成bootstrap-kubeconfig配置"><a href="#生成bootstrap-kubeconfig配置" class="headerlink" title="生成bootstrap.kubeconfig配置"></a>生成bootstrap.kubeconfig配置</h4><pre><code>$ kubectl config set-cluster kubernetes \  --certificate-authority=/etc/kubernetes/ssl/ca.pem \  --embed-certs=true \  --server=https://127.0.0.1:16443 \  --kubeconfig=bootstrap.kubeconfig # 配置集群$ kubectl config set-credentials kubelet-bootstrap \  --token=a0a5d162e00fff4420406defaae32e17 \  --kubeconfig=bootstrap.kubeconfig # 客户端认证$ kubectl config set-context default \  --cluster=kubernetes \  --user=kubelet-bootstrap \  --kubeconfig=bootstrap.kubeconfig # 配置关联$ kubectl config use-context default --kubeconfig=bootstrap.kubeconfig # 配置默认关联mv bootstrap.kubeconfig /etc/kubernetes/scp -p  /etc/kubernetes/bootstrap.kubeconfig  root@k8s-node02:/etc/kubernetes</code></pre><p><strong><em>注意：这里生成的bootstrap.kubeconfig非常重要,在 apiserver 配置中指定了一个 token.csv 文件，该文件中是一个预设的用户配置；同时该用户的 Token 和 apiserver 的 CA 证书被写入了 kubelet 所使用的 bootstrap.kubeconfig 配置文件中；这样在首次请求时，kubelet 使用 bootstrap.kubeconfig 中的 apiserver CA 证书来与 apiserver 建立 TLS 通讯，使用 bootstrap.kubeconfig 中的用户 Token 来向 apiserver 声明自己的 RBAC 授权身份</em></strong></p><h4 id="创建-kubelet-service-文件"><a href="#创建-kubelet-service-文件" class="headerlink" title="创建 kubelet.service 文件"></a>创建 kubelet.service 文件</h4><table><tr><td bgcolor="#008000"> node </td></tr></table><pre><code>$ mkdir /var/lib/kubelet$ vi /etc/systemd/system/kubelet.serviceAfter=docker.serviceRequires=docker.service[Service]WorkingDirectory=/var/lib/kubeletExecStart=/usr/local/bin/kubelet \  --cgroup-driver=cgroupfs \  --hostname-override=k8s-node01 \  --pod-infra-container-image=k8s-master01:8001/google_containers/pause:3.0 \  --experimental-bootstrap-kubeconfig=/etc/kubernetes/bootstrap.kubeconfig \  --kubeconfig=/etc/kubernetes/kubelet.kubeconfig \  --cert-dir=/etc/kubernetes/ssl \  --cluster_dns=10.254.0.2 \  --cluster_domain=cluster.local. \  --hairpin-mode promiscuous-bridge \  --allow-privileged=true \  --fail-swap-on=false \  --serialize-image-pulls=false \  --logtostderr=true \  --max-pods=512 \  --v=1[Install]WantedBy=multi-user.target</code></pre><h4 id="启动kubelet服务"><a href="#启动kubelet服务" class="headerlink" title="启动kubelet服务"></a>启动kubelet服务</h4><pre><code>$ systemctl daemon-reload$ systemctl enable kubelet$ systemctl start kubelet # 启动kubelet$ systemctl status kube$ journalctl -f -t kubelet  和 journalctl -u kubelet # 定位问题</code></pre><h4 id="配置-TLS-认证"><a href="#配置-TLS-认证" class="headerlink" title="配置 TLS 认证"></a>配置 TLS 认证</h4><pre><code>$ kubectl get csr # 查看 csr 的名称$ kubectl get csr | grep Pending | awk &apos;{print $1}&apos; | xargs kubectl certificate approve # 增加 认证</code></pre><h4 id="验证-nodes"><a href="#验证-nodes" class="headerlink" title="验证 nodes"></a>验证 nodes</h4><pre><code>$ kubectl get nodesNAME         STATUS    ROLES     AGE       VERSIONk8s-node01   Ready     &lt;none&gt;    6d        v1.9.1k8s-node02   Ready     &lt;none&gt;    5d        v1.9.1</code></pre><p><strong><em>注意：成功以后会自动生成配置文件与密钥</em></strong></p><pre><code>$ ls /etc/kubernetes/kubelet.kubeconfig/etc/kubernetes/kubelet.kubeconfig$ ls /etc/kubernetes/ssl/kubelet* -l/etc/kubernetes/ssl/kubelet-client.crt/etc/kubernetes/ssl/kubelet-client.key/etc/kubernetes/ssl/kubelet.crt/etc/kubernetes/ssl/kubelet.key</code></pre><h3 id="配置-kube-proxy"><a href="#配置-kube-proxy" class="headerlink" title="配置 kube-proxy"></a>配置 kube-proxy</h3><blockquote><p>证书的生成都是在master节点上完成，然后拷贝到相应的node上</p><table><tr><td bgcolor="#008000"> master </td></tr></table></blockquote><h4 id="生成请求文件"><a href="#生成请求文件" class="headerlink" title="生成请求文件"></a>生成请求文件</h4><pre><code>$ cd /opt/ssl$ vi kube-proxy-csr.json{  &quot;CN&quot;: &quot;system:kube-proxy&quot;,  &quot;hosts&quot;: [],  &quot;key&quot;: {    &quot;algo&quot;: &quot;rsa&quot;,    &quot;size&quot;: 2048  },  &quot;names&quot;: [    {      &quot;C&quot;: &quot;CN&quot;,      &quot;ST&quot;: &quot;GuangZhou&quot;,      &quot;L&quot;: &quot;GuangZhou&quot;,      &quot;O&quot;: &quot;k8s&quot;,      &quot;OU&quot;: &quot;System&quot;    }  ]}</code></pre><h4 id="生成-kube-proxy-证书和私钥"><a href="#生成-kube-proxy-证书和私钥" class="headerlink" title="生成 kube-proxy 证书和私钥"></a>生成 kube-proxy 证书和私钥</h4><pre><code>$ cfssl gencert -ca=/etc/kubernetes/ssl/ca.pem \-ca-key=/etc/kubernetes/ssl/ca-key.pem \-config=/opt/ssl/config.json \-profile=kubernetes  kube-proxy-csr.json | cfssljson -bare kube-proxy # 生成证书$ ls kube-proxy*  // 查看生成证书和私钥kube-proxy.csr  kube-proxy-csr.json  kube-proxy-key.pem  kube-proxy.pem$ cp kube-proxy* /etc/kubernetes/ssl/ 分发证书及私钥$ scp kube-proxy* k8s-node01:/etc/kubernetes/ssl/$ scp kube-proxy* k8s-node02:/etc/kubernetes/ssl/</code></pre><h4 id="创建-kube-proxy-kubeconfig-文件"><a href="#创建-kube-proxy-kubeconfig-文件" class="headerlink" title="创建 kube-proxy kubeconfig 文件"></a>创建 kube-proxy kubeconfig 文件</h4><pre><code>$ kubectl config set-cluster kubernetes \   --certificate-authority=/etc/kubernetes/ssl/ca.pem \   --embed-certs=true \  --server=https://127.0.0.1:16443 \   --kubeconfig=kube-proxy.kubeconfig  # 配置集群$ kubectl config set-credentials kube-proxy \  --client-certificate=/etc/kubernetes/ssl/kube-proxy.pem \  --client-key=/etc/kubernetes/ssl/kube-proxy-key.pem \  --embed-certs=true \  --kubeconfig=kube-proxy.kubeconfig # 配置客户端认证$ kubectl config set-context default \  --cluster=kubernetes \  --user=kube-proxy \  --kubeconfig=kube-proxy.kubeconfig$ kubectl config use-context default --kubeconfig=kube-proxy.kubeconfig$ scp kube-proxy.kubeconfig k8s-node01:/etc/kubernetes/ # 分发到node节点$ scp kube-proxy.kubeconfig k8s-node02:/etc/kubernetes/</code></pre><h4 id="创建-kube-proxy-service-文件"><a href="#创建-kube-proxy-service-文件" class="headerlink" title="创建 kube-proxy.service 文件"></a>创建 kube-proxy.service 文件</h4><blockquote><p>打开 ipvs 需要安装 ipvsadm 软件</p></blockquote><table><tr><td bgcolor="#008000"> node </td></tr></table><pre><code>$ yum install ipvsadm -y$ yum install ipset -y$ yum install conntrack -y$ mkdir -p /var/lib/kube-proxy$ vi /etc/systemd/system/kube-proxy.service[Unit]Description=Kubernetes Kube-Proxy ServerDocumentation=https://github.com/GoogleCloudPlatform/kubernetesAfter=network.target[Service]WorkingDirectory=/var/lib/kube-proxyExecStart=/usr/local/bin/kube-proxy \  --bind-address=10.173.36.216 \  --hostname-override=k8s-node01 \  --cluster-cidr=10.253.0.0/16 \  --masquerade-all \  --feature-gates=SupportIPVSProxyMode=true \  --proxy-mode=ipvs \  --ipvs-min-sync-period=5s \  --ipvs-sync-period=5s \  --ipvs-scheduler=rr \  --kubeconfig=/etc/kubernetes/kube-proxy.kubeconfig \  --logtostderr=true \  --v=1Restart=on-failureRestartSec=5LimitNOFILE=65536[Install]WantedBy=multi-user.target</code></pre><h4 id="启动kube-proxy"><a href="#启动kube-proxy" class="headerlink" title="启动kube-proxy"></a>启动kube-proxy</h4><pre><code>$ systemctl daemon-reload$ systemctl enable kube-proxy$ systemctl start kube-proxy # 启动kube-proxy$ systemctl status kube-proxy$ journalctl -f -t kube-proxy  和 journalctl -u kube-proxy # 定位问题</code></pre><h4 id="检查ipvs"><a href="#检查ipvs" class="headerlink" title="检查ipvs"></a>检查ipvs</h4><pre><code>$ ipvsadm -L -nIP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConnTCP  10.254.0.1:443 rr persistent 10800  -&gt; 10.173.36.214:6443           Masq    1      1          0  -&gt; 10.173.36.216:6443           Masq    1      0          0</code></pre><h2 id="配置-Flannel-网络"><a href="#配置-Flannel-网络" class="headerlink" title="配置 Flannel 网络"></a>配置 Flannel 网络</h2><blockquote><p>配置完Flannel网络，会覆盖原来docker0的配置，k8s中所有pods将使用这个网段！</p></blockquote><table><tr><td bgcolor="#008000"> node 和master</td></tr></table><h3 id="下载Flannel包"><a href="#下载Flannel包" class="headerlink" title="下载Flannel包"></a>下载Flannel包</h3><pre><code>$ cd /opt/tools$ wget https://github.com/coreos/flannel/releases/download/v0.10.0/flannel-v0.10.0-linux-amd64.tar.gz # 拷贝包里面的flanneld 和 mk-docker-opts.sh$ tar xf  flannel-v0.10.0-linux-amd64.tar.gz$ cp flanneld  mk-docker-opts.sh /usr/local/bin$ scp -p mk-docker-opts.sh  mk-docker-opts.sh root@k8s-node02:/usr/local/bin</code></pre><h3 id="设置集群的网络范围"><a href="#设置集群的网络范围" class="headerlink" title="设置集群的网络范围"></a>设置集群的网络范围</h3><pre><code>$ etcdctl --endpoints=https://10.173.36.214:2379,https://10.173.36.215:2379,\https://10.173.36.216:2379   --ca-file=/etc/kubernetes/ssl/ca.pem  \ --cert-file=/etc/kubernetes/ssl/etcd.pem \ --key-file=/etc/kubernetes/ssl/etcd-key.pem  mkdir /kubernetes/network$ etcdctl --endpoints=https://10.173.36.214:2379,https://10.173.36.215:2379,\https://10.173.36.216:2379  --ca-file=/etc/kubernetes/ssl/ca.pem \  --cert-file=/etc/kubernetes/ssl/etcd.pem  \  --key-file=/etc/kubernetes/ssl/etcd-key.pem  \ mk /kubernetes/network/config &apos;{ &quot;Network&quot;: &quot;10.253.0.0/16&quot;, &quot;Backend&quot;: { &quot;Type&quot;: &quot;vxlan&quot;, &quot;VNI&quot;: 1 }}&apos;</code></pre><h3 id="创建flanneld-service文件"><a href="#创建flanneld-service文件" class="headerlink" title="创建flanneld service文件"></a>创建flanneld service文件</h3><pre><code>$ vim /etc/systemd/system/flanneld.service[Unit]Description=Flanneld overlay address etcd agentAfter=network.targetAfter=network-online.targetWants=network-online.targetAfter=etcd.serviceBefore=docker.service[Service]Type=notifyExecStart=/usr/local/bin/flanneld \-etcd-cafile=/etc/kubernetes/ssl/ca.pem \-etcd-certfile=/etc/kubernetes/ssl/etcd.pem  \-etcd-keyfile=/etc/kubernetes/ssl/etcd-key.pem\-etcd-endpoints=https://10.173.36.216:2379,https://0.173.36.214:2379,https://0.173.36.215:2379 \-etcd-prefix=/kubernetes/network \-iface=eth0ExecStartPost=/usr/local/bin/mk-docker-opts.sh -k DOCKER_NETWORK_OPTIONS -d /run/flannel/dockerRestart=on-failure[Install]WantedBy=multi-user.targetRequiredBy=docker.service</code></pre><h3 id="修改dokcer-service文件"><a href="#修改dokcer-service文件" class="headerlink" title="修改dokcer service文件"></a>修改dokcer service文件</h3><blockquote><p>还需要关联docker和flanneld配置,并重启机器。</p></blockquote><pre><code>$ vim /etc/systemd/system/docker.serviceEnvironmentFile=/run/flannel/docker # 增加这个参数$ reboot</code></pre><p><strong>重启前操作：</strong></p><ul><li>master01:<br>systemctl  enable etcd  flanneld  kube-apiserver kube-controller-manager kube-scheduler   docker</li></ul><ul><li><p>node01:<br>systemctl enable  kube-apiserver kube-controller-manager kube-scheduler docker etcd flanneld kubelet kube-proxy</p></li><li><p>node02:<br>systemctl  enable docker  etcd flanneld kubelet kube-proxy   nginx-proxy</p></li></ul><h3 id="验证网络"><a href="#验证网络" class="headerlink" title="验证网络"></a>验证网络</h3><blockquote><p>ifconfig  查看  docker0 网络 是否已经更改为配置IP网段</p></blockquote><pre><code>$ mkdir /opt/build$ vim nginx.yamlapiVersion: extensions/v1beta1kind: Deploymentmetadata:  name: nginx-dmspec:  replicas: 2  template:    metadata:      labels:        name: nginx    spec:      containers:        - name: nginx          image: nginx:alpine          imagePullPolicy: IfNotPresent          ports:            - containerPort: 80---apiVersion: v1kind: Servicemetadata:  name: nginx-svcspec:  ports:    - port: 80      targetPort: 80      protocol: TCP  selector:    name: nginx$ kubectl create -f nginx.yaml$ kubectl get pods  -o wideNAME                        READY     STATUS    RESTARTS   AGE       IP            NODEnginx-dm-84f8f49555-ddn7x   1/1       Running   0          3d        10.253.76.2   k8s-node02nginx-dm-84f8f49555-sjvbj   1/1       Running   0          3d        10.253.76.5   k8s-node02$ kubectl get svc  -o wideNAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE       SELECTORkubernetes   ClusterIP   10.254.0.1      &lt;none&gt;        443/TCP   6d        &lt;none&gt;nginx-svc    ClusterIP   10.254.173.38   &lt;none&gt;        80/TCP    4d        name=nginx[root@k8s-node01 ~]# curl 10.254.173.38 # 在安装kube-proxy的节点使用&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt;    body {        width: 35em;        margin: 0 auto;        font-family: Tahoma, Verdana, Arial, sans-serif;    }&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer to&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;Commercial support is available at&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="配置-CoreDNS"><a href="#配置-CoreDNS" class="headerlink" title="配置 CoreDNS"></a>配置 <a href="https://coredns.io" target="_blank" rel="noopener">CoreDNS</a></h2><h3 id="下载并启动coreDNS-svc"><a href="#下载并启动coreDNS-svc" class="headerlink" title="下载并启动coreDNS svc"></a>下载并启动coreDNS svc</h3><ul><li>官方镜像<br>coredns/coredns:1.0.4</li><li>我的镜像<br>k8s-master01:8001/coredns:1.0.4</li></ul><table><tr><td bgcolor="#008000"> master</td></tr></table><pre><code>$ docker pull coredns/coredns:1.0.4$ docker tag coredns/coredns:1.0.4  k8s-master01:8001/coredns:1.0.4$ docker push  k8s-master01:8001/coredns:1.0.4$ cd /opt/build$ vim coredns.yamlapiVersion: v1kind: ServiceAccountmetadata:  name: coredns  namespace: kube-system  labels:      kubernetes.io/cluster-service: &quot;true&quot;      addonmanager.kubernetes.io/mode: Reconcile---apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRolemetadata:  labels:    kubernetes.io/bootstrapping: rbac-defaults    addonmanager.kubernetes.io/mode: Reconcile  name: system:corednsrules:- apiGroups:  - &quot;&quot;  resources:  - endpoints  - services  - pods  - namespaces  verbs:  - list  - watch---apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRoleBindingmetadata:  annotations:    rbac.authorization.kubernetes.io/autoupdate: &quot;true&quot;  labels:    kubernetes.io/bootstrapping: rbac-defaults    addonmanager.kubernetes.io/mode: EnsureExists  name: system:corednsroleRef:  apiGroup: rbac.authorization.k8s.io  kind: ClusterRole  name: system:corednssubjects:- kind: ServiceAccount  name: coredns  namespace: kube-system---apiVersion: v1kind: ConfigMapmetadata:  name: coredns  namespace: kube-system  labels:      addonmanager.kubernetes.io/mode: EnsureExistsdata:  Corefile: |    .:53 {        errors        log stdout        health        kubernetes cluster.local 10.254.0.0/16        prometheus        proxy . /etc/resolv.conf        cache 30    }---apiVersion: extensions/v1beta1kind: Deploymentmetadata:  name: coredns  namespace: kube-system  labels:    k8s-app: coredns    kubernetes.io/cluster-service: &quot;true&quot;    addonmanager.kubernetes.io/mode: Reconcile    kubernetes.io/name: &quot;CoreDNS&quot;spec:  replicas: 1  selector:    matchLabels:      k8s-app: coredns  template:    metadata:      labels:        k8s-app: coredns    spec:      serviceAccountName: coredns      tolerations:        - key: node-role.kubernetes.io/master          effect: NoSchedule        - key: &quot;CriticalAddonsOnly&quot;          operator: &quot;Exists&quot;      containers:      - name: coredns        image: k8s-master01:8001/coredns:1.0.4        imagePullPolicy: IfNotPresent        resources:          limits:            memory: 170Mi          requests:            cpu: 100m            memory: 70Mi        args: [ &quot;-conf&quot;, &quot;/etc/coredns/Corefile&quot; ]        volumeMounts:        - name: config-volume          mountPath: /etc/coredns        ports:        - containerPort: 53          name: dns          protocol: UDP        - containerPort: 53          name: dns-tcp          protocol: TCP        - containerPort: 9153          name: metrics          protocol: TCP        livenessProbe:          httpGet:            path: /health            port: 8080            scheme: HTTP          initialDelaySeconds: 60          timeoutSeconds: 5          successThreshold: 1          failureThreshold: 5      dnsPolicy: Default      volumes:        - name: config-volume          configMap:            name: coredns            items:            - key: Corefile              path: Corefile---apiVersion: v1kind: Servicemetadata:  name: coredns  namespace: kube-system  labels:    k8s-app: coredns    kubernetes.io/cluster-service: &quot;true&quot;    addonmanager.kubernetes.io/mode: Reconcile    kubernetes.io/name: &quot;CoreDNS&quot;spec:  selector:    k8s-app: coredns  clusterIP: 10.254.0.2  ports:  - name: dns    port: 53    protocol: UDP  - name: dns-tcp    port: 53    protocol: TCP  - name: metrics    port: 9153    protocol: TCP$ kubectl create -f coredns.yaml</code></pre><p><strong>配置说明:</strong></p><ul><li><p>这里 kubernetes cluster.local 为 创建 svc 的 IP 段10.254.0.0/16</p></li><li><p>clusterIP  为 指定 DNS 的 IP clusterIP: 10.254.0.2</p></li></ul><h3 id="验证-dns-服务"><a href="#验证-dns-服务" class="headerlink" title="验证 dns 服务"></a>验证 dns 服务</h3><p>创建一个 pods 来测试一下 dns</p><pre><code>$ vim /opt/build/alpine.yamlapiVersion: v1kind: Podmetadata:  name: alpinespec:  containers:  - name: alpine    image: alpine    command:    - sh    - -c    - while true; do sleep 1; done$ kubectl exec -it alpine nslookup nginx-svc # 测试解析nslookup: can&apos;t resolve &apos;(null)&apos;: Name does not resolveName:      nginx-svcAddress 1: 10.254.173.38 nginx-svc.default.svc.cluster.local</code></pre><h2 id="部署-Dashboard和Heapster"><a href="#部署-Dashboard和Heapster" class="headerlink" title="部署  Dashboard和Heapster"></a>部署  Dashboard和Heapster</h2><ul><li><a href="gcr.io">官方 google_container地址</a></li><li><a href="https://hub.tenxcloud.com/search?q=google_containers&amp;source=tenxcloud" target="_blank" rel="noopener">时速云 google_container 镜像地址</a>   # 当然使用国内镜像更快</li></ul><h3 id="下载-dashboard和heapster镜像"><a href="#下载-dashboard和heapster镜像" class="headerlink" title="下载 dashboard和heapster镜像"></a>下载 dashboard和heapster镜像</h3><pre><code>$ docker pull index.tenxcloud.com/google_containers/kubernetes-dashboard-amd64:v1.4.0$ docker pull index.tenxcloud.com/google_containers/heapster:v1.2.0$ docker tag index.tenxcloud.com/google_containers/kubernetes-dashboard-amd64:v1.4.0 k8s-master01:8001/google_containers/kubernetes-dashboard-amd64:v1.4.0$ docker tag index.tenxcloud.com/google_containers/heapster:v1.2.0   k8s-master01:8001/google_containers/google_containers/heapster:v1.2.0$ docker push k8s-master01:8001/google_containers/kubernetes-dashboard-amd64:v1.4.0$ docker push  k8s-master01:8001/google_containers/google_containers/heapster:v1.2.0</code></pre><h3 id="启动dashboard应用"><a href="#启动dashboard应用" class="headerlink" title="启动dashboard应用"></a>启动dashboard应用</h3><pre><code>$ vim  dashboard.yamlapiVersion: v1kind: ServiceAccountmetadata:  name: kubernetes-dashboard  namespace: kube-system---apiVersion: rbac.authorization.k8s.io/v1beta1kind: ClusterRoleBindingmetadata:  name: kubernetes-dashboard  labels:    k8s-app: kubernetes-dashboardroleRef:  apiGroup: rbac.authorization.k8s.io  kind: ClusterRole  name: cluster-adminsubjects:- kind: ServiceAccount  name: kubernetes-dashboard  namespace: kube-system---apiVersion: extensions/v1beta1kind: Deploymentmetadata:  name: kubernetes-dashboard  namespace: kube-system  labels:    k8s-app: kubernetes-dashboard    kubernetes.io/cluster-service: &quot;true&quot;    addonmanager.kubernetes.io/mode: Reconcilespec:  selector:    matchLabels:      k8s-app: kubernetes-dashboard  template:    metadata:      labels:        k8s-app: kubernetes-dashboard      annotations:        scheduler.alpha.kubernetes.io/critical-pod: &apos;&apos;    spec:      serviceAccountName: kubernetes-dashboard      containers:      - name: kubernetes-dashboard        image: k8s-master01:8001/google_containers/kubernetes-dashboard-amd64:v1.4.0        resources:          limits:            cpu: 100m            memory: 300Mi          requests:            cpu: 100m            memory: 100Mi        ports:        - containerPort: 9090        livenessProbe:          httpGet:            path: /            port: 9090          initialDelaySeconds: 30          timeoutSeconds: 30      tolerations:      - key: &quot;CriticalAddonsOnly&quot;        operator: &quot;Exists&quot;$ vim dashboard-svc.yamlapiVersion: v1kind: Servicemetadata:  name: kubernetes-dashboard  namespace: kube-system  labels:    k8s-app: kubernetes-dashboard    kubernetes.io/cluster-service: &quot;true&quot;    addonmanager.kubernetes.io/mode: Reconcilespec:  selector:    k8s-app: kubernetes-dashboard  type: NodePort  ports:  - port: 9090    targetPort: 9090    nodePort: 30001$ kubectl create -f dashboard.yaml$ kubectl create -f dashboard-svc.yaml # 转发到node节点的30001</code></pre><h3 id="启动heapster应用"><a href="#启动heapster应用" class="headerlink" title="启动heapster应用"></a>启动heapster应用</h3><pre><code>$ vim heapster.yamlapiVersion: v1kind: ServiceAccountmetadata:  name: heapster  namespace: kube-system---kind: ClusterRoleBindingapiVersion: rbac.authorization.k8s.io/v1beta1metadata:  name: heapstersubjects:  - kind: ServiceAccount    name: heapster    namespace: kube-systemroleRef:  kind: ClusterRole  name: cluster-admin  apiGroup: rbac.authorization.k8s.io---apiVersion: extensions/v1beta1kind: Deploymentmetadata:  name: heapster  namespace: kube-systemspec:  replicas: 1  template:    metadata:      labels:        task: monitoring        k8s-app: heapster    spec:      serviceAccountName: heapster      containers:      - name: heapster        image: k8s-master01:8001/google_containers/google_containers/heapster:v1.2.0        imagePullPolicy: IfNotPresent        command:        - /heapster        - --source=kubernetes:kubernetes:https://kubernetes.default---apiVersion: v1kind: Servicemetadata:  labels:    task: monitoring    kubernetes.io/cluster-service: &apos;true&apos;    kubernetes.io/name: Heapster  name: heapster  namespace: kube-systemspec:  ports:  - port: 80    targetPort: 8082  selector:    k8s-app: heapster$ kubectl create -f heapster.yaml$ kubectl get pods -o wide -n=kube-systemNAME                                   READY     STATUS    RESTARTS   AGE       IP            NODEcoredns-6b59c4cb6d-lt7st               1/1       Running   0          4d        10.253.76.4   k8s-node02heapster-77dd748d7d-h2g9l              1/1       Running   0          2h        10.253.76.3   k8s-node02kubernetes-dashboard-654448b8b-78hgh   1/1       Running   0          3h        10.253.14.2   k8s-node01</code></pre><p>Dashboard 访问地址: <a href="http://10.173.36.216:30001" target="_blank" rel="noopener">http://10.173.36.216:30001</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;集群环境说明&quot;&gt;&lt;a href=&quot;#集群环境说明&quot; class=&quot;headerlink&quot; title=&quot;集群环境说明&quot;&gt;&lt;/a&gt;集群环境说明&lt;/h2&gt;&lt;h3 id=&quot;服务器信息&quot;&gt;&lt;a href=&quot;#服务器信息&quot; class=&quot;headerlink&quot; title=&quot;服务器信息&quot;&gt;&lt;/a&gt;服务器信息&lt;/h3&gt;&lt;p&gt;这里配置2Master 2个node, k8s-master01只做 Master, k8s-node01即是Master也是Node, k8s-node02单纯做Node。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/04/02/9z62xH.png&quot; alt=&quot;服务器信息&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;集群详情&quot;&gt;&lt;a href=&quot;#集群详情&quot; class=&quot;headerlink&quot; title=&quot;集群详情&quot;&gt;&lt;/a&gt;集群详情&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Kubernetes 1.9.1&lt;/li&gt;
&lt;li&gt;Docker-17.03.1-ce&lt;/li&gt;
&lt;li&gt;Etcd-v3.2.14&lt;/li&gt;
&lt;li&gt;Flanneld-v0.10.0 vxlan&lt;/li&gt;
&lt;li&gt;TLS 认证通信&lt;/li&gt;
&lt;li&gt;RBAC 授权&lt;/li&gt;
&lt;li&gt;Kublet TLS BootStrapping&lt;/li&gt;
&lt;li&gt;Coredns:1.0.4&lt;/li&gt;
&lt;li&gt;Registry-2.6&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="k8s" scheme="http://www.chenfanlinux.org/categories/k8s/"/>
    
    
      <category term="k8s" scheme="http://www.chenfanlinux.org/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Python实战之简单爬虫</title>
    <link href="http://www.chenfanlinux.org/2018/03/14/Python%E5%AE%9E%E6%88%98%E4%B9%8B%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/"/>
    <id>http://www.chenfanlinux.org/2018/03/14/Python实战之简单爬虫/</id>
    <published>2018-03-14T02:59:43.000Z</published>
    <updated>2018-03-14T03:01:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码：爬豆瓣电影Top100"><a href="#代码：爬豆瓣电影Top100" class="headerlink" title="代码：爬豆瓣电影Top100"></a>代码：爬豆瓣电影Top100</h2><h3 id="方式一：-re-urllib"><a href="#方式一：-re-urllib" class="headerlink" title="方式一： re   +  urllib"></a>方式一： <a href="https://www.cnblogs.com/huxi/archive/2010/07/04/1771073.html" target="_blank" rel="noopener">re</a>   +  urllib</h3><pre><code># _*_ coding:utf-8 _*_&apos;&apos;&apos;&lt;span class=&quot;title&quot;&gt;肖申克的救赎&lt;/span&gt;&lt;em class=&quot;&quot;&gt;1&lt;/em&gt;&apos;&apos;&apos;import ioimport sysimport refrom urllib.request import urlopensys.stdout = io.TextIOWrapper(sys.stdout.buffer,encoding=&apos;gb18030&apos;)top_num = 1url_base = &apos;https://movie.douban.com/top250?start=&apos;urls = [url_base + str(i*25) for i in range(0,4)]for url in urls:    html = urlopen(url).read().decode(&apos;utf-8&apos;)    top_tag = re.compile(r&apos;&lt;span class=&quot;title&quot;&gt;(.*)&lt;/span&gt;&apos;)    title = re.findall(top_tag, html)    for i in title:        if i.find(&apos;/&apos;) == -1:            print(&apos;Top&apos; + str(top_num) + &apos; &apos; + i)            top_num += 1</code></pre><a id="more"></a><h3 id="方式二：-requests-BeautifulSoup"><a href="#方式二：-requests-BeautifulSoup" class="headerlink" title="方式二： requests + BeautifulSoup"></a>方式二： <a href="https://requests-docs-cn.readthedocs.io/zh_CN/latest/index.html" target="_blank" rel="noopener">requests</a> + <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/#id5" target="_blank" rel="noopener">BeautifulSoup</a></h3><pre><code># _*_ coding:utf-8 _*_&apos;&apos;&apos;&lt;span class=&quot;title&quot;&gt;肖申克的救赎&lt;/span&gt;pip install requestspip install BeautifulSoup&apos;&apos;&apos;import requestsfrom  bs4 import  BeautifulSouptop_num = 1url = &apos;https://movie.douban.com/top250?start=&apos;urls = [url + str(i*25) for i in range(0,4)]for url in urls:    r = requests.get(url)    html = r.text    # 实例化    soup = BeautifulSoup(html,&apos;html.parser&apos;)    movies = soup.find_all(&apos;span&apos;, class_=&apos;title&apos;)    for i in movies:        if i.text.find(&apos;/&apos;) == -1:            print(&apos;Top&apos; + str(top_num) + &apos; &apos; + i.text )            top_num += 1</code></pre><h3 id="运行结果展示"><a href="#运行结果展示" class="headerlink" title="运行结果展示"></a>运行结果展示</h3><pre><code>$ python .\豆瓣Top100.pyTop1 肖申克的救赎Top2 霸王别姬Top3 这个杀手不太冷Top4 阿甘正传Top5 美丽人生Top6 千与千寻Top7 泰坦尼克号Top8 辛德勒的名单Top9 盗梦空间Top10 机器人总动员Top11 海上钢琴师Top12 三傻大闹宝莱坞Top13 忠犬八公的故事Top14 放牛班的春天Top15 大话西游之大圣娶亲Top16 楚门的世界Top17 教父Top18 龙猫Top19 熔炉Top20 乱世佳人Top21 星际穿越Top22 触不可及Top23 无间道Top24 当幸福来敲门Top25 天堂电影院Top26 怦然心动Top27 十二怒汉Top28 搏击俱乐部Top29 少年派的奇幻漂流Top30 鬼子来了Top31 指环王3：王者无敌Top32 蝙蝠侠：黑暗骑士Top33 活着Top34 天空之城Top35 罗马假日Top36 大话西游之月光宝盒Top37 飞屋环游记Top38 疯狂动物城Top39 窃听风暴Top40 两杆大烟枪Top41 飞越疯人院Top42 控方证人Top43 闻香识女人Top44 海豚湾Top45 哈尔的移动城堡Top46 V字仇杀队Top47 辩护人Top48 死亡诗社Top49 教父2Top50 美丽心灵Top51 指环王2：双塔奇兵Top52 指环王1：魔戒再现Top53 情书Top54 饮食男女Top55 美国往事Top56 狮子王Top57 钢琴家Top58 天使爱美丽Top59 七宗罪Top60 摔跤吧！爸爸Top61 被嫌弃的松子的一生Top62 素媛Top63 小鞋子Top64 致命魔术Top65 勇敢的心Top66 音乐之声Top67 剪刀手爱德华Top68 本杰明·巴顿奇事Top69 低俗小说Top70 看不见的客人Top71 西西里的美丽传说Top72 黑客帝国Top73 拯救大兵瑞恩Top74 沉默的羔羊Top75 入殓师Top76 蝴蝶效应Top77 玛丽和马克思Top78 让子弹飞Top79 春光乍泄Top80 大闹天宫Top81 心灵捕手Top82 阳光灿烂的日子Top83 幽灵公主Top84 第六感Top85 末代皇帝Top86 重庆森林Top87 禁闭岛Top88 大鱼Top89 狩猎Top90 布达佩斯大饭店Top91 射雕英雄传之东成西就Top92 哈利·波特与魔法石Top93 甜蜜蜜Top94 致命IDTop95 一一Top96 阳光姐妹淘Top97 断背山Top98 告白Top99 猫鼠游戏Top100 上帝之城</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;代码：爬豆瓣电影Top100&quot;&gt;&lt;a href=&quot;#代码：爬豆瓣电影Top100&quot; class=&quot;headerlink&quot; title=&quot;代码：爬豆瓣电影Top100&quot;&gt;&lt;/a&gt;代码：爬豆瓣电影Top100&lt;/h2&gt;&lt;h3 id=&quot;方式一：-re-urllib&quot;&gt;&lt;a href=&quot;#方式一：-re-urllib&quot; class=&quot;headerlink&quot; title=&quot;方式一： re   +  urllib&quot;&gt;&lt;/a&gt;方式一： &lt;a href=&quot;https://www.cnblogs.com/huxi/archive/2010/07/04/1771073.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;re&lt;/a&gt;   +  urllib&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;# _*_ coding:utf-8 _*_


&amp;apos;&amp;apos;&amp;apos;
&amp;lt;span class=&amp;quot;title&amp;quot;&amp;gt;肖申克的救赎&amp;lt;/span&amp;gt;
&amp;lt;em class=&amp;quot;&amp;quot;&amp;gt;1&amp;lt;/em&amp;gt;
&amp;apos;&amp;apos;&amp;apos;
import io
import sys
import re
from urllib.request import urlopen
sys.stdout = io.TextIOWrapper(sys.stdout.buffer,encoding=&amp;apos;gb18030&amp;apos;)
top_num = 1
url_base = &amp;apos;https://movie.douban.com/top250?start=&amp;apos;
urls = [url_base + str(i*25) for i in range(0,4)]
for url in urls:
    html = urlopen(url).read().decode(&amp;apos;utf-8&amp;apos;)
    top_tag = re.compile(r&amp;apos;&amp;lt;span class=&amp;quot;title&amp;quot;&amp;gt;(.*)&amp;lt;/span&amp;gt;&amp;apos;)
    title = re.findall(top_tag, html)
    for i in title:
        if i.find(&amp;apos;/&amp;apos;) == -1:
            print(&amp;apos;Top&amp;apos; + str(top_num) + &amp;apos; &amp;apos; + i)
            top_num += 1
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="python项目实战" scheme="http://www.chenfanlinux.org/categories/python%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="Python" scheme="http://www.chenfanlinux.org/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python项目实战之密码管理器</title>
    <link href="http://www.chenfanlinux.org/2018/03/13/Python%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B9%8B%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    <id>http://www.chenfanlinux.org/2018/03/13/Python项目实战之密码管理器/</id>
    <published>2018-03-13T07:34:52.000Z</published>
    <updated>2018-03-13T07:41:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h2><h3 id="写入密码"><a href="#写入密码" class="headerlink" title="写入密码"></a>写入密码</h3><pre><code>$  python .\zpass4.py -m w1 web, 2 server, 0 退出 1title:chenfanlinuxuser:chenfanpasswd:123456url:chenfanlinux.org{&apos;web&apos;: {&apos;chenfanlinux&apos;: {&apos;passwd&apos;: &apos;123456&apos;,                          &apos;url&apos;: &apos;chenfanlinux.org&apos;,                          &apos;user&apos;: &apos;chenfan&apos;}}}保存成功!$  python .\zpass4.py -m w1 web, 2 server, 0 退出 2title:tomcat01user:rootpasswd:123hostname:tomcat01-serverip:127.0.0.1{&apos;server&apos;: {&apos;tomcat01&apos;: {&apos;hostname&apos;: &apos;tomcat01-server&apos;,                         &apos;ip&apos;: &apos;127.0.0.1&apos;,                         &apos;passwd&apos;: &apos;123&apos;,                         &apos;user&apos;: &apos;root&apos;}}, &apos;web&apos;: {&apos;chenfanlinux&apos;: {&apos;passwd&apos;: &apos;123456&apos;,                          &apos;url&apos;: &apos;chenfanlinux.org&apos;,                          &apos;user&apos;: &apos;chenfan&apos;}}}保存成功!</code></pre><h3 id="查找密码"><a href="#查找密码" class="headerlink" title="查找密码"></a>查找密码</h3><pre><code>$ python .\zpass4.py -m r -c web -i chenfanlinux{&apos;passwd&apos;: &apos;123456&apos;, &apos;url&apos;: &apos;chenfanlinux.org&apos;, &apos;user&apos;: &apos;chenfan&apos;}</code></pre><h3 id="生成密码"><a href="#生成密码" class="headerlink" title="生成密码"></a>生成密码</h3><pre><code>$ python .\zpass4.py -m g -l 10CCrkoMjbhA</code></pre><a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># _*_ coding:utf8 _*_&apos;&apos;&apos;密码管理器:* 保存密码* 取密码密码数据保存格式:{ category: { title : value1} }{  &apos;web&apos; : {&quot;chenfanlinux&quot;: {&quot;user&quot;:&quot;chenfan&quot;,&quot;passwd&quot;:&quot;123456&quot;,&quot;url&quot;: &quot;www.chenfanlinux.org&quot;},           &quot;zhihu&quot;: {&quot;user&quot;: &quot;chenfan&quot;,&quot;passwd&quot;: &quot;123456&quot;,&quot;url&quot; : &quot;www.zhihu.com&quot;}          }, &apos;server&apos; :          { &quot;nginx&quot;:{ &quot;user&quot;: &quot;root&quot;,&quot;passwd&quot;: &quot;123456&quot;,&quot;hostname&quot;: &quot;localhost&quot;,&quot;ip&quot;: &quot;127.0.0.1&quot;},            &quot;tomcat&quot;:{&quot;user&quot;: &quot;chenfan&quot;,&quot;passwd&quot;: &quot;123&quot; ,&quot;hostname&quot;: &quot;tomcat01&quot;,&quot;ip&quot; : &quot;192.168.0.1&quot;}          }}* 密码存取方式:    * 写密码      python zpass.py w               user_choise ---&gt; 1(web),2(server),0(退出)      python zpass.py r category title&apos;&apos;&apos;import pickleimport sysimport pprintimport argparseimport stringimport randomparser = argparse.ArgumentParser()parser.add_argument(&apos;-m&apos;, action=&apos;store&apos;, dest=&apos;method&apos;,                    help=&apos;操作方式 w:写密码, r查找密码, g: 生成密码&apos;)parser.add_argument(&apos;-c&apos;, action=&apos;store&apos;, dest=&apos;category&apos;,                    help=&apos;类别&apos;)parser.add_argument(&apos;-i&apos;, action=&apos;store&apos;, dest=&apos;title&apos;,                    help=&apos;查找的名称&apos;)parser.add_argument(&apos;-l&apos;, type = int, action=&apos;store&apos;, dest=&apos;length&apos;,                    help=&apos;密码长度&apos;)args = parser.parse_args()def select_db():    try:        with open (&apos;passwd.zpass&apos;,&apos;rb&apos;) as f:            return pickle.load(f)    except IOError:        return False    except Exception as e:        raise edef insert_db(user_data):    try:        with open(&apos;passwd.zpass&apos;, &apos;wb&apos;) as f:            pickle.dump(user_data, f)    except IOError:        return False    except Exception as e:        raise e    return Trueclass Password(dict):    def __init__(self, category, title, user, passwd):        super().__init__()        self.title = title        self.category = category        self[title] = {&apos;user&apos;: user, &apos;passwd&apos;: passwd}    @staticmethod    def get_passwd():        passwd_data = select_db() if select_db()  else {}        return passwd_data.get(args.category).get(args.title)    def save_passwd(self):        passwd_data = select_db() if select_db()  else {}        if not passwd_data or self.category not in passwd_data:            passwd_data[self.category] = {}        passwd_data[self.category][self.title] = self[self.title]        pprint.pprint(passwd_data)        insert_status = insert_db(passwd_data)        if not insert_status:            print(&quot;保存失败&quot;)        return True    @classmethod    def get_item(cls):        cls.item = [&apos;title&apos;, &apos;user&apos;, &apos;passwd&apos;]        return cls.itemclass WebPassword(Password):    def __init__(self, category, title, user, passwd,url):        super().__init__(category, title, user, passwd)        self[title][&apos;url&apos;] = url    @classmethod    def get_item(cls):        super().get_item()        cls.item.append(&apos;url&apos;)        return cls.itemclass ServerPassWord(Password):    def __init__(self, category, title, user, passwd, hostname, ip):        super().__init__(category, title, user, passwd)        self[title][&apos;hostname&apos;] = hostname        self[title][&apos;ip&apos;] = ip    @classmethod    def get_item(cls):        super().get_item()        cls.item.append(&apos;hostname&apos;)        cls.item.append(&apos;ip&apos;)        return cls.itemdef handle_passwd():    passwd_args = {}    user_choice = input(&quot;1 web, 2 server, 0 退出 &quot;)    pwd_class =  {    &apos;1&apos; : (&apos;web&apos;, WebPassword),    &apos;2&apos; : (&apos;server&apos;, ServerPassWord)    }    category = pwd_class[user_choice][0]    handle_class = pwd_class[user_choice][1]    for i in handle_class.get_item():        passwd_args[i] = input(i + &quot;:&quot;)    pwd = handle_class(category=category, **passwd_args)    stat = pwd.save_passwd()    if stat is False:        print(&apos;保存失败!&apos;)    print(&apos;保存成功!&apos;)def gen_passwd(length):    chars = string.ascii_letters + string.digits + &quot;!@#$%^&amp;*():&quot;    return &apos;&apos;.join([random.choice(chars) for  i in range(length)])def main():    if args.method == &apos;r&apos;:        print(Password.get_passwd())    elif args.method == &apos;w&apos;:        handle_passwd()    elif args.method == &apos;g&apos;:        print(gen_passwd(args.length))    else:        print(&apos;退出&apos;)if __name__ == &apos;__main__&apos;:    main()</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;使用介绍&quot;&gt;&lt;a href=&quot;#使用介绍&quot; class=&quot;headerlink&quot; title=&quot;使用介绍&quot;&gt;&lt;/a&gt;使用介绍&lt;/h2&gt;&lt;h3 id=&quot;写入密码&quot;&gt;&lt;a href=&quot;#写入密码&quot; class=&quot;headerlink&quot; title=&quot;写入密码&quot;&gt;&lt;/a&gt;写入密码&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;$  python .\zpass4.py -m w
1 web, 2 server, 0 退出 1
title:chenfanlinux
user:chenfan
passwd:123456
url:chenfanlinux.org
{&amp;apos;web&amp;apos;: {&amp;apos;chenfanlinux&amp;apos;: {&amp;apos;passwd&amp;apos;: &amp;apos;123456&amp;apos;,
                          &amp;apos;url&amp;apos;: &amp;apos;chenfanlinux.org&amp;apos;,
                          &amp;apos;user&amp;apos;: &amp;apos;chenfan&amp;apos;}}}
保存成功!


$  python .\zpass4.py -m w
1 web, 2 server, 0 退出 2
title:tomcat01
user:root
passwd:123
hostname:tomcat01-server
ip:127.0.0.1
{&amp;apos;server&amp;apos;: {&amp;apos;tomcat01&amp;apos;: {&amp;apos;hostname&amp;apos;: &amp;apos;tomcat01-server&amp;apos;,
                         &amp;apos;ip&amp;apos;: &amp;apos;127.0.0.1&amp;apos;,
                         &amp;apos;passwd&amp;apos;: &amp;apos;123&amp;apos;,
                         &amp;apos;user&amp;apos;: &amp;apos;root&amp;apos;}},
 &amp;apos;web&amp;apos;: {&amp;apos;chenfanlinux&amp;apos;: {&amp;apos;passwd&amp;apos;: &amp;apos;123456&amp;apos;,
                          &amp;apos;url&amp;apos;: &amp;apos;chenfanlinux.org&amp;apos;,
                          &amp;apos;user&amp;apos;: &amp;apos;chenfan&amp;apos;}}}
保存成功!
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;查找密码&quot;&gt;&lt;a href=&quot;#查找密码&quot; class=&quot;headerlink&quot; title=&quot;查找密码&quot;&gt;&lt;/a&gt;查找密码&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;$ python .\zpass4.py -m r -c web -i chenfanlinux
{&amp;apos;passwd&amp;apos;: &amp;apos;123456&amp;apos;, &amp;apos;url&amp;apos;: &amp;apos;chenfanlinux.org&amp;apos;, &amp;apos;user&amp;apos;: &amp;apos;chenfan&amp;apos;}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;生成密码&quot;&gt;&lt;a href=&quot;#生成密码&quot; class=&quot;headerlink&quot; title=&quot;生成密码&quot;&gt;&lt;/a&gt;生成密码&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;$ python .\zpass4.py -m g -l 10
CCrkoMjbhA
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="python项目实战" scheme="http://www.chenfanlinux.org/categories/python%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="Python" scheme="http://www.chenfanlinux.org/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python进阶之函数式编程</title>
    <link href="http://www.chenfanlinux.org/2018/03/12/Python%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://www.chenfanlinux.org/2018/03/12/Python进阶之函数式编程/</id>
    <published>2018-03-12T15:00:58.000Z</published>
    <updated>2018-03-12T15:02:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>在函数式编程中，我们可以将函数当作变量一样自由使用。一个函数接收另一个函数作为参数，这种函数称之为<strong>高阶函数（Higher-order Functions）</strong>。</p><p>看一个简单的例子：</p><pre><code>def func(g, arr):    return [g(x) for x in arr]</code></pre><p>上面的代码中，func 是一个高阶函数，它接收两个参数，第 1 个参数是函数，第 2 个参数是数组，func 的功能是将函数 g 逐个作用于数组 arr 上，并返回一个新的数组，比如，我们可以这样用：</p><pre><code>def double(x):    return 2 * xdef square(x):    return x * xarr1 = func(double, [1, 2, 3, 4])arr2 = func(square, [1, 2, 3, 4])</code></pre><p>不难判断出，arr1 是 [2, 4, 6, 8]，arr2 是 [1, 4, 9, 16]。<br>可接收其他函数作为参数的函数称为高阶函数。</p><a id="more"></a><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>在 Python 中，我们使用 def 语句来定义函数，比如：</p><pre><code>&gt;&gt;&gt; def double(x):    return 2 * x</code></pre><p>除了用上面的方式定义函数，Python 还提供了一个关键字 lambda，让我们可以创建一个匿名函数，也就是没有名称的函数。它的形式如下：</p><pre><code>lambda 参数: 表达式</code></pre><p>关键字 lambda 说明它是一个匿名函数，冒号 : 前面的变量是该匿名函数的参数，冒号后面是函数的返回值，注意这里不需使用 return 关键字。</p><p>我们将上面的 double 函数改写成一个匿名函数，如下：</p><pre><code>lambda x: 2 * x</code></pre><p>那怎么调用匿名函数呢？可以直接这样使用：</p><pre><code>&gt;&gt;&gt; (lambda x: 2 * x)(8)16</code></pre><p>由于匿名函数本质上是一个函数对象，也可以将其赋值给另一个变量，再由该变量来调用函数，如下：</p><pre><code>&gt;&gt;&gt; f = lambda x: 2 * x   # 将匿名函数赋给变量 f&gt;&gt;&gt; f&lt;function &lt;lambda&gt; at 0x7f835a696578&gt;&gt;&gt;&gt; f(8)16</code></pre><p>lambda 函数一般适用于创建一些临时性的，小巧的函数。比如上面的 double 函数，我们当然可以使用 def 来定义，但使用 lambda 来创建会显得很简洁，尤其是在高阶函数的使用中。</p><ul><li>匿名函数本质上是一个函数，没有函数名称，因此使用匿名函数不用担心函数名冲突；</li><li>匿名函数一般适用于创建一些临时性的，小巧的函数。</li></ul><h2 id="map-reduce-filter"><a href="#map-reduce-filter" class="headerlink" title="map/reduce/filter"></a>map/reduce/filter</h2><p>map/reduce/filter 是 Python 中较为常用的内建高阶函数，它们为函数式编程提供了不少便利。</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map 函数的使用形式如下：</p><pre><code>map(function, sequence)</code></pre><p>解释：对 sequence 中的 item 依次执行 function(item)，并将结果组成一个 List 返回，也就是：</p><pre><code>[function(item1), function(item2), function(item3), ...]</code></pre><p>看一些简单的例子：</p><pre><code>&gt;&gt;&gt; def square(x):    return x * x&gt;&gt;&gt; list(map(square, [1, 2, 3, 4]))[1, 4, 9, 16]&gt;&gt;&gt; list(map(lambda x: x*x , [1, 2, 3, 4]))[1, 4, 9, 16]&gt;&gt;&gt; list(map(str, [1, 2, 3, 4]))[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;]&gt;&gt;&gt; list(map(int, [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;]))[1, 2, 3, 4]</code></pre><p>再看一个例子：</p><pre><code>&gt;&gt;&gt; def double(x):    return 2 * x&gt;&gt;&gt; def triple(x):    return 3 *x&gt;&gt;&gt; def square(x):    return x * x&gt;&gt;&gt; funcs = [double, triple, square]  # 列表元素是函数对象&gt;&gt;&gt;&gt;&gt;&gt; # 相当于 [double(4), triple(4), square(4)]value = list(map(lambda f: f(4), funcs))&gt;&gt;&gt;&gt;&gt;&gt; print(value)[8, 12, 16]&gt;&gt;&gt;</code></pre><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>reduce 函数的使用形式如下：</p><pre><code>reduce(function, sequence[, initial])</code></pre><p><strong>解释</strong>：先将 sequence 的前两个 item 传给 function，即 function(item1, item2)，函数的返回值和 sequence 的下一个 item 再传给 function，即 function(function(item1, item2), item3)，如此迭代，直到 sequence 没有元素，如果有 initial，则作为初始值调用。</p><p>也就是说：</p><pre><code>reduece(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</code></pre><p>看一些例子，就能很快理解了。</p><pre><code>&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; reduce(lambda x, y: x * y, [1, 2, 3, 4])  # 相当于 ((1 * 2) * 3) * 424&gt;&gt;&gt; reduce(lambda x, y: x * y, [1, 2, 3, 4], 5) # ((((5 * 1) * 2) * 3)) * 4120&gt;&gt;&gt; f = lambda a, b: a if (a &gt; b) else b   # 两两比较，取最大值&gt;&gt;&gt; reduce(f, [5, 8, 1, 10])10</code></pre><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>filter 函数用于过滤元素，它的使用形式如下：</p><pre><code>filter(function, sequnce)</code></pre><p><strong>解释</strong>：将 function 依次作用于 sequnce 的每个 item，即 function(item)，将返回值为 True 的 item 组成一个 List/String/Tuple (取决于 sequnce 的类型，python3 统一返回迭代器) 返回</p><pre><code>&gt;&gt;&gt; even_num = list(filter(lambda x: x % 2 == 0, [1, 2, 3, 4, 5, 6]))&gt;&gt;&gt; even_num[2, 4, 6]&gt;&gt;&gt; odd_num = list(filter(lambda x: x % 2, [1, 2, 3, 4, 5, 6]))&gt;&gt;&gt; odd_num[1, 3, 5]</code></pre><h2 id="携带状态的闭包"><a href="#携带状态的闭包" class="headerlink" title="携带状态的闭包"></a>携带状态的闭包</h2><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>在 Python 中，函数也是一个对象。因此，我们在定义函数时，可以再嵌套定义一个函数，并将该嵌套函数返回，比如：</p><pre><code>&gt;&gt;&gt; from math import pow&gt;&gt;&gt; def make_pow(n):        def inner_func(x): # 嵌套定义了 inner_func            return pow(x, n) # 注意这里引用了外部函数的n        return inner_func # 返回 inner_func</code></pre><p>上面的代码中，函数 make_pow 里面又定义了一个内部函数 inner_func，然后将该函数返回。因此，我们可以使用 make_pow 来生成另一个函数。</p><pre><code>&gt;&gt;&gt; pow2 = make_pow(2) # pow2 是一个函数,参数2是自由变量&gt;&gt;&gt; pow2&lt;function make_pow.&lt;locals&gt;.inner_func at 0x0000000003556488&gt;&gt;&gt;&gt; pow2(6)36.0</code></pre><p>我们还注意到，内部函数 inner_func 引用了外部函数 make_pow 的自由变量 n，这也就意味着，当函数 make_pow 的生命周期结束之后，n 这个变量依然会保存在 inner_func 中，它被 inner_func 所引用。</p><pre><code>&gt;&gt;&gt; del make_pow         # 删除 make_pow&gt;&gt;&gt; pow3 = make_pow(3)Traceback (most recent call last):  File &quot;&lt;pyshell#13&gt;&quot;, line 1, in &lt;module&gt;    pow3 = make_pow(3)NameError: name &apos;make_pow&apos; is not defined&gt;&gt;&gt; pow2(9)     # pow2 仍可正常调用，自由变量 2 仍保存在 pow2 中81.0</code></pre><p>像上面这种情况，一个函数返回了一个内部函数，该内部函数引用了外部函数的相关参数和变量，我们把该返回的内部函数称为闭包（Closure）。在上面的例子中，inner_func 就是一个闭包，它引用了自由变量 n。</p><h3 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h3><ul><li>闭包的最大特点就是引用了自由变量，即使生成闭包的环境已经释放，闭包仍然存在。</li><li>闭包在运行时可以有多个实例，即使传入的参数相同。</li></ul><p>实例：</p><pre><code>&gt;&gt;&gt; pow_a = make_pow(2)&gt;&gt;&gt; pow_b = make_pow(2)&gt;&gt;&gt; pow_a == pow_bFalse</code></pre><ul><li>利用闭包，我们还可以模拟类的实例。</li></ul><p>这里构造一个类，用于求一个点到另一个点的距离：</p><pre><code>from math import sqrtclass Point(object):    def __init__(self, x, y):        self.x, self.y = x, y    def get_distance(self, u, v):        distance = sqrt((self.x - u) ** 2 + (self.y - v) ** 2)        return distance&gt;&gt;&gt; pt = Point(7, 2)        # 创建一个点&gt;&gt;&gt; pt.get_distance(10, 6)  # 求到另一个点的距离5.0</code></pre><p>用闭包来实现：</p><pre><code>&gt;&gt;&gt; def point(x, y):    def get_distance(u, v):        return sqrt((x - u) ** 2 + (y - v) ** 2)    return get_distance&gt;&gt;&gt; pt = point(7, 2) # 自由变量 7,2&gt;&gt;&gt; pt(10, 6)5.0</code></pre><p>可以看到，结果是一样的，但使用闭包实现比使用类更加简洁。</p><h3 id="常见误区"><a href="#常见误区" class="headerlink" title="常见误区"></a>常见误区</h3><p>闭包的概念很简单，但实现起来却容易出现一些误区，比如下面的例子：</p><pre><code>def count():    funcs = []    for i in [1, 2, 3]:        def f():            return i        funcs.append(f)    return funcs</code></pre><p>在该例子中，我们在每次 for 循环中创建了一个函数，并将它存到 funcs 中。现在，调用上面的函数，你可能认为返回结果是 1, 2, 3，事实上却不是：</p><pre><code>&gt;&gt;&gt; f1, f2, f3 = count()&gt;&gt;&gt; f1()3&gt;&gt;&gt; f2()3&gt;&gt;&gt; f3()3</code></pre><p>为什么呢？原因在于上面的函数 f 引用了变量 i，但函数 f 并非立刻执行，当 for 循环结束时，此时变量 i 的值是3，funcs 里面的函数引用的变量都是 3，最终结果也就全为 3。</p><p>因此，我们应尽量避免在闭包中引用循环变量，或者后续会发生变化的变量。</p><p>那上面这种情况应该怎么解决呢？我们可以再创建一个函数，并将循环变量的值传给该函数，如下：</p><pre><code>def count():funcs = []for i in [1, 2, 3]:    def g(param):        f = lambda : param    # 这里创建了一个匿名函数        return f    funcs.append(g(i))        # 将循环变量的值传给 greturn funcs&gt;&gt;&gt; f1, f2, f3 = count()&gt;&gt;&gt; f1()1&gt;&gt;&gt; f2()2&gt;&gt;&gt; f3()3</code></pre><ul><li>闭包是携带自由变量的函数，即使创建闭包的外部函数的生命周期结束了，闭包所引用的自由变量仍会存在。</li><li>闭包在运行可以有多个实例。</li><li>尽量不要在闭包中引用循环变量，或者后续会发生变化的变量。</li></ul><h2 id="会打扮的装饰器"><a href="#会打扮的装饰器" class="headerlink" title="会打扮的装饰器"></a>会打扮的装饰器</h2><p>我们知道，在 Python 中，我们可以像使用变量一样使用函数：</p><ul><li>函数可以被赋值给其他变量</li><li>函数可以被删除</li><li>可以在函数里面再定义函数</li><li>函数可以作为参数传递给另外一个函数</li><li>函数可以作为另一个函数的返回</li></ul><p><strong>简而言之，函数就是一个对象。</strong></p><h3 id="对一个简单的函数进行装饰"><a href="#对一个简单的函数进行装饰" class="headerlink" title="对一个简单的函数进行装饰"></a>对一个简单的函数进行装饰</h3><p>为了更好地理解装饰器，我们先从一个简单的例子开始，假设有下面的函数：</p><pre><code>&gt;&gt;&gt; def hello():    return &apos;hello world&apos;</code></pre><p>现在我们想增强 hello() 函数的功能，希望给返回加上 HTML 标签，比如 <i>hello world</i>，但是有一个要求，不改变原来 hello() 函数的定义。这里当然有很多种方法，下面给出一种跟本文相关的方法：</p><pre><code>def makeitalic(func):    def wrapped():        return &quot;&lt;i&gt;&quot; + func() + &quot;&lt;/i&gt;&quot;    return wrapped</code></pre><p>在上面的代码中，我们定义了一个函数 makeitalic，该函数有一个参数 func，它是一个函数；在 makeitalic 函数里面我们又定义了一个内部函数 wrapped，并将该函数作为返回。</p><p>现在，我们就可以不改变 hello() 函数的定义，给返回加上 HTML 标签了：</p><pre><code>&gt;&gt;&gt; hello = makeitalic(hello)  # 将 hello 函数传给 makeitalic&gt;&gt;&gt; hello()&apos;&lt;i&gt;&lt;i&gt;hello world&lt;/i&gt;&lt;/i&gt;&apos;</code></pre><p>在上面，我们将 hello 函数传给 makeitalic，再将返回新功能函数 wrapped 赋给 hello，此时调用 hello() 就得到了我们想要的结果。</p><p>不过要注意的是，由于我们将 makeitalic 的返回赋给了 hello，此时 hello() 函数仍然存在，但是它的函数名不再是 hello 了，而是 wrapped，正是 makeitalic 返回函数的名称，可以验证一下：</p><pre><code>&gt;&gt;&gt; hello.__name__&apos;wrapped&apos;</code></pre><p>现在，我们梳理一下上面的例子，为了增强原函数 hello 的功能，我们定义了一个函数，它接收原函数作为参数，并返回一个新的函数，完整的代码如下：</p><pre><code>def makeitalic(func):    def wrapped():        return &quot;&lt;i&gt;&quot; + func() + &quot;&lt;/i&gt;&quot;    return wrappeddef hello():    return &apos;hello world&apos;hello = makeitalic(hello)</code></pre><p>事实上，makeitalic 就是一个装饰器（decorator），它『装饰』了函数 hello，并返回一个函数，将其赋给 hello。</p><p>一般情况下，我们使用装饰器提供的 @ 语法糖（Syntactic Sugar），来简化上面的写法：</p><pre><code>&gt;&gt;&gt; def makeitalic(func):    def wrapped():        return &quot;&lt;i&gt;&quot; + func() + &quot;&lt;/i&gt;&quot;    return wrapped&gt;&gt;&gt; @makeitalicdef hello():    return &apos;hello world&apos;</code></pre><p>像上面的情况，可以动态修改函数（或类）功能的函数就是装饰器。本质上，它是一个高阶函数，以被装饰的函数（比如上面的 hello）为参数，并返回一个包装后的函数（比如上面的 wrapped）给被装饰函数（hello）。</p><h3 id="装饰器的使用形式"><a href="#装饰器的使用形式" class="headerlink" title="装饰器的使用形式"></a>装饰器的使用形式</h3><p>1.装饰器的一般使用形式如下：</p><pre><code>@decoratordef func():    pass</code></pre><p>等价于下面的形式：</p><pre><code>def func():    passfunc = decorator(func)</code></pre><p>2.装饰器可以定义多个，离函数定义最近的装饰器先被调用，比如：</p><pre><code>@decorator_one@decorator_twodef func():    pass</code></pre><p>等价于：</p><pre><code>def func():    passfunc = decorator_one(decorator_two(func))</code></pre><p>3.装饰器还可以带参数，比如：</p><pre><code>@decorator(arg1, arg2)def func():    pass</code></pre><p>等价于：</p><pre><code>def func():    passfunc = decorator(arg1, arg2)(func)</code></pre><p>下面我们再看一些具体的例子，以加深对它的理解。</p><h3 id="对带参数的函数进行装饰"><a href="#对带参数的函数进行装饰" class="headerlink" title="对带参数的函数进行装饰"></a>对带参数的函数进行装饰</h3><p>前面的例子中，被装饰的函数 hello() 是没有带参数的，我们看看被装饰函数带参数的情况。对前面例子中的 hello() 函数进行改写，使其带参数，如下：</p><pre><code>&gt;&gt;&gt; def makeitalic(func):    def wrapped(*args, **kwargs):        ret = func(*args,**kwargs)        return &apos;&lt;i&gt;&apos; + ret + &apos;&lt;/i&gt;&apos;    return wrapped&gt;&gt;&gt; @makeitalicdef hello(name):    return &apos;hello %s&apos; % name&gt;&gt;&gt; @makeitalicdef hello2(name1, name2):    return &apos;hello %s, %s&apos; %(name1, name2)</code></pre><p>由于函数 hello 带参数，因此内嵌包装函数 wrapped 也做了一点改变：</p><ul><li>内嵌包装函数的参数传给了 func，即被装饰函数，也就是说内嵌包装函数的参数跟被装饰函数的参数对应，这里使用了 (<em>args, *</em>kwargs)，是为了适应可变参数。</li></ul><p>看看使用：</p><pre><code>&gt;&gt;&gt; hello(&apos;python&apos;)&apos;&lt;i&gt;hello python&lt;/i&gt;&apos;&gt;&gt;&gt; hello2(&apos;python&apos;, &apos;java&apos;)&apos;&lt;i&gt;hello python, java&lt;/i&gt;&apos;</code></pre><h3 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h3><p>上面的例子，我们增强了函数 hello 的功能，给它的返回加上了标签 <i></i>，现在，我们想改用标签 <b\></b\> 或 <p\></p\>。是不是要像前面一样，再定义一个类似 makeitalic 的装饰器呢？其实，我们可以定义一个函数，将标签作为参数，返回一个装饰器，比如：</p><pre><code>&gt;&gt;&gt; def wrap_in_tag(tag):    def decorator(func):        def wrapped(*args, **kwargs):            ret = func(*args, **kwargs)            return &apos;&lt;/&apos; + tag + &apos;&gt;&apos; + ret + &apos;&lt;/&apos; + tag + &apos;&gt;&apos;        return wrapped    return decorator</code></pre><p>现在，我们可以根据需要生成想要的装饰器了：</p><pre><code>&gt;&gt;&gt; makebold = wrap_in_tag(&apos;b&apos;)  # 根据 &apos;b&apos; 返回 makebold 生成器&gt;&gt;&gt; def hello(name):    return &apos;hello %s&apos; % name&gt;&gt;&gt; hello(&apos;world&apos;)&apos;hello world&apos;</code></pre><p>上面的形式也可以写得更加简洁：</p><pre><code>&gt;&gt;&gt; @wrap_in_tag(&apos;b&apos;)def hello(name):    return &apos;hello %s&apos; % name&gt;&gt;&gt; hello(&apos;world&apos;)&apos;&lt;/b&gt;hello world&lt;/b&gt;&apos;</code></pre><p>这就是带参数的装饰器，其实就是在装饰器外面多了一层包装，根据不同的参数返回不同的装饰器。</p><h3 id="多个装饰器"><a href="#多个装饰器" class="headerlink" title="多个装饰器"></a>多个装饰器</h3><p>现在，让我们来看看多个装饰器的例子，为了简单起见，下面的例子就不使用带参数的装饰器。</p><pre><code>&gt;&gt;&gt; def makebold(func):    def wrapped():        return &apos;&lt;b&gt;&apos; + func() + &apos;&lt;/b&gt;&apos;    return wrapped&gt;&gt;&gt;&gt;&gt;&gt; def makeitalic(func):    def wrapped():        return &apos;&lt;i&gt;&apos; + func() + &apos;&lt;/i&gt;&apos;    return wrapped&gt;&gt;&gt; @makebold@makeitalicdef hello():    return &apos;hello world&apos;&gt;&gt;&gt; hello()&apos;&lt;b&gt;&lt;i&gt;hello world&lt;/i&gt;&lt;/b&gt;&apos;</code></pre><p>上面定义了两个装饰器，对 hello 进行装饰，上面的最后几行代码相当于：</p><pre><code>def hello():    return &apos;hello world&apos;hello = makebold(makeitalic(hello))</code></pre><p>调用函数 hello：</p><pre><code>&gt;&gt;&gt; hello()&apos;&lt;b&gt;&lt;i&gt;hello world&lt;/i&gt;&lt;/b&gt;&apos;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;高阶函数&quot;&gt;&lt;a href=&quot;#高阶函数&quot; class=&quot;headerlink&quot; title=&quot;高阶函数&quot;&gt;&lt;/a&gt;高阶函数&lt;/h2&gt;&lt;p&gt;在函数式编程中，我们可以将函数当作变量一样自由使用。一个函数接收另一个函数作为参数，这种函数称之为&lt;strong&gt;高阶函数（Higher-order Functions）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;看一个简单的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def func(g, arr):
    return [g(x) for x in arr]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的代码中，func 是一个高阶函数，它接收两个参数，第 1 个参数是函数，第 2 个参数是数组，func 的功能是将函数 g 逐个作用于数组 arr 上，并返回一个新的数组，比如，我们可以这样用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def double(x):
    return 2 * x

def square(x):
    return x * x

arr1 = func(double, [1, 2, 3, 4])
arr2 = func(square, [1, 2, 3, 4])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不难判断出，arr1 是 [2, 4, 6, 8]，arr2 是 [1, 4, 9, 16]。&lt;br&gt;可接收其他函数作为参数的函数称为高阶函数。&lt;/p&gt;
    
    </summary>
    
      <category term="python进阶知识" scheme="http://www.chenfanlinux.org/categories/python%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Python" scheme="http://www.chenfanlinux.org/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python进阶之面向对象</title>
    <link href="http://www.chenfanlinux.org/2018/03/12/Python%E8%BF%9B%E9%98%B6%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://www.chenfanlinux.org/2018/03/12/Python进阶之面向对象/</id>
    <published>2018-03-12T08:30:27.000Z</published>
    <updated>2018-03-12T08:31:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类与实例"><a href="#类与实例" class="headerlink" title="类与实例"></a>类与实例</h2><ul><li>Python里的所有数据都是以对象形式存在的，无论是的简单的数字类型还是复杂的代码模块。然而，Python特殊的语法形式巧妙地将实现对象机制的大量细节隐藏起来。</li><li>对象既包含数据（变量，更习惯称之为特性，attribute），也包含代码（函数，也成为方法）。它是某一类具体事务的特殊实例。</li><li>当你想要创建一个别人从来没有创建过的新对象时，首先必须定义一个类，用以指明该类的对象所包含的内容（特性和方法）。</li><li>对象就是像是包含了代码的超级数据结构。</li></ul><h3 id="使用-class-定义类"><a href="#使用-class-定义类" class="headerlink" title="使用 class 定义类"></a>使用 class 定义类</h3><p>类是一个抽象的概念，我们可以把它理解为具有相同属性和方法的一组对象的集合，而实例则是一个具体的对象。</p><p>首先需要定义 Person 类作为生产对象的模具。在接下来的几个例子中，我们会不停更新这个类的内容，从最简单的开始，知道它成为一个可实际使用的类。</p><p>首先创建的是最简单的类，即一个没有任何内容的空类：</p><pre><code>&gt;&gt;&gt; class Person(object):    pass</code></pre><h3 id="类的实例化"><a href="#类的实例化" class="headerlink" title="类的实例化"></a>类的实例化</h3><p>同函数一样，用 pass 表示这个类是一个空类。上面这种定义类的方法已经是最简形式，无法再忽略。你可以通过类名来创建对象，同调用函数一样：</p><pre><code>&gt;&gt;&gt; someone = Person()  # 类实例化&gt;&gt;&gt;</code></pre><p>在这个例子中，Person()创建了一个Person类的对象，并给它赋值 someone 这个名字。但是，由于我们的Person类是空的，所以由它创建的对象 someone 实际上什么也做不了。实际编程中，你永远也不会创建这样一个没用的类，我在这里只是为了从零开始引出后面每一步的内容。</p><p>我们来试着重新定义一下 Person 类。这一次，将 Python 中特殊的对象初始化方法放入其中：</p><pre><code>&gt;&gt;&gt; class Person(object):    def __init__(self):        pass</code></pre><a id="more"></a><p>我承认 init() 和 self 看起来很奇怪，但这就是实际的Python类的定义形式。init() 是 Python 中一个特殊的函数名，用于根据类的定义创建实例对象。self参数指向了这个正在被创建的对象本身。</p><p>当你在类生命定义 init() 方法时，第一个参数必须为 self。尽管 self 并不是一个 Python 保留字，但它很常用。</p><p>尽管我们添加了初始化方法，但用这个 Person 类创建的对象仍然什么也做不了。接着我们在初始化方法中添加 name 参数：</p><pre><code>&gt;&gt;&gt; class Person(object):    def __init__(self, name):        self.name = name</code></pre><p>用 Person 类创建一个对象，为 name 特性传递一个字符串参数：</p><pre><code>hunter = Person(&quot;xiao ming&quot;)</code></pre><blockquote><p>python执行： Person.init(huter, “xiao ming”)<br>self 其实就是代表要实例化的对象，这个例子里是 hunter。</p></blockquote><p>上面这短短的一行代码实际做了以下工作：</p><ul><li>查看 Person 类的定义</li><li>在内存中实例化（创建）一个新的对象</li><li>调用对象的 init 方法， 将这个新创建的对象作为 self 传入，并将另一个参数（’xiao ming’）作为 name 传入</li><li>将 name 的值存入对象</li><li>返回这个新的对象</li><li>将名字 hunter 与这个对象关联</li></ul><p>这个新对象与任何其他的python对象一样。 你可以把它当作列表、元组、字典或集合中的元素，也可以把它当作参数传递给函数，或者把它作为函数的返回结果。</p><p>我们传入的 name 参数 作为对象的特性存储在了对象里。可以直接对它进行读写操作：</p><pre><code>&gt;&gt;&gt; print(&apos;The mighty hunter: &apos;, hunter.name)The mighty hunter:  xiao ming</code></pre><p>记住，在 Person 类定义的内部， 你可以直接通过 self.name 访问 name 特性。 而当创建了一个实际的对象后，例如这里的 hunter，需要通过 hunter.name 来访问他。</p><p>在类的定义中， init 并不是必需的。只有当需要区分由该类创建的不同对象时，才需要指定 init 方法。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>在你编写代码解决实际问题时，经常能找到一些已有的类，它们能够实现你所需的大部分功能，但不是全部。这时该怎么办？当然，你可以对这个已有的类进行修改，但这么做很容易让代码变得更加复杂，一不留神就可能会破坏原来可以正常工作的功能,应该遵循 <strong><em>多继承类，少修改类原则。</em></strong></p><p>当然，也可以另起炉灶重新编写一个类：复制粘贴原来的代码再融入自己的新代码。但这意味着你需要维护更多的代码。同时，新类和旧类中实现同样功能的代码被分隔在了不同的地方（日后修改时需要改动多处）。</p><p>更好的解决方法是利用类的继承：从已有类中衍生出新的类，添加和修改部分功能。这是代码复用的一个绝佳的例子。使用继承得到的新类会自动获得旧类中的多有方法，而不需要进行任何复制。</p><p>你只需要在新类里面定义自己额外需要的方法，或者按照需求对继承的方法进行修改即可。修改得到的新方法会覆盖原有的方法。我们习惯将原始的类称为父类、超类或基类，将新的类称作孩子类、子类或衍生类。这些术语在面向对象的编程中不加以区分。</p><p>现在，我们来试试继承。首先，定义一个空类 Car。然后，定义一个 Car 的子类 Tesla。定义子类使用的也是 class 关键字，不过需要把父类的名字放在子类名字后面的括号里：</p><pre><code>&gt;&gt;&gt; class Car(object):    pass&gt;&gt;&gt; class Tesla(Car):    pass</code></pre><p>接着，为每个类创建一个实例对象:</p><pre><code>&gt;&gt;&gt; give_me_a_car = Car()&gt;&gt;&gt; give_me_a_tesla = Tesla()</code></pre><p>子类是父类的一种特殊情况，它属于父类。在面向对象的术语里，我们经常将 Tesla 看作是一个 Car。 对象 give_me_a_tesla 是 Tesla 类的一个实例，但它同时集成了 Car 能做到的所有事情。当然，上面的例子中 Car 和 Tesla 就像潜艇上的甲板水手一样起不到任何实际作用。我们来更新一下类的定义，让它们发挥点儿作用。</p><pre><code>&gt;&gt;&gt; class Car():    def exclaim(self):        print(&quot;I&apos;m a Car!&quot;)&gt;&gt;&gt; class Tesla(Car):    pass</code></pre><p>最后，为每一个类各创建一个对象，并调用刚刚声明的 exclaim 方法：</p><pre><code>&gt;&gt;&gt; give_me_a_car.exclaim()I&apos;m a Car!&gt;&gt;&gt; give_me_a_tesla.exclaim()I&apos;m a Car!&gt;&gt;&gt; isinstance(give_me_a_tesla,Car) # give_True&gt;&gt;&gt; isinstance(give_me_a_tesla,Tesla)True</code></pre><p>我们不需要进行任何特殊的操作，Tesla 就自动从 Car 那里继承了 exclaim() 方法。但事实上，我们并不希望 Tesla 在 exclaim() 方法里面宣称它是一个 Car，这可能会造成无法区分 Car 和 Tesla。让我们来看看怎么解决这个问题。</p><h3 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h3><p>新创建的子类会自动继承父类的所有信息。接下来我们来看子类如何替代——覆盖（override）父类的方法。</p><pre><code>&gt;&gt;&gt; class Car():    def exclaim(self):        print(&quot;I&apos;m a Car!&quot;)&gt;&gt;&gt; class Tesla(Car):    def exclaim(self):        print(&quot;I&apos;m a Tesla!&quot;)</code></pre><p>为每个类创建一个对象：</p><pre><code>&gt;&gt;&gt; give_me_a_car = Car()&gt;&gt;&gt; give_me_a_tesla = Tesla()</code></pre><p>执行看下结果：</p><pre><code>&gt;&gt;&gt; give_me_a_car.exclaim()I&apos;m a Car!&gt;&gt;&gt; give_me_a_tesla.exclaim()I&apos;m a Tesla!</code></pre><p>我们覆盖了父类的 exclaim() 方法。 在子类中，可以覆盖任何父类的方法，包括 <strong>init()</strong>。下面我们使用之前的 Person 类。我们来创建两个子类，分别代表医生(MDPerson)和律师（JDPerson）。</p><pre><code>&gt;&gt;&gt; class Person():    def __init__(self, name):        self.name = name&gt;&gt;&gt; class MDPerson(Person):    def __init__(self, name):        self.name = &quot;Doctor&quot; + name&gt;&gt;&gt; class JDPerson(Person):    def __init__(self, name):        self.name = name + &quot;, Esquire&quot;</code></pre><p>在上面的例子中，子类的初始化方法 init() 接受的参数和父类 Person 一样，但存储到对象内部 name 特性的值却不尽相同：</p><pre><code>&gt;&gt;&gt; print(person.name)Fudd&gt;&gt;&gt; print(doctor.name)DoctorFudd&gt;&gt;&gt; print(lawyer.name)Fudd, Esquire</code></pre><h3 id="添加新方法"><a href="#添加新方法" class="headerlink" title="添加新方法"></a>添加新方法</h3><p>子类还可以添加父类中没有的方法。回到 Car 类 和 Tesla 类，我们给 Tesla 类添加一个新的方法 need_a_push()</p><pre><code>&gt;&gt;&gt; class Car():    def exclaim(self):        print(&quot;I&apos;m a Car!&quot;)&gt;&gt;&gt; class Tesla(Car):    def exclaim(self):        print(&quot;I&apos;m a Tesla!&quot;)    def need_a_push(self):        print(&quot;A little help here?&quot;)</code></pre><p>接着创建一个 Car 和一个 Tesla 对象：</p><pre><code>&gt;&gt;&gt; give_me_a_car = Car()&gt;&gt;&gt; give_me_a_tesla = Tesla()</code></pre><p>Tesla 类的对象可以响应 need_a_push()方法：</p><pre><code>&gt;&gt;&gt; give_me_a_tesla.need_a_push()A little help here?</code></pre><p>但父类 Car 无法使用该方法：</p><pre><code>&gt;&gt;&gt; give_me_a_car.need_a_push()Traceback (most recent call last):  File &quot;&lt;pyshell#17&gt;&quot;, line 1, in &lt;module&gt;    give_me_a_car.need_a_push()AttributeError: &apos;Car&apos; object has no attribute &apos;need_a_push&apos;</code></pre><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>我们已经知道如何在子类中覆盖父类的方法，但如果想要调用父类的方法就要使用 super()。下面的例子将新定义一个新的类 EmailPerson，用于表示有电子邮箱的 Person。首先，来定义熟悉的Person类。</p><pre><code>&gt;&gt;&gt; class Person():    def __init__(self, name):        self.name = name</code></pre><p>下面是子类的定义。注意，子类的初始化方法 init() 中添加了一个额外的 email 参数：</p><pre><code>&gt;&gt;&gt; class EmailPerson(Person):    def __init__(self, name, email):        super().__init__(name)        self.email = email</code></pre><p>在子类中定义 init() 方法时，父类的 init() 方法会被覆盖。<strong><em>因此在子类中父类的初始化方法并不会被自动调用，我们必须显式调用它。</em></strong>以上代码实际上做了这样几件事情：</p><ul><li>通过 super() 方法获取了父类 Person 的定义。</li><li>子类的 init() 调用了 Person.init() 方法。它会自动将 self 参数传递给父类。因此，你只需传入其余参数即可。在上面的例子中，Person() 能接受的其余参数指的是 name。</li><li>self.email = email 这行新的代码才真正起到了将 EmailPerson 与 Person 区分开的作用。</li></ul><p>接下来，创建一个 EmailPerson 类的对象：</p><pre><code>&gt;&gt;&gt; bob = EmailPerson(&apos;Bob Frapples&apos;, &apos;bob@frapples.com&apos;)</code></pre><p>我们既可以访问 name 特性，也可访问 email 特性：</p><pre><code>&gt;&gt;&gt; bob.name&apos;Bob Frapples&apos;&gt;&gt;&gt; bob.email&apos;bob@frapples.com&apos;</code></pre><p>为什么不像下面这样定义 EmailPerson 类呢？</p><pre><code>class EmailPerson(Person):     def __init__(self, name, email):         self.name = name        self.email = email</code></pre><p>确实可以这么做，但这有悖我么使用继承的初衷。我们应该使用 super() 来让 Person 完成他应该做的事情，就像任何一个单纯的 Person 对象一样。除此之外，不这么写还有另一个好处，如果 Person 类的定义在未来发生改变，使用 super() 可以保证这些改变会自动体现在 EmailPersion类上，而不需要手动修改。</p><p>子类可以按照自己的方式处理问题，但如果人需要借助父类的帮助，使用 super() 是最佳的选择。</p><h2 id="特性访问限制"><a href="#特性访问限制" class="headerlink" title="特性访问限制"></a>特性访问限制</h2><h3 id="使用名称重整保护私有特性"><a href="#使用名称重整保护私有特性" class="headerlink" title="使用名称重整保护私有特性"></a>使用名称重整保护私有特性</h3><p>Python 对那些需要刻意隐藏在类内部的特性有自己的命名规范：由连续的两个下划线开头（_）。</p><pre><code>&gt;&gt;&gt; class Duck():    def __init__(self, input_name):        self.__name = input_name    @property    def name(self):        print(&apos;inside the getter&apos;)        return self.__name    @name.setter    def name(self, input_name):        print(&apos;inside the setter&apos;)        self.__name = input_name</code></pre><p>看看代码是否还能正常工作：</p><pre><code>&gt;&gt;&gt; fowl = Duck(&apos;Howard&apos;)&gt;&gt;&gt; fowl.nameinside the getter&apos;Howard&apos;&gt;&gt;&gt; fowl.name = &apos;Donald&apos;inside the setter&gt;&gt;&gt; fowl.nameinside the getter&apos;Donald&apos;</code></pre><p>看起来没问题，现在，你无法在外部访问 __name 特性了：</p><pre><code>&gt;&gt;&gt; fowl.__nameTraceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &apos;Duck&apos; object has no attribute &apos;__name&apos;</code></pre><p>这种命名规范本质上并没有把特性变成私有，但Python确实将它的名字重整了。让外部的代码无法使用。如果你是在好奇名称重整是怎么实现的。我可以偷偷告诉你其中的奥秘：</p><pre><code>&gt;&gt;&gt; fowl._Duck__name&apos;Howard&apos;</code></pre><p>发现了么？我们并没有得到 inside the getter，成功绕过了 getter 方法。尽管如我们所见，这种保护特性的方式并不完美，但它确实能在一定程度上避免我们无意或有意地对特性进行直接访问。</p><h3 id="使用-property"><a href="#使用-property" class="headerlink" title="使用 @property"></a>使用 @property</h3><p>@property 把方法『变成』了属性。在使用 @property 之前，让我们先来看一个简单的例子：</p><pre><code>&gt;&gt;&gt; e = Exam(60)&gt;&gt;&gt; e._score60&gt;&gt;&gt; e.set_score(70)&gt;&gt;&gt; e.get_score()70</code></pre><p>在上面，我们定义了一个 Exam 类，为了避免直接对 _score 特性操作，我们提供了 get_score 和 set_score 方法，这样起到了封装的作用，把一些不想对外公开的属性隐蔽起来，而只是提供方法给用户操作，在方法里面，我们可以检查参数的合理性等。</p><p>这样做没什么问题，但是我们有更简单的方式来做这件事，Python 提供了 property 装饰器，被装饰的方法，我们可以将其『当作』属性来用，看下面的例子:</p><pre><code>&gt;&gt;&gt; class Exam():    def __init__(self, score):        self.score = score    @property    def score(self):        return self._score    @score.setter    def score(self,var):        if var &lt; 0:            self._score = 0        elif var &gt; 100:            self._score = 100        else:            self._score = var&gt;&gt;&gt; e = Exam(60)&gt;&gt;&gt; e.score60&gt;&gt;&gt; e.score = 90&gt;&gt;&gt; e.score90&gt;&gt;&gt; e.score = 200&gt;&gt;&gt; e.score100</code></pre><p>在上面，我们给方法 score 加上了 @property，于是我们可以把 score 当成一个属性来用，此时，又会创建一个新的装饰器 score.setter，它可以把被装饰的方法变成属性来赋值。</p><p>另外，我们也不一定要使用 score.setter 这个装饰器，这时 score 就变成一个只读属性了：</p><pre><code>class Exam(object):    def __init__(self, score):        self._score = score    @property    def score(self):        return self._score&gt;&gt;&gt; e = Exam(60)&gt;&gt;&gt;&gt;&gt;&gt; e.score60&gt;&gt;&gt; e.score = 200Traceback (most recent call last):  File &quot;&lt;pyshell#31&gt;&quot;, line 1, in &lt;module&gt;    e.score = 200AttributeError: can&apos;t set attribute</code></pre><h2 id="方法的类型"><a href="#方法的类型" class="headerlink" title="方法的类型"></a>方法的类型</h2><p>有些数据（特性）和函数（方法）是类本身的一部分，还有一些是由类创建的实例的一部分。</p><p>在类的定义中，以 self 作为第一个参数的方法都是实例方法（instance method）。它们在创建自定义类时最常用。实例方法的首个参数是 self，当它被调用时，Python 会把调用该方法的对象作为 self 参数传入。</p><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p>与之相对，类方法（class method）会作用于整个类，对类作出的任何改变会对它的所有实例对象产生影响。在类定义内部，用前缀修饰符 @classmethod 指定的方法都是类方法。与实例方法相似，类方法的第一个参数是类本身。在Python中，这个采纳数常被写作 cls，因为全称 class 是保留字，在这里我们无法使用。下面的例子中，我们为A定义一个类方法来记录一共有多少个类A的对象被创建：</p><pre><code>&gt;&gt;&gt; class A():    count = 0 # 类属性    def __init__(self):        A.count += 1    def exclaim(self):        print(&quot;I&apos;m an A!&quot;)    @classmethod # 类方法    def kids(cls):        print(&quot;A has&quot;, cls.count, &quot;little objects.&quot;)&gt;&gt;&gt; easy_a = A()&gt;&gt;&gt; breezy_a = A()&gt;&gt;&gt; wheezy_a = A()&gt;&gt;&gt; A.kids()A has 3 little objects.</code></pre><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>类定义中的方法还存在着第三种类型，它既不会影响类也不会影响类的对象。他们出现在类的定义中仅仅是为了方便，否则他们只能孤零零地出现在代码的其他地方，这会影响代码的逻辑性。这种类型的方法被称作静态方法（static method），用 @staticmethod 修饰， 它既不需要 self 参数 也不需要 class 参数。 下面列子中的静态方法是一则 CoyoteWeapon的广告：</p><pre><code>&gt;&gt;&gt; class CoyoteWeapop():    @staticmethod    def commercial():        print(&apos;This CoyoteWeapon has been brought to you by Acme&apos;)&gt;&gt;&gt; CoyoteWeapop.commercial()This CoyoteWeapon has been brought to you by Acme</code></pre><p><strong><em>注意,在这个例子中,我们甚至都不用创建任何 CoyoteWeapon 类的对象就可以调用这个方法,语法优雅不失风格！</em></strong></p><h2 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h2><p>Python 对实现多态（polymorphism）要求得十分宽松，这意味着我们可以对不同对象调用同名的操作，甚至与用管这些对象的类型是什么。</p><p>我们来为上那个 Quote 类设定同样的初始化方法 init()，然后再添加两个新函数：</p><ul><li>who() 返回保存的 person 字符串的值</li><li>says() 返回保存的 words 字符串的内容，并添上指定的表点符号</li></ul><p>例子如下:</p><pre><code>&gt;&gt;&gt; class Quote():    def __init__(self, person, words):        self.person = person        self.words = words    def who(self):        return self.person    def says(self):        return self.words + &apos;.&apos;&gt;&gt;&gt; class QuestionQuote(Quote):    def says(self):        return self.words + &apos;?&apos;&gt;&gt;&gt; class ExclamationQuote(Quote):    def says(self):        return self.words + &apos;!&apos;</code></pre><p>我们不需要改变 QuestionQuote 或者 ExclamQuote 的初始化方式，因此没有覆盖它们的 init()方法。Python 会自动调用父类 Quote 的初始化函数 init() 来存储实例变量 person 和 words，这就是我们可以在子类 QuestionQuote 和 ExclamationQuote 的对象里访问 self.words 的原因。</p><p>接下来创建一些对象：</p><pre><code>&gt;&gt;&gt; hunter = Quote(&apos;Elmer Fudd&apos;, &quot;I&apos;m hunting rabbits&quot;)&gt;&gt;&gt; print(hunter.who(), &apos;says:&apos;, hunter.says())Elmer Fudd says: I&apos;m hunting rabbits.&gt;&gt;&gt; hunted1 = QuestionQuote(&apos;Bugs Bunny&apos;, &quot;What&apos;s up, doc&quot;)&gt;&gt;&gt; print(hunted1.who(), &apos;says:&apos;, hunted1.says())Bugs Bunny says: What&apos;s up, doc?&gt;&gt;&gt; print(hunted2.who(), &apos;says:&apos;, hunted2.says())Daffy Duck says: It&apos;s rabbit season!</code></pre><p>三个不同版本的 says() 为上面三种类型提供了不同的相应方式，这是面向对象的语言中多态的传统形式。Python 在这方面走的更远一些，无论对象的种类是什么，只要包含 who() 和 says()，你便可以调用它。我们再来定义一个 BabblingBrook 类，他与我们之前的猎人猎物（Quote 类的后代）什么的没有任何关系：</p><pre><code>&gt;&gt;&gt; class BabblingBrook():    def who(self):        return &apos;Brook&apos;    def says(self):        return &apos;Babble&apos;</code></pre><p>现在，对不同对象执行 who() 和 says() 方法，其中有一个（brook） 与其他类型的对象毫无关联：</p><pre><code>&gt;&gt;&gt; who_says(hunter)Elmer Fudd says I&apos;m hunting rabbits.&gt;&gt;&gt; who_says(hunted1)Bugs Bunny says What&apos;s up, doc?&gt;&gt;&gt; who_says(hunted2)Daffy Duck says It&apos;s rabbit season!&gt;&gt;&gt; who_says(brook)Brook says Babble</code></pre><p>这种方式有事被称作鸭子类型（duck typing），这个命名源自一句名言：</p><pre><code>如果它想鸭子一样走路，像样子一样叫，那么它就是一直鸭子。</code></pre><h2 id="特殊方法-方法重构"><a href="#特殊方法-方法重构" class="headerlink" title="特殊方法 (方法重构)"></a>特殊方法 (方法重构)</h2><p>到目前为止，你已经能创建并使用基本对象了。现在再往深钻研一些。</p><p>当我们输入像 a = 3 + 8 这样的表达式时，整数 3 和 8 怎么知道如何实现 + 的？ 同样， a 又是怎么知道如何使用 = 来获取计算结果的？ 你可以使用 Python 的特殊方法（special method），有时魔术方法（magic method）， 来实现这些操作符的功能。别担心，它们一点也不复杂。</p><p>这些特殊的方法的名称以双下划线()开头和结束。没错，你已经见过其中一个：<br><code>__init__</code>，它根据类的定义以及传入的参数对新创建的对象进行初始化。</p><p>假设你有一个简单的 Word 类，现在想要添加一个 equals() 方法来比较两个词是否一致，忽略大小写。也就是说，一个包含值 ‘ha’ 的 Word 对象与包含 ‘HA’ 的是相同的。</p><p>下面的代码是第一次尝试，创建一个普通方法 equals()。self.text 是当前 Word 对象所包含的字符串文本，equals() 方法将该字符串与 words （另一个 Word 对象）所包含的字符串做比较：</p><pre><code>&gt;&gt;&gt; class Word():    def __init__(self, text):        self.text = text    def equals(self, word2):        return self.text.lower() == word2.text.lower()</code></pre><p>接着创建三个包含不通字符串的 Word 对象：</p><pre><code>&gt;&gt;&gt; first = Word(&apos;ha&apos;)&gt;&gt;&gt; second = Word(&apos;HA&apos;)&gt;&gt;&gt; third = Word(&apos;eh&apos;)</code></pre><p>当字符串 ‘ha’ 和 ‘HA’ 被转换为小写形式再进行比较时（我们就是这么做的），他们应该是相等的：</p><pre><code>&gt;&gt;&gt; first.equals(second)True</code></pre><p>但字符串 ‘eh’ 无论如何与 ‘ha’也不会相等：</p><pre><code>&gt;&gt;&gt; first.equals(third)False</code></pre><p>我们成功定义了 equals() 方法进行小写转换并比较。但试想一下，如果能通过 first == second 进行比较的话岂不更妙？这样类会更自然，表现得更像一个 Python 内置的类。 好的，我们来试一下，把前面例子中的 equals() 方法的名称改为 eq() ：</p><pre><code>&gt;&gt;&gt; class Word():    def __init__(self,text):        self.text = text    def __eq__(self,word2):        return self.text.lower() == word2.text.lower()</code></pre><p>修改就此结束，来看看新的版本能否正常工作：</p><pre><code>&gt;&gt;&gt; first == secondTrue&gt;&gt;&gt; first == thirdFalse</code></pre><p>太神奇了！是不是如同魔术一般？仅需将方法名改为 Python 里进行相等比较的特殊方法名 eq() 即可。下面列出一些常用的魔术方法：</p><p>和比较相关的魔术方法</p><p><img src="https://s1.ax1x.com/2018/03/12/9fn3He.png" alt="比较相关的魔术方法"></p><p>和数学相关的魔术方法</p><p><img src="https://s1.ax1x.com/2018/03/12/9fnY4A.png" alt="数学相关的魔术方法"></p><p>不仅数字类型可以使用像 + （魔术方法 add()）和 - （魔术方法 sub()）的数学运算符，一些其他的类型也可以使用。例如，Python 的字符类型使用 + 进行拼接，使用 * 进行复制。</p><p>字符串常见的魔术方法如下：</p><p><img src="https://s1.ax1x.com/2018/03/12/9fndjf.png" alt="字符串模式方法"></p><p>除了 init() 外，你会发现在编写类方法时最常用到的是 str()，他用于定义如何打印对象信息。print() 方法，str() 方法以及一些字符串格式化的相关方法都会用到 str()。交互式解释器则用 repr() 方法输出变量。如果在你的类既没有定义 str() 也没有定义 repr(), Python会输出类似下面这样的默认字符串：</p><pre><code>&gt;&gt;&gt; first = Word(&apos;ha&apos;)&gt;&gt;&gt; first&lt;__main__.Word object at 0x0000000003561EB8&gt;&gt;&gt;&gt; print(first)&lt;__main__.Word object at 0x0000000003561EB8&gt;</code></pre><p>我们将 str() 和 repr() 方法都添加到 Word 类里，让输出的对象信息变得更好看些：</p><pre><code>&gt;&gt;&gt; class Word():    def __init__(self, text):        self.text = text    def __eq__(self, word2):        return self.text.lower() == word2.text.lower()    def __str__(self):        return self.text    def __repr__(self):        return &apos;Word(&apos; + self.text + &apos;)&apos;&gt;&gt;&gt; first = Word(&apos;ha&apos;)&gt;&gt;&gt; firstWord(ha)&gt;&gt;&gt; print(first)ha</code></pre><p>更多关于 <a href="(https://docs.python.org/3/reference/datamodel.html#special-method-names">魔术方法</a>) 的内容请查看 Python 文档</p><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>如果你想要创建的子类在大多数情况下的行为都和父类相似的话，使用继承是非常不错的选择，建立复杂的继承关系确实很吸引人，但有些时候使用组合（composition）或者聚合（aggregation）更加符合现实的逻辑。一只鸭子是鸟的一种，它有一条尾巴。尾巴并不是鸭子的一种，它是鸭子的组成部分。</p><pre><code>&gt;&gt;&gt; class Tail():    def __init__(self, length):        self.length = length&gt;&gt;&gt; class Bill():    def __init__(self, description):        self.description = description&gt;&gt;&gt; class Duck():    def __init__(self, bill, tail):        self.bill = bill        self.tail = tail    def about(self):        print(&apos;This duck has a&apos;, bill.description, &apos;bill and a&apos;, tail.length, &apos;tail&apos;)tail = Tail(&apos;long&apos;)bill = Bill(&apos;wide orange&apos;)duck = Duck(bill, tail)duck.about()</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类与实例&quot;&gt;&lt;a href=&quot;#类与实例&quot; class=&quot;headerlink&quot; title=&quot;类与实例&quot;&gt;&lt;/a&gt;类与实例&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Python里的所有数据都是以对象形式存在的，无论是的简单的数字类型还是复杂的代码模块。然而，Python特殊的语法形式巧妙地将实现对象机制的大量细节隐藏起来。&lt;/li&gt;
&lt;li&gt;对象既包含数据（变量，更习惯称之为特性，attribute），也包含代码（函数，也成为方法）。它是某一类具体事务的特殊实例。&lt;/li&gt;
&lt;li&gt;当你想要创建一个别人从来没有创建过的新对象时，首先必须定义一个类，用以指明该类的对象所包含的内容（特性和方法）。&lt;/li&gt;
&lt;li&gt;对象就是像是包含了代码的超级数据结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;使用-class-定义类&quot;&gt;&lt;a href=&quot;#使用-class-定义类&quot; class=&quot;headerlink&quot; title=&quot;使用 class 定义类&quot;&gt;&lt;/a&gt;使用 class 定义类&lt;/h3&gt;&lt;p&gt;类是一个抽象的概念，我们可以把它理解为具有相同属性和方法的一组对象的集合，而实例则是一个具体的对象。&lt;/p&gt;
&lt;p&gt;首先需要定义 Person 类作为生产对象的模具。在接下来的几个例子中，我们会不停更新这个类的内容，从最简单的开始，知道它成为一个可实际使用的类。&lt;/p&gt;
&lt;p&gt;首先创建的是最简单的类，即一个没有任何内容的空类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class Person(object):
    pass
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;类的实例化&quot;&gt;&lt;a href=&quot;#类的实例化&quot; class=&quot;headerlink&quot; title=&quot;类的实例化&quot;&gt;&lt;/a&gt;类的实例化&lt;/h3&gt;&lt;p&gt;同函数一样，用 pass 表示这个类是一个空类。上面这种定义类的方法已经是最简形式，无法再忽略。你可以通过类名来创建对象，同调用函数一样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; someone = Person()  # 类实例化
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在这个例子中，Person()创建了一个Person类的对象，并给它赋值 someone 这个名字。但是，由于我们的Person类是空的，所以由它创建的对象 someone 实际上什么也做不了。实际编程中，你永远也不会创建这样一个没用的类，我在这里只是为了从零开始引出后面每一步的内容。&lt;/p&gt;
&lt;p&gt;我们来试着重新定义一下 Person 类。这一次，将 Python 中特殊的对象初始化方法放入其中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class Person(object):
    def __init__(self):
        pass
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="python进阶知识" scheme="http://www.chenfanlinux.org/categories/python%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Python" scheme="http://www.chenfanlinux.org/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python基础之推导式</title>
    <link href="http://www.chenfanlinux.org/2018/02/28/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%A8%E5%AF%BC%E5%BC%8F/"/>
    <id>http://www.chenfanlinux.org/2018/02/28/Python基础之推导式/</id>
    <published>2018-02-28T04:19:12.000Z</published>
    <updated>2018-02-28T04:20:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h2><blockquote><p>推导式是从一个或者多个迭代器快速简洁地创建数据结构的一种方法。它可以加循环和条件判断结合，从而避免语法冗长的代码。会使用推导式有时可以说明你已经超过 Python初学者的水平。也就是说，使用推导式更像 Python 风格。</p></blockquote><h3 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h3><p>你可以从1到5创建一个整数列表，每次增加一项：</p><pre><code>&gt;&gt;&gt; number_list = []&gt;&gt;&gt; number_list.append(1)&gt;&gt;&gt; number_list.append(2)&gt;&gt;&gt; number_list.append(3)&gt;&gt;&gt; number_list.append(4)&gt;&gt;&gt; number_list.append(5)&gt;&gt;&gt; number_list[1, 2, 3, 4, 5]</code></pre><p>或者，可以结合 range() 函数使用一个迭代器：</p><pre><code>&gt;&gt;&gt; number_list = []&gt;&gt;&gt; for number in range(1, 6):    number_list.append(number)&gt;&gt;&gt; number_list[1, 2, 3, 4, 5]</code></pre><p>上面这些方法都是可行的Python代码，会得到相同的结果。然而，更像 Python 风格的创建列表方法是列表推导。语法如下：</p><pre><code>[ expression for item in iterable ]</code></pre><p>将通过列表推导创建一个整数列表：</p><pre><code>&gt;&gt;&gt; number_list = [number for number in range(1,6)]&gt;&gt;&gt; number_list[1, 2, 3, 4, 5]</code></pre><p>在第一行中，第一个 number 变量为列表生成值，也就是说，把循环的结果放在列表 number_list 中。 第二个 number 可以为表达式， 看下下面的例子：</p><pre><code>&gt;&gt;&gt; number_list = [number-1 for number in range(1, 6)]&gt;&gt;&gt; number_list[0, 1, 2, 3, 4]</code></pre><p>列表推到把循环放在方括号内部。这种例子和之前碰到的不大一样，但却是更为常见的方式。同样，列表推导也可以像下面的例子加上条件表达式：</p><pre><code>[expression for item in iterable if condition]</code></pre><p>现在，通过推导创建一个在1到5之间的偶数列表（当 number % 2 == 1 为真时，代表奇数；为假时代表偶数）</p><pre><code>&gt;&gt;&gt; a_list = [number for number in range(1,6) if number %2 ==1]&gt;&gt;&gt; a_list[1, 3, 5]</code></pre><p>使用一次推导，将结果赋值给变量 cells，使 row，col 成为元组：</p><pre><code>&gt;&gt;&gt; rows = range(1,4)&gt;&gt;&gt; cols = range(1,3)&gt;&gt;&gt; cells = [(row,col) for row in rows for col in cols]&gt;&gt;&gt; for cell in cells:    print(cell)(1, 1)(1, 2)(2, 1)(2, 2)(3, 1)(3, 2)</code></pre><a id="more"></a><p>另外，在对 cells 列表进行迭代时可以通过元组拆封将变量 row 和 col 的值分别取出：</p><pre><code>&gt;&gt;&gt; for row,col in cells:    print(row,col)1 11 22 12 23 13 2</code></pre><h3 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h3><p>集合也不例外，同样有推导式。最简单的版本和之前的列表、字典推导类似：</p><pre><code>{expression for expression in iterable }</code></pre><p>也可以使用条件判断：</p><pre><code>&gt;&gt;&gt; a_set = {number for number in range(6) if number % 3 == 1}&gt;&gt;&gt; a_set{1, 4}</code></pre><h3 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h3><pre><code>&gt;&gt;&gt; letter_counts = {letter: word.count(letter) for letter in word}        &gt;&gt;&gt; letter_counts        {&apos;t&apos;: 2, &apos;e&apos;: 2, &apos;l&apos;: 1, &apos;r&apos;: 1, &apos;s&apos;: 1}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;推导式&quot;&gt;&lt;a href=&quot;#推导式&quot; class=&quot;headerlink&quot; title=&quot;推导式&quot;&gt;&lt;/a&gt;推导式&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;推导式是从一个或者多个迭代器快速简洁地创建数据结构的一种方法。它可以加循环和条件判断结合，从而避免语法冗长的代码。会使用推导式有时可以说明你已经超过 Python初学者的水平。也就是说，使用推导式更像 Python 风格。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;列表推导式&quot;&gt;&lt;a href=&quot;#列表推导式&quot; class=&quot;headerlink&quot; title=&quot;列表推导式&quot;&gt;&lt;/a&gt;列表推导式&lt;/h3&gt;&lt;p&gt;你可以从1到5创建一个整数列表，每次增加一项：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; number_list = []
&amp;gt;&amp;gt;&amp;gt; number_list.append(1)
&amp;gt;&amp;gt;&amp;gt; number_list.append(2)
&amp;gt;&amp;gt;&amp;gt; number_list.append(3)
&amp;gt;&amp;gt;&amp;gt; number_list.append(4)
&amp;gt;&amp;gt;&amp;gt; number_list.append(5)
&amp;gt;&amp;gt;&amp;gt; number_list
[1, 2, 3, 4, 5]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或者，可以结合 range() 函数使用一个迭代器：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; number_list = []
&amp;gt;&amp;gt;&amp;gt; for number in range(1, 6):
    number_list.append(number)


&amp;gt;&amp;gt;&amp;gt; number_list
[1, 2, 3, 4, 5]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面这些方法都是可行的Python代码，会得到相同的结果。然而，更像 Python 风格的创建列表方法是列表推导。语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[ expression for item in iterable ]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将通过列表推导创建一个整数列表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; number_list = [number for number in range(1,6)]
&amp;gt;&amp;gt;&amp;gt; number_list
[1, 2, 3, 4, 5]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在第一行中，第一个 number 变量为列表生成值，也就是说，把循环的结果放在列表 number_list 中。 第二个 number 可以为表达式， 看下下面的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; number_list = [number-1 for number in range(1, 6)]
&amp;gt;&amp;gt;&amp;gt; number_list
[0, 1, 2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;列表推到把循环放在方括号内部。这种例子和之前碰到的不大一样，但却是更为常见的方式。同样，列表推导也可以像下面的例子加上条件表达式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[expression for item in iterable if condition]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在，通过推导创建一个在1到5之间的偶数列表（当 number % 2 == 1 为真时，代表奇数；为假时代表偶数）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a_list = [number for number in range(1,6) if number %2 ==1]
&amp;gt;&amp;gt;&amp;gt; a_list
[1, 3, 5]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用一次推导，将结果赋值给变量 cells，使 row，col 成为元组：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; rows = range(1,4)
&amp;gt;&amp;gt;&amp;gt; cols = range(1,3)
&amp;gt;&amp;gt;&amp;gt; cells = [(row,col) for row in rows for col in cols]
&amp;gt;&amp;gt;&amp;gt; for cell in cells:
    print(cell)


(1, 1)
(1, 2)
(2, 1)
(2, 2)
(3, 1)
(3, 2)
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="python基础知识" scheme="http://www.chenfanlinux.org/categories/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Python" scheme="http://www.chenfanlinux.org/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python基础之迭代器和生成器</title>
    <link href="http://www.chenfanlinux.org/2018/02/23/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://www.chenfanlinux.org/2018/02/23/Python基础之迭代器和生成器/</id>
    <published>2018-02-23T08:49:36.000Z</published>
    <updated>2018-02-23T08:51:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><blockquote><p>迭代器是一个可以记住遍历的位置的对象。迭代器对象要求支持迭代器协议的对象，在Python中，支持迭代器协议就是实现对象的iter()和next()方法。其中iter()方法返回迭代器对象本身；next()方法返回容器的下一个元素，在结尾时引发StopIteration异常。</p></blockquote><h3 id="可迭代对象-Iterable"><a href="#可迭代对象-Iterable" class="headerlink" title="可迭代对象: Iterable"></a>可迭代对象: Iterable</h3><p>在Python中，很多对象都是可以通过for语句来直接遍历的数据类型有以下几种:</p><ul><li>一类是集合数据类型，如list、tuple、dict、set、str等；</li><li>一类是generator，包括生成器和带yield的generator function 。</li></ul><p>这些可以直接作用于for循环的对象统称为可迭代对象：Iterable，可以使用isinstance()判断一个对象是否是Iterable对象:</p><pre><code>&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance([], Iterable)True&gt;&gt;&gt; isinstance({}, Iterable)True&gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterable)True&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable)True&gt;&gt;&gt; isinstance(100, Iterable)False</code></pre><a id="more"></a><h3 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器: Iterator"></a>迭代器: Iterator</h3><blockquote><p>可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。迭代器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。</p></blockquote><p>迭代器有两个基本的方法：</p><pre><code>__iter__()和next()方法</code></pre><p>可以使用isinstance()判断一个对象是否是Iterator对象：</p><pre><code>&gt;&gt;&gt; from collections import Iterator&gt;&gt;&gt;&gt;&gt;&gt; isinstance((x for x in range(10)), Iterator)True&gt;&gt;&gt; isinstance([], Iterator)False&gt;&gt;&gt; isinstance({}, Iterator)False&gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterator)False&gt;&gt;&gt;</code></pre><p><strong><em>生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。</em></strong></p><p>把list、dict、str等Iterable变成Iterator可以使用iter()函数：</p><pre><code>&gt;&gt;&gt; isinstance(iter([]), Iterator)True&gt;&gt;&gt; isinstance(iter(&apos;abc&apos;), Iterator)True</code></pre><p>你可能会问，为什么list、dict、str等数据类型不是Iterator？</p><p>这是因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。</p><p>Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。</p><h3 id="迭代器小结"><a href="#迭代器小结" class="headerlink" title="迭代器小结"></a>迭代器小结</h3><ul><li>凡是可作用于for循环的对象都是Iterable类型；</li><li>凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；</li><li>集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。</li><li>Python的for语句就会自动的通过iter()方法来获得迭代器对象，并且通过next()方法来获取下一个元素。</li></ul><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><blockquote><p>生成器是用来创建 Python 序列的一个对象。使用它可以迭代庞大的序列，且不需要再内存中创建和存储整个序列，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。</p></blockquote><h3 id="创建生成器"><a href="#创建生成器" class="headerlink" title="创建生成器"></a>创建生成器</h3><p>要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：</p><pre><code>&gt;&gt;&gt; L = [ x * x for x in range(10)]&gt;&gt;&gt; L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x0000000003541BA0&gt;</code></pre><p>如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值：</p><pre><code>&gt;&gt;&gt; next(g)0&gt;&gt;&gt; next(g)1&gt;&gt;&gt; next(g)4&gt;&gt;&gt; next(g)9&gt;&gt;&gt; next(g)16&gt;&gt;&gt; next(g)25&gt;&gt;&gt; next(g)36&gt;&gt;&gt; next(g)49&gt;&gt;&gt; next(g)64&gt;&gt;&gt; next(g)81&gt;&gt;&gt; next(g)Traceback (most recent call last):  File &quot;&lt;pyshell#27&gt;&quot;, line 1, in &lt;module&gt;    next(g)StopIteration</code></pre><p>generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。</p><p>当然，上面这种不断调用next(g)实在是太变态了，正确的方法是使用for循环，因为generator也是可迭代对象：</p><pre><code>&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; for n in g:    print(n)0149162536496481</code></pre><p>所以，我们创建了一个generator后，基本上永远不会调用next()，而是通过for循环来迭代它，并且不需要关心StopIteration的错误。</p><h3 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h3><blockquote><p>每次迭代生成器，它会记录上一次调用的位置，并且返回下一个值。这一点和普通的函数是不一样的，一般函数都不记录之前一次调用，而且都会在函数的第一行开始执行。</p></blockquote><p>如果你想创建一个比较大的序列，使用生成器推导的代码会很长，这是可以尝试写一个生成器函数。生成器函数和普通函数类似，但是它的返回值使用 yield 语句声明, 不是 return。下面编写我们自己的 range() 函数版本：</p><pre><code>&gt;&gt;&gt; def my_range(first=0, last=10, step=1):    number = first    while number &lt; last:        yield number        number += step</code></pre><p>这是一个普通的函数：</p><pre><code>&gt;&gt;&gt; my_range&lt;function my_range at 0x00000000035FC158&gt;</code></pre><p>并且它返回的是一个生成器对象:</p><pre><code>&gt;&gt;&gt; ranger = my_range(1, 5)&gt;&gt;&gt; ranger&lt;generator object my_range at 0x00000000035F1C50&gt;</code></pre><p>可以对这个生成器对象进行迭代：</p><pre><code>&gt;&gt;&gt; for x in ranger:    print(x)1234</code></pre><p><strong><em>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回yield的值。并在下一次执行 next()方法时从当前位置继续运行。</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;迭代器&quot;&gt;&lt;a href=&quot;#迭代器&quot; class=&quot;headerlink&quot; title=&quot;迭代器&quot;&gt;&lt;/a&gt;迭代器&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;迭代器是一个可以记住遍历的位置的对象。迭代器对象要求支持迭代器协议的对象，在Python中，支持迭代器协议就是实现对象的iter()和next()方法。其中iter()方法返回迭代器对象本身；next()方法返回容器的下一个元素，在结尾时引发StopIteration异常。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;可迭代对象-Iterable&quot;&gt;&lt;a href=&quot;#可迭代对象-Iterable&quot; class=&quot;headerlink&quot; title=&quot;可迭代对象: Iterable&quot;&gt;&lt;/a&gt;可迭代对象: Iterable&lt;/h3&gt;&lt;p&gt;在Python中，很多对象都是可以通过for语句来直接遍历的数据类型有以下几种:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一类是集合数据类型，如list、tuple、dict、set、str等；&lt;/li&gt;
&lt;li&gt;一类是generator，包括生成器和带yield的generator function 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些可以直接作用于for循环的对象统称为可迭代对象：Iterable，可以使用isinstance()判断一个对象是否是Iterable对象:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from collections import Iterable
&amp;gt;&amp;gt;&amp;gt; isinstance([], Iterable)
True
&amp;gt;&amp;gt;&amp;gt; isinstance({}, Iterable)
True
&amp;gt;&amp;gt;&amp;gt; isinstance(&amp;apos;abc&amp;apos;, Iterable)
True

&amp;gt;&amp;gt;&amp;gt; isinstance((x for x in range(10)), Iterable)
True
&amp;gt;&amp;gt;&amp;gt; isinstance(100, Iterable)
False
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="python基础知识" scheme="http://www.chenfanlinux.org/categories/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Python" scheme="http://www.chenfanlinux.org/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python基础之函数与模块</title>
    <link href="http://www.chenfanlinux.org/2018/02/23/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0%E4%B8%8E%E6%A8%A1%E5%9D%97/"/>
    <id>http://www.chenfanlinux.org/2018/02/23/Python基础之函数与模块/</id>
    <published>2018-02-23T04:15:11.000Z</published>
    <updated>2018-02-23T04:20:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><blockquote><p>代码复用的第一步是使用函数，它是命名的用于区分的代码段。函数可以接受任何数字或者其他类型的输入作为参数，并且返回数字或者其他类型的结果。函数是Python为了代码最大程度的重用和最小化代码冗余而提供的最基本的程序结构。</p></blockquote><h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><p>在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:；然后在缩进块中编写函数体，函数的返回值用return语句返回。</p><pre><code>def 函数名(参数):    ...    函数体    ...    返回值</code></pre><h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><p>函数的返回值需要使用到return这个关键字，返回值主要是用来接受函数的执行结果。</p><pre><code>&gt;&gt;&gt; def re():    if 1 == 1:        return True    else:        return False&gt;&gt;&gt; re()True</code></pre><p>函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕；如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。</p><a id="more"></a><h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><blockquote><p>定义函数的时候，我们把参数的名字和位置确定下来，函数的接口定义就完成了。对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值就够了，函数内部的复杂逻辑被封装起来，调用者无需了解。</p></blockquote><h4 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h4><p>Python 处理参数的方式要比其他语言更加灵活。其中，最熟悉的参数类型是位置参数，传入参数的值必须按照顺序依次复制过去的。</p><pre><code>// n1, n2, n3是形参&gt;&gt;&gt; def name (n1, n2, n3):    print(&apos;1&apos;, n1)    print(&apos;2&apos;, n2)    print(&apos;3&apos;, n3)// 老大, 老二, 老三是实参&gt;&gt;&gt; name(&apos;老大&apos;, &apos;老二&apos;, &apos;老三&apos;)1 老大2 老二3 老三</code></pre><p>尽管这种方式很常见，但是位置参数的一个弊端是必须熟记没个位置的参数的含义。在调用函数name() 时误把最后一个参数当做第一个参数，会得到完全不同的结果：</p><pre><code>&gt;&gt;&gt; name(&apos;老三&apos;,&apos;老大&apos;,&apos;老二&apos;)1 老三2 老大3 老二</code></pre><h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>为了避免位置参数带来的混乱，调用参数时可以指定对应的名字，甚至可以采用与函数定义不同的顺序调用，<strong><em>关键字参数需要在位置参数之后。</em></strong></p><pre><code>&gt;&gt;&gt; name(n2=&apos;老二&apos;, n1=&apos;老大&apos;, n3=&apos;老三&apos;)1 老大2 老二3 老三</code></pre><p>你也可以把位置参数和关键字参数混合起来:</p><pre><code>&gt;&gt;&gt; name(&apos;老大&apos;, n2=&apos;老二&apos;, n3=&apos;老三&apos;)1 老大2 老二3 老三</code></pre><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p><strong>当调用方没有提供对应的参数值时，你可以指定默认参数值。</strong></p><pre><code>&gt;&gt;&gt; def name(n2, n3, n1=&apos;老大&apos;):    print(&apos;1&apos;, n1)    print(&apos;2&apos;, n2)    print(&apos;3&apos;, n3)&gt;&gt;&gt; name(&apos;老二&apos;, &apos;老三&apos;)1 老大2 老二3 老三</code></pre><p><strong><em>默认参数可以简化函数的调用,设置默认参数时,有几点要注意:</em></strong></p><ul><li>一是必选参数在前，默认参数在后，否则Python的解释器会报错。</li><li>当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。</li><li>定义默认参数要牢记一点：默认参数必须指向不变对象！</li></ul><p>默认参数值在函数被定义时已经计算出来，而不是在程序运行时。Python程序员经常犯的一个错误是把可变的数据类型（例如列表或者字典）当做默认参数值。Python函数在定义的时候，默认参数result的值就被计算出来了，即[]，因为默认参数result也是一个变量，它指向对象[]，每次调用该函数，如果改变了result的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。</p><pre><code>&gt;&gt;&gt; def box(arg, result=[]):    result.append(arg)    print(result)&gt;&gt;&gt; box(&apos;a&apos;)[&apos;a&apos;]&gt;&gt;&gt; box(&apos;b&apos;)[&apos;a&apos;, &apos;b&apos;]</code></pre><p>如果写成下面的样子就会解决刚才的问题：</p><pre><code>&gt;&gt;&gt; def box(arg):    result = []    result.append(arg)    return result&gt;&gt;&gt; box(&apos;a&apos;)[&apos;a&apos;]&gt;&gt;&gt; box(&apos;b&apos;)[&apos;b&apos;]</code></pre><p>这样的修改也是为了表明第一次调用跳过一些操作：</p><pre><code>&gt;&gt;&gt; def box(arg, result=None):    if result is None:        result = []    result.append(arg)    print(result)&gt;&gt;&gt; box(&apos;a&apos;)[&apos;a&apos;]&gt;&gt;&gt; box(&apos;b&apos;)[&apos;b&apos;]</code></pre><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p><strong>若你的函数在定义时不确定用户想传入多少个参数，就可以使用可变参数。</strong></p><pre><code>&gt;&gt;&gt; def stu_register(name, age, *args): # *args 会把多传入的参数变成一个元组形式    print(name, age , args)&gt;&gt;&gt; stu_register(&quot;chenfanlinux&quot;, 23)chenfanlinux 23 () # 后面这个()就是args,只是因为没传值,所以为空&gt;&gt;&gt; stu_register(&quot;chenfanlinux&quot;, 30, &quot;CN&quot;, &quot;Python&quot;)chenfanlinux 30 (&apos;CN&apos;, &apos;Python&apos;)  # 后面传入的参数会被当做一个元组</code></pre><p>还可以有一个 **kwargs</p><pre><code>&gt;&gt;&gt; def stu_register(name, age, *args, **kwargs):    print(name, age, args, kwargs)&gt;&gt;&gt; stu_register(&quot;chenfan&quot;, 22)chenfan 22 () {}    # 后面这个{}就是kwargs,只是因为没传值,所以为空&gt;&gt;&gt; stu_register(&quot;chenfan&quot;, 22, &quot;CN&quot;, &quot;Python&quot;, sex=&quot;Male&quot;, province=&quot;guangzhou&quot;)chenfan 22 (&apos;CN&apos;, &apos;Python&apos;) {&apos;province&apos;: &apos;guangzhou&apos;, &apos;sex&apos;: &apos;Male&apos;}</code></pre><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a><a href="http://www.cnblogs.com/wupeiqi/articles/4963027.html" target="_blank" rel="noopener">模块</a></h2><p>在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。<br>为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。<strong><em>在Python中，一个.py文件就称之为一个模块（Module）。</em></strong></p><h3 id="使用模块的好处"><a href="#使用模块的好处" class="headerlink" title="使用模块的好处"></a>使用模块的好处</h3><ul><li>最大的好处是大大提高了代码的可维护性。</li><li>编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。</li><li>相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。</li><li>如果不同的人编写的模块名相同怎么办？为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package）。</li></ul><h3 id="模块与包"><a href="#模块与包" class="headerlink" title="模块与包"></a>模块与包</h3><p>举个例子，一个 <strong><em>abc.py</em></strong> 的文件就是一个名字叫 <strong><em>abc</em></strong> 的模块，一个 <strong><em>xyz.py</em></strong> 的文件就一个名字叫 <strong><em>xyz</em></strong> 的模块。</p><p>现在，假设我们的 <strong><em>abc</em></strong> 和 <strong><em>xyz</em></strong> 这两个模块名字与其他模块冲突了，于是我们可以通过包来组织模块，避免冲突。方法是选择一个顶层包名，比如<strong><em>mycompany</em></strong>，按照如下目录存放：</p><pre><code>mycompany # 包名├─ __init__.py├─ abc.py # 模块名└─ xyz.py</code></pre><p>引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。现在，<strong><em>abc.py</em></strong> 模块的名字就变成了 <strong><em>mycompany.abc</em></strong>，<strong><em>xyz.py</em></strong> 的模块名变成了 <strong><em>mycompany.xyz</em></strong>。</p><p>请注意，每一个包目录下面都会有一个 __init__.py 的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。__init__.py可以是空文件，也可以有Python代码，因为__init__.py本身就是一个模块，而它的模块名就是文件夹名mycompany。</p><p>类似的，可以有多级目录，组成多级层次的包结构。比如如下的目录结构：</p><pre><code>mycompany ├─ web │  ├─ __init__.py │  ├─ utils.py │  └─ www.py ├─ __init__.py ├─ abc.py └─ xyz.py</code></pre><p>文件www.py的模块名就是mycompany.web.www 。</p><blockquote><p>自己创建模块时要注意命名，不能和Python自带的模块名称冲突。例如，系统自带了sys模块，自己的模块就不可命名为sys.py，否则将无法导入系统自带的sys模块。</p></blockquote><h3 id="模块的导入"><a href="#模块的导入" class="headerlink" title="模块的导入"></a>模块的导入</h3><p>导入模块有一下几种方法：</p><ul><li>import module</li><li>from module.xx.xx import xx</li><li>from module.xx.xx import xx as rename</li><li>from module.xx.xx import *</li></ul><p>导入模块其实就是告诉Python解释器去解释那个py文件</p><ul><li>导入一个py文件，解释器解释该py文件</li><li>导入一个包，解释器解释该包下的 __init__.py 文件</li></ul><p>那么问题来了，导入模块时是根据那个路径作为基准来进行的呢？即：sys.path</p><pre><code>&gt;&gt;&gt; import sys&gt;&gt;&gt; print(sys.path)[&apos;&apos;, &apos;F:\\Python35\\Lib\\idlelib&apos;, &apos;F:\\Python35\\python35.zip&apos;, &apos;F:\\Python35\\DLLs&apos;, &apos;F:\\Python35\\lib&apos;, &apos;F:\\Python35&apos;, &apos;F:\\Python35\\lib\\site-packages&apos;]</code></pre><p>如果sys.path路径列表没有你想要的路径，可以通过 sys.path.append(‘路径’) 添加。</p><pre><code>import sysimport ospre_path = os.path.abspath(&apos;../&apos;)sys.path.append(pre_path)</code></pre><h3 id="模块总结"><a href="#模块总结" class="headerlink" title="模块总结"></a>模块总结</h3><p>模块是一组Python代码的集合，可以使用其他模块，也可以被其他模块使用。</p><p>创建自己的模块时，要注意：</p><ul><li>模块名要遵循Python变量命名规范，不要使用中文、特殊字符；</li><li>模块名不要和系统模块名冲突，最好先查看系统是否已存在该模块，检查方法是在Python交互环境执行import abc，若成功则说明系统存在此模块。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;代码复用的第一步是使用函数，它是命名的用于区分的代码段。函数可以接受任何数字或者其他类型的输入作为参数，并且返回数字或者其他类型的结果。函数是Python为了代码最大程度的重用和最小化代码冗余而提供的最基本的程序结构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;函数的定义&quot;&gt;&lt;a href=&quot;#函数的定义&quot; class=&quot;headerlink&quot; title=&quot;函数的定义&quot;&gt;&lt;/a&gt;函数的定义&lt;/h3&gt;&lt;p&gt;在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:；然后在缩进块中编写函数体，函数的返回值用return语句返回。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def 函数名(参数):
    ...
    函数体
    ...
    返回值
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;函数的返回值&quot;&gt;&lt;a href=&quot;#函数的返回值&quot; class=&quot;headerlink&quot; title=&quot;函数的返回值&quot;&gt;&lt;/a&gt;函数的返回值&lt;/h3&gt;&lt;p&gt;函数的返回值需要使用到return这个关键字，返回值主要是用来接受函数的执行结果。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def re():
    if 1 == 1:
        return True
    else:
        return False


&amp;gt;&amp;gt;&amp;gt; re()
True
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕；如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。&lt;/p&gt;
    
    </summary>
    
      <category term="python基础知识" scheme="http://www.chenfanlinux.org/categories/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Python" scheme="http://www.chenfanlinux.org/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python基础之文件与异常</title>
    <link href="http://www.chenfanlinux.org/2018/02/22/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BC%82%E5%B8%B8/"/>
    <id>http://www.chenfanlinux.org/2018/02/22/Python基础之文件与异常/</id>
    <published>2018-02-22T08:41:24.000Z</published>
    <updated>2018-02-22T08:42:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><blockquote><p>数据持久化最简单的类型是普通文件,它仅仅是在一个文件名下的字节流，把数据从一个文件读入内存，然后从内存写入文件。</p></blockquote><h3 id="文件操作模型"><a href="#文件操作模型" class="headerlink" title="文件操作模型"></a>文件操作模型</h3><pre><code>data = open(filename, mode)</code></pre><p>下面是对该 open() 调用的简单解释：</p><ul><li>data 是 open() 返回的文件对象</li><li>filename 是该文件的字符串名</li><li>mode 是指明文件类型和操作的字符串</li></ul><p>mode 的第一个字母表明对其的操作：</p><ul><li>r 以只读方式打开文件。文件的指针将会放在文件的开头，这是默认模式。</li><li>r+ 可读可写，不会创建不存在的文件。如果直接写文件，则从顶部开始写，覆盖之前此位置的内容，如果先读后写，则会在文件最后追加内容。</li><li>w 表示写模式。若果文件不存在则新创建，如果该文件已存在则将其覆盖。</li><li>w+ 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</li><li>x 表示在文件不存在的情况下新创建并写文件，如果文件存在就会报错。</li><li>a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</li><li>a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</li></ul><p>mode 的第二个字母是文件类型：</p><ul><li>t（或者省略） 代表文本类型</li><li>b 代表二进制文件</li></ul><p><strong><em>注意: 打开文件之后就可以调用函数来读写数据，最后需要关闭文件。</em></strong></p><a id="more"></a><h3 id="使用-write-写文本文件"><a href="#使用-write-写文本文件" class="headerlink" title="使用 write() 写文本文件"></a>使用 write() 写文本文件</h3><pre><code>&gt;&gt;&gt; poem = &quot;日照香炉生紫烟，遥看瀑布挂前川。飞流直下三千尺，疑是银河落九天。&quot;&gt;&gt;&gt;&gt;&gt;&gt; len(poem)32</code></pre><p>将整首诗写到libai.txt中：</p><pre><code>&gt;&gt;&gt; fout = open(&apos;libai.txt&apos;,&apos;wt&apos;)&gt;&gt;&gt; fout.write(poem)32&gt;&gt;&gt; fout.close&lt;built-in method close of _io.TextIOWrapper object at 0x00000000034E1120&gt;</code></pre><p>函数 write() 返回写入文件的字节数。和 print() 一样， 他没有增加空格或者换行符。同样，你也可以在一个文本文件中使用 print()。</p><pre><code>&gt;&gt;&gt; fout = open(&apos;libai.txt&apos;,&apos;wt&apos;)&gt;&gt;&gt; print(poem, file=fout)&gt;&gt;&gt; fout.close()</code></pre><p>这就产生了一个问题：到底是用是 write() 还是 print()？ print() 默认会在每个参数后面添加空格，在每行结束处添加换行。在之前的例子中， libai.txt 中默认添加了一个换行。为了使 print() 与 write() 有同样的输出，传入下面两个参数：</p><ul><li>sep 分隔符：默认是一个空格‘’</li><li>end 结束字符：默认是一个换行符 ‘\n’</li></ul><p>除非自定义参数，否则 print() 会使用默认参数。在这里，我们通过空字符串替换 print() 添加的所有多余输出：</p><pre><code>&gt;&gt;&gt; print(poem, file=fout, sep=&apos;&apos;, end=&apos;&apos;)&gt;&gt;&gt; fout.close()</code></pre><p>如果字符串非常大，可以将数据分块，直到所有字符被写入：</p><pre><code>&gt;&gt;&gt; size = len(poem)&gt;&gt;&gt;&gt;&gt;&gt; fout = open(&apos;libai.txt&apos;, &apos;w&apos;)&gt;&gt;&gt; offset = 0&gt;&gt;&gt; chunk = 10&gt;&gt;&gt; while True:    if offset &gt; size:        break    fout.write(poem[offset:offset+chunk])    offset += chunk1010102&gt;&gt;&gt;&gt;&gt;&gt; fout.close()</code></pre><p>如果 libai.txt 文件已经存在，使用模式 x 可以避免重写文件：</p><pre><code>&gt;&gt;&gt; fount = open(&apos;libai.txt&apos;,&apos;xt&apos;)Traceback (most recent call last):  File &quot;&lt;pyshell#0&gt;&quot;, line 1, in &lt;module&gt;    fount = open(&apos;libai.txt&apos;,&apos;xt&apos;)FileExistsError: [Errno 17] File exists: &apos;libai.txt&apos;</code></pre><h3 id="使用-read-、readline-或者-readlines-读取文本文件"><a href="#使用-read-、readline-或者-readlines-读取文本文件" class="headerlink" title="使用 read()、readline() 或者 readlines() 读取文本文件"></a>使用 read()、readline() 或者 readlines() 读取文本文件</h3><p>使用不带参数的 read() 函数一次读入文件的所有内容。但在读入文件时要格外注意，1GB的文件会用到相同大小的内存，如果文件大小太大的话，需要防止内存爆掉。</p><pre><code>&gt;&gt;&gt; fin = open(&apos;libai.txt&apos;, &apos;rt&apos;)&gt;&gt;&gt; poem = fin.read()&gt;&gt;&gt; poem&apos;日照香炉生紫烟，遥看瀑布挂前川。飞流直下三千尺，疑是银河落九天。&apos;&gt;&gt;&gt; fin.close()&gt;&gt;&gt; len(poem)32</code></pre><p>同样也可以设置最大的读入字符数限制 read() 函数一次返回的大小。下面一次读入10个字符，然后把每一快拼接成原来的字符串 poem。</p><pre><code>&gt;&gt;&gt; poem = &apos;&apos;&gt;&gt;&gt; fin = open(&apos;libai.txt&apos;, &apos;rt&apos;)&gt;&gt;&gt; chunk = 10&gt;&gt;&gt; while True:    fragment = fin.read(chunk)    if not fragment:        break    poem += fragment&gt;&gt;&gt; fin.close()&gt;&gt;&gt; len(poem)32&gt;&gt;&gt; poem&apos;日照香炉生紫烟，遥看瀑布挂前川。飞流直下三千尺，疑是银河落九天。&apos;</code></pre><p>读到结尾之后，再次调用 read() 会返回空字符串(‘’)， if not fragment 条件被判断为 False。此时会跳出 while True 的循环。 当然， 你也能使用 readline() 每次读入文件的一行。 在下面的例子中，通过追加每一行拼接成原来的字符串 poem。</p><pre><code>&gt;&gt;&gt; poem = &apos;&apos;&gt;&gt;&gt; fin = open(&apos;libai.txt&apos;, &apos;rt&apos;)&gt;&gt;&gt; while True:    line = fin.readline()    if not line:        break    poem += line&gt;&gt;&gt; fin.close()&gt;&gt;&gt; len(poem)32&gt;&gt;&gt; poem&apos;日照香炉生紫烟，遥看瀑布挂前川。飞流直下三千尺，疑是银河落九天。&apos;</code></pre><p>读取文本文件最简单的方式是使用一个迭代器（iterator），它会每次返回一行。这和之前的例子类似，但代码会更短：</p><pre><code>&gt;&gt;&gt; poem = &apos;&apos;&gt;&gt;&gt; fin = open(&apos;libai.txt&apos;, &apos;rt&apos;)&gt;&gt;&gt; for line in fin:    poem += line&gt;&gt;&gt; fin.close()&gt;&gt;&gt; len(poem)32&gt;&gt;&gt; poem&apos;日照香炉生紫烟，遥看瀑布挂前川。飞流直下三千尺，疑是银河落九天。&apos;</code></pre><p>前面所有的示例最终都返回单个字符串 poem。 函数 readlines() 调用时每次读取一行，并返回单行字符串的列表：</p><pre><code>&gt;&gt;&gt; poem = &apos;&apos;&apos;日照香炉生紫烟，遥看瀑布挂前川。飞流直下三千尺,疑是银河落九天。&apos;&apos;&apos;&gt;&gt;&gt; fin = open(&apos;libai.txt&apos;,&apos;wt&apos;)&gt;&gt;&gt; fin.write(poem)36&gt;&gt;&gt; fin.close()&gt;&gt;&gt; fin = open(&apos;libai.txt&apos;, &apos;rt&apos;)&gt;&gt;&gt; lines = fin.readlines()&gt;&gt;&gt; fin.close()&gt;&gt;&gt; lines[&apos;日照香炉生紫烟，\n&apos;, &apos;遥看瀑布挂前川。\n&apos;, &apos;飞流直下三千尺,\n&apos;, &apos;疑是银河落九天。\n&apos;]&gt;&gt;&gt; for line in lines:print(line,end=&apos;&apos;)日照香炉生紫烟，遥看瀑布挂前川。飞流直下三千尺,疑是银河落九天。</code></pre><h3 id="使用-with-自动关闭文件"><a href="#使用-with-自动关闭文件" class="headerlink" title="使用 with 自动关闭文件"></a>使用 with 自动关闭文件</h3><p>Python的上下文管理器（context manager）会清理一些资源，例如打开的文件。<br>它的形式<br><code>with expression as variable：</code></p><pre><code>&gt;&gt;&gt; opem = &apos;&apos;&apos;welcome to chenfanlinux.org&apos;&apos;&apos;// 利用这种方式就可以不必用close()函数关闭文件&gt;&gt;&gt; with open(&apos;libai.txt&apos;, &apos;wt&apos;) as fout:    print(opem,file=fout,end=&apos;&apos;)&gt;&gt;&gt; with open(&apos;libai.txt&apos;, &apos;rt&apos;) as fin:    for line in fin:        print(line,end=&apos;&apos;)welcome to chenfanlinux.org</code></pre><p>完成上下文管理器的代码后，文件会自动关闭。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><blockquote><p>Python使用被称为异常的特殊对象来管理程序执行期间发生的错误。每当发生让Python不知 所措的错误时，它都会创建一个异常对象。如果你编写了处理该异常的代码，程序将继续运行; 如果你未对异常进行处理，程序将停止，并显示一个traceback，其中包含有关异常的报告。<br>异常是使用try-except代码块处理的。try-except代码块让Python执行指定的操作，同时告 诉Python发生异常时怎么办。使用了try-except代码块时，即便出现异常，程序也将继续运行: 显示你编写的友好的错误消息，而不是令用户迷惑的traceback。</p></blockquote><h3 id="使用-try-except-代码块"><a href="#使用-try-except-代码块" class="headerlink" title="使用 try-except 代码块"></a>使用 try-except 代码块</h3><blockquote><p>try 语句有两种主要形式: try-except 和 try-finally . 这两个语句是互斥的, 也就是说你 只能使用其中的一种. 一个 try 语句可以对应一个或多个 except 子句, 但只能对应一个 finally 子句, 或是一个 try-except-finally 复合语句。</p></blockquote><p>处理ZeroDivisionError异常的try-except代码 类似于下面这样：</p><pre><code>&gt;&gt;&gt; try:    print(5/0)except ZeroDivisionError:    print(&quot;You can&apos;t divide by zero!&quot;)You can&apos;t divide by zero!</code></pre><p>我们将导致错误的代码行print(5/0)放在了一个try代码中。如果try代码中的代码运行起来没有问题，Python将跳过except代码; 如果try代码中的代码导致了错误，Python将查找这样的except代码块，并运行其中的代码，即其中指定的错误与引发的错误相同。<br>在这个示例中，try代码中的代码引发了ZeroDivisionError异常，因此Python指出了该如何解决问题的except代码块，并运行其中的代码。这样，用户看到的是一条 好的错误消息，而不是traceback:</p><pre><code>You can&apos;t divide by zero!</code></pre><p>如果try-except代码后面还有其他代码，程序将接着运行，因为已经告诉了Python如何处理这种错误。</p><h3 id="使用异常避免崩溃"><a href="#使用异常避免崩溃" class="headerlink" title="使用异常避免崩溃"></a>使用异常避免崩溃</h3><p>发生错误时，如果程序还有工作没有完成，妥善地处理错误就尤其重要。这种情况经常会出现在要求用户提供输入的程序中;如果程序能够妥善地处理无效输入，就能再提示用户提供有效输入，而不至于崩溃。</p><pre><code>#__author: Administrator#date: 2018/2/11print(&quot;Give me two numbers, and I&apos;ll divide them.&quot;)print(&quot;Enter &apos;q&apos; to quit.&quot;)while True:    first_number = input(&quot;\n First number: &quot;)    if first_number == &apos;q&apos;:        break    second_number = input(&quot;\n Second number: &quot;)    if second_number == &apos;q&apos;:        break    answer = int(first_number) / int(second_number)    print(answer)</code></pre><p>这个程序没有采取任何处理错误的措施，因此让它执行除数为0的除法运算时，它将崩溃:</p><pre><code>Give me two numbers, and I&apos;ll divide them.Enter &apos;q&apos; to quit.First number: 5Second number: 0Traceback (most recent call last):  File &quot;&lt;ipython-input-208-1e61f850d337&gt;&quot;, line 11, in &lt;module&gt;    answer = int(first_number) / int(second_number)ZeroDivisionError: division by zero&gt;&gt;&gt;</code></pre><p>程序崩溃可不好，但让用户看到 traceback 也不是好主意。不懂技术的用户会被它们搞糊涂， 而且如果用户 怀有恶意，他会通过traceback获悉你不希望他知道的信息。例如，他将知道你的程序文件的名称，还将看到部分不能正确运行的代码。有时候，训练有素的攻击者可根据这些信息判断出可对你的代码发起什么样的攻击。</p><h3 id="else-代码块"><a href="#else-代码块" class="headerlink" title="else 代码块"></a>else 代码块</h3><p>通过将可能引发错误的代码放在try-except代码中，可提高这个程序抵御错误的能力。错误是执行除法运算的代码行导致的，因此我们需要将它放到try-except代码块中。这个示例还包含一个else代码块; 依赖于try代码块成功执行的代码都应放到else代码中:</p><pre><code>#__author: Administrator#date: 2018/2/11print(&quot;Give me two numbers, and I&apos;ll divide them.&quot;)print(&quot;Enter &apos;q&apos; to quit.&quot;)while True:    first_number = input(&quot;\n First number: &quot;)    if first_number == &apos;q&apos;:        break    second_number = input(&quot;\n Second number: &quot;)    if second_number == &apos;q&apos;:        break    try:        answer = int(first_number) / int(second_number)    except ZeroDivisionError:        print(&quot;You can&apos;t divide by 0!&quot;)    else:        print(answer)</code></pre><p>我们让Python尝试执行try代码块中的除法运算，这个代码块只包含可能导致错误的代码。依赖于try代码块成功执行的代码都放在else代码中; 在这个示例中，如果除法运算成功，我们就使用else代码块来打印结果。<br>except代码块告诉Python，出现ZeroDivisionError异常时该怎么办。如果try代码因除零错误而失败，我们就打印一条友好的消息，告诉用户如何避免这种错误。程序将继续运行，用户根本看不到traceback。</p><pre><code>Give me two numbers, and I&apos;ll divide them.Enter &apos;q&apos; to quit.First number: 5Second number: 0You can&apos;t divide by 0!First number: 5Second number: 22.5First number: q&gt;&gt;&gt;</code></pre><p>try-except-else代码块的工作原理大致如下: Python尝试执行try代码块中的代码; 只有可能引发异常的代码才需要放在try语句中。有时候，有一些仅在try代码块成功执行时才需要运行的的代码; 这些代码应放在else代码中。except代码块告诉Python，如果它尝试运行try代码块中的代码时引发了指定的异常，该怎么办。通过预测可能发生错误的代码，可编写健壮的程序，它们即便面临无效数据或缺少资源，也能继续运行，从而能够抵御无意的用户错误和恶意的攻击。</p><h3 id="finally子句"><a href="#finally子句" class="headerlink" title="finally子句"></a>finally子句</h3><p>finally 子句是无论异常是否发生,是否捕捉都会执行的一段代码. 你可以将 finally 仅仅配合 try 一起使用,也可以和 try-except(else 也是可选的)一起使用。你可以用 finally 子句 与 try-except 或 try-except-else 一起使用。</p><p>下面是 try-except-else-finally 语法的示例:</p><pre><code>try:    Aexcept MyException1:    B1except MyException2:    B2else:    Cfinally:    D</code></pre><p>当然,无论如何,你都可以有不止一个的 except 子句,但最少有一个 except 语句,而 else 和 finally 都是可选的. A,B,C 和 D 是程序(代码块). 程序会按预期的顺序执行.(注意:可能的顺序是 A-C-D[正常]或 A-B-D[异常])，无论异常发生都将执行 finally 块。</p><h3 id="常见的异常"><a href="#常见的异常" class="headerlink" title="常见的异常"></a>常见的异常</h3><p><img src="https://s1.ax1x.com/2018/02/22/9UQn74.png" alt="常见的异常"></p><h3 id="决定报告那些错误"><a href="#决定报告那些错误" class="headerlink" title="决定报告那些错误"></a>决定报告那些错误</h3><ul><li>编写得很好且经过详尽测试的代码不容易出现内部错误，如语法或逻辑错误。</li><li>但只要程序依赖于外部因素，如用户输入、存在指定的文件、有网络连接，就有可能出现异常。凭借经验可判断该在程序的什么地方包含异常处理 ，以及出现错误时该向用户提供多少相关的信息。</li><li>向用户显示他不想看到的信息可能会降低程序的可用性。Python的错误处理结构让你能够细致地控制与用户分享错误信息的程度，要分享多少信息由你决定。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文件&quot;&gt;&lt;a href=&quot;#文件&quot; class=&quot;headerlink&quot; title=&quot;文件&quot;&gt;&lt;/a&gt;文件&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;数据持久化最简单的类型是普通文件,它仅仅是在一个文件名下的字节流，把数据从一个文件读入内存，然后从内存写入文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;文件操作模型&quot;&gt;&lt;a href=&quot;#文件操作模型&quot; class=&quot;headerlink&quot; title=&quot;文件操作模型&quot;&gt;&lt;/a&gt;文件操作模型&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;data = open(filename, mode)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面是对该 open() 调用的简单解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;data 是 open() 返回的文件对象&lt;/li&gt;
&lt;li&gt;filename 是该文件的字符串名&lt;/li&gt;
&lt;li&gt;mode 是指明文件类型和操作的字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;mode 的第一个字母表明对其的操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;r 以只读方式打开文件。文件的指针将会放在文件的开头，这是默认模式。&lt;/li&gt;
&lt;li&gt;r+ 可读可写，不会创建不存在的文件。如果直接写文件，则从顶部开始写，覆盖之前此位置的内容，如果先读后写，则会在文件最后追加内容。&lt;/li&gt;
&lt;li&gt;w 表示写模式。若果文件不存在则新创建，如果该文件已存在则将其覆盖。&lt;/li&gt;
&lt;li&gt;w+ 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。&lt;/li&gt;
&lt;li&gt;x 表示在文件不存在的情况下新创建并写文件，如果文件存在就会报错。&lt;/li&gt;
&lt;li&gt;a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。&lt;/li&gt;
&lt;li&gt;a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;mode 的第二个字母是文件类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;t（或者省略） 代表文本类型&lt;/li&gt;
&lt;li&gt;b 代表二进制文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意: 打开文件之后就可以调用函数来读写数据，最后需要关闭文件。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python基础知识" scheme="http://www.chenfanlinux.org/categories/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Python" scheme="http://www.chenfanlinux.org/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python基础之变量与运算符</title>
    <link href="http://www.chenfanlinux.org/2018/02/17/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://www.chenfanlinux.org/2018/02/17/Python基础之变量与运算符/</id>
    <published>2018-02-16T22:44:59.000Z</published>
    <updated>2018-02-16T22:48:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><blockquote><p>在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。所谓变量就是在程序中为了方便地引用内存中的值而为它取的名称。在 Python 中，我们用 = 来给一个变量赋值。</p></blockquote><h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><p>Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</p><pre><code>&gt;&gt;&gt; a = 123  # a是整数&gt;&gt;&gt; id(a)1647579408&gt;&gt;&gt; a = &apos;ABC&apos; # a变为字符串&gt;&gt;&gt; id(a)10190496</code></pre><p><strong><em>Python 中的变量有一个非常重要的性质:它仅仅是一个名字。赋值操作并不会实际 复制值，它只是为数据对象取个相关的名字。名字是对对象的引用而不是对象本身。你可以把名字想象成贴在盒子上的标签</em></strong></p><a id="more"></a><h3 id="变量在内存中表示"><a href="#变量在内存中表示" class="headerlink" title="变量在内存中表示"></a>变量在内存中表示</h3><p>理解变量在计算机内存中的表示也非常重要。当我们写:</p><pre><code>a =  &apos;ABC&apos;</code></pre><p>Python解释器干了两件事情：</p><ul><li>在内存中创建了一个’ABC’的字符串；</li><li>在内存中创建了一个名为a的变量，并把它指向’ABC’。</li></ul><p>也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据，例如下面的代码：</p><pre><code>&gt;&gt;&gt; a =  &apos;ABC&apos;&gt;&gt;&gt; a = &apos;ABC&apos;&gt;&gt;&gt; b = a&gt;&gt;&gt; a = &apos;XYZ&apos;&gt;&gt;&gt; print(b)ABC</code></pre><p>上面的代码执行步骤如下:</p><ul><li>执行a = ‘ABC’，解释器创建了字符串’ABC’和变量a，并把a指向’ABC’</li><li>执行b = a，解释器创建了变量b，并把b指向a指向的字符串’ABC’</li><li>执行a = ‘XYZ’，解释器创建了字符串’XYZ’，并把a的指向改为’XYZ’，但b并没有更改,所以，最后打印变量b的结果自然是’ABC’了</li></ul><h3 id="变量的命名"><a href="#变量的命名" class="headerlink" title="变量的命名"></a>变量的命名</h3><p>在Python中使用变量时，需要遵守一些规则和指南。违反这些规则将引发错误，而指南旨在 让你编写的代码更容易阅读和理解， 请务必牢记下述有关变量的规则。</p><ul><li>变量名只能包含字母、数字和下划线。变量名可以字母或下划线打头，但不能以数字打 头，例如，可将变量命名为message_1，不能命名为1_message</li><li>变量名不能包含空格，但可使用下划线来分隔其中的单词。例如，变量名greeting_message 可行，但变量名greeting message会引发错误。</li><li>不要将Python关键字和函数名用作变量名，即不要使用Python保留用于特殊用途的单词。</li></ul><h4 id="Python-关键字"><a href="#Python-关键字" class="headerlink" title="Python 关键字"></a>Python 关键字</h4><p>下面的关键字都有特殊含义，如果你将它们用作变量名，将引发错误:<br><img src="https://s1.ax1x.com/2018/02/18/9tDAZn.md.png" alt="Python关键字"></p><h4 id="Python-内置函数"><a href="#Python-内置函数" class="headerlink" title="Python 内置函数"></a>Python 内置函数</h4><p>将内置函数名用作变量名时，不会导致错误，但将覆盖这些函数的行为:<br><img src="https://s1.ax1x.com/2018/02/18/9tDEaq.md.png" alt="Python内置函数"></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><blockquote><p>你所编写的大多数语句(逻辑行)都包含了表达式(Expressions)。一个表达式的简单例子<br>便是 2+3 。表达式可以拆分成运算符（ Operators） 与操作数（ Operands),运算符（ Operators） 是进行某些操作，并且可以用诸如 + 等符号或特殊关键词加以表达的<br>功能。运算符需要一些数据来进行操作，这些数据就被称作操作数（ Operands)。</p></blockquote><p>Python语言支持以下类型的运算符:</p><ul><li>算术运算符</li><li>比较（关系）运算符</li><li>赋值运算符</li><li>逻辑运算符</li><li>位运算符</li><li>成员运算符</li><li>身份运算符</li><li>运算符优先级</li></ul><h3 id="Python算术运算符"><a href="#Python算术运算符" class="headerlink" title="Python算术运算符"></a>Python算术运算符</h3><p><img src="https://s1.ax1x.com/2018/02/18/9tDtJK.png" alt="Python算术运算符"></p><h3 id="Python比较运算符"><a href="#Python比较运算符" class="headerlink" title="Python比较运算符"></a>Python比较运算符</h3><p><img src="https://s1.ax1x.com/2018/02/18/9tDsot.png" alt="Python比较运算符"></p><h3 id="Python赋值运算符"><a href="#Python赋值运算符" class="headerlink" title="Python赋值运算符"></a>Python赋值运算符</h3><p><img src="https://s1.ax1x.com/2018/02/18/9tDRSS.png" alt="Python赋值运算符"></p><h3 id="Python位运算符"><a href="#Python位运算符" class="headerlink" title="Python位运算符"></a>Python位运算符</h3><blockquote><p>按位运算符是把数字看作二进制来进行计算的。</p></blockquote><p><img src="https://s1.ax1x.com/2018/02/18/9tDIwn.png" alt="Python位运算符"></p><h3 id="Python逻辑运算符"><a href="#Python逻辑运算符" class="headerlink" title="Python逻辑运算符"></a>Python逻辑运算符</h3><p><img src="https://s1.ax1x.com/2018/02/18/9tDHYV.png" alt="Python逻辑运算符"></p><h3 id="Python成员运算符"><a href="#Python成员运算符" class="headerlink" title="Python成员运算符"></a>Python成员运算符</h3><blockquote><p>除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。</p></blockquote><p><img src="https://s1.ax1x.com/2018/02/18/9tDLSU.png" alt="Python成员运算符"></p><h3 id="Python身份运算符"><a href="#Python身份运算符" class="headerlink" title="Python身份运算符"></a>Python身份运算符</h3><blockquote><p>身份运算符用于比较两个对象的存储单元。</p></blockquote><p><img src="https://s1.ax1x.com/2018/02/18/9tDXy4.md.png" alt="Python身份运算符"></p><p><strong>is 与 == 区别：</strong></p><p>is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。</p><pre><code>&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; b = a&gt;&gt;&gt; b is aTrue&gt;&gt;&gt; b == aTrue&gt;&gt;&gt; b = a[:]&gt;&gt;&gt; b is aFalse&gt;&gt;&gt; b == aTrue</code></pre><h3 id="Python运算符优先级"><a href="#Python运算符优先级" class="headerlink" title="Python运算符优先级"></a>Python运算符优先级</h3><p>以下表格列出了从最高到最低优先级的所有运算符:</p><p><img src="https://s1.ax1x.com/2018/02/18/9trklD.png" alt="运算符优先级"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。所谓变量就是在程序中为了方便地引用内存中的值而为它取的名称。在 Python 中，我们用 = 来给一个变量赋值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;变量赋值&quot;&gt;&lt;a href=&quot;#变量赋值&quot; class=&quot;headerlink&quot; title=&quot;变量赋值&quot;&gt;&lt;/a&gt;变量赋值&lt;/h3&gt;&lt;p&gt;Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = 123  # a是整数
&amp;gt;&amp;gt;&amp;gt; id(a)
1647579408
&amp;gt;&amp;gt;&amp;gt; a = &amp;apos;ABC&amp;apos; # a变为字符串
&amp;gt;&amp;gt;&amp;gt; id(a)
10190496
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Python 中的变量有一个非常重要的性质:它仅仅是一个名字。赋值操作并不会实际 复制值，它只是为数据对象取个相关的名字。名字是对对象的引用而不是对象本身。你可以把名字想象成贴在盒子上的标签&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python基础知识" scheme="http://www.chenfanlinux.org/categories/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Python" scheme="http://www.chenfanlinux.org/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Pytho基础之内置数据类型(二)</title>
    <link href="http://www.chenfanlinux.org/2018/02/14/Pytho%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%BA%8C/"/>
    <id>http://www.chenfanlinux.org/2018/02/14/Pytho基础之内置数据类型-二/</id>
    <published>2018-02-14T04:17:34.000Z</published>
    <updated>2018-02-14T04:25:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><blockquote><p>列表由一系列按特定顺序排列的元素组成，可以将任何东西加入列表中，其中的元素之间可以没有任何关系。列表非常适合利用顺序和位置定位某一元素，尤其是当元素的顺序或内容经常发生改变时。与字符串不同，列表是可变的。你可以直接对原始列表进行修改:添加新元素、删除 或覆盖已有元素。在列表中，具有相同值的元素允许出现多次。</p></blockquote><h3 id="常用列表方法"><a href="#常用列表方法" class="headerlink" title="常用列表方法"></a>常用列表方法</h3><pre><code>&gt;&gt;&gt; dir(list)[&apos;__add__&apos;, &apos;__class__&apos;, &apos;__contains__&apos;,&apos;__delattr__&apos;, &apos;__delitem__&apos;, &apos;__dir__&apos;,&apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;,&apos;__getattribute__&apos;, &apos;__getitem__&apos;, &apos;__gt__&apos;,&apos;__hash__&apos;, &apos;__iadd__&apos;, &apos;__imul__&apos;,&apos;__init__&apos;, &apos;__iter__&apos;, &apos;__le__&apos;, &apos;__len__&apos;, &apos;__lt__&apos;, &apos;__mul__&apos;,&apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__reversed__&apos;, &apos;__rmul__&apos;, &apos;__setattr__&apos;, &apos;__setitem__&apos;,&apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;append&apos;, &apos;clear&apos;, &apos;copy&apos;, &apos;count&apos;, &apos;extend&apos;, &apos;index&apos;, &apos;insert&apos;, &apos;pop&apos;, &apos;remove&apos;, &apos;reverse&apos;, &apos;sort&apos;]</code></pre><h3 id="列表切片"><a href="#列表切片" class="headerlink" title="列表切片"></a>列表切片</h3><p><strong>定义列表后，可从其中获取任何部分作为新列表。该技术称为对列表进行切片，对于有序序列，包括字符串，元组都可以切片。</strong></p><pre><code>&gt;&gt;&gt; lists = [&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;, &apos;Bob&apos;, &apos;Jack&apos;]&gt;&gt;&gt; lists[0]&apos;Michael&apos;&gt;&gt;&gt; lists[1:3] # 切片实际是索引尾部取开区间 [1:3)[&apos;Sarah&apos;, &apos;Tracy&apos;]&gt;&gt;&gt; lists[:3]  # 相当于索引lists[0:3][&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;]&gt;&gt;&gt; lists[0:3][&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;]&gt;&gt;&gt; lists[-2:] # 取列表最后两个元素[&apos;Bob&apos;, &apos;Jack&apos;]</code></pre><h3 id="append-向列表尾部追加一个元素"><a href="#append-向列表尾部追加一个元素" class="headerlink" title="append 向列表尾部追加一个元素"></a>append 向列表尾部追加一个元素</h3><pre><code>&gt;&gt;&gt; lists[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;, &apos;Bob&apos;, &apos;Jack&apos;]&gt;&gt;&gt; lists.append(&apos;chenfan&apos;)&gt;&gt;&gt; lists[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;, &apos;Bob&apos;, &apos;Jack&apos;, &apos;chenfan&apos;]</code></pre><h3 id="clear-清除列表中的所有元素"><a href="#clear-清除列表中的所有元素" class="headerlink" title="clear 清除列表中的所有元素"></a>clear 清除列表中的所有元素</h3><pre><code>&gt;&gt;&gt; num = [1,2,3,4,5]&gt;&gt;&gt; num.clear()&gt;&gt;&gt; num[]</code></pre><a id="more"></a><h3 id="copy-复制一个列表"><a href="#copy-复制一个列表" class="headerlink" title="copy 复制一个列表"></a>copy 复制一个列表</h3><pre><code>&gt;&gt;&gt; lists[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;, &apos;Bob&apos;, &apos;Jack&apos;, &apos;chenfan&apos;]&gt;&gt;&gt; the_list = lists.copy()&gt;&gt;&gt; the_list[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;, &apos;Bob&apos;, &apos;Jack&apos;, &apos;chenfan&apos;]</code></pre><h3 id="count-计算某个元素在列表中出现的次数"><a href="#count-计算某个元素在列表中出现的次数" class="headerlink" title="count 计算某个元素在列表中出现的次数"></a>count 计算某个元素在列表中出现的次数</h3><pre><code>&gt;&gt;&gt; numbers = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]&gt;&gt;&gt; numbers.count(4)4&gt;&gt;&gt; numbers.count(2)2</code></pre><h3 id="extend-向列表末尾一次性追加另一个列表"><a href="#extend-向列表末尾一次性追加另一个列表" class="headerlink" title="extend 向列表末尾一次性追加另一个列表"></a>extend 向列表末尾一次性追加另一个列表</h3><pre><code>&gt;&gt;&gt; numbers[1, 2, 2, 3, 3, 3, 4, 4, 4, 4]&gt;&gt;&gt; a = [5, 5, 5, 5, 5]&gt;&gt;&gt; numbers.extend(a)&gt;&gt;&gt; numbers[1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]</code></pre><h3 id="index-从列表中找出某个值第一个匹配的索引位置"><a href="#index-从列表中找出某个值第一个匹配的索引位置" class="headerlink" title="index 从列表中找出某个值第一个匹配的索引位置"></a>index 从列表中找出某个值第一个匹配的索引位置</h3><pre><code>&gt;&gt;&gt; numbers[1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]&gt;&gt;&gt; numbers.index(5)10&gt;&gt;&gt; numbers.index(2)1</code></pre><h3 id="insert-将对象插入列表某个索引位置"><a href="#insert-将对象插入列表某个索引位置" class="headerlink" title="insert 将对象插入列表某个索引位置"></a>insert 将对象插入列表某个索引位置</h3><pre><code>&gt;&gt;&gt; numbers.insert(0,0)&gt;&gt;&gt; numbers[0, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5</code></pre><h3 id="pop-移除列表中的最后一个元素"><a href="#pop-移除列表中的最后一个元素" class="headerlink" title="pop 移除列表中的最后一个元素"></a>pop 移除列表中的最后一个元素</h3><pre><code>&gt;&gt;&gt; numbers[0, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]&gt;&gt;&gt; numbers.pop()5&gt;&gt;&gt; numbers[0, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5]</code></pre><h3 id="remove-移除列表中第一个匹配的元素"><a href="#remove-移除列表中第一个匹配的元素" class="headerlink" title="remove 移除列表中第一个匹配的元素"></a>remove 移除列表中第一个匹配的元素</h3><pre><code>&gt;&gt;&gt; num = [1, 2, 1, 3, 2]&gt;&gt;&gt; num.remove(1)&gt;&gt;&gt; num[2, 1, 3, 2]&gt;&gt;&gt; num.remove(2)&gt;&gt;&gt; num[1, 3, 2]</code></pre><h3 id="reverse-将列表中的元素反向存放"><a href="#reverse-将列表中的元素反向存放" class="headerlink" title="reverse 将列表中的元素反向存放"></a>reverse 将列表中的元素反向存放</h3><pre><code>&gt;&gt;&gt; numbers[0, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5]&gt;&gt;&gt; numbers.reverse()&gt;&gt;&gt; numbers[5, 5, 5, 5, 4, 4, 4, 4, 3, 3, 3, 2, 2, 1, 0]</code></pre><h3 id="sort-对列表排序"><a href="#sort-对列表排序" class="headerlink" title="sort 对列表排序"></a>sort 对列表排序</h3><h4 id="默认排序（升序）"><a href="#默认排序（升序）" class="headerlink" title="默认排序（升序）"></a>默认排序（升序）</h4><pre><code>&gt;&gt;&gt; L = [1,4,3,2]&gt;&gt;&gt; L.sort()&gt;&gt;&gt; L[1, 2, 3, 4]</code></pre><h4 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h4><p><strong>看sort的使用方法</strong></p><pre><code>&gt;&gt;&gt; L.sort.__doc__&apos;L.sort(key=None, reverse=False) -&gt; None -- stable sort *IN PLACE*&apos;</code></pre><p><strong>根据提供的key函数为元素产生一个键，列表的元素按照这个键值来排序</strong></p><pre><code>&gt;&gt;&gt; x = [&apos;abc&apos;,&apos;a&apos;,&apos;bc&apos;,&apos;abcd&apos;]&gt;&gt;&gt; x.sort(key=len)&gt;&gt;&gt; x[&apos;a&apos;, &apos;bc&apos;, &apos;abc&apos;, &apos;abcd&apos;]</code></pre><p><strong>反向排序</strong></p><pre><code>&gt;&gt;&gt; n = [3, 1, 2, 5]&gt;&gt;&gt; n.sort(reverse=True)&gt;&gt;&gt; n[5, 3, 2, 1]</code></pre><h3 id="使用-in-判断值是否存在"><a href="#使用-in-判断值是否存在" class="headerlink" title="使用 in 判断值是否存在"></a>使用 in 判断值是否存在</h3><pre><code>&gt;&gt;&gt; num = [1, 2, 3]&gt;&gt;&gt; 1 in numTrue&gt;&gt;&gt; 4 in numFalse</code></pre><h3 id="使用-len-获取长度"><a href="#使用-len-获取长度" class="headerlink" title="使用 len() 获取长度"></a>使用 len() 获取长度</h3><pre><code>&gt;&gt;&gt; num[1, 2, 3]&gt;&gt;&gt; len(num)3</code></pre><h3 id="使用-赋值，使用copy-复制"><a href="#使用-赋值，使用copy-复制" class="headerlink" title="使用=赋值，使用copy()复制"></a>使用=赋值，使用copy()复制</h3><p><strong>如果将一个列表赋值给了多个变量，改变其中的任何一处造成其他变量对应的值也被修改</strong></p><pre><code>&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; a[1, 2, 3]&gt;&gt;&gt; b = a&gt;&gt;&gt; a[0] = &apos;surpise&apos;&gt;&gt;&gt; a[&apos;surpise&apos;, 2, 3]&gt;&gt;&gt; b[&apos;surpise&apos;, 2, 3]</code></pre><p>b与a实际上指向的是同一个对象，因此，无论我们是通过a还是b来修改列表的内容，其结果都会作用于双方。</p><pre><code>&gt;&gt;&gt; b[&apos;surpise&apos;, 2, 3]&gt;&gt;&gt; b[0] = &apos;I love surprises&apos;&gt;&gt;&gt; b[&apos;I love surprises&apos;, 2, 3]&gt;&gt;&gt; a[&apos;I love surprises&apos;, 2, 3]&gt;&gt;&gt;</code></pre><p><strong>通过下面任意一种方法，都可以将一个列表的值复制到另一个新的列表中</strong></p><pre><code>&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; b = a.copy()&gt;&gt;&gt; c = list(a)&gt;&gt;&gt; d = a[:]&gt;&gt;&gt; a[0] = &apos;one&apos;&gt;&gt;&gt; b[1, 2, 3]&gt;&gt;&gt; c[1, 2, 3]&gt;&gt;&gt; d[1, 2, 3]</code></pre><ul><li>列表 copy() 函数</li><li>list() 转换函数</li><li>列表分片 [:]</li></ul><p>b、c、d 都是a的复制：它们是自身带有值的新对象，与原始的a所指向的列表对象[1, 2, 3]没有任何关联。所以改变a不影响b、c、d的复制。</p><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><blockquote><p>与列表类似，元组也是由任意类型元素组成的有序序列。与列表不同的是，元组是不可改变的，这意味着一但元组被定义，将无法再进行增加、删除或者修改元素等操作。因此元组就像一个常量列表。元组的只读性使其拥有更好的内存效率和性能。除无法修改外，其普通特征和列表类似。 在需要传递 “不可变” 参数时，应鼓励用元组替代列表。</p></blockquote><h3 id="使用-创建元组"><a href="#使用-创建元组" class="headerlink" title="使用()创建元组"></a>使用()创建元组</h3><p>可以用()创建一个空元组：</p><pre><code>&gt;&gt;&gt; empty_tuple = () # 创建空元组&gt;&gt;&gt; empty_tuple()&gt;&gt;&gt; type(empty_tuple)&lt;class &apos;tuple&apos;&gt;</code></pre><p>创建包含一个或多个元素的元组时，每一个元素后面需要跟着一个逗号：</p><pre><code>&gt;&gt;&gt; num = (1)&gt;&gt;&gt; type(num)&lt;class &apos;int&apos;&gt;&gt;&gt;&gt; num = (1,)&gt;&gt;&gt; type(num)&lt;class &apos;tuple&apos;&gt;</code></pre><p>创建多个元素的元组，可以用括号将所有元素包裹起来，这会使得程序更加清晰：</p><pre><code>&gt;&gt;&gt; num = 1,2,3&gt;&gt;&gt; num1 = (1,2,3)&gt;&gt;&gt; num(1, 2, 3)&gt;&gt;&gt; num1(1, 2, 3)</code></pre><h3 id="元组解包"><a href="#元组解包" class="headerlink" title="元组解包"></a>元组解包</h3><p><strong>可以一口气将元组赋值给多个变量</strong></p><pre><code>&gt;&gt;&gt; num(1, 2, 3)&gt;&gt;&gt; a, b, c = num&gt;&gt;&gt; a1&gt;&gt;&gt; b2&gt;&gt;&gt; c3</code></pre><p><strong>可以利用元组在一条语句中对多个变量的值进行交换，而不需借助临时变量</strong></p><pre><code>&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = 2&gt;&gt;&gt; a, b = b, a&gt;&gt;&gt; a2&gt;&gt;&gt; b1</code></pre><h3 id="元组与列表对比"><a href="#元组与列表对比" class="headerlink" title="元组与列表对比"></a>元组与列表对比</h3><p>在许多地方都可以用元组代替列表，但元组的方法函数与类表相比要少一些，元组没有append()、insert()等等。因为一但创建元组变无法修改，既然列表更加灵活那为什么不在所有地方都是用列表呢？原因如下：</p><ul><li>元组占用的空间小</li><li>你不会意外修改元组的值</li><li>可以将元组用作字典的键（详细的后面会介绍）</li><li>命名元组可以作为对象的代替</li><li>函数的参数是以元组形式是传递的</li></ul><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><blockquote><p>字典 是键值对的无序集合。向字典添加一个键的同时，必须为该键增添一个值。（之后可随时修改该值。） Python 的字典为通过键获取值进行了优化，而不是反过来。比如字典的键必须为不可变对象，因此列表、字典和集合都不能作为字典的键，但元组可以作为字典的键。</p></blockquote><h3 id="使用-创建字典"><a href="#使用-创建字典" class="headerlink" title="使用 {} 创建字典"></a>使用 {} 创建字典</h3><pre><code>&gt;&gt;&gt; empty_dict = {}&gt;&gt;&gt; empty_dict{}&gt;&gt;&gt; type(empty_dict)&lt;class &apos;dict&apos;&gt;</code></pre><h3 id="字典的键也不允许重复"><a href="#字典的键也不允许重复" class="headerlink" title="字典的键也不允许重复"></a>字典的键也不允许重复</h3><pre><code>&gt;&gt;&gt; c = {&quot;1&quot;:2, &quot;1&quot;:3, &quot;1&quot;:4}&gt;&gt;&gt; c{&apos;1&apos;: 4}</code></pre><h3 id="使用-dict-转换为字典"><a href="#使用-dict-转换为字典" class="headerlink" title="使用 dict() 转换为字典"></a>使用 dict() 转换为字典</h3><p><strong>记住，字典是无序的，字典中元素的顺序是无关紧要的，实际存储顺序可能取决于你添加元素的顺序。</strong></p><p>双值子序列的序列转换成字典：</p><pre><code>&gt;&gt;&gt; type(empty_dict)&lt;class &apos;dict&apos;&gt;&gt;&gt;&gt; lol = [ [&apos;a&apos;, &apos;b&apos;], [&apos;c&apos;, &apos;d&apos;], [&apos;e&apos;, &apos;f&apos;] ]&gt;&gt;&gt; dict(lol){&apos;c&apos;: &apos;d&apos;, &apos;a&apos;: &apos;b&apos;, &apos;e&apos;: &apos;f&apos;}</code></pre><p>双值元组列表：</p><pre><code>&gt;&gt;&gt; lot = [ (&apos;a&apos;, &apos;b&apos;), (&apos;c&apos;, &apos;d&apos;), (&apos;e&apos;, &apos;f&apos;) ]&gt;&gt;&gt; dict(lot){&apos;c&apos;: &apos;d&apos;, &apos;a&apos;: &apos;b&apos;, &apos;e&apos;: &apos;f&apos;}</code></pre><p>双字符串的字符串组成的列表：</p><pre><code>&gt;&gt;&gt; los = [ &apos;ab&apos;, &apos;cd&apos;, &apos;ef&apos; ]&gt;&gt;&gt; dict(los){&apos;c&apos;: &apos;d&apos;, &apos;a&apos;: &apos;b&apos;, &apos;e&apos;: &apos;f&apos;}</code></pre><p>双字符的字符串组成的元组：</p><pre><code>&gt;&gt;&gt; tos = ( &apos;ab&apos;, &apos;cd&apos;, &apos;ef&apos;)&gt;&gt;&gt; dict(tos){&apos;c&apos;: &apos;d&apos;, &apos;a&apos;: &apos;b&apos;, &apos;e&apos;: &apos;f&apos;}</code></pre><h3 id="使用-key-添加或修改元素"><a href="#使用-key-添加或修改元素" class="headerlink" title="使用 [key] 添加或修改元素"></a>使用 [key] 添加或修改元素</h3><pre><code>&gt;&gt;&gt; d = {&quot;11&quot;:1, &quot;12&quot;:2, &quot;13&quot;:3}&gt;&gt;&gt; d[&quot;14&quot;] = 4&gt;&gt;&gt; d{&apos;13&apos;: 3, &apos;14&apos;: 4, &apos;11&apos;: 1, &apos;12&apos;: 2}</code></pre><h3 id="使用-update-合并字典"><a href="#使用-update-合并字典" class="headerlink" title="使用 update() 合并字典"></a>使用 update() 合并字典</h3><pre><code>&gt;&gt;&gt; d = {&quot;l1&quot;:1, &quot;l2&quot;:2, &quot;l3&quot;:3}&gt;&gt;&gt; e = {&quot;14&quot;:4, &quot;15&quot;:5}&gt;&gt;&gt; d.update(e)&gt;&gt;&gt; d{&apos;14&apos;: 4, &apos;l1&apos;: 1, &apos;l2&apos;: 2, &apos;l3&apos;: 3, &apos;15&apos;: 5}</code></pre><h3 id="使用-del-删除具有指定键的元素"><a href="#使用-del-删除具有指定键的元素" class="headerlink" title="使用 del 删除具有指定键的元素"></a>使用 del 删除具有指定键的元素</h3><pre><code>&gt;&gt;&gt; d{&apos;14&apos;: 4, &apos;l1&apos;: 1, &apos;l2&apos;: 2, &apos;l3&apos;: 3, &apos;15&apos;: 5}&gt;&gt;&gt; del d[&quot;14&quot;]&gt;&gt;&gt; d{&apos;l1&apos;: 1, &apos;l2&apos;: 2, &apos;l3&apos;: 3, &apos;15&apos;: 5}</code></pre><h3 id="使用-clear-删除所有元素"><a href="#使用-clear-删除所有元素" class="headerlink" title="使用 clear() 删除所有元素"></a>使用 clear() 删除所有元素</h3><pre><code>&gt;&gt;&gt; d{&apos;l1&apos;: 1, &apos;l2&apos;: 2, &apos;l3&apos;: 3, &apos;15&apos;: 5}&gt;&gt;&gt; d{&apos;l1&apos;: 1, &apos;l2&apos;: 2, &apos;l3&apos;: 3, &apos;15&apos;: 5}&gt;&gt;&gt; d.clear()&gt;&gt;&gt; d{}</code></pre><h3 id="使用-in-判断是否存在"><a href="#使用-in-判断是否存在" class="headerlink" title="使用 in 判断是否存在"></a>使用 in 判断是否存在</h3><p>如果你希望判断某一个键是否存在于一个字典中，可以使用 in。</p><pre><code>&gt;&gt;&gt; d = {&quot;l1&quot;:1, &quot;l2&quot;:2, &quot;l3&quot;:3}&gt;&gt;&gt; d{&apos;l1&apos;: 1, &apos;l3&apos;: 3, &apos;l2&apos;: 2}&gt;&gt;&gt; 1 in dFalse&gt;&gt;&gt; &quot;l1&quot; in dTrue&gt;&gt;&gt; &quot;l4&quot; in dFalse</code></pre><h3 id="使用-keys-获取元素"><a href="#使用-keys-获取元素" class="headerlink" title="使用 keys() 获取元素"></a>使用 keys() 获取元素</h3><pre><code>&gt;&gt;&gt; d = {&quot;l1&quot;:1, &quot;l2&quot;:2, &quot;l3&quot;:3}&gt;&gt;&gt; d.keys()dict_keys([&apos;l1&apos;, &apos;l3&apos;, &apos;l2&apos;])</code></pre><h3 id="使用-values-获取所有值"><a href="#使用-values-获取所有值" class="headerlink" title="使用 values() 获取所有值"></a>使用 values() 获取所有值</h3><pre><code>&gt;&gt;&gt; d.values()dict_values([1, 3, 2])</code></pre><h3 id="使用-赋值，使用copy-复制-1"><a href="#使用-赋值，使用copy-复制-1" class="headerlink" title="使用=赋值，使用copy()复制"></a>使用=赋值，使用copy()复制</h3><p>与列表一样，对字典内容进行修改会反应到所有与之相关联的变量名上：</p><pre><code>&gt;&gt;&gt; d = {&quot;l1&quot;:1, &quot;l2&quot;:2, &quot;l3&quot;:3}&gt;&gt;&gt; d2 = d&gt;&gt;&gt; d.update({&quot;14&quot;:4})&gt;&gt;&gt; d{&apos;l1&apos;: 1, &apos;l3&apos;: 3, &apos;14&apos;: 4, &apos;l2&apos;: 2}&gt;&gt;&gt; d2{&apos;l1&apos;: 1, &apos;l3&apos;: 3, &apos;14&apos;: 4, &apos;l2&apos;: 2}</code></pre><p>若想避免这种情况，可以使用 copy() 将字典复制到一个新的字典中：</p><pre><code>&gt;&gt;&gt; d = {&quot;l1&quot;:1, &quot;l2&quot;:2, &quot;l3&quot;:3}&gt;&gt;&gt; d2 = d.copy()&gt;&gt;&gt; d2.update({&quot;14&quot;:5})&gt;&gt;&gt; d{&apos;l3&apos;: 3, &apos;l2&apos;: 2, &apos;l1&apos;: 1}&gt;&gt;&gt; d2{&apos;14&apos;: 5, &apos;l3&apos;: 3, &apos;l1&apos;: 1, &apos;l2&apos;: 2}</code></pre><h3 id="两个列表转换为字典"><a href="#两个列表转换为字典" class="headerlink" title="两个列表转换为字典"></a>两个列表转换为字典</h3><pre><code>&gt;&gt;&gt; l1 = [1,2,3]&gt;&gt;&gt; l2 = [&quot;one&quot;, &quot;two&quot;, &quot;there&quot;]&gt;&gt;&gt; zip(l1,l2)&lt;zip object at 0x0000000003569E08&gt;&gt;&gt;&gt; dict(zip(l1,l2)){1: &apos;one&apos;, 2: &apos;two&apos;, 3: &apos;there&apos;}</code></pre><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><blockquote><p>集合就像舍弃了值，仅剩下键的字典一样。键与键之间也不允许重复。如果你仅仅想知道某一个元素是否存在而不关心其他的，使用集合是个非常好的选择。如果需要为键附加其他信息的话建议使用字典。</p></blockquote><h3 id="使用-set-创建集合"><a href="#使用-set-创建集合" class="headerlink" title="使用 set() 创建集合"></a>使用 set() 创建集合</h3><pre><code>&gt;&gt;&gt; empty_set = set()&gt;&gt;&gt; empty_setset()&gt;&gt;&gt; type(empty_set)&lt;class &apos;set&apos;&gt;</code></pre><blockquote><p>与字典一样，集合是无序的。{} 创建的是一个空字典，这仅仅是因为字典出现的比较早抢占了花括号；因此创建空的集合，使用set()。</p></blockquote><h3 id="使用set-将其他类型转换为集合"><a href="#使用set-将其他类型转换为集合" class="headerlink" title="使用set()将其他类型转换为集合"></a>使用set()将其他类型转换为集合</h3><p><strong>你可以利用已有的列表、字符串、元组或字典的内容来创建集合，其中重复的值会被丢弃。</strong></p><pre><code>&gt;&gt;&gt; set(&apos;letters&apos;){&apos;t&apos;, &apos;s&apos;, &apos;l&apos;, &apos;e&apos;, &apos;r&apos;}</code></pre><p>再试试用列表建立集合：</p><pre><code>&gt;&gt;&gt; set([&apos;one&apos;, &apos;two&apos;, &apos;three&apos;]){&apos;one&apos;, &apos;three&apos;, &apos;two&apos;}</code></pre><p>再看下元组：</p><pre><code>&gt;&gt;&gt; set((&apos;one&apos;, &apos;two&apos;, &apos;three&apos;)){&apos;one&apos;, &apos;three&apos;, &apos;two&apos;}</code></pre><p>当字典作为参数传入set()函数时，只有键会被使用：</p><pre><code>&gt;&gt;&gt; set( {&apos;apple&apos;: &apos;red&apos;, &apos;orange&apos;: &apos;orange&apos;, &apos;cherry&apos;: &apos;red&apos;} ){&apos;apple&apos;, &apos;orange&apos;, &apos;cherry&apos;}</code></pre><h3 id="使用in测试值是否存在"><a href="#使用in测试值是否存在" class="headerlink" title="使用in测试值是否存在"></a>使用in测试值是否存在</h3><pre><code>&gt;&gt;&gt; num_set = {&apos;one&apos;, &apos;two&apos;, &apos;three&apos;}&gt;&gt;&gt; &quot;one&quot; in num_setTrue&gt;&gt;&gt; &quot;four&quot; in num_setFalse</code></pre><h3 id="添加删除数据"><a href="#添加删除数据" class="headerlink" title="添加删除数据"></a>添加删除数据</h3><pre><code>&gt;&gt;&gt; num_set = {&apos;one&apos;, &apos;two&apos;, &apos;three&apos;}&gt;&gt;&gt; num_set.add(&quot;four&quot;) # 增加数据&gt;&gt;&gt; num_set{&apos;four&apos;, &apos;one&apos;, &apos;three&apos;, &apos;two&apos;}&gt;&gt;&gt; num_set{&apos;four&apos;, &apos;one&apos;, &apos;three&apos;, &apos;two&apos;}&gt;&gt;&gt; num_set.remove(&quot;three&quot;) # 删除数据&gt;&gt;&gt; num_set{&apos;four&apos;, &apos;one&apos;, &apos;two&apos;}</code></pre><h3 id="交集和并集"><a href="#交集和并集" class="headerlink" title="交集和并集"></a>交集和并集</h3><pre><code>&gt;&gt;&gt; s1 = set([1, 2, 3])&gt;&gt;&gt; s2 = set([2, 3, 4])&gt;&gt;&gt; s1 &amp; s2{2, 3}&gt;&gt;&gt; s1 | s2{1, 2, 3, 4}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;列表&quot;&gt;&lt;a href=&quot;#列表&quot; class=&quot;headerlink&quot; title=&quot;列表&quot;&gt;&lt;/a&gt;列表&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;列表由一系列按特定顺序排列的元素组成，可以将任何东西加入列表中，其中的元素之间可以没有任何关系。列表非常适合利用顺序和位置定位某一元素，尤其是当元素的顺序或内容经常发生改变时。与字符串不同，列表是可变的。你可以直接对原始列表进行修改:添加新元素、删除 或覆盖已有元素。在列表中，具有相同值的元素允许出现多次。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;常用列表方法&quot;&gt;&lt;a href=&quot;#常用列表方法&quot; class=&quot;headerlink&quot; title=&quot;常用列表方法&quot;&gt;&lt;/a&gt;常用列表方法&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; dir(list)
[&amp;apos;__add__&amp;apos;, &amp;apos;__class__&amp;apos;, &amp;apos;__contains__&amp;apos;,
&amp;apos;__delattr__&amp;apos;, &amp;apos;__delitem__&amp;apos;, &amp;apos;__dir__&amp;apos;,
&amp;apos;__doc__&amp;apos;, &amp;apos;__eq__&amp;apos;, &amp;apos;__format__&amp;apos;, &amp;apos;__ge__&amp;apos;,
&amp;apos;__getattribute__&amp;apos;, &amp;apos;__getitem__&amp;apos;, &amp;apos;__gt__&amp;apos;,
&amp;apos;__hash__&amp;apos;, &amp;apos;__iadd__&amp;apos;, &amp;apos;__imul__&amp;apos;,
&amp;apos;__init__&amp;apos;, &amp;apos;__iter__&amp;apos;, &amp;apos;__le__&amp;apos;,
 &amp;apos;__len__&amp;apos;, &amp;apos;__lt__&amp;apos;, &amp;apos;__mul__&amp;apos;,
&amp;apos;__ne__&amp;apos;, &amp;apos;__new__&amp;apos;, &amp;apos;__reduce__&amp;apos;,
 &amp;apos;__reduce_ex__&amp;apos;, &amp;apos;__repr__&amp;apos;, &amp;apos;__reversed__&amp;apos;
, &amp;apos;__rmul__&amp;apos;, &amp;apos;__setattr__&amp;apos;, &amp;apos;__setitem__&amp;apos;,
&amp;apos;__sizeof__&amp;apos;, &amp;apos;__str__&amp;apos;, &amp;apos;__subclasshook__&amp;apos;,
 &amp;apos;append&amp;apos;, &amp;apos;clear&amp;apos;, &amp;apos;copy&amp;apos;, &amp;apos;count&amp;apos;, &amp;apos;extend&amp;apos;, &amp;apos;index&amp;apos;, &amp;apos;insert&amp;apos;, &amp;apos;pop&amp;apos;, &amp;apos;remove&amp;apos;, &amp;apos;reverse&amp;apos;, &amp;apos;sort&amp;apos;]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;列表切片&quot;&gt;&lt;a href=&quot;#列表切片&quot; class=&quot;headerlink&quot; title=&quot;列表切片&quot;&gt;&lt;/a&gt;列表切片&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;定义列表后，可从其中获取任何部分作为新列表。该技术称为对列表进行切片，对于有序序列，包括字符串，元组都可以切片。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; lists = [&amp;apos;Michael&amp;apos;, &amp;apos;Sarah&amp;apos;, &amp;apos;Tracy&amp;apos;, &amp;apos;Bob&amp;apos;, &amp;apos;Jack&amp;apos;]
&amp;gt;&amp;gt;&amp;gt; lists[0]
&amp;apos;Michael&amp;apos;
&amp;gt;&amp;gt;&amp;gt; lists[1:3] # 切片实际是索引尾部取开区间 [1:3)
[&amp;apos;Sarah&amp;apos;, &amp;apos;Tracy&amp;apos;]
&amp;gt;&amp;gt;&amp;gt; lists[:3]  # 相当于索引lists[0:3]
[&amp;apos;Michael&amp;apos;, &amp;apos;Sarah&amp;apos;, &amp;apos;Tracy&amp;apos;]
&amp;gt;&amp;gt;&amp;gt; lists[0:3]
[&amp;apos;Michael&amp;apos;, &amp;apos;Sarah&amp;apos;, &amp;apos;Tracy&amp;apos;]
&amp;gt;&amp;gt;&amp;gt; lists[-2:] # 取列表最后两个元素
[&amp;apos;Bob&amp;apos;, &amp;apos;Jack&amp;apos;]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;append-向列表尾部追加一个元素&quot;&gt;&lt;a href=&quot;#append-向列表尾部追加一个元素&quot; class=&quot;headerlink&quot; title=&quot;append 向列表尾部追加一个元素&quot;&gt;&lt;/a&gt;append 向列表尾部追加一个元素&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; lists
[&amp;apos;Michael&amp;apos;, &amp;apos;Sarah&amp;apos;, &amp;apos;Tracy&amp;apos;, &amp;apos;Bob&amp;apos;, &amp;apos;Jack&amp;apos;]
&amp;gt;&amp;gt;&amp;gt; lists.append(&amp;apos;chenfan&amp;apos;)
&amp;gt;&amp;gt;&amp;gt; lists
[&amp;apos;Michael&amp;apos;, &amp;apos;Sarah&amp;apos;, &amp;apos;Tracy&amp;apos;, &amp;apos;Bob&amp;apos;, &amp;apos;Jack&amp;apos;, &amp;apos;chenfan&amp;apos;]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;clear-清除列表中的所有元素&quot;&gt;&lt;a href=&quot;#clear-清除列表中的所有元素&quot; class=&quot;headerlink&quot; title=&quot;clear 清除列表中的所有元素&quot;&gt;&lt;/a&gt;clear 清除列表中的所有元素&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; num = [1,2,3,4,5]
&amp;gt;&amp;gt;&amp;gt; num.clear()
&amp;gt;&amp;gt;&amp;gt; num
[]
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="python基础知识" scheme="http://www.chenfanlinux.org/categories/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Python" scheme="http://www.chenfanlinux.org/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python基础之内置数据类型(一)</title>
    <link href="http://www.chenfanlinux.org/2018/02/13/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%80/"/>
    <id>http://www.chenfanlinux.org/2018/02/13/Python基础之内置数据类型-一/</id>
    <published>2018-02-13T14:14:07.000Z</published>
    <updated>2018-02-14T04:20:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在 Python 中， 每个值都有一种数据类型，但您并不需要声明变量的数据类型。那该方式是如何运作的呢？Python 根据每个变量的初始赋值情况分析其类型，并在内部对其进行跟踪。</p></blockquote><h3 id="内置数据类型分类"><a href="#内置数据类型分类" class="headerlink" title="内置数据类型分类"></a>内置数据类型分类</h3><ul><li>Booleans［布尔型］ 或为 True［真］ 或为 False［假］</li><li>Numbers［数值型］ 可以是 Integers［整数］（1 和 2）、Floats［浮点数］（1.1 和 1.2）、Fractions［分数］（1/2 和 2/3）；甚至是 Complex Number［复数］</li><li>Strings［字符串型］ 是 Unicode 字符序列，例如： 一份 html 文档</li><li>Bytes［字节］ 和 Byte Arrays［字节数组］， 例如: 一份 jpeg 图像文件</li><li>Lists［列表］ 是值的有序序列</li><li>Tuples［元组］ 是有序而不可变的值序列</li><li>Sets［集合］ 是装满无序值的包裹</li><li>Dictionaries［字典］ 是键值对的无序包裹</li></ul><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><p><strong>布尔类型或为真或为假。Python 有两个被巧妙地命名为 True 和 False 的常量，可用于对布尔类型的直接赋值。表达式也可以计算为布尔类型的值。数字 0、None、以及元素为空的容器类对象都可视作 bool False，反之为 True。</strong></p><pre><code>&gt;&gt;&gt; bool(0)False&gt;&gt;&gt; bool(None)False&gt;&gt;&gt; bool([])False&gt;&gt;&gt; bool({})False&gt;&gt;&gt; bool(1)True&gt;&gt;&gt; bool([1,2])True</code></pre><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><p>python本身支持整数以及浮点数。你可以对这些数字进行下表中的计算。</p><p><img src="https://s1.ax1x.com/2018/02/13/9YZkc9.png" alt="数字类型"></p><a id="more"></a><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>任何仅含数字的序列在 Python 中都被认为是整数</p><pre><code>&gt;&gt;&gt; 55</code></pre><p>Python还支持运算次序，因此你可在同一个表达式中使用多种运算。你还可以使用括号来修 改运算次序，让Python按你指定的次序执行运算，如下所示:</p><pre><code>&gt;&gt;&gt; 2 + 3 * 414&gt;&gt;&gt; (2 + 3) * 420</code></pre><p>在这些示例中，空格不影响Python计算表达式的方式，它们的存在旨在让你阅读代码时，能迅速确定先执行哪些运算。</p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p><strong>Python将带小数点的数字都称为浮点数。大多数编程语言都使用了这个术语，它指出了这样一个事实:小数点可出现在数字的任何位置。</strong></p><pre><code>&gt;&gt;&gt; 0.1 + 0.10.2&gt;&gt;&gt; 2 * 0.10.2</code></pre><p>但需要注意的是，结果包含的小数位数可能是不确定的:</p><pre><code>&gt;&gt;&gt; 3 * 0.10.30000000000000004&gt;&gt;&gt; 0.2 + 0.10.30000000000000004&gt;&gt;&gt; 4 * 0.10.4</code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是由多个字符组成的序列。在Python中，用引号括起的都是字符串，字符串定义简单自由，可以是单引号、双引号或者三引号。字符串是不可变序列（immutable, sequence）类型，默认存储 Unicode 文本。</p><h3 id="字符串使用"><a href="#字符串使用" class="headerlink" title="字符串使用"></a>字符串使用</h3><pre><code>&gt;&gt;&gt; s = &quot;chenfanlinux博客&quot;&gt;&gt;&gt; len(s)14&gt;&gt;&gt; print(ascii(s))&apos;chenfanlinux\u535a\u5ba2&apos;</code></pre><p>内置函数 ascii 将目标转换为可打印 ASCII 字符组成的字符串。</p><p><strong>构建字符串很容易，单引号、双引号，以及跨行的三个引号。</strong></p><pre><code>&gt;&gt;&gt; &quot;ab&apos;c&quot;  #双引号&quot;ab&apos;c&quot;&gt;&gt;&gt; &apos;ab&quot;c&quot;&apos; #单引号&apos;ab&quot;c&quot;&gt;&gt;&gt; &quot;&quot;&quot; abc #多行efdhij&quot;&quot;&quot;&apos; abc\nefd\nhij\n&apos;&gt;&gt;&gt; &apos;ab\&apos;c&apos; #引号转义&quot;ab&apos;c&quot;</code></pre><p><strong>可在字面量前添加特殊指示符。</strong></p><pre><code>&gt;&gt;&gt; print(r&quot;abc\nd&quot;)  # raw string，禁用转义。abc\nd&gt;&gt;&gt; type(b&quot;ab&quot;)&lt;class &apos;bytes&apos;&gt;&gt;&gt;&gt; type(u&quot;ab&quot;)&lt;class &apos;str&apos;&gt;</code></pre><h3 id="str-类型转换"><a href="#str-类型转换" class="headerlink" title="str() 类型转换"></a>str() 类型转换</h3><pre><code>&gt;&gt;&gt; &quot;abc&quot; + str(2.2)&apos;abc2.2&apos;</code></pre><h3 id="合并字符串"><a href="#合并字符串" class="headerlink" title="合并字符串"></a>合并字符串</h3><h4 id="format格式化输出-推荐使用"><a href="#format格式化输出-推荐使用" class="headerlink" title="format格式化输出(推荐使用)"></a>format格式化输出(推荐使用)</h4><pre><code>&gt;&gt;&gt; &quot;谁的博客很酷: {}&quot;.format(&quot;陈凡&quot;)&apos;谁的博客很酷: 陈凡&apos;&gt;&gt;&gt; s =&quot;&quot;&quot;你的名字是: {};你的工资是多少: {};你是做什么工作的: {}&quot;&quot;&quot;.format(&quot;陈凡&quot;,&quot;不告诉你&quot;,&quot;运维&quot;)&gt;&gt;&gt; print(s)你的名字是: 陈凡;你的工资是多少: 不告诉你;你是做什么工作的: 运维&gt;&gt;&gt; &quot;你喜欢什么音乐:{0} 你的偶像是谁:{1}&quot;.format(&quot;戒指&quot;,&quot;你猜&quot;)&apos;你喜欢什么音乐:戒指 你的偶像是谁:你猜&apos;</code></pre><h4 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="% 字符串格式化"></a>% 字符串格式化</h4><pre><code>&gt;&gt;&gt; msg = &quot;my name is %s and weight is %d kg!&quot; %(&quot;chenfan&quot;,120)&gt;&gt;&gt; print(msg)my name is chenfan and weight is 120 kg!</code></pre><h4 id=""><a href="#" class="headerlink" title="+"></a>+</h4><pre><code>&gt;&gt;&gt; &quot;欢迎来到:&quot; + &quot;www.chenfanlinux.org&quot;&apos;欢迎来到:www.chenfanlinux.org&apos;</code></pre><h3 id="split-分割"><a href="#split-分割" class="headerlink" title="split() 分割"></a>split() 分割</h3><pre><code>&gt;&gt;&gt; (man,said) = &quot;chenfan : welcome to my bolg:www.chenfanlinu.org&quot;.split(&apos;:&apos;,1)&gt;&gt;&gt; print(man)chenfan&gt;&gt;&gt; print(said) welcome to my bolg:www.chenfanlinu.org</code></pre><h3 id="strip-移除头尾的字符串"><a href="#strip-移除头尾的字符串" class="headerlink" title="strip() 移除头尾的字符串"></a>strip() 移除头尾的字符串</h3><pre><code>&gt;&gt;&gt; &quot; www.chenfanlinux.org &quot;.strip()  # 注意只能移除头部和尾部字符串&apos;www.chenfanlinux.org&apos;&gt;&gt; &quot;www.chenfanlinux. org&quot;.strip() # 这种空格无法移除www.chenfanlinux. org&apos;&gt;&gt;&gt; &quot;www.chenfanlinux.org&quot;.strip(&quot;www.&quot;)&apos;chenfanlinux.org&apos;</code></pre><h3 id="join-合并列表"><a href="#join-合并列表" class="headerlink" title="join() 合并列表"></a>join() 合并列表</h3><pre><code>&gt;&gt;&gt; path = [&quot;/etc&quot;, &quot;nginx&quot;, &quot;nginx.conf&quot; ]&gt;&gt;&gt; &apos;/&apos;.join(path)&apos;/etc/nginx/nginx.conf&apos;</code></pre><h3 id="find-查找子串"><a href="#find-查找子串" class="headerlink" title="find 查找子串"></a>find 查找子串</h3><p><strong>查找到返回该子串在原字符串中的索引位置，如果无法找到，find方法会返回值-1</strong></p><pre><code>&gt;&gt;&gt; s = &quot;www.chenfanlinux.org&quot;&gt;&gt;&gt; s.find(&quot;chenfan&quot;)  #访问索引位置4&gt;&gt;&gt; s.find(&quot;chenfanfan&quot;) # 未找到返回-1-1</code></pre><h3 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h3><p><strong>存在索引的数据类型，包括字符串,列表和元组都可以做切片操作</strong></p><pre><code>&gt;&gt;&gt; s = &quot;www.chenfanlinux.org&quot;&gt;&gt;&gt; s[0]&apos;w&apos;&gt;&gt;&gt; s[0:5]&apos;www.c&apos;&gt;&gt;&gt; s[-1]&apos;g&apos;</code></pre><h3 id="字符串运算符总结"><a href="#字符串运算符总结" class="headerlink" title="字符串运算符总结"></a>字符串运算符总结</h3><p>下表实例变量 a 值为字符串 “Hello”，b 变量值为 “Python”<br><img src="https://s1.ax1x.com/2018/02/13/9YVUSJ.png" alt="字符串运算符"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在 Python 中， 每个值都有一种数据类型，但您并不需要声明变量的数据类型。那该方式是如何运作的呢？Python 根据每个变量的初始赋值情况分析其类型，并在内部对其进行跟踪。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;内置数据类型分类&quot;&gt;&lt;a href=&quot;#内置数据类型分类&quot; class=&quot;headerlink&quot; title=&quot;内置数据类型分类&quot;&gt;&lt;/a&gt;内置数据类型分类&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Booleans［布尔型］ 或为 True［真］ 或为 False［假］&lt;/li&gt;
&lt;li&gt;Numbers［数值型］ 可以是 Integers［整数］（1 和 2）、Floats［浮点数］（1.1 和 1.2）、Fractions［分数］（1/2 和 2/3）；甚至是 Complex Number［复数］&lt;/li&gt;
&lt;li&gt;Strings［字符串型］ 是 Unicode 字符序列，例如： 一份 html 文档&lt;/li&gt;
&lt;li&gt;Bytes［字节］ 和 Byte Arrays［字节数组］， 例如: 一份 jpeg 图像文件&lt;/li&gt;
&lt;li&gt;Lists［列表］ 是值的有序序列&lt;/li&gt;
&lt;li&gt;Tuples［元组］ 是有序而不可变的值序列&lt;/li&gt;
&lt;li&gt;Sets［集合］ 是装满无序值的包裹&lt;/li&gt;
&lt;li&gt;Dictionaries［字典］ 是键值对的无序包裹&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;布尔类型&quot;&gt;&lt;a href=&quot;#布尔类型&quot; class=&quot;headerlink&quot; title=&quot;布尔类型&quot;&gt;&lt;/a&gt;布尔类型&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;布尔类型或为真或为假。Python 有两个被巧妙地命名为 True 和 False 的常量，可用于对布尔类型的直接赋值。表达式也可以计算为布尔类型的值。数字 0、None、以及元素为空的容器类对象都可视作 bool False，反之为 True。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; bool(0)
False
&amp;gt;&amp;gt;&amp;gt; bool(None)
False
&amp;gt;&amp;gt;&amp;gt; bool([])
False
&amp;gt;&amp;gt;&amp;gt; bool({})
False
&amp;gt;&amp;gt;&amp;gt; bool(1)
True
&amp;gt;&amp;gt;&amp;gt; bool([1,2])
True
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;数字类型&quot;&gt;&lt;a href=&quot;#数字类型&quot; class=&quot;headerlink&quot; title=&quot;数字类型&quot;&gt;&lt;/a&gt;数字类型&lt;/h2&gt;&lt;p&gt;python本身支持整数以及浮点数。你可以对这些数字进行下表中的计算。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/02/13/9YZkc9.png&quot; alt=&quot;数字类型&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python基础知识" scheme="http://www.chenfanlinux.org/categories/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Python" scheme="http://www.chenfanlinux.org/tags/Python/"/>
    
  </entry>
  
</feed>
